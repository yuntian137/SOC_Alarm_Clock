; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\sc32f1xxx_twi.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\sc32f1xxx_twi.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\Buzz\Inc -I..\Drivers\TKDriver\C -I..\ADC_IAP\Inc -ID:\keil\ARM\PACK\Keil\SC32F1xxx_DFP\1.0.6\Device\SC32F10xx\FWLib\SC32_Lib\inc -D__MICROLIB -D__UVISION_VERSION=534 -DSC32F10xx -DSC32f10xx --omf_browse=..\output\sc32f1xxx_twi.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_twi.c]
                          THUMB

                          AREA ||i.TWI_AcknowledgeConfig||, CODE, READONLY, ALIGN=2

                  TWI_AcknowledgeConfig PROC
;;;211      */
;;;212    void TWI_AcknowledgeConfig ( TWI_TypeDef* TWIx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;213    {
;;;214        /* Check the parameters */
;;;215        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;216        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;217        if ( NewState != DISABLE )
000002  d004              BEQ      |L1.14|
;;;218        {
;;;219            /* Enable the acknowledgement */
;;;220            TWIx->TWI_CON |= TWI_CON_AA;
000004  6802              LDR      r2,[r0,#0]
000006  2302              MOVS     r3,#2
000008  431a              ORRS     r2,r2,r3
00000a  6002              STR      r2,[r0,#0]
00000c  e003              B        |L1.22|
                  |L1.14|
;;;221        }
;;;222        else
;;;223        {
;;;224            /* Disable the acknowledgement */
;;;225            TWIx->TWI_CON &= ( uint16_t ) ~TWI_CON_AA;
00000e  6802              LDR      r2,[r0,#0]
000010  4b01              LDR      r3,|L1.24|
000012  401a              ANDS     r2,r2,r3
000014  6002              STR      r2,[r0,#0]
                  |L1.22|
;;;226        }
;;;227    }
000016  4770              BX       lr
;;;228    
                          ENDP

                  |L1.24|
                          DCD      0x0000fffd

                          AREA ||i.TWI_ClearFlag||, CODE, READONLY, ALIGN=1

                  TWI_ClearFlag PROC
;;;608     */
;;;609    void TWI_ClearFlag ( TWI_TypeDef* TWIx, TWI_FLAG_TypeDef TWI_FLAG )
000000  6842              LDR      r2,[r0,#4]
;;;610    {
;;;611        /* Check the parameters */
;;;612        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;613        /* Clear the flags */
;;;614        TWIx->TWI_STS |= ( uint16_t ) TWI_FLAG;
000002  430a              ORRS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
;;;615    }
000006  4770              BX       lr
;;;616    
                          ENDP


                          AREA ||i.TWI_Cmd||, CODE, READONLY, ALIGN=2

                  TWI_Cmd PROC
;;;184     */
;;;185    void TWI_Cmd ( TWI_TypeDef* TWIx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;186    {
;;;187        /* Check the parameters */
;;;188        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;189        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;190        if ( NewState != DISABLE )
000002  d004              BEQ      |L3.14|
;;;191        {
;;;192            /* Enable the TWI Function */
;;;193            TWIx->TWI_CON |= TWI_CON_TWEN;
000004  6802              LDR      r2,[r0,#0]
000006  2380              MOVS     r3,#0x80
000008  431a              ORRS     r2,r2,r3
00000a  6002              STR      r2,[r0,#0]
00000c  e003              B        |L3.22|
                  |L3.14|
;;;194        }
;;;195        else
;;;196        {
;;;197            /* Disable the TWI Function */
;;;198            TWIx->TWI_CON &= ( uint16_t ) ~TWI_CON_TWEN;
00000e  6802              LDR      r2,[r0,#0]
000010  4b01              LDR      r3,|L3.24|
000012  401a              ANDS     r2,r2,r3
000014  6002              STR      r2,[r0,#0]
                  |L3.22|
;;;199        }
;;;200    }
000016  4770              BX       lr
;;;201    
                          ENDP

                  |L3.24|
                          DCD      0x0000ff7f

                          AREA ||i.TWI_DMACmd||, CODE, READONLY, ALIGN=1

                  TWI_DMACmd PROC
;;;656     */
;;;657    void TWI_DMACmd ( TWI_TypeDef* TWIx, TWI_DMAReq_TypeDef TWI_DMAReq, FunctionalState NewState )
000000  b510              PUSH     {r4,lr}
;;;658    {
;;;659        /* Check the parameters */
;;;660        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;661        assert_param ( IS_TWI_DMAREQ ( TWI_DMAReq ) );
;;;662        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;663        if ( NewState != DISABLE )
000002  2a00              CMP      r2,#0
000004  d003              BEQ      |L4.14|
;;;664        {
;;;665            /* Enable the selected TWI DMA requests */
;;;666            TWIx->TWI_IDE |= TWI_DMAReq;
000006  6903              LDR      r3,[r0,#0x10]
000008  430b              ORRS     r3,r3,r1
00000a  6103              STR      r3,[r0,#0x10]
00000c  e004              B        |L4.24|
                  |L4.14|
;;;667        }
;;;668        else
;;;669        {
;;;670            /* Disable the selected TWI DMA requests */
;;;671            TWIx->TWI_IDE &= ( uint16_t ) ~TWI_DMAReq;
00000e  6903              LDR      r3,[r0,#0x10]
000010  43cc              MVNS     r4,r1
000012  b2a4              UXTH     r4,r4
000014  4023              ANDS     r3,r3,r4
000016  6103              STR      r3,[r0,#0x10]
                  |L4.24|
;;;672        }
;;;673    }
000018  bd10              POP      {r4,pc}
;;;674    
                          ENDP


                          AREA ||i.TWI_DeInit||, CODE, READONLY, ALIGN=2

                  TWI_DeInit PROC
;;;46      */
;;;47     void TWI_DeInit ( TWI_TypeDef* TWIx )
000000  b510              PUSH     {r4,lr}
;;;48     {
000002  4604              MOV      r4,r0
;;;49         /* Check the parameters */
;;;50         assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;51         if ( TWIx == TWI0 )
000004  480b              LDR      r0,|L5.52|
000006  4284              CMP      r4,r0
000008  d108              BNE      |L5.28|
;;;52         {
;;;53             /* Enable TWI0 reset state */
;;;54             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TWI0, ENABLE );
00000a  2101              MOVS     r1,#1
00000c  2010              MOVS     r0,#0x10
00000e  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;55             /* Disable TWI0 reset state */
;;;56             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_TWI0, DISABLE );
000012  2100              MOVS     r1,#0
000014  2010              MOVS     r0,#0x10
000016  f7fffffe          BL       RCC_APB0PeriphResetCmd
00001a  e00a              B        |L5.50|
                  |L5.28|
;;;57         }
;;;58         else if ( TWIx == TWI1 )
00001c  4806              LDR      r0,|L5.56|
00001e  4284              CMP      r4,r0
000020  d107              BNE      |L5.50|
;;;59         {
;;;60     #if !defined (SC32f15xx)
;;;61             /* Enable TWI1 reset state */
;;;62             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TWI1, ENABLE );
000022  2101              MOVS     r1,#1
000024  2010              MOVS     r0,#0x10
000026  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;63             /* Disable TWI1 reset state */
;;;64             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_TWI1, DISABLE );
00002a  2100              MOVS     r1,#0
00002c  2010              MOVS     r0,#0x10
00002e  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L5.50|
;;;65     #else
;;;66     			    /* Enable SPI0 reset state */
;;;67         RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI1_TWI1, ENABLE);
;;;68         /* Release SPI0 from reset state */
;;;69         RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI1_TWI1, DISABLE);		
;;;70     #endif
;;;71     			
;;;72         }
;;;73     }
000032  bd10              POP      {r4,pc}
;;;74     
                          ENDP

                  |L5.52|
                          DCD      0x40020060
                  |L5.56|
                          DCD      0x40021060

                          AREA ||i.TWI_GeneralCallCmd||, CODE, READONLY, ALIGN=2

                  TWI_GeneralCallCmd PROC
;;;238      */
;;;239    void TWI_GeneralCallCmd ( TWI_TypeDef* TWIx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;240    {
;;;241        /* Check the parameters */
;;;242        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;243        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;244        if ( NewState != DISABLE )
000002  d004              BEQ      |L6.14|
;;;245        {
;;;246            /* Enable general call */
;;;247            TWIx->TWI_ADD |= TWI_ADD_GC;
000004  6882              LDR      r2,[r0,#8]
000006  2301              MOVS     r3,#1
000008  431a              ORRS     r2,r2,r3
00000a  6082              STR      r2,[r0,#8]
00000c  e003              B        |L6.22|
                  |L6.14|
;;;248        }
;;;249        else
;;;250        {
;;;251            /* Disable general call */
;;;252            TWIx->TWI_ADD &= ( uint16_t ) ~TWI_ADD_GC;
00000e  6882              LDR      r2,[r0,#8]
000010  4b01              LDR      r3,|L6.24|
000012  401a              ANDS     r2,r2,r3
000014  6082              STR      r2,[r0,#8]
                  |L6.22|
;;;253        }
;;;254    }
000016  4770              BX       lr
;;;255    
                          ENDP

                  |L6.24|
                          DCD      0x0000fffe

                          AREA ||i.TWI_GenerateSTART||, CODE, READONLY, ALIGN=2

                  TWI_GenerateSTART PROC
;;;340      */
;;;341    void TWI_GenerateSTART ( TWI_TypeDef* TWIx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;342    {
;;;343        /* Check the parameters */
;;;344        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;345        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;346        if ( NewState != DISABLE )
000002  d004              BEQ      |L7.14|
;;;347        {
;;;348            /* Generate a START condition */
;;;349            TWIx->TWI_CON |= TWI_CON_STA;
000004  6802              LDR      r2,[r0,#0]
000006  2320              MOVS     r3,#0x20
000008  431a              ORRS     r2,r2,r3
00000a  6002              STR      r2,[r0,#0]
00000c  e003              B        |L7.22|
                  |L7.14|
;;;350        }
;;;351        else
;;;352        {
;;;353            /* Disable the START condition generation */
;;;354            TWIx->TWI_CON &= ( uint16_t ) ~TWI_CON_STA;
00000e  6802              LDR      r2,[r0,#0]
000010  4b01              LDR      r3,|L7.24|
000012  401a              ANDS     r2,r2,r3
000014  6002              STR      r2,[r0,#0]
                  |L7.22|
;;;355        }
;;;356    }
000016  4770              BX       lr
;;;357    
                          ENDP

                  |L7.24|
                          DCD      0x0000ffdf

                          AREA ||i.TWI_GenerateSTOP||, CODE, READONLY, ALIGN=2

                  TWI_GenerateSTOP PROC
;;;367      */
;;;368    void TWI_GenerateSTOP ( TWI_TypeDef* TWIx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;369    {
;;;370        /* Check the parameters */
;;;371        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;372        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;373        if ( NewState != DISABLE )
000002  d004              BEQ      |L8.14|
;;;374        {
;;;375            /* Generate a STOP condition */
;;;376            TWIx->TWI_CON |= TWI_CON_STO;
000004  6802              LDR      r2,[r0,#0]
000006  2310              MOVS     r3,#0x10
000008  431a              ORRS     r2,r2,r3
00000a  6002              STR      r2,[r0,#0]
00000c  e003              B        |L8.22|
                  |L8.14|
;;;377        }
;;;378        else
;;;379        {
;;;380            /* Disable the STOP condition generation */
;;;381            TWIx->TWI_CON &= ( uint16_t ) ~TWI_CON_STO;
00000e  6802              LDR      r2,[r0,#0]
000010  4b01              LDR      r3,|L8.24|
000012  401a              ANDS     r2,r2,r3
000014  6002              STR      r2,[r0,#0]
                  |L8.22|
;;;382        }
;;;383    }
000016  4770              BX       lr
;;;384    
                          ENDP

                  |L8.24|
                          DCD      0x0000ffef

                          AREA ||i.TWI_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  TWI_GetFlagStatus PROC
;;;579     */
;;;580    FlagStatus TWI_GetFlagStatus ( TWI_TypeDef* TWIx, TWI_FLAG_TypeDef TWI_FLAG )
000000  4602              MOV      r2,r0
;;;581    {
;;;582        ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;583        /* Check the parameters */
;;;584        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;585        assert_param ( IS_TWI_FLAG ( TWI_FLAG ) );
;;;586        if ( ( TWIx->TWI_STS & TWI_FLAG ) != ( uint16_t ) RESET )
000004  6853              LDR      r3,[r2,#4]
000006  400b              ANDS     r3,r3,r1
000008  2b00              CMP      r3,#0
00000a  d001              BEQ      |L9.16|
;;;587        {
;;;588            bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L9.18|
                  |L9.16|
;;;589        }
;;;590        else
;;;591        {
;;;592            bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L9.18|
;;;593        }
;;;594        return bitstatus;
;;;595    }
000012  4770              BX       lr
;;;596    
                          ENDP


                          AREA ||i.TWI_GetNbytes||, CODE, READONLY, ALIGN=1

                  TWI_GetNbytes PROC
;;;306      */
;;;307    uint8_t TWI_GetNbytes ( TWI_TypeDef* TWIx )
000000  4601              MOV      r1,r0
;;;308    {
;;;309        uint8_t tmpnum;
;;;310    
;;;311        /* Check the parameters */
;;;312        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;313    
;;;314        tmpnum = ( uint8_t ) ( TWIx->TWI_STS >> TWI_STS_NBYTES_Pos );
000002  684a              LDR      r2,[r1,#4]
000004  0212              LSLS     r2,r2,#8
000006  0e10              LSRS     r0,r2,#24
;;;315    
;;;316        return tmpnum;
;;;317    }
000008  4770              BX       lr
;;;318    
                          ENDP


                          AREA ||i.TWI_GetStateMachine||, CODE, READONLY, ALIGN=1

                  TWI_GetStateMachine PROC
;;;635     */
;;;636    TWI_StateMachine_TypeDef TWI_GetStateMachine ( TWI_TypeDef* TWIx )
000000  4601              MOV      r1,r0
;;;637    {
;;;638        /* Check the parameters */
;;;639        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;640    
;;;641        return ( TWI_StateMachine_TypeDef ) ( TWIx->TWI_STS & TWI_STS_STATE );
000002  6848              LDR      r0,[r1,#4]
000004  2207              MOVS     r2,#7
000006  0212              LSLS     r2,r2,#8
000008  4010              ANDS     r0,r0,r2
;;;642    }
00000a  4770              BX       lr
;;;643    
                          ENDP


                          AREA ||i.TWI_ITConfig||, CODE, READONLY, ALIGN=1

                  TWI_ITConfig PROC
;;;542     */
;;;543    void TWI_ITConfig ( TWI_TypeDef* TWIx, uint16_t TWI_IT, FunctionalState NewState )
000000  b510              PUSH     {r4,lr}
;;;544    {
;;;545        /* Check the parameters */
;;;546        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;547        assert_param ( IS_TWI_IT ( TWI_IT ) );
;;;548        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;549        if ( NewState != DISABLE )
000002  2a00              CMP      r2,#0
000004  d003              BEQ      |L12.14|
;;;550        {
;;;551            /* Enable the Interrupt sources */
;;;552            TWIx->TWI_IDE |= TWI_IT;
000006  6903              LDR      r3,[r0,#0x10]
000008  430b              ORRS     r3,r3,r1
00000a  6103              STR      r3,[r0,#0x10]
00000c  e004              B        |L12.24|
                  |L12.14|
;;;553        }
;;;554        else
;;;555        {
;;;556            /* Disable the Interrupt sources */
;;;557            TWIx->TWI_IDE &= ( uint16_t ) ~TWI_IT;
00000e  6903              LDR      r3,[r0,#0x10]
000010  43cc              MVNS     r4,r1
000012  b2a4              UXTH     r4,r4
000014  4023              ANDS     r3,r3,r4
000016  6103              STR      r3,[r0,#0x10]
                  |L12.24|
;;;558        }
;;;559    }
000018  bd10              POP      {r4,pc}
;;;560    
                          ENDP


                          AREA ||i.TWI_Init||, CODE, READONLY, ALIGN=2

                  TWI_Init PROC
;;;98      */
;;;99     void TWI_Init ( TWI_TypeDef* TWIx, TWI_InitTypeDef* TWI_InitStruct )
000000  b530              PUSH     {r4,r5,lr}
;;;100    {
000002  4602              MOV      r2,r0
;;;101    #if !defined (SC32f15xx)
;;;102        uint32_t tmpreg;
;;;103        /* Check the parameters */
;;;104        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;105        assert_param ( IS_TWI_ACK ( TWI_InitStruct->TWI_Ack ) );
;;;106        assert_param ( IS_TWI_PRESCALER ( TWI_InitStruct->TWI_Prescaler ) );
;;;107        assert_param ( IS_TWI_STRETCH ( TWI_InitStruct->TWI_Stretch ) );
;;;108        assert_param ( IS_TWI_GENERALCALL ( TWI_InitStruct->TWI_GeneralCall ) );
;;;109        /*---------------------------- TWIx TWI_CON Configuration ------------------------*/
;;;110        /* Get the TWIx TWI_CON value */
;;;111        tmpreg = TWIx->TWI_CON;
000004  6810              LDR      r0,[r2,#0]
;;;112        /* Clear AA, TWCK, STRETCH bits */
;;;113        tmpreg &= ( uint32_t ) ~ ( TWI_CON_AA | TWI_CON_SPOS | TWI_CON_STRETCH );
000006  4b0a              LDR      r3,|L13.48|
000008  4018              ANDS     r0,r0,r3
;;;114        /* Configure TWIx: Ack, Clock division and Slave Clock Stretch */
;;;115        /* Set AA bits to TWI_Ack value */
;;;116        /* Set TWCK bits according to TWI_DataSize value */
;;;117        /* Set STRETCH bit according to TWI_Stretch value */
;;;118        tmpreg |= ( uint32_t ) ( TWI_InitStruct->TWI_Ack | TWI_InitStruct->TWI_Prescaler |
00000a  880b              LDRH     r3,[r1,#0]
00000c  884c              LDRH     r4,[r1,#2]
00000e  4323              ORRS     r3,r3,r4
000010  888c              LDRH     r4,[r1,#4]
000012  4323              ORRS     r3,r3,r4
000014  4318              ORRS     r0,r0,r3
;;;119                                 TWI_InitStruct->TWI_Stretch );
;;;120        /* Write to TWIx TWI_CON */
;;;121        TWIx->TWI_CON = tmpreg;
000016  6010              STR      r0,[r2,#0]
;;;122        /*---------------------------- TWIx TWI_ADD Configuration ------------------------*/
;;;123        /* Get the TWIx TWI_ADD value */
;;;124        tmpreg = TWIx->TWI_ADD;
000018  6890              LDR      r0,[r2,#8]
;;;125        /* Clear GC, TWCK, STRETCH bits */
;;;126        tmpreg &= ( uint32_t ) ~ ( TWI_ADD_GC | TWI_ADD_TWA );
00001a  0a00              LSRS     r0,r0,#8
00001c  0200              LSLS     r0,r0,#8
;;;127        /* Configure TWIx: General Call and Slave Slave Address */
;;;128        /* Set AA bits to TWI_GC value */
;;;129        /* Set TWA according to TWI_SlaveAdress value */
;;;130        tmpreg |= ( uint32_t ) ( TWI_InitStruct->TWI_GeneralCall | ( ( TWI_InitStruct->TWI_SlaveAdress << 1 ) & 0xFE ) );
00001e  88cb              LDRH     r3,[r1,#6]
000020  688c              LDR      r4,[r1,#8]
000022  0064              LSLS     r4,r4,#1
000024  25fe              MOVS     r5,#0xfe
000026  402c              ANDS     r4,r4,r5
000028  4323              ORRS     r3,r3,r4
00002a  4318              ORRS     r0,r0,r3
;;;131    
;;;132        /* Write to TWIx TWI_ADD */
;;;133        TWIx->TWI_ADD = tmpreg;
00002c  6090              STR      r0,[r2,#8]
;;;134    #else
;;;135      uint32_t tmpreg;
;;;136      /* Check the parameters */
;;;137      assert_param(IS_TWI_ALL_PERIPH(TWIx));
;;;138      assert_param(IS_TWI_ACK(TWI_InitStruct->TWI_Ack));
;;;139      assert_param(IS_TWI_PRESCALER(TWI_InitStruct->TWI_Prescaler));
;;;140      assert_param(IS_TWI_STRETCH(TWI_InitStruct->TWI_Stretch));
;;;141      assert_param(IS_TWI_GENERALCALL(TWI_InitStruct->TWI_GeneralCall));
;;;142    	/*---------------------------- TWIx TWI_CON Configuration ------------------------*/
;;;143    
;;;144    	/* Get the TWIx TWI_CON value */
;;;145      tmpreg = TWIx->TWI_CON;
;;;146      /* Clear AA, TWCK, STRETCH bits */
;;;147      tmpreg &= (uint32_t) ~(TWI_CON_AA | TWI_CON_SPOS | TWI_CON_STRETCH |TWI_CON_TWCK);
;;;148      /* Configure TWIx: Ack, Clock division and Slave Clock Stretch */
;;;149      /* Set AA bits to TWI_Ack value */
;;;150      /* Set TWCK bits according to TWI_DataSize value */
;;;151      /* Set STRETCH bit according to TWI_Stretch value */
;;;152      tmpreg |= (uint32_t)(TWI_InitStruct->TWI_Ack | TWI_InitStruct->TWI_Prescaler |
;;;153                           TWI_InitStruct->TWI_Stretch);
;;;154      if(TWIx == TWI1)
;;;155    	{
;;;156    		tmpreg &=~(0x00<<SPI1_TWI1_CON_MODE_Pos);
;;;157    	}
;;;158      /* Write to TWIx TWI_CON */
;;;159      TWIx->TWI_CON = tmpreg;
;;;160      /*---------------------------- TWIx TWI_ADD Configuration ------------------------*/
;;;161      /* Get the TWIx TWI_ADD value */
;;;162      tmpreg = TWIx->TWI_ADD;
;;;163      /* Clear GC, TWCK, STRETCH bits */
;;;164      tmpreg &= (uint32_t) ~(TWI_ADD_GC | TWI_ADD_TWA);
;;;165      /* Configure TWIx: General Call and Slave Slave Address */
;;;166      /* Set AA bits to TWI_GC value */
;;;167      /* Set TWA according to TWI_SlaveAdress value */
;;;168      tmpreg |= (uint32_t)(TWI_InitStruct->TWI_GeneralCall |  ( ( TWI_InitStruct->TWI_SlaveAdress << 1 ) & 0xFE ) );
;;;169    
;;;170      /* Write to TWIx TWI_ADD */
;;;171      TWIx->TWI_ADD = tmpreg;
;;;172    #endif
;;;173    }
00002e  bd30              POP      {r4,r5,pc}
;;;174    
                          ENDP

                  |L13.48|
                          DCD      0xffff3ffc

                          AREA ||i.TWI_PinRemapConfig||, CODE, READONLY, ALIGN=2

                  TWI_PinRemapConfig PROC
;;;475     */
;;;476    void TWI_PinRemapConfig ( TWI_TypeDef* TWIx, TWI_PinRemap_TypeDef TWI_Remap )
000000  b510              PUSH     {r4,lr}
;;;477    {
000002  460a              MOV      r2,r1
;;;478    #if !defined (SC32f15xx)
;;;479        uint32_t tmpreg ;
;;;480        /* Check the parameters */
;;;481        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;482        if ( TWIx == TWI0 )
000004  4b07              LDR      r3,|L14.36|
000006  4298              CMP      r0,r3
000008  d100              BNE      |L14.12|
;;;483        {
;;;484            assert_param ( IS_TWI_LIST1_PINREMAP ( TWI_Remap ) );
00000a  e000              B        |L14.14|
                  |L14.12|
;;;485        }
;;;486        else
;;;487        {
;;;488            assert_param ( IS_TWI_LIST2_PINREMAP ( TWI_Remap ) );
00000c  bf00              NOP      
                  |L14.14|
;;;489        }
;;;490    
;;;491        tmpreg = TWIx->TWI_CON;
00000e  6801              LDR      r1,[r0,#0]
;;;492    
;;;493        tmpreg &= ( uint32_t ) ( ~TWI_CON_SPOS );
000010  2403              MOVS     r4,#3
000012  03a4              LSLS     r4,r4,#14
000014  460b              MOV      r3,r1
000016  43a3              BICS     r3,r3,r4
000018  4619              MOV      r1,r3
;;;494    
;;;495        tmpreg |= TWI_Remap;
00001a  460b              MOV      r3,r1
00001c  4313              ORRS     r3,r3,r2
00001e  4619              MOV      r1,r3
;;;496    
;;;497        TWIx->TWI_CON = tmpreg;
000020  6001              STR      r1,[r0,#0]
;;;498    #else
;;;499      uint32_t tmpreg ;
;;;500      /* Check the parameters */
;;;501      assert_param(IS_TWI_ALL_PERIPH(TWIx));
;;;502      
;;;503    	
;;;504    
;;;505      tmpreg = TWIx->TWI_CON;
;;;506    
;;;507      tmpreg &= (uint32_t)(~TWI_CON_SPOS);
;;;508    
;;;509      tmpreg |= TWI_Remap;
;;;510    
;;;511      TWIx->TWI_CON = tmpreg;
;;;512    #endif	
;;;513    }
000022  bd10              POP      {r4,pc}
;;;514    
                          ENDP

                  |L14.36|
                          DCD      0x40020060

                          AREA ||i.TWI_ReceiveData||, CODE, READONLY, ALIGN=1

                  TWI_ReceiveData PROC
;;;445     */
;;;446    uint16_t TWI_ReceiveData ( TWI_TypeDef* TWIx )
000000  4601              MOV      r1,r0
;;;447    {
;;;448        /* Check the parameters */
;;;449        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;450        /* Receive Data */
;;;451        return ( uint16_t ) TWIx->TWI_DATA;
000002  68c8              LDR      r0,[r1,#0xc]
000004  b280              UXTH     r0,r0
;;;452    }
000006  4770              BX       lr
;;;453    
                          ENDP


                          AREA ||i.TWI_Send7bitAddress||, CODE, READONLY, ALIGN=1

                  TWI_Send7bitAddress PROC
;;;395      */
;;;396    void TWI_Send7bitAddress ( TWI_TypeDef* TWIx, uint8_t Address, TWI_Command_TypeDef TWI_Command )
000000  064b              LSLS     r3,r1,#25
;;;397    {
;;;398        /* Check the parameters */
;;;399        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;400        assert_param ( IS_TWI_COMMAND ( TWI_Command ) );
;;;401        Address = ( Address << 1 );
000002  0e19              LSRS     r1,r3,#24
;;;402        /* Test on the direction to set/reset the read/write bit */
;;;403        if ( TWI_Command != TWI_Command_Write )
000004  2a00              CMP      r2,#0
000006  d002              BEQ      |L16.14|
;;;404        {
;;;405            /* Set the address bit0 for read */
;;;406            Address |= TWI_Command_Read;
000008  2301              MOVS     r3,#1
00000a  4319              ORRS     r1,r1,r3
00000c  e001              B        |L16.18|
                  |L16.14|
;;;407        }
;;;408        else
;;;409        {
;;;410            /* Reset the address bit0 for write */
;;;411            Address &= ( uint8_t ) ~ ( ( uint8_t ) TWI_Command_Read );
00000e  23fe              MOVS     r3,#0xfe
000010  4019              ANDS     r1,r1,r3
                  |L16.18|
;;;412        }
;;;413    
;;;414        /* Send the address */
;;;415        TWIx->TWI_DATA = Address;
000012  60c1              STR      r1,[r0,#0xc]
;;;416    }
000014  4770              BX       lr
;;;417    
                          ENDP


                          AREA ||i.TWI_SendData||, CODE, READONLY, ALIGN=1

                  TWI_SendData PROC
;;;430     */
;;;431    void TWI_SendData ( TWI_TypeDef* TWIx, uint8_t Data )
000000  60c1              STR      r1,[r0,#0xc]
;;;432    {
;;;433        /* Check the parameters */
;;;434        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;435        /* Transmit Data */
;;;436        TWIx->TWI_DATA = Data;
;;;437    }
000002  4770              BX       lr
;;;438    
                          ENDP


                          AREA ||i.TWI_SetNbytes||, CODE, READONLY, ALIGN=1

                  TWI_SetNbytes PROC
;;;291      */
;;;292    void TWI_SetNbytes ( TWI_TypeDef* TWIx, uint8_t Nbytes )
000000  040a              LSLS     r2,r1,#16
;;;293    {
;;;294        /* Check the parameters */
;;;295        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;296    
;;;297        TWIx->TWI_STS = ( uint32_t ) ( Nbytes << TWI_STS_NBYTES_Pos );
000002  6042              STR      r2,[r0,#4]
;;;298    }
000004  4770              BX       lr
;;;299    
                          ENDP


                          AREA ||i.TWI_StretchClockConfig||, CODE, READONLY, ALIGN=2

                  TWI_StretchClockConfig PROC
;;;265      */
;;;266    void TWI_StretchClockConfig ( TWI_TypeDef* TWIx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;267    {
;;;268        /* Check the parameters */
;;;269        assert_param ( IS_TWI_ALL_PERIPH ( TWIx ) );
;;;270        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;271        if ( NewState == DISABLE )
000002  d104              BNE      |L19.14|
;;;272        {
;;;273            /* Enable the selected TWI Clock stretching */
;;;274            TWIx->TWI_CON |= TWI_CON_STRETCH;
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  431a              ORRS     r2,r2,r3
00000a  6002              STR      r2,[r0,#0]
00000c  e003              B        |L19.22|
                  |L19.14|
;;;275        }
;;;276        else
;;;277        {
;;;278            /* Disable the selected TWI Clock stretching */
;;;279            TWIx->TWI_CON &= ( uint16_t ) ~ ( ( uint16_t ) TWI_CON_STRETCH );
00000e  6802              LDR      r2,[r0,#0]
000010  4b01              LDR      r3,|L19.24|
000012  401a              ANDS     r2,r2,r3
000014  6002              STR      r2,[r0,#0]
                  |L19.22|
;;;280        }
;;;281    }
000016  4770              BX       lr
;;;282    
                          ENDP

                  |L19.24|
                          DCD      0x0000fffe

                          AREA ||i.TWI_StructInit||, CODE, READONLY, ALIGN=1

                  TWI_StructInit PROC
;;;79       */
;;;80     void TWI_StructInit ( TWI_InitTypeDef* TWI_InitStruct )
000000  2102              MOVS     r1,#2
;;;81     {
;;;82         /* Set the default configuration */
;;;83         TWI_InitStruct->TWI_Ack = TWI_Ack_Enable;
000002  8001              STRH     r1,[r0,#0]
;;;84         TWI_InitStruct->TWI_Prescaler = 0x00;
000004  2100              MOVS     r1,#0
000006  8041              STRH     r1,[r0,#2]
;;;85         TWI_InitStruct->TWI_Stretch = 0;
000008  8081              STRH     r1,[r0,#4]
;;;86     
;;;87         TWI_InitStruct->TWI_GeneralCall = TWI_GeneralCall_Disable;
00000a  80c1              STRH     r1,[r0,#6]
;;;88         TWI_InitStruct->TWI_SlaveAdress = 0x00;
00000c  6081              STR      r1,[r0,#8]
;;;89     }
00000e  4770              BX       lr
;;;90     
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_twi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_twi_c_24100672____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___15_sc32f1xxx_twi_c_24100672____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_twi_c_24100672____REVSH|
#line 478
|__asm___15_sc32f1xxx_twi_c_24100672____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
