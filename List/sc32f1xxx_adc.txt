; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\sc32f1xxx_adc.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\sc32f1xxx_adc.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\Buzz\Inc -I..\Drivers\TKDriver\C -I..\ADC_IAP\Inc -ID:\keil\ARM\PACK\Keil\SC32F1xxx_DFP\1.0.6\Device\SC32F10xx\FWLib\SC32_Lib\inc -D__MICROLIB -D__UVISION_VERSION=534 -DSC32F10xx -DSC32f10xx --omf_browse=..\output\sc32f1xxx_adc.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_adc.c]
                          THUMB

                          AREA ||i.ADC_ClearFlag||, CODE, READONLY, ALIGN=1

                  ADC_ClearFlag PROC
;;;441     */
;;;442    void ADC_ClearFlag ( ADC_TypeDef* ADCx, uint32_t ADC_FLAG )
000000  6041              STR      r1,[r0,#4]
;;;443    {
;;;444        /* Check the parameters */
;;;445        assert_param ( IS_ADC_ALL_PERIPH ( ADCx ) );
;;;446    
;;;447        /* Clear the flags */
;;;448        ADCx->ADC_STS = ( uint32_t ) ADC_FLAG;
;;;449    }
000002  4770              BX       lr
;;;450    
                          ENDP


                          AREA ||i.ADC_Cmd||, CODE, READONLY, ALIGN=1

                  ADC_Cmd PROC
;;;141     */
;;;142    void ADC_Cmd ( ADC_TypeDef* ADCx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;143    {
;;;144        /* Check the parameters */
;;;145        assert_param ( IS_ADC_ALL_PERIPH ( ADCx ) );
;;;146        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;147    
;;;148        if ( NewState != DISABLE )
000002  d005              BEQ      |L2.16|
;;;149        {
;;;150            /* Enable the ADC Counter */
;;;151            ADCx->ADC_CON |= ADC_CON_ADCEN;
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  03db              LSLS     r3,r3,#15
00000a  431a              ORRS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
00000e  e004              B        |L2.26|
                  |L2.16|
;;;152        }
;;;153        else
;;;154        {
;;;155            /* Disable the ADC Counter */
;;;156            ADCx->ADC_CON &= ( uint32_t ) ~ADC_CON_ADCEN;
000010  6802              LDR      r2,[r0,#0]
000012  2301              MOVS     r3,#1
000014  03db              LSLS     r3,r3,#15
000016  439a              BICS     r2,r2,r3
000018  6002              STR      r2,[r0,#0]
                  |L2.26|
;;;157        }
;;;158    }
00001a  4770              BX       lr
;;;159    
                          ENDP


                          AREA ||i.ADC_ConvModeConfig||, CODE, READONLY, ALIGN=1

                  ADC_ConvModeConfig PROC
;;;168     */
;;;169    void ADC_ConvModeConfig ( ADC_TypeDef* ADCx, ADC_ConvMode_TypeDef ADC_ConvMode )
000000  2900              CMP      r1,#0
;;;170    {
;;;171        /* Check the parameters */
;;;172        assert_param ( IS_ADC_ALL_PERIPH ( ADCx ) );
;;;173    
;;;174        if ( ADC_ConvMode != ADC_ConvMode_Single )
000002  d005              BEQ      |L3.16|
;;;175        {
;;;176            /* Enable the ADC Counter */
;;;177            ADCx->ADC_CON |= ADC_CON_CONT;
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  02db              LSLS     r3,r3,#11
00000a  431a              ORRS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
00000e  e004              B        |L3.26|
                  |L3.16|
;;;178        }
;;;179        else
;;;180        {
;;;181            /* Disable the ADC Counter */
;;;182            ADCx->ADC_CON &= ( uint32_t ) ~ADC_CON_CONT;
000010  6802              LDR      r2,[r0,#0]
000012  2301              MOVS     r3,#1
000014  02db              LSLS     r3,r3,#11
000016  439a              BICS     r2,r2,r3
000018  6002              STR      r2,[r0,#0]
                  |L3.26|
;;;183        }
;;;184    }
00001a  4770              BX       lr
;;;185    
                          ENDP


                          AREA ||i.ADC_DMACmd||, CODE, READONLY, ALIGN=1

                  ADC_DMACmd PROC
;;;459     */
;;;460    void ADC_DMACmd ( ADC_TypeDef* ADCx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;461    {
;;;462    #if defined(SC32f10xx)||defined(SC32f11xx)||defined(SC32f12xx)
;;;463        /* Check the parameters */
;;;464        assert_param ( IS_ADC_ALL_PERIPH ( ADCx ) );
;;;465    
;;;466        if ( NewState != DISABLE )
000002  d005              BEQ      |L4.16|
;;;467        {
;;;468            /* Enable the selected ADC DMA requests */
;;;469            ADCx->ADC_CON |= ( uint32_t ) ADC_CON_DMAEN;
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  031b              LSLS     r3,r3,#12
00000a  431a              ORRS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
00000e  e004              B        |L4.26|
                  |L4.16|
;;;470        }
;;;471        else
;;;472        {
;;;473            /* Disable the selected ADC DMA requests */
;;;474            ADCx->ADC_CON &= ( uint32_t ) ~ADC_CON_DMAEN;
000010  6802              LDR      r2,[r0,#0]
000012  2301              MOVS     r3,#1
000014  031b              LSLS     r3,r3,#12
000016  439a              BICS     r2,r2,r3
000018  6002              STR      r2,[r0,#0]
                  |L4.26|
;;;475        }
;;;476    #elif defined(SC32f15xx)
;;;477        /* Check the parameters */
;;;478        assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;479    
;;;480        if(NewState != DISABLE)
;;;481        {
;;;482        /* Enable the selected ADC DMA requests */
;;;483        ADCx->ADC_IDE |= (uint32_t)0x40;
;;;484        }
;;;485        else
;;;486        {
;;;487        /* Disable the selected ADC DMA requests */
;;;488        ADCx->ADC_IDE &= (uint32_t)~0x40;
;;;489        }		
;;;490    #endif
;;;491    }
00001a  4770              BX       lr
;;;492    
                          ENDP


                          AREA ||i.ADC_DeInit||, CODE, READONLY, ALIGN=1

                  ADC_DeInit PROC
;;;45      */
;;;46     void ADC_DeInit ( ADC_TypeDef* ADCx )
000000  2100              MOVS     r1,#0
;;;47     {
;;;48     #if defined(SC32f10xx)||defined(SC32f11xx)||defined(SC32f12xx)
;;;49         /* Check the parameters */
;;;50         assert_param ( IS_ADC_ALL_PERIPH ( ADCx ) );
;;;51     
;;;52         ADCx->ADC_CFG = ( uint32_t ) 0x00000000U;
000002  60c1              STR      r1,[r0,#0xc]
;;;53         ADCx->ADC_CON = ( uint32_t ) 0x00000000U;
000004  6001              STR      r1,[r0,#0]
;;;54         ADCx->ADC_VALUE = ( uint32_t ) 0x00000000U;
000006  6081              STR      r1,[r0,#8]
;;;55         ADCx->ADC_STS = ( uint32_t ) 0x00000001U;
000008  2101              MOVS     r1,#1
00000a  6041              STR      r1,[r0,#4]
;;;56     #elif defined(SC32f15xx)
;;;57       /* Check the parameters */
;;;58       assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;59     
;;;60       if(ADCx == ADC)
;;;61       	{
;;;62         RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, ENABLE);
;;;63     	  RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, DISABLE);
;;;64       	}	
;;;65     #endif
;;;66     }
00000c  4770              BX       lr
;;;67     
                          ENDP


                          AREA ||i.ADC_GetChannel||, CODE, READONLY, ALIGN=1

                  ADC_GetChannel PROC
;;;272     */
;;;273    ADC_ChannelTypedef ADC_GetChannel ( ADC_TypeDef* ADCx )
000000  4601              MOV      r1,r0
;;;274    {
;;;275    #if defined(SC32f10xx)||defined(SC32f11xx)||defined(SC32f12xx)
;;;276        /* Check the parameters */
;;;277        assert_param ( IS_ADC_ALL_PERIPH ( ADCx ) );
;;;278    
;;;279        /* Get the ADC channel type */
;;;280        return ( ADC_ChannelTypedef ) ( ADCx->ADC_CON & ADC_CON_ADCIS );
000002  6808              LDR      r0,[r1,#0]
000004  06c0              LSLS     r0,r0,#27
000006  0ec0              LSRS     r0,r0,#27
;;;281    #elif defined(SC32f15xx)
;;;282      /* Check the parameters */
;;;283      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;284    
;;;285      /* Get the ADC channel type */
;;;286      return (ADC_ChannelTypedef)(ADCx->ADC_CON  & ( ADC_CON_ADCISA));
;;;287    #endif	
;;;288    	
;;;289    }
000008  4770              BX       lr
;;;290    
                          ENDP


                          AREA ||i.ADC_GetConversionValue||, CODE, READONLY, ALIGN=1

                  ADC_GetConversionValue PROC
;;;327     */
;;;328    uint16_t ADC_GetConversionValue ( ADC_TypeDef* ADCx )
000000  4601              MOV      r1,r0
;;;329    {
;;;330        /* Check the parameters */
;;;331        assert_param ( IS_ADC_ALL_PERIPH ( ADCx ) );
;;;332        /*Returns the result of the latest ADCx conversion */
;;;333        return ( uint16_t ) ADCx->ADC_VALUE;
000002  6888              LDR      r0,[r1,#8]
000004  b280              UXTH     r0,r0
;;;334    }
000006  4770              BX       lr
;;;335    
                          ENDP


                          AREA ||i.ADC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  ADC_GetFlagStatus PROC
;;;407     */
;;;408    FlagStatus ADC_GetFlagStatus ( ADC_TypeDef* ADCx, uint32_t ADC_FLAG )
000000  b530              PUSH     {r4,r5,lr}
;;;409    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;410        ADC_SoftwareStartConv(ADC);
000006  4806              LDR      r0,|L8.32|
000008  f7fffffe          BL       ADC_SoftwareStartConv
;;;411        ITStatus bitstatus = RESET;
00000c  2500              MOVS     r5,#0
;;;412        /* Check the parameters */
;;;413        assert_param ( IS_ADC_ALL_PERIPH ( ADCx ) );
;;;414    
;;;415        if ( ( ADCx->ADC_STS & ADC_FLAG ) != ( uint16_t ) RESET )
00000e  6858              LDR      r0,[r3,#4]
000010  4020              ANDS     r0,r0,r4
000012  2800              CMP      r0,#0
000014  d001              BEQ      |L8.26|
;;;416        {
;;;417            bitstatus = SET;
000016  2501              MOVS     r5,#1
000018  e000              B        |L8.28|
                  |L8.26|
;;;418        }
;;;419        else
;;;420        {
;;;421            bitstatus = RESET;
00001a  2500              MOVS     r5,#0
                  |L8.28|
;;;422        }
;;;423        return bitstatus;
00001c  4628              MOV      r0,r5
;;;424    }
00001e  bd30              POP      {r4,r5,pc}
;;;425    
                          ENDP

                  |L8.32|
                          DCD      0x40022110

                          AREA ||i.ADC_ITConfig||, CODE, READONLY, ALIGN=1

                  ADC_ITConfig PROC
;;;370     */
;;;371    void ADC_ITConfig ( ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState )
000000  2a00              CMP      r2,#0
;;;372    {
;;;373        /* Check the parameters */
;;;374        assert_param ( IS_ADC_ALL_PERIPH ( ADCx ) );
;;;375        assert_param ( IS_ADC_IT ( ADC_IT ) );
;;;376        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;377    
;;;378        if ( NewState != DISABLE )
000002  d003              BEQ      |L9.12|
;;;379        {
;;;380            /* Enable the Interrupt sources */
;;;381            ADCx->ADC_CON |= ADC_IT;
000004  6803              LDR      r3,[r0,#0]
000006  430b              ORRS     r3,r3,r1
000008  6003              STR      r3,[r0,#0]
00000a  e002              B        |L9.18|
                  |L9.12|
;;;382        }
;;;383        else
;;;384        {
;;;385            /* Disable the Interrupt sources */
;;;386            ADCx->ADC_CON &= ( uint32_t ) ~ADC_IT;
00000c  6803              LDR      r3,[r0,#0]
00000e  438b              BICS     r3,r3,r1
000010  6003              STR      r3,[r0,#0]
                  |L9.18|
;;;387        }
;;;388    }
000012  4770              BX       lr
;;;389    
                          ENDP


                          AREA ||i.ADC_Init||, CODE, READONLY, ALIGN=2

                  ADC_Init PROC
;;;75      */
;;;76     void ADC_Init ( ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct )
000000  b510              PUSH     {r4,lr}
;;;77     {
;;;78     #if defined(SC32f10xx)||defined(SC32f11xx)||defined(SC32f12xx)
;;;79         uint32_t tmpreg;
;;;80         /* Check the parameters */
;;;81         assert_param ( IS_ADC_ALL_PERIPH ( ADCx ) );
;;;82         assert_param ( IS_ADC_CONVMODE ( ADC_InitStruct->ADC_ConvMode ) );
;;;83         assert_param ( IS_ADC_PRESCALER ( ADC_InitStruct->ADC_Prescaler ) );
;;;84         assert_param ( IS_ADC_VREF ( ADC_InitStruct->ADC_VREF ) );
;;;85         assert_param ( IS_ADC_EAIN ( ADC_InitStruct->ADC_EAIN ) );
;;;86     
;;;87         tmpreg = ADCx->ADC_CON;
000002  6802              LDR      r2,[r0,#0]
;;;88         tmpreg &= ~ ( ADC_CON_ADCIS | ADC_CON_CONT | ADC_CON_LOWSP | ADC_CON_VREFS );
000004  4b05              LDR      r3,|L10.28|
000006  401a              ANDS     r2,r2,r3
;;;89         tmpreg |= ( ADC_InitStruct->ADC_Prescaler | ADC_InitStruct->ADC_VREF |
000008  688c              LDR      r4,[r1,#8]
00000a  680b              LDR      r3,[r1,#0]
00000c  4323              ORRS     r3,r3,r4
00000e  898c              LDRH     r4,[r1,#0xc]
000010  4323              ORRS     r3,r3,r4
000012  431a              ORRS     r2,r2,r3
;;;90                     ADC_InitStruct->ADC_ConvMode );
;;;91         ADCx->ADC_CON = tmpreg;
000014  6002              STR      r2,[r0,#0]
;;;92         ADCx->ADC_CFG = ADC_InitStruct->ADC_EAIN;
000016  684b              LDR      r3,[r1,#4]
000018  60c3              STR      r3,[r0,#0xc]
;;;93     #elif defined(SC32f15xx)
;;;94       uint32_t tmpreg;
;;;95       /* Check the parameters */
;;;96       assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;97       assert_param(IS_ADC_CONVMODE(ADC_InitStruct->ADC_ConvMode));
;;;98       assert_param(IS_ADC_PRESCALER(ADC_InitStruct->ADC_Prescaler));
;;;99       assert_param(IS_ADC_EAIN(ADC_InitStruct->ADC_EAIN));
;;;100      assert_param(IS_ADC_VREF(ADC_InitStruct->ADC_VREF));
;;;101      
;;;102      tmpreg = ADCx->ADC_CON;
;;;103      tmpreg &= ~( ADC_CON_CONT | ADC_CON_LOWSP | ADC_CON_REFSEL );
;;;104      tmpreg |= ( ADC_InitStruct->ADC_Prescaler |
;;;105      	          ADC_InitStruct->ADC_VREF | ADC_InitStruct->ADC_ConvMode);
;;;106      ADCx->ADC_CON = tmpreg;
;;;107      
;;;108      ADCx->ADC_CFG = ADC_InitStruct->ADC_EAIN;
;;;109    #endif
;;;110    }
00001a  bd10              POP      {r4,pc}
;;;111    
                          ENDP

                  |L10.28|
                          DCD      0xffc8f7e0

                          AREA ||i.ADC_SetChannel||, CODE, READONLY, ALIGN=1

                  ADC_SetChannel PROC
;;;218     */
;;;219    void ADC_SetChannel ( ADC_TypeDef* ADCx, ADC_ChannelTypedef ADC_Channel )
000000  460a              MOV      r2,r1
;;;220    {
;;;221    #if defined(SC32f10xx)||defined(SC32f11xx)||defined(SC32f12xx)
;;;222        uint32_t tmpreg;
;;;223        /* Check the parameters */
;;;224        assert_param ( IS_ADC_ALL_PERIPH ( ADCx ) );
;;;225    
;;;226        tmpreg = ADCx->ADC_CON;
000002  6801              LDR      r1,[r0,#0]
;;;227        tmpreg &= ( uint32_t ) ~ ( ADC_CON_ADCIS );
000004  0949              LSRS     r1,r1,#5
000006  0149              LSLS     r1,r1,#5
;;;228    
;;;229        /* Set the ADC channel type */
;;;230        tmpreg |= ADC_Channel;
000008  460b              MOV      r3,r1
00000a  4313              ORRS     r3,r3,r2
00000c  4619              MOV      r1,r3
;;;231    
;;;232        ADCx->ADC_CON = tmpreg;
00000e  6001              STR      r1,[r0,#0]
;;;233    #elif defined(SC32f15xx)
;;;234        /* Check the parameters */
;;;235        assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;236        ADCx->ADC_CON &=(uint32_t) ~(ADC_CON_ADCISA);
;;;237        ADCx->ADC_CON  |= ADC_Channel<<16;
;;;238    #endif
;;;239    }
000010  4770              BX       lr
;;;240    
                          ENDP


                          AREA ||i.ADC_SoftwareStartConv||, CODE, READONLY, ALIGN=1

                  ADC_SoftwareStartConv PROC
;;;312     */
;;;313    void ADC_SoftwareStartConv ( ADC_TypeDef* ADCx )
000000  6801              LDR      r1,[r0,#0]
;;;314    {
;;;315        /* Check the parameters */
;;;316        assert_param ( IS_ADC_ALL_PERIPH ( ADCx ) );
;;;317    
;;;318        /* Set the ADCS Bit */
;;;319        ADCx->ADC_CON |= ADC_CON_ADCS;
000002  2280              MOVS     r2,#0x80
000004  4311              ORRS     r1,r1,r2
000006  6001              STR      r1,[r0,#0]
;;;320    }
000008  4770              BX       lr
;;;321    
                          ENDP


                          AREA ||i.ADC_StructInit||, CODE, READONLY, ALIGN=1

                  ADC_StructInit PROC
;;;117      */
;;;118    void ADC_StructInit ( ADC_InitTypeDef* ADC_InitStruct )
000000  2100              MOVS     r1,#0
;;;119    {
;;;120        /* Set the default configuration */
;;;121        ADC_InitStruct->ADC_ConvMode = ADC_ConvMode_Single;
000002  8181              STRH     r1,[r0,#0xc]
;;;122        ADC_InitStruct->ADC_EAIN = ADC_EAIN_Less;
000004  6041              STR      r1,[r0,#4]
;;;123        ADC_InitStruct->ADC_Prescaler = ADC_Prescaler_3CLOCK;
000006  2101              MOVS     r1,#1
000008  0489              LSLS     r1,r1,#18
00000a  6001              STR      r1,[r0,#0]
;;;124    #if !defined(SC32f15xx)
;;;125        ADC_InitStruct->ADC_VREF = ADC_VREF_VDD;
00000c  2100              MOVS     r1,#0
00000e  6081              STR      r1,[r0,#8]
;;;126    #else
;;;127    	ADC_InitStruct->ADC_VREF      = ADC_RefSource_VDD;
;;;128    #endif
;;;129    	
;;;130    
;;;131    }
000010  4770              BX       lr
;;;132    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_adc_c_e11a2ea2____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___15_sc32f1xxx_adc_c_e11a2ea2____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_adc_c_e11a2ea2____REVSH|
#line 478
|__asm___15_sc32f1xxx_adc_c_e11a2ea2____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
