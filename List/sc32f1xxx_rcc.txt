; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\sc32f1xxx_rcc.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\sc32f1xxx_rcc.d --cpu=Cortex-M0+ --apcs=interwork --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\Buzz\Inc -I..\Drivers\TKDriver\C -ID:\keil\ARM\PACK\Keil\SC32F1xxx_DFP\1.0.6\Device\SC32F10xx\FWLib\SC32_Lib\inc -D__UVISION_VERSION=534 -DSC32F10xx -DSC32f10xx --omf_browse=..\output\sc32f1xxx_rcc.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_rcc.c]
                          THUMB

                          AREA ||i.RCC_AHBPeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphClockCmd PROC
;;;732      */
;;;733    void RCC_AHBPeriphClockCmd ( uint32_t RCC_AHBPeriph, FunctionalState NewState )
000000  4a04              LDR      r2,|L1.20|
;;;734    {
;;;735        /* Check the parameters */
;;;736        assert_param ( IS_RCC_AHBPERIPH ( RCC_AHBPeriph ) );
;;;737    
;;;738        if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
;;;739        {
;;;740            RCCAHB->AHB_CFG |= RCC_AHBPeriph;
;;;741        }
;;;742        else
;;;743        {
;;;744            RCCAHB->AHB_CFG &= ~RCC_AHBPeriph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L1.12|
000008  4301              ORRS     r1,r1,r0              ;740
00000a  e000              B        |L1.14|
                  |L1.12|
00000c  4381              BICS     r1,r1,r0
                  |L1.14|
00000e  6011              STR      r1,[r2,#0]            ;740
;;;745        }
;;;746    }
000010  4770              BX       lr
;;;747    
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      0x40003000

                          AREA ||i.RCC_AHBPeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphResetCmd PROC
;;;873     */
;;;874    void RCC_AHBPeriphResetCmd ( uint32_t RCC_AHBPeriph, FunctionalState NewState )
000000  4a04              LDR      r2,|L2.20|
;;;875    {
;;;876        /* Check the parameters */
;;;877        assert_param ( IS_RCC_AHBPERIPH ( RCC_AHBPeriph ) );
;;;878    
;;;879        if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
;;;880        {
;;;881            RCCAHB->AHB_RST |= RCC_AHBPeriph;
;;;882        }
;;;883        else
;;;884        {
;;;885            RCCAHB->AHB_RST &= ~RCC_AHBPeriph;
000004  6851              LDR      r1,[r2,#4]
000006  d001              BEQ      |L2.12|
000008  4301              ORRS     r1,r1,r0              ;881
00000a  e000              B        |L2.14|
                  |L2.12|
00000c  4381              BICS     r1,r1,r0
                  |L2.14|
00000e  6051              STR      r1,[r2,#4]            ;881
;;;886        }
;;;887    }
000010  4770              BX       lr
;;;888    
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      0x40003000

                          AREA ||i.RCC_APB0Cmd||, CODE, READONLY, ALIGN=2

                  RCC_APB0Cmd PROC
;;;257      */
;;;258    void RCC_APB0Cmd ( FunctionalState NewState )
000000  4904              LDR      r1,|L3.20|
;;;259    {
;;;260        /* Check the parameters */
;;;261        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;262    
;;;263        if ( NewState != DISABLE )
;;;264        {
;;;265            RCCAPB0->APB0_CFG |= APB0_CFG_ENAPB;
000002  018a              LSLS     r2,r1,#6
000004  2800              CMP      r0,#0                 ;263
;;;266        }
;;;267        else
;;;268        {
;;;269            RCCAPB0->APB0_CFG &= ~APB0_CFG_ENAPB;
000006  6808              LDR      r0,[r1,#0]
000008  d001              BEQ      |L3.14|
00000a  4310              ORRS     r0,r0,r2              ;265
00000c  e000              B        |L3.16|
                  |L3.14|
00000e  4390              BICS     r0,r0,r2
                  |L3.16|
000010  6008              STR      r0,[r1,#0]            ;265
;;;270        }
;;;271    }
000012  4770              BX       lr
;;;272    
                          ENDP

                  |L3.20|
                          DCD      0x40020000

                          AREA ||i.RCC_APB0Config||, CODE, READONLY, ALIGN=2

                  RCC_APB0Config PROC
;;;498     */
;;;499    void RCC_APB0Config ( RCC_PCLK_TypeDef RCC_APB0CLK )
000000  4904              LDR      r1,|L4.20|
;;;500    {
;;;501        /* Check the parameters */
;;;502        assert_param ( IS_RCC_PCLK ( RCC_APB0CLK ) );
;;;503    
;;;504        RCCAPB0->APB0_CFG &= ~ ( ( uint32_t ) APB0_CFG_CLKDIV );
000002  680a              LDR      r2,[r1,#0]
000004  2307              MOVS     r3,#7
000006  051b              LSLS     r3,r3,#20
000008  439a              BICS     r2,r2,r3
00000a  600a              STR      r2,[r1,#0]
;;;505        RCCAPB0->APB0_CFG |= RCC_APB0CLK;
00000c  680a              LDR      r2,[r1,#0]
00000e  4302              ORRS     r2,r2,r0
000010  600a              STR      r2,[r1,#0]
;;;506    }
000012  4770              BX       lr
;;;507    
                          ENDP

                  |L4.20|
                          DCD      0x40020000

                          AREA ||i.RCC_APB0PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB0PeriphClockCmd PROC
;;;770      */
;;;771    void RCC_APB0PeriphClockCmd ( uint32_t RCC_APB0Periph, FunctionalState NewState )
000000  4a04              LDR      r2,|L5.20|
;;;772    {
;;;773        /* Check the parameters */
;;;774        assert_param ( IS_RCC_APB0PERIPH ( RCC_APB0Periph ) );
;;;775    
;;;776        if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
;;;777        {
;;;778            RCCAPB0->APB0_CFG |= RCC_APB0Periph;
;;;779        }
;;;780        else
;;;781        {
;;;782            RCCAPB0->APB0_CFG &= ~RCC_APB0Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L5.12|
000008  4301              ORRS     r1,r1,r0              ;778
00000a  e000              B        |L5.14|
                  |L5.12|
00000c  4381              BICS     r1,r1,r0
                  |L5.14|
00000e  6011              STR      r1,[r2,#0]            ;778
;;;783        }
;;;784    }
000010  4770              BX       lr
;;;785    
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40020000

                          AREA ||i.RCC_APB0PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB0PeriphResetCmd PROC
;;;911     */
;;;912    void RCC_APB0PeriphResetCmd ( uint32_t RCC_APB0Periph, FunctionalState NewState )
000000  4a04              LDR      r2,|L6.20|
;;;913    {
;;;914        /* Check the parameters */
;;;915        assert_param ( IS_RCC_APB0PERIPH ( RCC_APB0Periph ) );
;;;916    
;;;917        if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
;;;918        {
;;;919            RCCAPB0->APB0_RST |= RCC_APB0Periph;
;;;920        }
;;;921        else
;;;922        {
;;;923            RCCAPB0->APB0_RST &= ~RCC_APB0Periph;
000004  6851              LDR      r1,[r2,#4]
000006  d001              BEQ      |L6.12|
000008  4301              ORRS     r1,r1,r0              ;919
00000a  e000              B        |L6.14|
                  |L6.12|
00000c  4381              BICS     r1,r1,r0
                  |L6.14|
00000e  6051              STR      r1,[r2,#4]            ;919
;;;924        }
;;;925    }
000010  4770              BX       lr
;;;926    
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x40020000

                          AREA ||i.RCC_APB1Cmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1Cmd PROC
;;;279      */
;;;280    void RCC_APB1Cmd ( FunctionalState NewState )
000000  2201              MOVS     r2,#1
;;;281    {
;;;282        /* Check the parameters */
;;;283        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;284    
;;;285        if ( NewState != DISABLE )
;;;286        {
;;;287            RCCAPB1->APB1_CFG |= APB1_CFG_ENAPB;
000002  4905              LDR      r1,|L7.24|
000004  05d2              LSLS     r2,r2,#23
000006  2800              CMP      r0,#0                 ;285
;;;288        }
;;;289        else
;;;290        {
;;;291            RCCAPB1->APB1_CFG &= ~APB1_CFG_ENAPB;
000008  6808              LDR      r0,[r1,#0]
00000a  d001              BEQ      |L7.16|
00000c  4310              ORRS     r0,r0,r2              ;287
00000e  e000              B        |L7.18|
                  |L7.16|
000010  4390              BICS     r0,r0,r2
                  |L7.18|
000012  6008              STR      r0,[r1,#0]            ;287
;;;292        }
;;;293    }
000014  4770              BX       lr
;;;294    
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1Config||, CODE, READONLY, ALIGN=2

                  RCC_APB1Config PROC
;;;520     */
;;;521    void RCC_APB1Config ( RCC_PCLK_TypeDef RCC_APB1CLK )
000000  4904              LDR      r1,|L8.20|
;;;522    {
;;;523        /* Check the parameters */
;;;524        assert_param ( IS_RCC_PCLK ( RCC_APB1CLK ) );
;;;525    
;;;526        RCCAPB1->APB1_CFG &= ~ ( ( uint32_t ) APB1_CFG_CLKDIV );
000002  680a              LDR      r2,[r1,#0]
000004  2307              MOVS     r3,#7
000006  051b              LSLS     r3,r3,#20
000008  439a              BICS     r2,r2,r3
00000a  600a              STR      r2,[r1,#0]
;;;527        RCCAPB1->APB1_CFG |= RCC_APB1CLK;
00000c  680a              LDR      r2,[r1,#0]
00000e  4302              ORRS     r2,r2,r0
000010  600a              STR      r2,[r1,#0]
;;;528    }
000012  4770              BX       lr
;;;529    
                          ENDP

                  |L8.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;807      */
;;;808    void RCC_APB1PeriphClockCmd ( uint32_t RCC_APB1Periph, FunctionalState NewState )
000000  4a04              LDR      r2,|L9.20|
;;;809    {
;;;810        /* Check the parameters */
;;;811        assert_param ( IS_RCC_APB1PERIPH ( RCC_APB1Periph ) );
;;;812    
;;;813        if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
;;;814        {
;;;815            RCCAPB1->APB1_CFG |= RCC_APB1Periph;
;;;816        }
;;;817        else
;;;818        {
;;;819            RCCAPB1->APB1_CFG &= ~RCC_APB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L9.12|
000008  4301              ORRS     r1,r1,r0              ;815
00000a  e000              B        |L9.14|
                  |L9.12|
00000c  4381              BICS     r1,r1,r0
                  |L9.14|
00000e  6011              STR      r1,[r2,#0]            ;815
;;;820        }
;;;821    }
000010  4770              BX       lr
;;;822    
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;948     */
;;;949    void RCC_APB1PeriphResetCmd ( uint32_t RCC_APB1Periph, FunctionalState NewState )
000000  4a04              LDR      r2,|L10.20|
;;;950    {
;;;951        /* Check the parameters */
;;;952        assert_param ( IS_RCC_APB1PERIPH ( RCC_APB1Periph ) );
;;;953    
;;;954        if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
;;;955        {
;;;956            RCCAPB1->APB1_RST |= RCC_APB1Periph;
;;;957        }
;;;958        else
;;;959        {
;;;960            RCCAPB1->APB1_RST &= ~RCC_APB1Periph;
000004  6851              LDR      r1,[r2,#4]
000006  d001              BEQ      |L10.12|
000008  4301              ORRS     r1,r1,r0              ;956
00000a  e000              B        |L10.14|
                  |L10.12|
00000c  4381              BICS     r1,r1,r0
                  |L10.14|
00000e  6051              STR      r1,[r2,#4]            ;956
;;;961        }
;;;962    }
000010  4770              BX       lr
;;;963    
                          ENDP

000012  0000              DCW      0x0000
                  |L10.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2Cmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2Cmd PROC
;;;301      */
;;;302    void RCC_APB2Cmd ( FunctionalState NewState )
000000  2201              MOVS     r2,#1
;;;303    {
;;;304        /* Check the parameters */
;;;305        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;306    
;;;307        if ( NewState != DISABLE )
;;;308        {
;;;309            RCCAPB2->APB2_CFG |= APB2_CFG_ENAPB;
000002  4905              LDR      r1,|L11.24|
000004  05d2              LSLS     r2,r2,#23
000006  2800              CMP      r0,#0                 ;307
;;;310        }
;;;311        else
;;;312        {
;;;313            RCCAPB2->APB2_CFG &= ~APB2_CFG_ENAPB;
000008  6808              LDR      r0,[r1,#0]
00000a  d001              BEQ      |L11.16|
00000c  4310              ORRS     r0,r0,r2              ;309
00000e  e000              B        |L11.18|
                  |L11.16|
000010  4390              BICS     r0,r0,r2
                  |L11.18|
000012  6008              STR      r0,[r1,#0]            ;309
;;;314        }
;;;315    }
000014  4770              BX       lr
;;;316    
                          ENDP

000016  0000              DCW      0x0000
                  |L11.24|
                          DCD      0x40022000

                          AREA ||i.RCC_APB2Config||, CODE, READONLY, ALIGN=2

                  RCC_APB2Config PROC
;;;542     */
;;;543    void RCC_APB2Config ( RCC_PCLK_TypeDef RCC_APB2CLK )
000000  4904              LDR      r1,|L12.20|
;;;544    {
;;;545        /* Check the parameters */
;;;546        assert_param ( IS_RCC_PCLK ( RCC_APB2CLK ) );
;;;547    
;;;548        RCCAPB2->APB2_CFG &= ~ ( ( uint32_t ) APB2_CFG_CLKDIV );
000002  680a              LDR      r2,[r1,#0]
000004  2307              MOVS     r3,#7
000006  051b              LSLS     r3,r3,#20
000008  439a              BICS     r2,r2,r3
00000a  600a              STR      r2,[r1,#0]
;;;549        RCCAPB2->APB2_CFG |= RCC_APB2CLK;
00000c  680a              LDR      r2,[r1,#0]
00000e  4302              ORRS     r2,r2,r0
000010  600a              STR      r2,[r1,#0]
;;;550    }
000012  4770              BX       lr
;;;551    
                          ENDP

                  |L12.20|
                          DCD      0x40022000

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;841      */
;;;842    void RCC_APB2PeriphClockCmd ( uint32_t RCC_APB2Periph, FunctionalState NewState )
000000  4a04              LDR      r2,|L13.20|
;;;843    {
;;;844        /* Check the parameters */
;;;845        assert_param ( IS_RCC_APB2PERIPH ( RCC_APB2Periph ) );
;;;846    
;;;847        if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
;;;848        {
;;;849            RCCAPB2->APB2_CFG |= RCC_APB2Periph;
;;;850        }
;;;851        else
;;;852        {
;;;853            RCCAPB2->APB2_CFG &= ~RCC_APB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L13.12|
000008  4301              ORRS     r1,r1,r0              ;849
00000a  e000              B        |L13.14|
                  |L13.12|
00000c  4381              BICS     r1,r1,r0
                  |L13.14|
00000e  6011              STR      r1,[r2,#0]            ;849
;;;854        }
;;;855    }
000010  4770              BX       lr
;;;856    
                          ENDP

000012  0000              DCW      0x0000
                  |L13.20|
                          DCD      0x40022000

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;982     */
;;;983    void RCC_APB2PeriphResetCmd ( uint32_t RCC_APB2Periph, FunctionalState NewState )
000000  4a04              LDR      r2,|L14.20|
;;;984    {
;;;985        /* Check the parameters */
;;;986        assert_param ( IS_RCC_APB2PERIPH ( RCC_APB2Periph ) );
;;;987    
;;;988        if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
;;;989        {
;;;990            RCCAPB2->APB2_RST |= RCC_APB2Periph;
;;;991        }
;;;992        else
;;;993        {
;;;994            RCCAPB2->APB2_RST &= ~RCC_APB2Periph;
000004  6851              LDR      r1,[r2,#4]
000006  d001              BEQ      |L14.12|
000008  4301              ORRS     r1,r1,r0              ;990
00000a  e000              B        |L14.14|
                  |L14.12|
00000c  4381              BICS     r1,r1,r0
                  |L14.14|
00000e  6051              STR      r1,[r2,#4]            ;990
;;;995        }
;;;996    }
000010  4770              BX       lr
;;;997    
                          ENDP

000012  0000              DCW      0x0000
                  |L14.20|
                          DCD      0x40022000

                          AREA ||i.RCC_BTMCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_BTMCLKConfig PROC
;;;704     */
;;;705    void RCC_BTMCLKConfig ( RCC_BTMCLKSource_TypeDef RCC_BTMCLKSource )
000000  b500              PUSH     {lr}
;;;706    {
000002  4602              MOV      r2,r0
;;;707        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;708        /* Check the parameters */
;;;709        assert_param ( RCC_BTMCLKSOURCE ( RCC_BTMCLKSource ) );
;;;710    
;;;711        RCC->RCC_CFG1 &= ~ ( ( uint32_t ) RCC_CFG1_BTMCLKSEL );
00000a  4904              LDR      r1,|L15.28|
00000c  6988              LDR      r0,[r1,#0x18]
00000e  0840              LSRS     r0,r0,#1
000010  0040              LSLS     r0,r0,#1
000012  6188              STR      r0,[r1,#0x18]
;;;712        RCC->RCC_CFG1 |= ( uint32_t ) ( RCC_BTMCLKSource );
000014  698b              LDR      r3,[r1,#0x18]
000016  4313              ORRS     r3,r3,r2
000018  618b              STR      r3,[r1,#0x18]
;;;713    }
00001a  bd00              POP      {pc}
;;;714    
                          ENDP

                  |L15.28|
                          DCD      0x40003000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;45      */
;;;46     void RCC_DeInit ( void )
000000  4805              LDR      r0,|L16.24|
;;;47     {
;;;48         /*	RCC Reg Unlock = 0 */
;;;49         RCC->RCC_KEY = 0x40;
000002  2140              MOVS     r1,#0x40
000004  60c1              STR      r1,[r0,#0xc]
;;;50     
;;;51         /* Reset RCC_CFG0 register */
;;;52         RCC->RCC_CFG0 = ( uint32_t ) 0x00001040;
000006  2141              MOVS     r1,#0x41
000008  0189              LSLS     r1,r1,#6
00000a  6141              STR      r1,[r0,#0x14]
;;;53     
;;;54         /* Reset RCC_CFG1 register */
;;;55         RCC->RCC_CFG1 = ( uint32_t ) 0x00000000;
00000c  2100              MOVS     r1,#0
00000e  6181              STR      r1,[r0,#0x18]
;;;56     
;;;57     #if defined(SC32f10xx)
;;;58         /* Reset PLL_CFG register */
;;;59         RCC->PLL_CFG = ( uint32_t ) 0x00000000;
000010  61c1              STR      r1,[r0,#0x1c]
;;;60     #endif
;;;61     
;;;62         /* Reset PLL_CFG register */
;;;63         RCC->NMI_CFG = ( uint32_t ) 0x00000000;
000012  62c1              STR      r1,[r0,#0x2c]
;;;64     
;;;65     }
000014  4770              BX       lr
;;;66     
                          ENDP

000016  0000              DCW      0x0000
                  |L16.24|
                          DCD      0x40003000

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;557      */
;;;558    void RCC_GetClocksFreq ( RCC_ClocksTypeDef* RCC_Clocks )
000000  b5f8              PUSH     {r3-r7,lr}
;;;559    {
;;;560        uint32_t  tmp;
;;;561    
;;;562    #if defined(SC32f10xx)
;;;563        uint32_t  pllp, pllsource, pllm, plln;
;;;564    #endif
;;;565    
;;;566        /* Get SYSCLK source -------------------------------------------------------*/
;;;567        if ( ( RCC->RCC_CFG0 & RCC_CFG0_SYSCLKSW ) == RESET )
000002  4d23              LDR      r5,|L17.144|
000004  4604              MOV      r4,r0                 ;559
000006  6968              LDR      r0,[r5,#0x14]
000008  0601              LSLS     r1,r0,#24
;;;568        {
;;;569    #if defined(SC32f10xx)
;;;570            RCC_Clocks->SYSCLK_Frequency = HIRC_VALUE;
00000a  4822              LDR      r0,|L17.148|
00000c  d524              BPL      |L17.88|
;;;571    #elif defined(SC32f11xx) ||defined(SC32f12xx)
;;;572            RCC_Clocks->SYSCLK_Frequency = HIRC_VALUE / 2;
;;;573    #endif
;;;574        }
;;;575        else
;;;576        {
;;;577            switch ( RCC->RCC_CFG0 & RCC_CFG0_SYSCLKSEL )
00000e  6969              LDR      r1,[r5,#0x14]
000010  2203              MOVS     r2,#3
000012  0212              LSLS     r2,r2,#8
000014  4011              ANDS     r1,r1,r2
000016  d007              BEQ      |L17.40|
000018  39ff              SUBS     r1,r1,#0xff
00001a  39ff              SUBS     r1,r1,#0xff
00001c  1e89              SUBS     r1,r1,#2
00001e  d009              BEQ      |L17.52|
000020  39ff              SUBS     r1,r1,#0xff
000022  2901              CMP      r1,#1
000024  d119              BNE      |L17.90|
000026  e002              B        |L17.46|
                  |L17.40|
;;;578            {
;;;579    #if defined(SC32f11xx) ||defined(SC32f12xx)
;;;580            case RCC_SYSCLKSource_HXT:   /* HXT used as system clock source */
;;;581                RCC_Clocks->SYSCLK_Frequency = HXT_VALUE;
;;;582                break;
;;;583    #endif
;;;584            case RCC_SYSCLKSource_LIRC:   /* LIRC used as system clock source */
;;;585                RCC_Clocks->SYSCLK_Frequency = LIRC_VALUE;
000028  207d              MOVS     r0,#0x7d
00002a  0200              LSLS     r0,r0,#8
;;;586                break;
00002c  e014              B        |L17.88|
                  |L17.46|
;;;587            case RCC_SYSCLKSource_LXT:   /* LXT used as system clock source */
;;;588                RCC_Clocks->SYSCLK_Frequency = LXT_VALUE;
00002e  2001              MOVS     r0,#1
000030  03c0              LSLS     r0,r0,#15
;;;589                break;
000032  e011              B        |L17.88|
                  |L17.52|
;;;590    #if defined(SC32f11xx) ||defined(SC32f12xx)||defined(SC32f15xx)
;;;591            case RCC_SYSCLKSource_HIRC_2:   /* HIRC used as system clock source */
;;;592                RCC_Clocks->SYSCLK_Frequency = HIRC_VALUE;
;;;593                break;
;;;594    #elif defined(SC32f10xx)
;;;595            case RCC_SYSCLKSource_PLLRCLK:   /* PLL used as system clock source */
;;;596                if ( ( RCC->PLL_CFG & PLL_CFG_PLLCLKSEL ) == RESET ) /* HXT used as PLL clock source */
000034  69e9              LDR      r1,[r5,#0x1c]
000036  0209              LSLS     r1,r1,#8
000038  d500              BPL      |L17.60|
;;;597                {
;;;598                    pllsource = HIRC_VALUE;
;;;599                }
;;;600                else   /* HIRC used as PLL clock source */
;;;601                {
;;;602                    pllsource = HXT_VALUE;
00003a  4817              LDR      r0,|L17.152|
                  |L17.60|
;;;603                }
;;;604    
;;;605                pllm = ( ( RCC->PLL_CFG & PLL_CFG_MDIVM ) >> PLL_CFG_MDIVM_Pos );
00003c  69e9              LDR      r1,[r5,#0x1c]
;;;606                plln = ( ( RCC->PLL_CFG & PLL_CFG_NDIVN ) >> PLL_CFG_NDIVN_Pos );
00003e  69ea              LDR      r2,[r5,#0x1c]
;;;607                pllp = ( ( RCC->PLL_CFG & PLL_CFG_PDIVP ) >> PLL_CFG_PDIVP_Pos );
;;;608    
;;;609                RCC_Clocks->SYSCLK_Frequency = ( ( ( pllsource / pllm ) * plln ) >> ( pllp + 1 ) );
;;;610                break;
;;;611    #endif
;;;612            }
;;;613        }
;;;614    
;;;615        /* Get AHB source -------------------------------------------------------*/
;;;616        tmp = ( ( RCCAHB->AHB_CFG & AHB_CFG_CLKDIV ) >> AHB_CFG_CLKDIV_Pos );
;;;617        RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> tmp;
;;;618    
;;;619        /* Get APB source -------------------------------------------------------*/
;;;620        tmp = ( ( RCCAPB0->APB0_CFG & APB0_CFG_CLKDIV ) >> APB0_CFG_CLKDIV_Pos );
;;;621        RCC_Clocks->PCLK0_Frequency = RCC_Clocks->HCLK_Frequency >> tmp;
;;;622    
;;;623        /* Get AHB source -------------------------------------------------------*/
;;;624        tmp = ( ( RCCAPB1->APB1_CFG & APB1_CFG_CLKDIV ) >> APB1_CFG_CLKDIV_Pos );
;;;625        RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> tmp;
;;;626    
;;;627        /* Get AHB source -------------------------------------------------------*/
;;;628        tmp = ( ( RCCAPB2->APB2_CFG & APB2_CFG_CLKDIV ) >> APB2_CFG_CLKDIV_Pos );
;;;629        RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> tmp;
;;;630    }
000040  02c9              LSLS     r1,r1,#11
000042  0ec9              LSRS     r1,r1,#27
000044  0412              LSLS     r2,r2,#16             ;606
000046  0e17              LSRS     r7,r2,#24             ;606
000048  69ea              LDR      r2,[r5,#0x1c]         ;607
00004a  0796              LSLS     r6,r2,#30             ;607
00004c  0fb6              LSRS     r6,r6,#30             ;607
00004e  f7fffffe          BL       __aeabi_uidivmod
000052  4378              MULS     r0,r7,r0              ;609
000054  1c76              ADDS     r6,r6,#1              ;609
000056  40f0              LSRS     r0,r0,r6              ;609
                  |L17.88|
000058  6020              STR      r0,[r4,#0]            ;609
                  |L17.90|
00005a  6828              LDR      r0,[r5,#0]            ;616
00005c  0240              LSLS     r0,r0,#9
00005e  0f41              LSRS     r1,r0,#29
000060  6820              LDR      r0,[r4,#0]            ;617
000062  40c8              LSRS     r0,r0,r1              ;617
000064  490d              LDR      r1,|L17.156|
000066  6060              STR      r0,[r4,#4]            ;620
000068  6809              LDR      r1,[r1,#0]            ;620
00006a  4602              MOV      r2,r0
00006c  0249              LSLS     r1,r1,#9
00006e  0f49              LSRS     r1,r1,#29
000070  40ca              LSRS     r2,r2,r1              ;621
000072  490b              LDR      r1,|L17.160|
000074  60a2              STR      r2,[r4,#8]            ;624
000076  6809              LDR      r1,[r1,#0]            ;624
000078  4602              MOV      r2,r0
00007a  0249              LSLS     r1,r1,#9
00007c  0f49              LSRS     r1,r1,#29
00007e  40ca              LSRS     r2,r2,r1              ;625
000080  4908              LDR      r1,|L17.164|
000082  60e2              STR      r2,[r4,#0xc]          ;628
000084  6809              LDR      r1,[r1,#0]            ;628
000086  0249              LSLS     r1,r1,#9
000088  0f49              LSRS     r1,r1,#29
00008a  40c8              LSRS     r0,r0,r1              ;629
00008c  6120              STR      r0,[r4,#0x10]         ;629
00008e  bdf8              POP      {r3-r7,pc}
;;;631    
                          ENDP

                  |L17.144|
                          DCD      0x40003000
                  |L17.148|
                          DCD      0x01e84800
                  |L17.152|
                          DCD      0x00f42400
                  |L17.156|
                          DCD      0x40020000
                  |L17.160|
                          DCD      0x40021000
                  |L17.164|
                          DCD      0x40022000

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;1179    */
;;;1180   FlagStatus RCC_GetFlagStatus ( uint32_t RCC_FLAG )
000000  4903              LDR      r1,|L18.16|
;;;1181   {
;;;1182       /* Check the parameters */
;;;1183       assert_param ( IS_GET_RCC_FLAG ( RCC_FLAG ) );
;;;1184   
;;;1185       if( ( RCC->RCC_STS & RCC_FLAG ) != ( uint32_t ) RESET )
000002  6a09              LDR      r1,[r1,#0x20]
000004  4201              TST      r1,r0
000006  d001              BEQ      |L18.12|
;;;1186       {
;;;1187           return ( SET );
000008  2001              MOVS     r0,#1
;;;1188       }
;;;1189       return ( RESET );
;;;1190   }
00000a  4770              BX       lr
                  |L18.12|
00000c  2000              MOVS     r0,#0                 ;1189
00000e  4770              BX       lr
;;;1191   
                          ENDP

                  |L18.16|
                          DCD      0x40003000

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;449      */
;;;450    RCC_SYSCLKSource_TypeDef RCC_GetSYSCLKSource ( void )
000000  4805              LDR      r0,|L19.24|
;;;451    {
;;;452        if ( ( RCC->RCC_CFG0 & RCC_CFG0_SYSCLKSW ) != RESET )
000002  6941              LDR      r1,[r0,#0x14]
000004  0609              LSLS     r1,r1,#24
000006  d504              BPL      |L19.18|
;;;453        {
;;;454            return ( ( RCC_SYSCLKSource_TypeDef ) ( RCC->RCC_CFG0 & RCC_CFG0_SYSCLKSEL ) );
000008  6940              LDR      r0,[r0,#0x14]
00000a  2103              MOVS     r1,#3
00000c  0209              LSLS     r1,r1,#8
00000e  4008              ANDS     r0,r0,r1
;;;455        }
;;;456        else
;;;457        {
;;;458    #if defined (SC32f10xx)
;;;459            return RCC_SYSCLKSource_HIRC;
;;;460    #elif defined (SC32f11xx) ||  defined (SC32f12xx) ||  defined (SC32f15xx)
;;;461            return RCC_SYSCLKSource_HIRC_2;
;;;462    #endif
;;;463        }
;;;464    
;;;465    }
000010  4770              BX       lr
                  |L19.18|
000012  4802              LDR      r0,|L19.28|
000014  4770              BX       lr
;;;466    
                          ENDP

000016  0000              DCW      0x0000
                  |L19.24|
                          DCD      0x40003000
                  |L19.28|
                          DCD      0x0000ff7f

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;476     */
;;;477    void RCC_HCLKConfig ( RCC_HCLK_TypeDef RCC_HCLK )
000000  4904              LDR      r1,|L20.20|
;;;478    {
;;;479        /* Check the parameters */
;;;480        assert_param ( IS_RCC_HCLK ( RCC_HCLK ) );
;;;481    
;;;482        RCCAHB->AHB_CFG &= ( uint32_t ) ~ ( AHB_CFG_CLKDIV );
000002  680a              LDR      r2,[r1,#0]
000004  2307              MOVS     r3,#7
000006  051b              LSLS     r3,r3,#20
000008  439a              BICS     r2,r2,r3
00000a  600a              STR      r2,[r1,#0]
;;;483        RCCAHB->AHB_CFG |= RCC_HCLK;
00000c  680a              LDR      r2,[r1,#0]
00000e  4302              ORRS     r2,r2,r0
000010  600a              STR      r2,[r1,#0]
;;;484    }
000012  4770              BX       lr
;;;485    
                          ENDP

                  |L20.20|
                          DCD      0x40003000

                          AREA ||i.RCC_HIRCCmd||, CODE, READONLY, ALIGN=2

                  RCC_HIRCCmd PROC
;;;118      */
;;;119    void RCC_HIRCCmd ( FunctionalState NewState )
000000  b500              PUSH     {lr}
;;;120    {
000002  4602              MOV      r2,r0
;;;121        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;122        if ( NewState != DISABLE )
;;;123        {
;;;124            /* Enable the selected HIRC peripheral */
;;;125            RCC->RCC_CFG0 |= RCC_CFG0_HIRCEN;
00000a  4905              LDR      r1,|L21.32|
00000c  2340              MOVS     r3,#0x40
;;;126        }
;;;127        else
;;;128        {
;;;129            /* Disable the selected HIRC peripheral */
;;;130            RCC->RCC_CFG0 &= ( uint32_t ) ~ ( ( uint32_t ) RCC_CFG0_HIRCEN );
00000e  6948              LDR      r0,[r1,#0x14]
000010  2a00              CMP      r2,#0                 ;122
000012  d001              BEQ      |L21.24|
000014  4318              ORRS     r0,r0,r3              ;125
000016  e000              B        |L21.26|
                  |L21.24|
000018  4398              BICS     r0,r0,r3
                  |L21.26|
00001a  6148              STR      r0,[r1,#0x14]         ;125
;;;131        }
;;;132    }
00001c  bd00              POP      {pc}
;;;133    
                          ENDP

00001e  0000              DCW      0x0000
                  |L21.32|
                          DCD      0x40003000

                          AREA ||i.RCC_HXTCmd||, CODE, READONLY, ALIGN=2

                  RCC_HXTCmd PROC
;;;96       */
;;;97     void RCC_HXTCmd ( FunctionalState NewState )
000000  b500              PUSH     {lr}
;;;98     {
000002  4602              MOV      r2,r0
;;;99         RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;100        if ( NewState != DISABLE )
;;;101        {
;;;102            /* Enable the selected HXT peripheral */
;;;103            RCC->RCC_CFG0 |= RCC_CFG0_HXTEN;
00000a  4905              LDR      r1,|L22.32|
00000c  2320              MOVS     r3,#0x20
;;;104        }
;;;105        else
;;;106        {
;;;107            /* Disable the selected HXT peripheral */
;;;108            RCC->RCC_CFG0 &= ( uint32_t ) ~ ( ( uint32_t ) RCC_CFG0_HXTEN );
00000e  6948              LDR      r0,[r1,#0x14]
000010  2a00              CMP      r2,#0                 ;100
000012  d001              BEQ      |L22.24|
000014  4318              ORRS     r0,r0,r3              ;103
000016  e000              B        |L22.26|
                  |L22.24|
000018  4398              BICS     r0,r0,r3
                  |L22.26|
00001a  6148              STR      r0,[r1,#0x14]         ;103
;;;109        }
;;;110    }
00001c  bd00              POP      {pc}
;;;111    #endif
                          ENDP

00001e  0000              DCW      0x0000
                  |L22.32|
                          DCD      0x40003000

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;1153     */
;;;1154   void RCC_ITConfig ( FunctionalState NewState )
000000  b500              PUSH     {lr}
;;;1155   {
000002  4602              MOV      r2,r0
;;;1156       RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;1157       if ( NewState != DISABLE )
;;;1158       {
;;;1159           RCC->RCC_CFG0 |= RCC_CFG0_INTEN;
00000a  4905              LDR      r1,|L23.32|
00000c  13cb              ASRS     r3,r1,#15
;;;1160       }
;;;1161       else
;;;1162       {
;;;1163           RCC->RCC_CFG0 &= ( uint32_t ) ~ ( ( uint32_t ) RCC_CFG0_INTEN );
00000e  6948              LDR      r0,[r1,#0x14]
000010  2a00              CMP      r2,#0                 ;1157
000012  d001              BEQ      |L23.24|
000014  4318              ORRS     r0,r0,r3              ;1159
000016  e000              B        |L23.26|
                  |L23.24|
000018  4398              BICS     r0,r0,r3
                  |L23.26|
00001a  6148              STR      r0,[r1,#0x14]         ;1159
;;;1164       }
;;;1165   }
00001c  bd00              POP      {pc}
;;;1166   
                          ENDP

00001e  0000              DCW      0x0000
                  |L23.32|
                          DCD      0x40003000

                          AREA ||i.RCC_LCDLEDCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_LCDLEDCLKConfig PROC
;;;687     */
;;;688    void RCC_LCDLEDCLKConfig ( RCC_LCDLEDCLKSource_TypeDef RCC_LCDLEDCLKSource )
000000  b500              PUSH     {lr}
;;;689    {
000002  4603              MOV      r3,r0
;;;690        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;691        /* Check the parameters */
;;;692        assert_param ( RCC_LCDLEDCLKSOURCE ( RCC_LCDLEDCLKSource ) );
;;;693    
;;;694        RCC->RCC_CFG1 &= ~ ( ( uint32_t ) RCC_CFG1_LCDCLKSEL );
00000a  4904              LDR      r1,|L24.28|
00000c  698a              LDR      r2,[r1,#0x18]
00000e  2002              MOVS     r0,#2
000010  4382              BICS     r2,r2,r0
000012  618a              STR      r2,[r1,#0x18]
;;;695        RCC->RCC_CFG1 |= ( uint32_t ) ( RCC_LCDLEDCLKSource );
000014  698a              LDR      r2,[r1,#0x18]
000016  431a              ORRS     r2,r2,r3
000018  618a              STR      r2,[r1,#0x18]
;;;696    }
00001a  bd00              POP      {pc}
;;;697    #endif
                          ENDP

                  |L24.28|
                          DCD      0x40003000

                          AREA ||i.RCC_LIRCCmd||, CODE, READONLY, ALIGN=2

                  RCC_LIRCCmd PROC
;;;162      */
;;;163    void RCC_LIRCCmd ( FunctionalState NewState )
000000  b500              PUSH     {lr}
;;;164    {
000002  4602              MOV      r2,r0
;;;165        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;166        if ( NewState != DISABLE )
;;;167        {
;;;168            /* Enable the selected LIRC peripheral */
;;;169            RCC->RCC_CFG0 |= RCC_CFG0_LIRCEN;
00000a  4905              LDR      r1,|L25.32|
00000c  2302              MOVS     r3,#2
;;;170        }
;;;171        else
;;;172        {
;;;173            /* Disable the selected LIRC peripheral */
;;;174            RCC->RCC_CFG0 &= ( uint32_t ) ~ ( ( uint32_t ) RCC_CFG0_LIRCEN );
00000e  6948              LDR      r0,[r1,#0x14]
000010  2a00              CMP      r2,#0                 ;166
000012  d001              BEQ      |L25.24|
000014  4318              ORRS     r0,r0,r3              ;169
000016  e000              B        |L25.26|
                  |L25.24|
000018  4398              BICS     r0,r0,r3
                  |L25.26|
00001a  6148              STR      r0,[r1,#0x14]         ;169
;;;175        }
;;;176    }
00001c  bd00              POP      {pc}
;;;177    
                          ENDP

00001e  0000              DCW      0x0000
                  |L25.32|
                          DCD      0x40003000

                          AREA ||i.RCC_LXTCmd||, CODE, READONLY, ALIGN=2

                  RCC_LXTCmd PROC
;;;140      */
;;;141    void RCC_LXTCmd ( FunctionalState NewState )
000000  b500              PUSH     {lr}
;;;142    {
000002  4602              MOV      r2,r0
;;;143        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;144        if ( NewState != DISABLE )
;;;145        {
;;;146            /* Enable the selected LXT peripheral */
;;;147            RCC->RCC_CFG0 |= RCC_CFG0_LXTEN;
00000a  4905              LDR      r1,|L26.32|
00000c  2a00              CMP      r2,#0                 ;144
;;;148        }
;;;149        else
;;;150        {
;;;151            /* Disable the selected LXT peripheral */
;;;152            RCC->RCC_CFG0 &= ( uint32_t ) ~ ( ( uint32_t ) RCC_CFG0_LXTEN );
00000e  6948              LDR      r0,[r1,#0x14]
000010  d002              BEQ      |L26.24|
000012  2201              MOVS     r2,#1                 ;147
000014  4310              ORRS     r0,r0,r2              ;147
000016  e001              B        |L26.28|
                  |L26.24|
000018  0840              LSRS     r0,r0,#1
00001a  0040              LSLS     r0,r0,#1
                  |L26.28|
00001c  6148              STR      r0,[r1,#0x14]         ;147
;;;153        }
;;;154    }
00001e  bd00              POP      {pc}
;;;155    
                          ENDP

                  |L26.32|
                          DCD      0x40003000

                          AREA ||i.RCC_NMICmd||, CODE, READONLY, ALIGN=2

                  RCC_NMICmd PROC
;;;1018    */
;;;1019   void RCC_NMICmd ( uint32_t RCC_NMIPeriph, FunctionalState NewState )
000000  b510              PUSH     {r4,lr}
;;;1020   {
;;;1021       uint32_t temp;
;;;1022       /* Check the parameters */
;;;1023       assert_param ( IS_RCC_NMIPeriph ( RCC_NMIPeriph ) );
;;;1024   
;;;1025       temp = RCC->NMI_CFG;
000002  4b05              LDR      r3,|L27.24|
000004  6ada              LDR      r2,[r3,#0x2c]
;;;1026   
;;;1027       temp &= ( ~RCC_NMIPeriph );
;;;1028   
;;;1029       if ( NewState != DISABLE )
;;;1030       {
;;;1031           temp |= 0xA05F0000 | RCC_NMIPeriph;
000006  4c05              LDR      r4,|L27.28|
000008  4382              BICS     r2,r2,r0              ;1027
00000a  2900              CMP      r1,#0                 ;1029
00000c  d000              BEQ      |L27.16|
00000e  4302              ORRS     r2,r2,r0
                  |L27.16|
;;;1032       }
;;;1033       else
;;;1034       {
;;;1035           temp |= 0xA05F0000;
000010  4322              ORRS     r2,r2,r4
;;;1036       }
;;;1037       RCC->NMI_CFG = temp;
000012  62da              STR      r2,[r3,#0x2c]
;;;1038   }
000014  bd10              POP      {r4,pc}
;;;1039   /* End of RCC_Group3.	*/
                          ENDP

000016  0000              DCW      0x0000
                  |L27.24|
                          DCD      0x40003000
                  |L27.28|
                          DCD      0xa05f0000

                          AREA ||i.RCC_PLLCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLCmd PROC
;;;185      */
;;;186    void RCC_PLLCmd ( FunctionalState NewState )
000000  b500              PUSH     {lr}
;;;187    {
000002  4602              MOV      r2,r0
;;;188        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;189        /* Check the parameters */
;;;190        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;191    
;;;192        if ( NewState != DISABLE )
;;;193        {
;;;194            /* Enable the PLL peripheral */
;;;195            RCC->PLL_CFG |= PLL_CFG_PLLON;
00000a  4905              LDR      r1,|L28.32|
00000c  2380              MOVS     r3,#0x80
;;;196        }
;;;197        else
;;;198        {
;;;199            /* Disable the PLL Clock */
;;;200            RCC->PLL_CFG &= ( uint32_t ) ~ ( ( uint32_t ) PLL_CFG_PLLON );
00000e  69c8              LDR      r0,[r1,#0x1c]
000010  2a00              CMP      r2,#0                 ;192
000012  d001              BEQ      |L28.24|
000014  4318              ORRS     r0,r0,r3              ;195
000016  e000              B        |L28.26|
                  |L28.24|
000018  4398              BICS     r0,r0,r3
                  |L28.26|
00001a  61c8              STR      r0,[r1,#0x1c]         ;195
;;;201        }
;;;202    }
00001c  bd00              POP      {pc}
;;;203    
                          ENDP

00001e  0000              DCW      0x0000
                  |L28.32|
                          DCD      0x40003000

                          AREA ||i.RCC_PLLConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLConfig PROC
;;;326     */
;;;327    void RCC_PLLConfig ( RCC_PLLCLKSource_TypeDef RCC_PLLCLKSource, RLL_Factor_TypeDef* RLL_Factor )
000000  b530              PUSH     {r4,r5,lr}
;;;328    {
000002  4604              MOV      r4,r0
000004  460a              MOV      r2,r1
;;;329        RCC_Unlock ( 0xFF );
000006  20ff              MOVS     r0,#0xff
000008  f7fffffe          BL       RCC_Unlock
;;;330        uint32_t tmpreg = 0;
;;;331        
;;;332        /* Check the parameters */
;;;333        assert_param ( RCC_PLLCLKSOURCE ( RCC_PLLCLKSource ) );
;;;334    	
;;;335            tmpreg = RCC->PLL_CFG;
00000c  4807              LDR      r0,|L29.44|
00000e  69c3              LDR      r3,[r0,#0x1c]
;;;336    
;;;337        tmpreg &= ( uint32_t ) ~ ( PLL_CFG_PLLCLKSEL | PLL_CFG_MDIVM | PLL_CFG_NDIVN | PLL_CFG_PDIVP );
000010  4907              LDR      r1,|L29.48|
;;;338    
;;;339        tmpreg |= ( uint32_t ) ( RCC_PLLCLKSource | ( RLL_Factor->PLLM << PLL_CFG_MDIVM_Pos ) |
000012  6855              LDR      r5,[r2,#4]
000014  400b              ANDS     r3,r3,r1              ;337
000016  8811              LDRH     r1,[r2,#0]
000018  6892              LDR      r2,[r2,#8]
00001a  0409              LSLS     r1,r1,#16
00001c  022d              LSLS     r5,r5,#8
00001e  4329              ORRS     r1,r1,r5
000020  4322              ORRS     r2,r2,r4
000022  4311              ORRS     r1,r1,r2
000024  4319              ORRS     r1,r1,r3
;;;340                                 ( RLL_Factor->PLLN << PLL_CFG_NDIVN_Pos ) | ( RLL_Factor->PLLP << PLL_CFG_PDIVP_Pos ) );
;;;341    
;;;342        RCC->PLL_CFG = tmpreg;
000026  61c1              STR      r1,[r0,#0x1c]
;;;343    }
000028  bd30              POP      {r4,r5,pc}
;;;344    #endif
                          ENDP

00002a  0000              DCW      0x0000
                  |L29.44|
                          DCD      0x40003000
                  |L29.48|
                          DCD      0xff6000fc

                          AREA ||i.RCC_PLLRCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLRCmd PROC
;;;210      */
;;;211    void RCC_PLLRCmd ( FunctionalState NewState )
000000  b500              PUSH     {lr}
;;;212    {
000002  4602              MOV      r2,r0
;;;213        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;214        /* Check the parameters */
;;;215        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;216    
;;;217        if ( NewState != DISABLE )
;;;218        {
;;;219            RCC->PLL_CFG |= PLL_CFG_PLLREN;
00000a  4905              LDR      r1,|L30.32|
00000c  2340              MOVS     r3,#0x40
;;;220        }
;;;221        else
;;;222        {
;;;223            RCC->PLL_CFG &= ( uint32_t ) ~ ( ( uint32_t ) PLL_CFG_PLLREN );
00000e  69c8              LDR      r0,[r1,#0x1c]
000010  2a00              CMP      r2,#0                 ;217
000012  d001              BEQ      |L30.24|
000014  4318              ORRS     r0,r0,r3              ;219
000016  e000              B        |L30.26|
                  |L30.24|
000018  4398              BICS     r0,r0,r3
                  |L30.26|
00001a  61c8              STR      r0,[r1,#0x1c]         ;219
;;;224        }
;;;225    }
00001c  bd00              POP      {pc}
;;;226    #endif
                          ENDP

00001e  0000              DCW      0x0000
                  |L30.32|
                          DCD      0x40003000

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;375     */
;;;376    ErrorStatus RCC_SYSCLKConfig ( RCC_SYSCLKSource_TypeDef RCC_SYSCLKSource )
000000  b5f8              PUSH     {r3-r7,lr}
;;;377    {
000002  4605              MOV      r5,r0
;;;378        uint32_t tmpreg;
;;;379        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;380    
;;;381    
;;;382        /* Check the parameters */
;;;383        assert_param ( IS_RCC_SYSCLKSOURCE ( RCC_SYSCLKSource ) );
;;;384        if ( RCC_SYSCLKSource != ( ( uint16_t ) ( ~RCC_CFG0_SYSCLKSW ) ) )
00000a  4821              LDR      r0,|L31.144|
;;;385        {
;;;386    
;;;387    #if defined(SC32f11xx)||defined(SC32f12xx)||defined(SC32f15xx)
;;;388            if ( RCC_SYSCLKSource == RCC_SYSCLKSource_HIRC )
;;;389            {
;;;390                RCC->RCC_CFG0 &= ~RCC_CFG0_WAIT_Msk;
;;;391                RCC->RCC_CFG0 |= RCC_WAIT_2;
;;;392            }
;;;393    #elif defined(SC32f10xx)
;;;394        uint32_t Multioperator = 1;
;;;395        for ( int i = 1; i <= ((RCC->PLL_CFG &0x03) + 1 ); i++ )
;;;396        {
;;;397            Multioperator *=  2;
;;;398        }
;;;399        if ( ( ( 2 * ((RCC->PLL_CFG &0xFF00)>>8) ) / Multioperator ) >= 64 )
;;;400        {
;;;401            RCC->RCC_CFG0 &= ~RCC_CFG0_WAIT_Msk;
00000c  2603              MOVS     r6,#3
;;;402            RCC->RCC_CFG0 |= RCC_WAIT_1;
00000e  2701              MOVS     r7,#1
000010  0336              LSLS     r6,r6,#12             ;401
000012  033f              LSLS     r7,r7,#12
000014  4c1f              LDR      r4,|L31.148|
000016  4285              CMP      r5,r0                 ;384
000018  d029              BEQ      |L31.110|
00001a  2101              MOVS     r1,#1                 ;394
00001c  4608              MOV      r0,r1                 ;395
00001e  e001              B        |L31.36|
                  |L31.32|
000020  0049              LSLS     r1,r1,#1              ;397
000022  1c40              ADDS     r0,r0,#1              ;397
                  |L31.36|
000024  69e2              LDR      r2,[r4,#0x1c]         ;395
000026  0792              LSLS     r2,r2,#30             ;395
000028  0f92              LSRS     r2,r2,#30             ;395
00002a  1c52              ADDS     r2,r2,#1              ;395
00002c  4282              CMP      r2,r0                 ;395
00002e  d2f7              BCS      |L31.32|
000030  69e0              LDR      r0,[r4,#0x1c]         ;399
000032  0400              LSLS     r0,r0,#16             ;399
000034  0e00              LSRS     r0,r0,#24             ;399
000036  0040              LSLS     r0,r0,#1              ;399
000038  f7fffffe          BL       __aeabi_uidivmod
00003c  2840              CMP      r0,#0x40              ;399
00003e  d305              BCC      |L31.76|
000040  6960              LDR      r0,[r4,#0x14]         ;401
000042  43b0              BICS     r0,r0,r6              ;401
000044  6160              STR      r0,[r4,#0x14]         ;401
000046  6960              LDR      r0,[r4,#0x14]
000048  4338              ORRS     r0,r0,r7
00004a  6160              STR      r0,[r4,#0x14]
                  |L31.76|
;;;403        }
;;;404    #endif
;;;405    		    RCC_Unlock ( 0xFF );
00004c  20ff              MOVS     r0,#0xff
00004e  f7fffffe          BL       RCC_Unlock
;;;406    				
;;;407            tmpreg = RCC->RCC_CFG0;
000052  6960              LDR      r0,[r4,#0x14]
;;;408    
;;;409            tmpreg &= ( uint32_t ) ~ ( RCC_CFG0_SYSCLKSEL | RCC_CFG0_SYSCLKSW );
000054  2107              MOVS     r1,#7
000056  01c9              LSLS     r1,r1,#7
000058  4388              BICS     r0,r0,r1
;;;410    
;;;411            tmpreg |= ( uint32_t ) RCC_SYSCLKSource;
00005a  4328              ORRS     r0,r0,r5
;;;412    
;;;413            RCC->RCC_CFG0 = tmpreg;
00005c  6160              STR      r0,[r4,#0x14]
;;;414    
;;;415            RCC->RCC_CFG0 |= RCC_CFG0_SYSCLKSW;
00005e  6960              LDR      r0,[r4,#0x14]
000060  2180              MOVS     r1,#0x80
000062  4308              ORRS     r0,r0,r1
000064  6160              STR      r0,[r4,#0x14]
;;;416    
;;;417            if ( ( RCC->RCC_CFG0 & RCC_CFG0_SYSCLKSW ) != RESET )
000066  6960              LDR      r0,[r4,#0x14]
000068  0600              LSLS     r0,r0,#24
00006a  d40d              BMI      |L31.136|
00006c  e00e              B        |L31.140|
                  |L31.110|
;;;418                return SUCCESS;
;;;419            else
;;;420                return ERROR;
;;;421        }
;;;422        else
;;;423        {
;;;424            RCC->RCC_CFG0 &= ~RCC_CFG0_WAIT_Msk;
00006e  6960              LDR      r0,[r4,#0x14]
000070  43b0              BICS     r0,r0,r6
000072  6160              STR      r0,[r4,#0x14]
;;;425            RCC->RCC_CFG0 |= RCC_WAIT_1;
000074  6960              LDR      r0,[r4,#0x14]
000076  4338              ORRS     r0,r0,r7
000078  6160              STR      r0,[r4,#0x14]
;;;426            RCC->RCC_CFG0 &= ( uint32_t ) ~RCC_CFG0_SYSCLKSW;
00007a  6961              LDR      r1,[r4,#0x14]
00007c  2080              MOVS     r0,#0x80
00007e  4381              BICS     r1,r1,r0
000080  6161              STR      r1,[r4,#0x14]
;;;427    
;;;428            if ( ( RCC->RCC_CFG0 & RCC_CFG0_SYSCLKSW ) == RESET )
000082  6960              LDR      r0,[r4,#0x14]
000084  0600              LSLS     r0,r0,#24
000086  d401              BMI      |L31.140|
                  |L31.136|
;;;429                return SUCCESS;
000088  2000              MOVS     r0,#0
;;;430            else
;;;431                return ERROR;
;;;432        }
;;;433    }
00008a  bdf8              POP      {r3-r7,pc}
                  |L31.140|
00008c  2001              MOVS     r0,#1                 ;431
00008e  bdf8              POP      {r3-r7,pc}
;;;434    
                          ENDP

                  |L31.144|
                          DCD      0x0000ff7f
                  |L31.148|
                          DCD      0x40003000

                          AREA ||i.RCC_SystickCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SystickCLKConfig PROC
;;;1062    */
;;;1063   void RCC_SystickCLKConfig ( RCC_SysTickSource_TypeDef RCC_SysTickSource )
000000  b510              PUSH     {r4,lr}
;;;1064   {
;;;1065   
;;;1066       /* Check the parameters */
;;;1067       assert_param ( IS_RCC_SYSTICKSOURCE ( RCC_SysTickSource ) );
;;;1068   
;;;1069       if ( RCC_SysTickSource == RCC_SysTickSource_HCLK )
;;;1070       {
;;;1071           SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
000002  4c0c              LDR      r4,|L32.52|
000004  2304              MOVS     r3,#4
000006  4602              MOV      r2,r0                 ;1064
000008  2801              CMP      r0,#1                 ;1069
00000a  d00e              BEQ      |L32.42|
;;;1072       }
;;;1073       else
;;;1074       {
;;;1075           RCC_Unlock ( 0xFF );
00000c  20ff              MOVS     r0,#0xff
00000e  f7fffffe          BL       RCC_Unlock
;;;1076           SysTick->CTRL &= ~SysTick_CTRL_CLKSOURCE_Msk;
000012  6920              LDR      r0,[r4,#0x10]
000014  4398              BICS     r0,r0,r3
000016  6120              STR      r0,[r4,#0x10]
;;;1077           RCC->RCC_CFG1 &= ~ ( ( uint32_t ) RCC_CFG1_STCLKSEL );
000018  4907              LDR      r1,|L32.56|
00001a  6988              LDR      r0,[r1,#0x18]
00001c  2360              MOVS     r3,#0x60
00001e  4398              BICS     r0,r0,r3
000020  6188              STR      r0,[r1,#0x18]
;;;1078           RCC->RCC_CFG1 |= ( uint32_t ) ( RCC_SysTickSource );
000022  6988              LDR      r0,[r1,#0x18]
000024  4310              ORRS     r0,r0,r2
000026  6188              STR      r0,[r1,#0x18]
;;;1079       }
;;;1080   }
000028  bd10              POP      {r4,pc}
                  |L32.42|
00002a  6920              LDR      r0,[r4,#0x10]         ;1071
00002c  4318              ORRS     r0,r0,r3              ;1071
00002e  6120              STR      r0,[r4,#0x10]         ;1071
000030  bd10              POP      {r4,pc}
;;;1081   /**
                          ENDP

000032  0000              DCW      0x0000
                  |L32.52|
                          DCD      0xe000e000
                  |L32.56|
                          DCD      0x40003000

                          AREA ||i.RCC_SystickCmd||, CODE, READONLY, ALIGN=2

                  RCC_SystickCmd PROC
;;;1100     */
;;;1101   void RCC_SystickCmd ( FunctionalState NewState )
000000  4905              LDR      r1,|L33.24|
;;;1102   {
;;;1103       /* Check the parameters */
;;;1104       assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;1105   
;;;1106       if ( NewState != DISABLE )
000002  2800              CMP      r0,#0
;;;1107       {
;;;1108           SysTick->CTRL |= ( uint32_t ) ( SysTick_CTRL_ENABLE_Msk | SysTick_CTRL_TICKINT_Msk ); /* Enable SysTick IRQ and SysTick Timer */
;;;1109       }
;;;1110       else
;;;1111       {
;;;1112           SysTick->CTRL &= ~ ( uint32_t ) ( SysTick_CTRL_ENABLE_Msk | SysTick_CTRL_TICKINT_Msk );
000004  6908              LDR      r0,[r1,#0x10]
000006  d002              BEQ      |L33.14|
000008  2203              MOVS     r2,#3                 ;1108
00000a  4310              ORRS     r0,r0,r2              ;1108
00000c  e001              B        |L33.18|
                  |L33.14|
00000e  0880              LSRS     r0,r0,#2
000010  0080              LSLS     r0,r0,#2
                  |L33.18|
000012  6108              STR      r0,[r1,#0x10]         ;1108
;;;1113       }
;;;1114   }
000014  4770              BX       lr
;;;1115   /**
                          ENDP

000016  0000              DCW      0x0000
                  |L33.24|
                          DCD      0xe000e000

                          AREA ||i.RCC_SystickGetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_SystickGetFlagStatus PROC
;;;1121    */
;;;1122   FlagStatus RCC_SystickGetFlagStatus ( void )
000000  4803              LDR      r0,|L34.16|
;;;1123   {
;;;1124       if ( ( SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk ) != ( uint32_t ) RESET )
000002  6900              LDR      r0,[r0,#0x10]
000004  03c0              LSLS     r0,r0,#15
000006  d501              BPL      |L34.12|
;;;1125       {
;;;1126           return ( SET );
000008  2001              MOVS     r0,#1
;;;1127       }
;;;1128       return ( RESET );
;;;1129   }
00000a  4770              BX       lr
                  |L34.12|
00000c  2000              MOVS     r0,#0                 ;1128
00000e  4770              BX       lr
;;;1130   /**
                          ENDP

                  |L34.16|
                          DCD      0xe000e000

                          AREA ||i.RCC_SystickSetCounter||, CODE, READONLY, ALIGN=2

                  RCC_SystickSetCounter PROC
;;;1085    */
;;;1086   void RCC_SystickSetCounter ( uint32_t Counter )
000000  4904              LDR      r1,|L35.20|
;;;1087   {
;;;1088       if ( ( Counter - 1UL ) <= SysTick_LOAD_RELOAD_Msk ) /* Reload value possible */
000002  1e40              SUBS     r0,r0,#1
000004  4288              CMP      r0,r1
000006  d803              BHI      |L35.16|
;;;1089       {
;;;1090           SysTick->LOAD = ( uint32_t ) ( Counter - 1UL ); /* set reload register */
000008  4903              LDR      r1,|L35.24|
00000a  6148              STR      r0,[r1,#0x14]
;;;1091           SysTick->VAL  = 0UL;   /* Load the SysTick Counter Value */
00000c  2000              MOVS     r0,#0
00000e  6188              STR      r0,[r1,#0x18]
                  |L35.16|
;;;1092       }
;;;1093   }
000010  4770              BX       lr
;;;1094   /**
                          ENDP

000012  0000              DCW      0x0000
                  |L35.20|
                          DCD      0x00ffffff
                  |L35.24|
                          DCD      0xe000e000

                          AREA ||i.RCC_Unlock||, CODE, READONLY, ALIGN=2

                  RCC_Unlock PROC
;;;76      */
;;;77     ErrorStatus RCC_Unlock ( uint8_t TimeLimit )
000000  2840              CMP      r0,#0x40
;;;78     {
000002  d303              BCC      |L36.12|
;;;79         if ( TimeLimit >= 0x40 )
;;;80         {
;;;81             RCC->RCC_KEY = TimeLimit;
000004  4902              LDR      r1,|L36.16|
000006  60c8              STR      r0,[r1,#0xc]
;;;82             return SUCCESS;
000008  2000              MOVS     r0,#0
;;;83         }
;;;84         else
;;;85         {
;;;86             return ERROR;
;;;87         }
;;;88     }
00000a  4770              BX       lr
                  |L36.12|
00000c  2001              MOVS     r0,#1                 ;86
00000e  4770              BX       lr
;;;89     #if !defined(SC32f15xx)
                          ENDP

                  |L36.16|
                          DCD      0x40003000

                          AREA ||i.RCC_WaitConfig||, CODE, READONLY, ALIGN=2

                  RCC_WaitConfig PROC
;;;640     */
;;;641    void RCC_WaitConfig ( RCC_Wait_TypeDef RCC_Wait )
000000  b500              PUSH     {lr}
;;;642    {
000002  4603              MOV      r3,r0
;;;643        RCC_Unlock ( 0xFF );
000004  20ff              MOVS     r0,#0xff
000006  f7fffffe          BL       RCC_Unlock
;;;644        /* Check the parameters */
;;;645        assert_param ( IS_RCC_Wait ( RCC_Wait ) );
;;;646    
;;;647        RCC->RCC_CFG0 &= ~RCC_CFG0_WAIT_Msk;
00000a  4905              LDR      r1,|L37.32|
00000c  694a              LDR      r2,[r1,#0x14]
00000e  2003              MOVS     r0,#3
000010  0300              LSLS     r0,r0,#12
000012  4382              BICS     r2,r2,r0
000014  614a              STR      r2,[r1,#0x14]
;;;648        RCC->RCC_CFG0 |= RCC_Wait;
000016  694a              LDR      r2,[r1,#0x14]
000018  431a              ORRS     r2,r2,r3
00001a  614a              STR      r2,[r1,#0x14]
;;;649    
;;;650    }
00001c  bd00              POP      {pc}
;;;651    /** @defgroup RCC_Group3 Peripheral clocks configuration functions
                          ENDP

00001e  0000              DCW      0x0000
                  |L37.32|
                          DCD      0x40003000

;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_rcc_c_49e27980____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___15_sc32f1xxx_rcc_c_49e27980____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_rcc_c_49e27980____REVSH|
#line 478
|__asm___15_sc32f1xxx_rcc_c_49e27980____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
