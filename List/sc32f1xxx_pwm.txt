; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\sc32f1xxx_pwm.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\sc32f1xxx_pwm.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\Buzz\Inc -I..\Drivers\TKDriver\C -I..\ADC_IAP\Inc -ID:\keil\ARM\PACK\Keil\SC32F1xxx_DFP\1.0.6\Device\SC32F10xx\FWLib\SC32_Lib\inc -D__MICROLIB -D__UVISION_VERSION=534 -DSC32F10xx -DSC32f10xx --omf_browse=..\output\sc32f1xxx_pwm.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_pwm.c]
                          THUMB

                          AREA ||i.PWM_ClearFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearFlag PROC
;;;493     */
;;;494    void PWM_ClearFlag ( PWM_TypeDef* PWMx, uint16_t PWM_FLAG )
000000  6081              STR      r1,[r0,#8]
;;;495    {
;;;496        /* Check the parameters */
;;;497        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;498        assert_param ( IS_GET_PWM_FLAG ( PWM_FLAG ) );
;;;499    
;;;500        /* Clear the flags */
;;;501        PWMx->PWM_STS = ( uint16_t ) PWM_FLAG;
;;;502    }
000002  4770              BX       lr
;;;503    #endif
                          ENDP


                          AREA ||i.PWM_Cmd||, CODE, READONLY, ALIGN=2

                  PWM_Cmd PROC
;;;163     */
;;;164    void PWM_Cmd ( PWM_TypeDef* PWMx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;165    {
;;;166        /* Check the parameters */
;;;167        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;168        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;169    
;;;170        if ( NewState != DISABLE )
000002  d004              BEQ      |L2.14|
;;;171        {
;;;172            /* Enable the PWM Counter */
;;;173            PWMx->PWM_CON |= PWM_CON_ENPWM;
000004  6802              LDR      r2,[r0,#0]
000006  2380              MOVS     r3,#0x80
000008  431a              ORRS     r2,r2,r3
00000a  6002              STR      r2,[r0,#0]
00000c  e003              B        |L2.22|
                  |L2.14|
;;;174        }
;;;175        else
;;;176        {
;;;177            /* Disable the PWM Counter */
;;;178            PWMx->PWM_CON &= ( uint16_t ) ~PWM_CON_ENPWM;
00000e  6802              LDR      r2,[r0,#0]
000010  4b01              LDR      r3,|L2.24|
000012  401a              ANDS     r2,r2,r3
000014  6002              STR      r2,[r0,#0]
                  |L2.22|
;;;179        }
;;;180    }
000016  4770              BX       lr
;;;181    
                          ENDP

                  |L2.24|
                          DCD      0x0000ff7f

                          AREA ||i.PWM_DeInit||, CODE, READONLY, ALIGN=2

                  PWM_DeInit PROC
;;;32      */
;;;33     void PWM_DeInit ( PWM_TypeDef* PWMx )
000000  b510              PUSH     {r4,lr}
;;;34     {
000002  4604              MOV      r4,r0
;;;35         /* Check the parameters */
;;;36         assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;37     
;;;38         if ( PWMx == PWM0 )
000004  4805              LDR      r0,|L3.28|
000006  4284              CMP      r4,r0
000008  d107              BNE      |L3.26|
;;;39         {
;;;40             /* Enable PWM reset state */
;;;41             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_PWM0, ENABLE );
00000a  2101              MOVS     r1,#1
00000c  1580              ASRS     r0,r0,#22
00000e  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;42             /* Enable PWM reset state */
;;;43             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_PWM0, DISABLE );
000012  2100              MOVS     r1,#0
000014  15a0              ASRS     r0,r4,#22
000016  f7fffffe          BL       RCC_APB0PeriphResetCmd
                  |L3.26|
;;;44         }
;;;45     }
00001a  bd10              POP      {r4,pc}
;;;46     
                          ENDP

                  |L3.28|
                          DCD      0x40020200

                          AREA ||i.PWM_FDCmd||, CODE, READONLY, ALIGN=2

                  PWM_FDCmd PROC
;;;394     */
;;;395    void PWM_FDCmd ( PWM_TypeDef* PWMx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;396    {
;;;397        /* Check the parameters */
;;;398        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;399        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;400    
;;;401        if ( NewState != DISABLE )
000002  d004              BEQ      |L4.14|
;;;402        {
;;;403            /* Enable the PWM Fault Dectection */
;;;404            PWMx->PWM_FLT |= PWM_FLT_FLTEN;
000004  6942              LDR      r2,[r0,#0x14]
000006  2380              MOVS     r3,#0x80
000008  431a              ORRS     r2,r2,r3
00000a  6142              STR      r2,[r0,#0x14]
00000c  e003              B        |L4.22|
                  |L4.14|
;;;405        }
;;;406        else
;;;407        {
;;;408            /* Disable the PWM Fault Dectection */
;;;409            PWMx->PWM_FLT &= ( uint16_t ) ~PWM_FLT_FLTEN;
00000e  6942              LDR      r2,[r0,#0x14]
000010  4b01              LDR      r3,|L4.24|
000012  401a              ANDS     r2,r2,r3
000014  6142              STR      r2,[r0,#0x14]
                  |L4.22|
;;;410        }
;;;411    }
000016  4770              BX       lr
;;;412    /**
                          ENDP

                  |L4.24|
                          DCD      0x0000ff7f

                          AREA ||i.PWM_FDInit||, CODE, READONLY, ALIGN=1

                  PWM_FDInit PROC
;;;376     */
;;;377    void PWM_FDInit ( PWM_TypeDef* PWMx, PWM_FDInitTypeDef* PWM_FDInitStruct )
000000  6942              LDR      r2,[r0,#0x14]
;;;378    {
;;;379        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;380    
;;;381        PWMx->PWM_FLT &= ( uint32_t ) ~ ( PWM_FLT_FLTDT | PWM_FLT_FLTTV | PWM_FLT_FLTMD );
000002  2333              MOVS     r3,#0x33
000004  439a              BICS     r2,r2,r3
000006  6142              STR      r2,[r0,#0x14]
;;;382        PWMx->PWM_FLT |= ( uint32_t ) ( PWM_FDInitStruct->PWM_FDFilteringTime | PWM_FDInitStruct->PWM_FDMode |
000008  888a              LDRH     r2,[r1,#4]
00000a  880b              LDRH     r3,[r1,#0]
00000c  431a              ORRS     r2,r2,r3
00000e  884b              LDRH     r3,[r1,#2]
000010  431a              ORRS     r2,r2,r3
000012  6943              LDR      r3,[r0,#0x14]
000014  431a              ORRS     r2,r2,r3
000016  6142              STR      r2,[r0,#0x14]
;;;383                                        PWM_FDInitStruct->PWM_FDVoltage );
;;;384    }
000018  4770              BX       lr
;;;385    
                          ENDP


                          AREA ||i.PWM_FDStructInit||, CODE, READONLY, ALIGN=1

                  PWM_FDStructInit PROC
;;;361      */
;;;362    void PWM_FDStructInit ( PWM_FDInitTypeDef* PWM_FDInitStruct )
000000  2100              MOVS     r1,#0
;;;363    {
;;;364        /* Set the default configuration */
;;;365        PWM_FDInitStruct->PWM_FDFilteringTime = PWM_FilteringTime_0us;
000002  8081              STRH     r1,[r0,#4]
;;;366        PWM_FDInitStruct->PWM_FDMode = PWM_FDMode_Latch;
000004  8001              STRH     r1,[r0,#0]
;;;367        PWM_FDInitStruct->PWM_FDVoltage = PWM_FDVoltage_Low;
000006  8041              STRH     r1,[r0,#2]
;;;368    }
000008  4770              BX       lr
;;;369    
                          ENDP


                          AREA ||i.PWM_FallingDeadTimeConfig||, CODE, READONLY, ALIGN=1

                  PWM_FallingDeadTimeConfig PROC
;;;135     */
;;;136    void PWM_FallingDeadTimeConfig ( PWM_TypeDef* PWMx, uint8_t PWM_FallingDeadTime )
000000  b510              PUSH     {r4,lr}
;;;137    {
000002  460a              MOV      r2,r1
;;;138        uint32_t tmpreg;
;;;139        /* Check the parameters */
;;;140        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;141    
;;;142        /* Get the PWMx PWM_DFR value */
;;;143        tmpreg = PWMx->PWM_DFR;
000004  6901              LDR      r1,[r0,#0x10]
;;;144    
;;;145        /* Clear PDF bits */
;;;146        tmpreg &= ( uint32_t ) ~ ( PWM_DFR_PDF );
000006  240f              MOVS     r4,#0xf
000008  0224              LSLS     r4,r4,#8
00000a  460b              MOV      r3,r1
00000c  43a3              BICS     r3,r3,r4
00000e  4619              MOV      r1,r3
;;;147    
;;;148        /* Set PDF bits to Rising Dead Time value */
;;;149        tmpreg |= ( uint32_t ) ( PWM_FallingDeadTime << PWM_DFR_PDF_Pos );
000010  0213              LSLS     r3,r2,#8
000012  4319              ORRS     r1,r1,r3
;;;150    
;;;151        /* Write to PWMx PWM_DFR */
;;;152        PWMx->PWM_DFR = tmpreg;
000014  6101              STR      r1,[r0,#0x10]
;;;153    }
000016  bd10              POP      {r4,pc}
;;;154    
                          ENDP


                          AREA ||i.PWM_GetCycle||, CODE, READONLY, ALIGN=1

                  PWM_GetCycle PROC
;;;255     */
;;;256    uint16_t PWM_GetCycle ( PWM_TypeDef* PWMx )
000000  4601              MOV      r1,r0
;;;257    {
;;;258        /* Check the parameters */
;;;259        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;260    
;;;261        /* Get the ReloadData Register value */
;;;262        return ( uint16_t ) PWMx->PWM_CYCLE;
000002  6988              LDR      r0,[r1,#0x18]
000004  b280              UXTH     r0,r0
;;;263    }
000006  4770              BX       lr
;;;264    
                          ENDP


                          AREA ||i.PWM_GetDuty||, CODE, READONLY, ALIGN=1

                  PWM_GetDuty PROC
;;;318     */
;;;319    uint16_t PWM_GetDuty ( PWM_TypeDef* PWMx, PWM_Channel_Typedef PWM_Channel )
000000  b530              PUSH     {r4,r5,lr}
;;;320    {
000002  4602              MOV      r2,r0
000004  460c              MOV      r4,r1
;;;321        uint8_t tmpvalue ;
;;;322        uint32_t tmpchannel;
;;;323        /* Check the parameters */
;;;324        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;325        assert_param ( IS_PWM_CHANNEL ( PWM_Channel ) );
;;;326    
;;;327        tmpchannel = 1;
000006  2301              MOVS     r3,#1
;;;328        for ( tmpvalue = 0; tmpvalue < 8; tmpvalue++ )
000008  2100              MOVS     r1,#0
00000a  e00c              B        |L9.38|
                  |L9.12|
;;;329        {
;;;330            if ( ( uint32_t ) PWM_Channel & tmpchannel )
00000c  4620              MOV      r0,r4
00000e  4018              ANDS     r0,r0,r3
000010  2800              CMP      r0,#0
000012  d005              BEQ      |L9.32|
;;;331            {
;;;332                return ( uint16_t ) ( PWMx->PWM_DT[tmpvalue] );
000014  008d              LSLS     r5,r1,#2
000016  4610              MOV      r0,r2
000018  3030              ADDS     r0,r0,#0x30
00001a  5940              LDR      r0,[r0,r5]
00001c  b280              UXTH     r0,r0
                  |L9.30|
;;;333            }
;;;334            tmpchannel = tmpchannel << 1;
;;;335        }
;;;336        return 0;
;;;337    }
00001e  bd30              POP      {r4,r5,pc}
                  |L9.32|
000020  005b              LSLS     r3,r3,#1              ;334
000022  1c48              ADDS     r0,r1,#1              ;328
000024  b2c1              UXTB     r1,r0                 ;328
                  |L9.38|
000026  2908              CMP      r1,#8                 ;328
000028  dbf0              BLT      |L9.12|
00002a  2000              MOVS     r0,#0                 ;336
00002c  e7f7              B        |L9.30|
;;;338    
                          ENDP


                          AREA ||i.PWM_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  PWM_GetFlagStatus PROC
;;;466     */
;;;467    FlagStatus PWM_GetFlagStatus ( PWM_TypeDef* PWMx, uint16_t PWM_FLAG )
000000  4602              MOV      r2,r0
;;;468    {
;;;469        ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;470        /* Check the parameters */
;;;471        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;472        assert_param ( IS_PWM_FLAG ( PWM_FLAG ) );
;;;473    
;;;474        if ( ( PWMx->PWM_STS & PWM_FLAG ) != ( uint16_t ) RESET )
000004  6893              LDR      r3,[r2,#8]
000006  400b              ANDS     r3,r3,r1
000008  2b00              CMP      r3,#0
00000a  d001              BEQ      |L10.16|
;;;475        {
;;;476            bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L10.18|
                  |L10.16|
;;;477        }
;;;478        else
;;;479        {
;;;480            bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L10.18|
;;;481        }
;;;482        return bitstatus;
;;;483    }
000012  4770              BX       lr
;;;484    
                          ENDP


                          AREA ||i.PWM_GetPrescaler||, CODE, READONLY, ALIGN=1

                  PWM_GetPrescaler PROC
;;;223     */
;;;224    PWM_Prescaler_TypeDef PWM_GetPrescaler ( PWM_TypeDef* PWMx )
000000  4601              MOV      r1,r0
;;;225    {
;;;226        /* Check the parameters */
;;;227        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;228    
;;;229        /* Get the CKD value */
;;;230        return ( PWM_Prescaler_TypeDef ) ( PWMx->PWM_CON & PWM_CON_PWMCLK );
000002  6808              LDR      r0,[r1,#0]
000004  0700              LSLS     r0,r0,#28
000006  0f00              LSRS     r0,r0,#28
;;;231    }
000008  4770              BX       lr
;;;232    
                          ENDP


                          AREA ||i.PWM_ITConfig||, CODE, READONLY, ALIGN=1

                  PWM_ITConfig PROC
;;;437     */
;;;438    void PWM_ITConfig ( PWM_TypeDef* PWMx, uint16_t PWM_IT, FunctionalState NewState )
000000  b510              PUSH     {r4,lr}
;;;439    {
;;;440        /* Check the parameters */
;;;441        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;442        assert_param ( IS_PWM_IT ( PWM_IT ) );
;;;443        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;444    
;;;445        if ( NewState != DISABLE )
000002  2a00              CMP      r2,#0
000004  d003              BEQ      |L12.14|
;;;446        {
;;;447            /* Enable the Interrupt sources */
;;;448            PWMx->PWM_CON |= PWM_IT;
000006  6803              LDR      r3,[r0,#0]
000008  430b              ORRS     r3,r3,r1
00000a  6003              STR      r3,[r0,#0]
00000c  e004              B        |L12.24|
                  |L12.14|
;;;449        }
;;;450        else
;;;451        {
;;;452            /* Disable the Interrupt sources */
;;;453            PWMx->PWM_CON &= ( uint16_t ) ~PWM_IT;
00000e  6803              LDR      r3,[r0,#0]
000010  43cc              MVNS     r4,r1
000012  b2a4              UXTH     r4,r4
000014  4023              ANDS     r3,r3,r4
000016  6003              STR      r3,[r0,#0]
                  |L12.24|
;;;454        }
;;;455    }
000018  bd10              POP      {r4,pc}
;;;456    
                          ENDP


                          AREA ||i.PWM_Init||, CODE, READONLY, ALIGN=1

                  PWM_Init PROC
;;;70      */
;;;71     void PWM_Init ( PWM_TypeDef* PWMx, PWM_InitTypeDef* PWM_InitStruct )
000000  b510              PUSH     {r4,lr}
;;;72     {
;;;73         uint32_t tmpreg;
;;;74         /* Check the parameters */
;;;75         assert_param ( IS_PWM_COMPLEMENTARY_PERIPH ( PWMx ) );
;;;76     
;;;77         /*---------------------------- PWMx PWM_CON Configuration ------------------------*/
;;;78         /* Get the PWMx PWM_CON value */
;;;79         tmpreg = PWMx->PWM_CON;
000002  6802              LDR      r2,[r0,#0]
;;;80         /* Clear PWMCLK, PWMMD0 and PWMMD1 SPR bits */
;;;81         tmpreg &= ( uint32_t ) ~ ( PWM_CON_PWMCLK | PWM_CON_PWMMD0 | PWM_CON_PWMMD1 );
000004  246f              MOVS     r4,#0x6f
000006  4613              MOV      r3,r2
000008  43a3              BICS     r3,r3,r4
00000a  461a              MOV      r2,r3
;;;82         /* Configure PWMx: Prescaler, AlignedMode and WorkMode */
;;;83         /* Set PWMCLK bits according to Prescaler value */
;;;84         /* Set PWMMD0 bit according to AlignedMode value */
;;;85         /* Set PWMMD1 bit according to WorkMode value */
;;;86         tmpreg |= ( uint32_t ) ( PWM_InitStruct->PWM_Prescaler | PWM_InitStruct->PWM_AlignedMode |
00000c  880b              LDRH     r3,[r1,#0]
00000e  884c              LDRH     r4,[r1,#2]
000010  4323              ORRS     r3,r3,r4
000012  888c              LDRH     r4,[r1,#4]
000014  4323              ORRS     r3,r3,r4
000016  431a              ORRS     r2,r2,r3
;;;87                                  PWM_InitStruct->PWM_WorkMode );
;;;88     
;;;89         /* Write to PWMx PWM_CON */
;;;90         PWMx->PWM_CON = tmpreg;
000018  6002              STR      r2,[r0,#0]
;;;91     
;;;92         /* Write to PWMx PWM_CHN */
;;;93         PWMx->PWM_CHN = PWM_InitStruct->PWM_OutputChannel;
00001a  688b              LDR      r3,[r1,#8]
00001c  6043              STR      r3,[r0,#4]
;;;94     
;;;95         /* Write to PWMx PWM_INV */
;;;96         PWMx->PWM_INV = PWM_InitStruct->PWM_LowPolarityChannl;
00001e  68cb              LDR      r3,[r1,#0xc]
000020  60c3              STR      r3,[r0,#0xc]
;;;97     
;;;98         /* Write to PWMx PWM_CYCLE */
;;;99         PWMx->PWM_CYCLE = PWM_InitStruct->PWM_Cycle;
000022  88cb              LDRH     r3,[r1,#6]
000024  6183              STR      r3,[r0,#0x18]
;;;100    }
000026  bd10              POP      {r4,pc}
;;;101    
                          ENDP


                          AREA ||i.PWM_RisingDeadTimeConfig||, CODE, READONLY, ALIGN=1

                  PWM_RisingDeadTimeConfig PROC
;;;109     */
;;;110    void PWM_RisingDeadTimeConfig ( PWM_TypeDef* PWMx, uint8_t PWM_RisingDeadTime )
000000  460a              MOV      r2,r1
;;;111    {
;;;112        uint32_t tmpreg;
;;;113        /* Check the parameters */
;;;114        assert_param ( IS_PWM_COMPLEMENTARY_PERIPH ( PWMx ) );
;;;115    
;;;116        /* Get the PWMx PWM_DFR value */
;;;117        tmpreg = PWMx->PWM_DFR;
000002  6901              LDR      r1,[r0,#0x10]
;;;118    
;;;119        /* Clear PDR bits */
;;;120        tmpreg &= ( uint32_t ) ~ ( PWM_DFR_PDR );
000004  0909              LSRS     r1,r1,#4
000006  0109              LSLS     r1,r1,#4
;;;121    
;;;122        /* Set PDR bits to Rising Dead Time value */
;;;123        tmpreg |= ( uint32_t ) ( PWM_RisingDeadTime << PWM_DFR_PDR_Pos );
000008  460b              MOV      r3,r1
00000a  4313              ORRS     r3,r3,r2
00000c  4619              MOV      r1,r3
;;;124    
;;;125        /* Write to PWMx PWM_DFR */
;;;126        PWMx->PWM_DFR = tmpreg;
00000e  6101              STR      r1,[r0,#0x10]
;;;127    }
000010  4770              BX       lr
;;;128    
                          ENDP


                          AREA ||i.PWM_SetCycle||, CODE, READONLY, ALIGN=1

                  PWM_SetCycle PROC
;;;240     */
;;;241    void PWM_SetCycle ( PWM_TypeDef* PWMx, uint32_t PWM_Cycle )
000000  6181              STR      r1,[r0,#0x18]
;;;242    {
;;;243        /* Check the parameters */
;;;244        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;245    
;;;246        /* Set the ReloadData Register value */
;;;247        PWMx->PWM_CYCLE = PWM_Cycle;
;;;248    }
000002  4770              BX       lr
;;;249    
                          ENDP


                          AREA ||i.PWM_SetDuty||, CODE, READONLY, ALIGN=1

                  PWM_SetDuty PROC
;;;282     */
;;;283    void PWM_SetDuty ( PWM_TypeDef* PWMx, PWM_Channel_Typedef PWM_Channel, uint16_t PWM_Duty )
000000  b570              PUSH     {r4-r6,lr}
;;;284    {
000002  4603              MOV      r3,r0
;;;285        uint8_t tmpvalue;
;;;286        uint32_t tmpchannel;
;;;287        /* Check the parameters */
;;;288        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;289        assert_param ( IS_PWM_CHANNEL ( PWM_Channel ) );
;;;290    
;;;291        tmpchannel = 1;
000004  2401              MOVS     r4,#1
;;;292        for ( tmpvalue = 0; tmpvalue < 8; tmpvalue++ )
000006  2000              MOVS     r0,#0
000008  e00a              B        |L16.32|
                  |L16.10|
;;;293        {
;;;294            if ( ( uint32_t ) PWM_Channel & tmpchannel )
00000a  460d              MOV      r5,r1
00000c  4025              ANDS     r5,r5,r4
00000e  2d00              CMP      r5,#0
000010  d003              BEQ      |L16.26|
;;;295            {
;;;296                PWMx->PWM_DT[tmpvalue] = PWM_Duty;
000012  0085              LSLS     r5,r0,#2
000014  461e              MOV      r6,r3
000016  3630              ADDS     r6,r6,#0x30
000018  5172              STR      r2,[r6,r5]
                  |L16.26|
;;;297            }
;;;298            tmpchannel = tmpchannel << 1;
00001a  0064              LSLS     r4,r4,#1
00001c  1c45              ADDS     r5,r0,#1              ;292
00001e  b2e8              UXTB     r0,r5                 ;292
                  |L16.32|
000020  2808              CMP      r0,#8                 ;292
000022  dbf2              BLT      |L16.10|
;;;299        }
;;;300    }
000024  bd70              POP      {r4-r6,pc}
;;;301    
                          ENDP


                          AREA ||i.PWM_SetPrescaler||, CODE, READONLY, ALIGN=2

                  PWM_SetPrescaler PROC
;;;196     */
;;;197    void PWM_SetPrescaler ( PWM_TypeDef* PWMx, PWM_Prescaler_TypeDef PWM_Prescaler )
000000  6802              LDR      r2,[r0,#0]
;;;198    {
;;;199        /* Check the parameters */
;;;200        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;201        assert_param ( IS_PWM_PRESCALER ( PWM_Prescaler ) );
;;;202    
;;;203        /* Reset the CKD Bits */
;;;204        PWMx->PWM_CON &= ( uint16_t ) ~ ( PWM_CON_PWMCLK );
000002  4b03              LDR      r3,|L17.16|
000004  401a              ANDS     r2,r2,r3
000006  6002              STR      r2,[r0,#0]
;;;205    
;;;206        /* Set the CKD value */
;;;207        PWMx->PWM_CON |= PWM_Prescaler;
000008  6802              LDR      r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  6002              STR      r2,[r0,#0]
;;;208    }
00000e  4770              BX       lr
;;;209    
                          ENDP

                  |L17.16|
                          DCD      0x0000fff0

                          AREA ||i.PWM_StructInit||, CODE, READONLY, ALIGN=1

                  PWM_StructInit PROC
;;;51       */
;;;52     void PWM_StructInit ( PWM_InitTypeDef* PWM_InitStruct )
000000  2100              MOVS     r1,#0
;;;53     {
;;;54         /* Set the default configuration */
;;;55         PWM_InitStruct->PWM_AlignedMode = PWM_AlignmentMode_Edge;
000002  8041              STRH     r1,[r0,#2]
;;;56         PWM_InitStruct->PWM_Cycle = 0x0000;
000004  80c1              STRH     r1,[r0,#6]
;;;57         PWM_InitStruct->PWM_LowPolarityChannl = PWMChannel_Less;
000006  60c1              STR      r1,[r0,#0xc]
;;;58         PWM_InitStruct->PWM_OutputChannel = PWMChannel_Less;
000008  6081              STR      r1,[r0,#8]
;;;59         PWM_InitStruct->PWM_Prescaler = PWM_PRESCALER_DIV1;
00000a  8001              STRH     r1,[r0,#0]
;;;60         PWM_InitStruct->PWM_WorkMode = PWM_WorkMode_Independent;
00000c  8081              STRH     r1,[r0,#4]
;;;61     }
00000e  4770              BX       lr
;;;62     
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_pwm.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_pwm_c_a9b1a8f2____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___15_sc32f1xxx_pwm_c_a9b1a8f2____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_pwm_c_a9b1a8f2____REVSH|
#line 478
|__asm___15_sc32f1xxx_pwm_c_a9b1a8f2____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
