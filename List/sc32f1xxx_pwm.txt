; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\sc32f1xxx_pwm.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\sc32f1xxx_pwm.d --cpu=Cortex-M0+ --apcs=interwork --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\Buzz\Inc -ID:\keil\ARM\PACK\Keil\SC32F1xxx_DFP\1.0.6\Device\SC32F10xx\FWLib\SC32_Lib\inc -D__UVISION_VERSION=534 -DSC32F10xx -DSC32f10xx --omf_browse=..\output\sc32f1xxx_pwm.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_pwm.c]
                          THUMB

                          AREA ||i.PWM_ClearFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearFlag PROC
;;;493     */
;;;494    void PWM_ClearFlag ( PWM_TypeDef* PWMx, uint16_t PWM_FLAG )
000000  6081              STR      r1,[r0,#8]
;;;495    {
;;;496        /* Check the parameters */
;;;497        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;498        assert_param ( IS_GET_PWM_FLAG ( PWM_FLAG ) );
;;;499    
;;;500        /* Clear the flags */
;;;501        PWMx->PWM_STS = ( uint16_t ) PWM_FLAG;
;;;502    }
000002  4770              BX       lr
;;;503    #endif
                          ENDP


                          AREA ||i.PWM_Cmd||, CODE, READONLY, ALIGN=2

                  PWM_Cmd PROC
;;;163     */
;;;164    void PWM_Cmd ( PWM_TypeDef* PWMx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;165    {
;;;166        /* Check the parameters */
;;;167        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;168        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;169    
;;;170        if ( NewState != DISABLE )
;;;171        {
;;;172            /* Enable the PWM Counter */
;;;173            PWMx->PWM_CON |= PWM_CON_ENPWM;
;;;174        }
;;;175        else
;;;176        {
;;;177            /* Disable the PWM Counter */
;;;178            PWMx->PWM_CON &= ( uint16_t ) ~PWM_CON_ENPWM;
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L2.12|
000006  2280              MOVS     r2,#0x80              ;173
000008  4311              ORRS     r1,r1,r2              ;173
00000a  e001              B        |L2.16|
                  |L2.12|
00000c  4a01              LDR      r2,|L2.20|
00000e  4011              ANDS     r1,r1,r2
                  |L2.16|
000010  6001              STR      r1,[r0,#0]            ;173
;;;179        }
;;;180    }
000012  4770              BX       lr
;;;181    
                          ENDP

                  |L2.20|
                          DCD      0x0000ff7f

                          AREA ||i.PWM_DeInit||, CODE, READONLY, ALIGN=2

                  PWM_DeInit PROC
;;;32      */
;;;33     void PWM_DeInit ( PWM_TypeDef* PWMx )
000000  4906              LDR      r1,|L3.28|
;;;34     {
000002  b510              PUSH     {r4,lr}
;;;35         /* Check the parameters */
;;;36         assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;37     
;;;38         if ( PWMx == PWM0 )
000004  4288              CMP      r0,r1
000006  d108              BNE      |L3.26|
;;;39         {
;;;40             /* Enable PWM reset state */
;;;41             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_PWM0, ENABLE );
000008  1584              ASRS     r4,r0,#22
00000a  2101              MOVS     r1,#1
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;42             /* Enable PWM reset state */
;;;43             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_PWM0, DISABLE );
000012  2100              MOVS     r1,#0
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       RCC_APB0PeriphResetCmd
                  |L3.26|
;;;44         }
;;;45     }
00001a  bd10              POP      {r4,pc}
;;;46     
                          ENDP

                  |L3.28|
                          DCD      0x40020200

                          AREA ||i.PWM_FDCmd||, CODE, READONLY, ALIGN=2

                  PWM_FDCmd PROC
;;;394     */
;;;395    void PWM_FDCmd ( PWM_TypeDef* PWMx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;396    {
;;;397        /* Check the parameters */
;;;398        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;399        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;400    
;;;401        if ( NewState != DISABLE )
;;;402        {
;;;403            /* Enable the PWM Fault Dectection */
;;;404            PWMx->PWM_FLT |= PWM_FLT_FLTEN;
;;;405        }
;;;406        else
;;;407        {
;;;408            /* Disable the PWM Fault Dectection */
;;;409            PWMx->PWM_FLT &= ( uint16_t ) ~PWM_FLT_FLTEN;
000002  6941              LDR      r1,[r0,#0x14]
000004  d002              BEQ      |L4.12|
000006  2280              MOVS     r2,#0x80              ;404
000008  4311              ORRS     r1,r1,r2              ;404
00000a  e001              B        |L4.16|
                  |L4.12|
00000c  4a01              LDR      r2,|L4.20|
00000e  4011              ANDS     r1,r1,r2
                  |L4.16|
000010  6141              STR      r1,[r0,#0x14]         ;404
;;;410        }
;;;411    }
000012  4770              BX       lr
;;;412    /**
                          ENDP

                  |L4.20|
                          DCD      0x0000ff7f

                          AREA ||i.PWM_FDInit||, CODE, READONLY, ALIGN=1

                  PWM_FDInit PROC
;;;376     */
;;;377    void PWM_FDInit ( PWM_TypeDef* PWMx, PWM_FDInitTypeDef* PWM_FDInitStruct )
000000  6942              LDR      r2,[r0,#0x14]
;;;378    {
;;;379        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;380    
;;;381        PWMx->PWM_FLT &= ( uint32_t ) ~ ( PWM_FLT_FLTDT | PWM_FLT_FLTTV | PWM_FLT_FLTMD );
000002  2333              MOVS     r3,#0x33
000004  439a              BICS     r2,r2,r3
000006  6142              STR      r2,[r0,#0x14]
;;;382        PWMx->PWM_FLT |= ( uint32_t ) ( PWM_FDInitStruct->PWM_FDFilteringTime | PWM_FDInitStruct->PWM_FDMode |
000008  6942              LDR      r2,[r0,#0x14]
00000a  888b              LDRH     r3,[r1,#4]
00000c  431a              ORRS     r2,r2,r3
00000e  880b              LDRH     r3,[r1,#0]
000010  8849              LDRH     r1,[r1,#2]
000012  430b              ORRS     r3,r3,r1
000014  431a              ORRS     r2,r2,r3
000016  6142              STR      r2,[r0,#0x14]
;;;383                                        PWM_FDInitStruct->PWM_FDVoltage );
;;;384    }
000018  4770              BX       lr
;;;385    
                          ENDP


                          AREA ||i.PWM_FDStructInit||, CODE, READONLY, ALIGN=1

                  PWM_FDStructInit PROC
;;;361      */
;;;362    void PWM_FDStructInit ( PWM_FDInitTypeDef* PWM_FDInitStruct )
000000  2100              MOVS     r1,#0
;;;363    {
;;;364        /* Set the default configuration */
;;;365        PWM_FDInitStruct->PWM_FDFilteringTime = PWM_FilteringTime_0us;
000002  8081              STRH     r1,[r0,#4]
;;;366        PWM_FDInitStruct->PWM_FDMode = PWM_FDMode_Latch;
000004  8001              STRH     r1,[r0,#0]
;;;367        PWM_FDInitStruct->PWM_FDVoltage = PWM_FDVoltage_Low;
000006  8041              STRH     r1,[r0,#2]
;;;368    }
000008  4770              BX       lr
;;;369    
                          ENDP


                          AREA ||i.PWM_FallingDeadTimeConfig||, CODE, READONLY, ALIGN=1

                  PWM_FallingDeadTimeConfig PROC
;;;135     */
;;;136    void PWM_FallingDeadTimeConfig ( PWM_TypeDef* PWMx, uint8_t PWM_FallingDeadTime )
000000  6902              LDR      r2,[r0,#0x10]
;;;137    {
;;;138        uint32_t tmpreg;
;;;139        /* Check the parameters */
;;;140        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;141    
;;;142        /* Get the PWMx PWM_DFR value */
;;;143        tmpreg = PWMx->PWM_DFR;
;;;144    
;;;145        /* Clear PDF bits */
;;;146        tmpreg &= ( uint32_t ) ~ ( PWM_DFR_PDF );
000002  230f              MOVS     r3,#0xf
000004  021b              LSLS     r3,r3,#8
000006  439a              BICS     r2,r2,r3
;;;147    
;;;148        /* Set PDF bits to Rising Dead Time value */
;;;149        tmpreg |= ( uint32_t ) ( PWM_FallingDeadTime << PWM_DFR_PDF_Pos );
000008  0209              LSLS     r1,r1,#8
00000a  4311              ORRS     r1,r1,r2
;;;150    
;;;151        /* Write to PWMx PWM_DFR */
;;;152        PWMx->PWM_DFR = tmpreg;
00000c  6101              STR      r1,[r0,#0x10]
;;;153    }
00000e  4770              BX       lr
;;;154    
                          ENDP


                          AREA ||i.PWM_GetCycle||, CODE, READONLY, ALIGN=1

                  PWM_GetCycle PROC
;;;255     */
;;;256    uint16_t PWM_GetCycle ( PWM_TypeDef* PWMx )
000000  6980              LDR      r0,[r0,#0x18]
;;;257    {
;;;258        /* Check the parameters */
;;;259        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;260    
;;;261        /* Get the ReloadData Register value */
;;;262        return ( uint16_t ) PWMx->PWM_CYCLE;
000002  b280              UXTH     r0,r0
;;;263    }
000004  4770              BX       lr
;;;264    
                          ENDP


                          AREA ||i.PWM_GetDuty||, CODE, READONLY, ALIGN=1

                  PWM_GetDuty PROC
;;;318     */
;;;319    uint16_t PWM_GetDuty ( PWM_TypeDef* PWMx, PWM_Channel_Typedef PWM_Channel )
000000  b510              PUSH     {r4,lr}
;;;320    {
;;;321        uint8_t tmpvalue ;
;;;322        uint32_t tmpchannel;
;;;323        /* Check the parameters */
;;;324        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;325        assert_param ( IS_PWM_CHANNEL ( PWM_Channel ) );
;;;326    
;;;327        tmpchannel = 1;
000002  2301              MOVS     r3,#1
000004  460c              MOV      r4,r1                 ;320
;;;328        for ( tmpvalue = 0; tmpvalue < 8; tmpvalue++ )
000006  2200              MOVS     r2,#0
                  |L9.8|
;;;329        {
;;;330            if ( ( uint32_t ) PWM_Channel & tmpchannel )
000008  421c              TST      r4,r3
00000a  d004              BEQ      |L9.22|
;;;331            {
;;;332                return ( uint16_t ) ( PWMx->PWM_DT[tmpvalue] );
00000c  0091              LSLS     r1,r2,#2
00000e  1808              ADDS     r0,r1,r0
000010  6b00              LDR      r0,[r0,#0x30]
000012  b280              UXTH     r0,r0
;;;333            }
;;;334            tmpchannel = tmpchannel << 1;
;;;335        }
;;;336        return 0;
;;;337    }
000014  bd10              POP      {r4,pc}
                  |L9.22|
000016  1c52              ADDS     r2,r2,#1              ;334
000018  005b              LSLS     r3,r3,#1              ;334
00001a  b2d2              UXTB     r2,r2                 ;328
00001c  2a08              CMP      r2,#8                 ;328
00001e  d3f3              BCC      |L9.8|
000020  2000              MOVS     r0,#0                 ;336
000022  bd10              POP      {r4,pc}
;;;338    
                          ENDP


                          AREA ||i.PWM_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  PWM_GetFlagStatus PROC
;;;466     */
;;;467    FlagStatus PWM_GetFlagStatus ( PWM_TypeDef* PWMx, uint16_t PWM_FLAG )
000000  4602              MOV      r2,r0
;;;468    {
;;;469        ITStatus bitstatus = RESET;
;;;470        /* Check the parameters */
;;;471        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;472        assert_param ( IS_PWM_FLAG ( PWM_FLAG ) );
;;;473    
;;;474        if ( ( PWMx->PWM_STS & PWM_FLAG ) != ( uint16_t ) RESET )
000002  6892              LDR      r2,[r2,#8]
000004  2000              MOVS     r0,#0                 ;469
000006  420a              TST      r2,r1
000008  d000              BEQ      |L10.12|
;;;475        {
;;;476            bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L10.12|
;;;477        }
;;;478        else
;;;479        {
;;;480            bitstatus = RESET;
;;;481        }
;;;482        return bitstatus;
;;;483    }
00000c  4770              BX       lr
;;;484    
                          ENDP


                          AREA ||i.PWM_GetPrescaler||, CODE, READONLY, ALIGN=1

                  PWM_GetPrescaler PROC
;;;223     */
;;;224    PWM_Prescaler_TypeDef PWM_GetPrescaler ( PWM_TypeDef* PWMx )
000000  6800              LDR      r0,[r0,#0]
;;;225    {
;;;226        /* Check the parameters */
;;;227        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;228    
;;;229        /* Get the CKD value */
;;;230        return ( PWM_Prescaler_TypeDef ) ( PWMx->PWM_CON & PWM_CON_PWMCLK );
000002  0700              LSLS     r0,r0,#28
000004  0f00              LSRS     r0,r0,#28
;;;231    }
000006  4770              BX       lr
;;;232    
                          ENDP


                          AREA ||i.PWM_ITConfig||, CODE, READONLY, ALIGN=1

                  PWM_ITConfig PROC
;;;437     */
;;;438    void PWM_ITConfig ( PWM_TypeDef* PWMx, uint16_t PWM_IT, FunctionalState NewState )
000000  2a00              CMP      r2,#0
;;;439    {
;;;440        /* Check the parameters */
;;;441        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;442        assert_param ( IS_PWM_IT ( PWM_IT ) );
;;;443        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;444    
;;;445        if ( NewState != DISABLE )
;;;446        {
;;;447            /* Enable the Interrupt sources */
;;;448            PWMx->PWM_CON |= PWM_IT;
;;;449        }
;;;450        else
;;;451        {
;;;452            /* Disable the Interrupt sources */
;;;453            PWMx->PWM_CON &= ( uint16_t ) ~PWM_IT;
000002  6802              LDR      r2,[r0,#0]
000004  d001              BEQ      |L12.10|
000006  430a              ORRS     r2,r2,r1              ;448
000008  e002              B        |L12.16|
                  |L12.10|
00000a  43c9              MVNS     r1,r1
00000c  b289              UXTH     r1,r1
00000e  400a              ANDS     r2,r2,r1
                  |L12.16|
000010  6002              STR      r2,[r0,#0]            ;448
;;;454        }
;;;455    }
000012  4770              BX       lr
;;;456    
                          ENDP


                          AREA ||i.PWM_Init||, CODE, READONLY, ALIGN=1

                  PWM_Init PROC
;;;70      */
;;;71     void PWM_Init ( PWM_TypeDef* PWMx, PWM_InitTypeDef* PWM_InitStruct )
000000  b510              PUSH     {r4,lr}
;;;72     {
;;;73         uint32_t tmpreg;
;;;74         /* Check the parameters */
;;;75         assert_param ( IS_PWM_COMPLEMENTARY_PERIPH ( PWMx ) );
;;;76     
;;;77         /*---------------------------- PWMx PWM_CON Configuration ------------------------*/
;;;78         /* Get the PWMx PWM_CON value */
;;;79         tmpreg = PWMx->PWM_CON;
000002  6802              LDR      r2,[r0,#0]
;;;80         /* Clear PWMCLK, PWMMD0 and PWMMD1 SPR bits */
;;;81         tmpreg &= ( uint32_t ) ~ ( PWM_CON_PWMCLK | PWM_CON_PWMMD0 | PWM_CON_PWMMD1 );
000004  236f              MOVS     r3,#0x6f
000006  439a              BICS     r2,r2,r3
;;;82         /* Configure PWMx: Prescaler, AlignedMode and WorkMode */
;;;83         /* Set PWMCLK bits according to Prescaler value */
;;;84         /* Set PWMMD0 bit according to AlignedMode value */
;;;85         /* Set PWMMD1 bit according to WorkMode value */
;;;86         tmpreg |= ( uint32_t ) ( PWM_InitStruct->PWM_Prescaler | PWM_InitStruct->PWM_AlignedMode |
000008  880b              LDRH     r3,[r1,#0]
00000a  884c              LDRH     r4,[r1,#2]
00000c  4323              ORRS     r3,r3,r4
00000e  888c              LDRH     r4,[r1,#4]
000010  4314              ORRS     r4,r4,r2
000012  4323              ORRS     r3,r3,r4
;;;87                                  PWM_InitStruct->PWM_WorkMode );
;;;88     
;;;89         /* Write to PWMx PWM_CON */
;;;90         PWMx->PWM_CON = tmpreg;
000014  6003              STR      r3,[r0,#0]
;;;91     
;;;92         /* Write to PWMx PWM_CHN */
;;;93         PWMx->PWM_CHN = PWM_InitStruct->PWM_OutputChannel;
000016  688a              LDR      r2,[r1,#8]
000018  6042              STR      r2,[r0,#4]
;;;94     
;;;95         /* Write to PWMx PWM_INV */
;;;96         PWMx->PWM_INV = PWM_InitStruct->PWM_LowPolarityChannl;
00001a  68ca              LDR      r2,[r1,#0xc]
00001c  60c2              STR      r2,[r0,#0xc]
;;;97     
;;;98         /* Write to PWMx PWM_CYCLE */
;;;99         PWMx->PWM_CYCLE = PWM_InitStruct->PWM_Cycle;
00001e  88c9              LDRH     r1,[r1,#6]
000020  6181              STR      r1,[r0,#0x18]
;;;100    }
000022  bd10              POP      {r4,pc}
;;;101    
                          ENDP


                          AREA ||i.PWM_RisingDeadTimeConfig||, CODE, READONLY, ALIGN=1

                  PWM_RisingDeadTimeConfig PROC
;;;109     */
;;;110    void PWM_RisingDeadTimeConfig ( PWM_TypeDef* PWMx, uint8_t PWM_RisingDeadTime )
000000  6902              LDR      r2,[r0,#0x10]
;;;111    {
;;;112        uint32_t tmpreg;
;;;113        /* Check the parameters */
;;;114        assert_param ( IS_PWM_COMPLEMENTARY_PERIPH ( PWMx ) );
;;;115    
;;;116        /* Get the PWMx PWM_DFR value */
;;;117        tmpreg = PWMx->PWM_DFR;
;;;118    
;;;119        /* Clear PDR bits */
;;;120        tmpreg &= ( uint32_t ) ~ ( PWM_DFR_PDR );
000002  0912              LSRS     r2,r2,#4
000004  0112              LSLS     r2,r2,#4
;;;121    
;;;122        /* Set PDR bits to Rising Dead Time value */
;;;123        tmpreg |= ( uint32_t ) ( PWM_RisingDeadTime << PWM_DFR_PDR_Pos );
000006  430a              ORRS     r2,r2,r1
;;;124    
;;;125        /* Write to PWMx PWM_DFR */
;;;126        PWMx->PWM_DFR = tmpreg;
000008  6102              STR      r2,[r0,#0x10]
;;;127    }
00000a  4770              BX       lr
;;;128    
                          ENDP


                          AREA ||i.PWM_SetCycle||, CODE, READONLY, ALIGN=1

                  PWM_SetCycle PROC
;;;240     */
;;;241    void PWM_SetCycle ( PWM_TypeDef* PWMx, uint32_t PWM_Cycle )
000000  6181              STR      r1,[r0,#0x18]
;;;242    {
;;;243        /* Check the parameters */
;;;244        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;245    
;;;246        /* Set the ReloadData Register value */
;;;247        PWMx->PWM_CYCLE = PWM_Cycle;
;;;248    }
000002  4770              BX       lr
;;;249    
                          ENDP


                          AREA ||i.PWM_SetDuty||, CODE, READONLY, ALIGN=1

                  PWM_SetDuty PROC
;;;282     */
;;;283    void PWM_SetDuty ( PWM_TypeDef* PWMx, PWM_Channel_Typedef PWM_Channel, uint16_t PWM_Duty )
000000  b530              PUSH     {r4,r5,lr}
;;;284    {
;;;285        uint8_t tmpvalue;
;;;286        uint32_t tmpchannel;
;;;287        /* Check the parameters */
;;;288        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;289        assert_param ( IS_PWM_CHANNEL ( PWM_Channel ) );
;;;290    
;;;291        tmpchannel = 1;
000002  2401              MOVS     r4,#1
;;;292        for ( tmpvalue = 0; tmpvalue < 8; tmpvalue++ )
000004  2300              MOVS     r3,#0
                  |L16.6|
;;;293        {
;;;294            if ( ( uint32_t ) PWM_Channel & tmpchannel )
000006  4221              TST      r1,r4
000008  d002              BEQ      |L16.16|
;;;295            {
;;;296                PWMx->PWM_DT[tmpvalue] = PWM_Duty;
00000a  009d              LSLS     r5,r3,#2
00000c  182d              ADDS     r5,r5,r0
00000e  632a              STR      r2,[r5,#0x30]
                  |L16.16|
;;;297            }
;;;298            tmpchannel = tmpchannel << 1;
000010  1c5b              ADDS     r3,r3,#1
000012  0064              LSLS     r4,r4,#1
000014  b2db              UXTB     r3,r3                 ;292
000016  2b08              CMP      r3,#8                 ;292
000018  d3f5              BCC      |L16.6|
;;;299        }
;;;300    }
00001a  bd30              POP      {r4,r5,pc}
;;;301    
                          ENDP


                          AREA ||i.PWM_SetPrescaler||, CODE, READONLY, ALIGN=2

                  PWM_SetPrescaler PROC
;;;196     */
;;;197    void PWM_SetPrescaler ( PWM_TypeDef* PWMx, PWM_Prescaler_TypeDef PWM_Prescaler )
000000  6802              LDR      r2,[r0,#0]
;;;198    {
;;;199        /* Check the parameters */
;;;200        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;201        assert_param ( IS_PWM_PRESCALER ( PWM_Prescaler ) );
;;;202    
;;;203        /* Reset the CKD Bits */
;;;204        PWMx->PWM_CON &= ( uint16_t ) ~ ( PWM_CON_PWMCLK );
000002  4b03              LDR      r3,|L17.16|
000004  401a              ANDS     r2,r2,r3
000006  6002              STR      r2,[r0,#0]
;;;205    
;;;206        /* Set the CKD value */
;;;207        PWMx->PWM_CON |= PWM_Prescaler;
000008  6802              LDR      r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  6002              STR      r2,[r0,#0]
;;;208    }
00000e  4770              BX       lr
;;;209    
                          ENDP

                  |L17.16|
                          DCD      0x0000fff0

                          AREA ||i.PWM_StructInit||, CODE, READONLY, ALIGN=1

                  PWM_StructInit PROC
;;;51       */
;;;52     void PWM_StructInit ( PWM_InitTypeDef* PWM_InitStruct )
000000  2100              MOVS     r1,#0
;;;53     {
;;;54         /* Set the default configuration */
;;;55         PWM_InitStruct->PWM_AlignedMode = PWM_AlignmentMode_Edge;
000002  8041              STRH     r1,[r0,#2]
;;;56         PWM_InitStruct->PWM_Cycle = 0x0000;
000004  80c1              STRH     r1,[r0,#6]
;;;57         PWM_InitStruct->PWM_LowPolarityChannl = PWMChannel_Less;
;;;58         PWM_InitStruct->PWM_OutputChannel = PWMChannel_Less;
000006  60c1              STR      r1,[r0,#0xc]
;;;59         PWM_InitStruct->PWM_Prescaler = PWM_PRESCALER_DIV1;
000008  6081              STR      r1,[r0,#8]
00000a  8001              STRH     r1,[r0,#0]
;;;60         PWM_InitStruct->PWM_WorkMode = PWM_WorkMode_Independent;
00000c  8081              STRH     r1,[r0,#4]
;;;61     }
00000e  4770              BX       lr
;;;62     
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_pwm.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_pwm_c_a9b1a8f2____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___15_sc32f1xxx_pwm_c_a9b1a8f2____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_pwm_c_a9b1a8f2____REVSH|
#line 478
|__asm___15_sc32f1xxx_pwm_c_a9b1a8f2____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
