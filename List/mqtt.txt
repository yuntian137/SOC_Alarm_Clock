; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\mqtt.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\mqtt.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\Buzz\Inc -I..\Drivers\TKDriver\C -I..\Mqtt\Inc -ID:\keil\ARM\PACK\Keil\SC32F1xxx_DFP\1.0.6\Device\SC32F10xx\FWLib\SC32_Lib\inc -D__MICROLIB -D__UVISION_VERSION=534 -DSC32F10xx -DSC32f10xx --omf_browse=..\output\mqtt.crf ..\Mqtt\Src\mqtt.c]
                          THUMB

                          AREA ||i.CLR_Buf2||, CODE, READONLY, ALIGN=2

                  CLR_Buf2 PROC
;;;254    }
;;;255    void CLR_Buf2(void)
000000  b510              PUSH     {r4,lr}
;;;256    {
;;;257        memset((void *)UART_RxBuffer, 0, MAX_BUFFER_SIZE); // 清除接收缓存
000002  2164              MOVS     r1,#0x64
000004  4803              LDR      r0,|L1.20|
000006  f7fffffe          BL       __aeabi_memclr
;;;258        RxIndex = 0; // 重置接收索引
00000a  2000              MOVS     r0,#0
00000c  4902              LDR      r1,|L1.24|
00000e  7008              STRB     r0,[r1,#0]
;;;259    }
000010  bd10              POP      {r4,pc}
;;;260    
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      UART_RxBuffer
                  |L1.24|
                          DCD      RxIndex

                          AREA ||i.Client_Connect||, CODE, READONLY, ALIGN=2

                  Client_Connect PROC
;;;98     /*********************连接客户端*******************************/
;;;99     void Client_Connect(void)
000000  b500              PUSH     {lr}
;;;100    {
000002  b099              SUB      sp,sp,#0x64
;;;101        char client_connect_buf[100] = {"AT+MQTTCLIENTID=0,\"12345|securemode=3\\,signmethod=hmacsha1|\"\r\n\r\n"};
000004  2264              MOVS     r2,#0x64
000006  4907              LDR      r1,|L2.36|
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       __aeabi_memcpy4
;;;102        USART_TxStr(UART2,"连接客户端...\r\n");
00000e  a106              ADR      r1,|L2.40|
000010  480b              LDR      r0,|L2.64|
000012  f7fffffe          BL       USART_TxStr
;;;103        USART_TxStr(UART1,client_connect_buf);
000016  4669              MOV      r1,sp
000018  480a              LDR      r0,|L2.68|
00001a  f7fffffe          BL       USART_TxStr
;;;104    }
00001e  b019              ADD      sp,sp,#0x64
000020  bd00              POP      {pc}
;;;105    
                          ENDP

000022  0000              DCW      0x0000
                  |L2.36|
                          DCD      ||.constdata||+0x190
                  |L2.40|
000028  e8bf9ee6          DCB      232,191,158,230,142,165,229,174,162,230,136,183,231,171,175
00002c  8ea5e5ae
000030  a2e688b7
000034  e7abaf  
000037  2e2e2e0d          DCB      "...\r\n",0
00003b  0a00    
00003d  00                DCB      0
00003e  00                DCB      0
00003f  00                DCB      0
                  |L2.64|
                          DCD      0x40021020
                  |L2.68|
                          DCD      0x40020080

                          AREA ||i.Client_Subscribe||, CODE, READONLY, ALIGN=2

                  Client_Subscribe PROC
;;;114    /*********************客户端订阅*************************/
;;;115    void Client_Subscribe(void)
000000  b500              PUSH     {lr}
;;;116    {
000002  b099              SUB      sp,sp,#0x64
;;;117        char client_subscribe_buf[100] = {"AT+MQTTSUB=0,\"/k23m6LAJ0V9/SC32F10TS8/user/Test\",1\r\n\r\n"};
000004  2264              MOVS     r2,#0x64
000006  4907              LDR      r1,|L3.36|
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       __aeabi_memcpy4
;;;118        USART_TxStr(UART2,"客户端订阅消息...\r\n");
00000e  a106              ADR      r1,|L3.40|
000010  480c              LDR      r0,|L3.68|
000012  f7fffffe          BL       USART_TxStr
;;;119        USART_TxStr(UART1,client_subscribe_buf);
000016  4669              MOV      r1,sp
000018  480b              LDR      r0,|L3.72|
00001a  f7fffffe          BL       USART_TxStr
;;;120    }
00001e  b019              ADD      sp,sp,#0x64
000020  bd00              POP      {pc}
;;;121    
                          ENDP

000022  0000              DCW      0x0000
                  |L3.36|
                          DCD      ||.constdata||+0x258
                  |L3.40|
000028  e5aea2e6          DCB      229,174,162,230,136,183,231,171,175,232,174,162,233,152,133
00002c  88b7e7ab
000030  afe8aea2
000034  e99885  
000037  e6b688e6          DCB      230,182,136,230,129,175,"...\r\n",0
00003b  81af2e2e
00003f  2e0d0a00
000043  00                DCB      0
                  |L3.68|
                          DCD      0x40021020
                  |L3.72|
                          DCD      0x40020080

                          AREA ||i.Connect_Aliyun_Server||, CODE, READONLY, ALIGN=2

                  Connect_Aliyun_Server PROC
;;;106    /*********************连接阿里云服务器*************************/
;;;107    void Connect_Aliyun_Server(void)
000000  b500              PUSH     {lr}
;;;108    {
000002  b099              SUB      sp,sp,#0x64
;;;109        char connect_server_buf[100] = {"AT+MQTTCONN=0,\"k23m6LAJ0V9.iot-as-mqtt.cn-shanghai.aliyuncs.com\",1883,1\r\n\r\n"};
000004  2264              MOVS     r2,#0x64
000006  4907              LDR      r1,|L4.36|
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       __aeabi_memcpy4
;;;110        USART_TxStr(UART2,"连接阿里云服务器...\r\n");
00000e  a106              ADR      r1,|L4.40|
000010  480d              LDR      r0,|L4.72|
000012  f7fffffe          BL       USART_TxStr
;;;111        USART_TxStr(UART1,connect_server_buf);
000016  4669              MOV      r1,sp
000018  480c              LDR      r0,|L4.76|
00001a  f7fffffe          BL       USART_TxStr
;;;112    }
00001e  b019              ADD      sp,sp,#0x64
000020  bd00              POP      {pc}
;;;113    
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      ||.constdata||+0x1f4
                  |L4.40|
000028  e8bf9ee6          DCB      232,191,158,230,142,165,233,152,191,233,135,140,228,186,145
00002c  8ea5e998
000030  bfe9878c
000034  e4ba91  
000037  e69c8de5          DCB      230,156,141,229,138,161,229,153,168,"...\r\n",0
00003b  8aa1e599
00003f  a82e2e2e
000043  0d0a00  
000046  00                DCB      0
000047  00                DCB      0
                  |L4.72|
                          DCD      0x40021020
                  |L4.76|
                          DCD      0x40020080

                          AREA ||i.ExtractDateTime||, CODE, READONLY, ALIGN=2

                  ExtractDateTime PROC
;;;155    // 提取日期和时间的函数
;;;156    void ExtractDateTime(uint8_t* buffer, char* dateTime, size_t maxLen) 
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;157    {
000002  b082              SUB      sp,sp,#8
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;158        const char* prefix = "+CIPSNTPTIME:";  // 前缀字符串
000008  a019              ADR      r0,|L5.112|
00000a  9001              STR      r0,[sp,#4]
;;;159        size_t prefixLen = strlen(prefix);     // 前缀长度
00000c  9801              LDR      r0,[sp,#4]
00000e  f7fffffe          BL       strlen
000012  4605              MOV      r5,r0
;;;160        size_t bufferLen = sizeof(UART_RxBuffer) / sizeof(UART_RxBuffer[0]);  // 缓冲区长度
000014  2064              MOVS     r0,#0x64
000016  9000              STR      r0,[sp,#0]
;;;161    
;;;162        // 遍历缓冲区，查找前缀
;;;163        for (size_t i = 0; i < bufferLen - prefixLen; i++) {
000018  2400              MOVS     r4,#0
00001a  e020              B        |L5.94|
                  |L5.28|
;;;164            if (memcmp(&buffer[i], prefix, prefixLen) == 0) {
00001c  1930              ADDS     r0,r6,r4
00001e  462a              MOV      r2,r5
000020  9901              LDR      r1,[sp,#4]
000022  f7fffffe          BL       memcmp
000026  2800              CMP      r0,#0
000028  d118              BNE      |L5.92|
;;;165                // 找到前缀，提取日期和时间
;;;166                size_t j = 0;
00002a  bf00              NOP      
;;;167                while (i + prefixLen + j < bufferLen && buffer[i + prefixLen + j] != '\r' && j < maxLen - 1) {
00002c  e004              B        |L5.56|
                  |L5.46|
;;;168                    dateTime[j] = buffer[i + prefixLen + j];
00002e  1961              ADDS     r1,r4,r5
000030  1809              ADDS     r1,r1,r0
000032  5c71              LDRB     r1,[r6,r1]
000034  5439              STRB     r1,[r7,r0]
;;;169                    j++;
000036  1c40              ADDS     r0,r0,#1
                  |L5.56|
000038  1961              ADDS     r1,r4,r5              ;167
00003a  180a              ADDS     r2,r1,r0              ;167
00003c  9900              LDR      r1,[sp,#0]            ;167
00003e  428a              CMP      r2,r1                 ;167
000040  d208              BCS      |L5.84|
000042  1961              ADDS     r1,r4,r5              ;167
000044  1809              ADDS     r1,r1,r0              ;167
000046  5c71              LDRB     r1,[r6,r1]            ;167
000048  290d              CMP      r1,#0xd               ;167
00004a  d003              BEQ      |L5.84|
00004c  9904              LDR      r1,[sp,#0x10]         ;167
00004e  1e49              SUBS     r1,r1,#1              ;167
000050  4281              CMP      r1,r0                 ;167
000052  d8ec              BHI      |L5.46|
                  |L5.84|
;;;170                }
;;;171                dateTime[j] = '\0';  // 字符串结尾
000054  2100              MOVS     r1,#0
000056  5439              STRB     r1,[r7,r0]
                  |L5.88|
;;;172                return;
;;;173            }
;;;174        }
;;;175    
;;;176        // 如果未找到前缀，返回空字符串
;;;177        dateTime[0] = '\0';
;;;178    }
000058  b005              ADD      sp,sp,#0x14
00005a  bdf0              POP      {r4-r7,pc}
                  |L5.92|
00005c  1c64              ADDS     r4,r4,#1              ;163
                  |L5.94|
00005e  9800              LDR      r0,[sp,#0]            ;163
000060  1b40              SUBS     r0,r0,r5              ;163
000062  42a0              CMP      r0,r4                 ;163
000064  d8da              BHI      |L5.28|
000066  2000              MOVS     r0,#0                 ;177
000068  7038              STRB     r0,[r7,#0]            ;177
00006a  bf00              NOP      
00006c  e7f4              B        |L5.88|
;;;179    
                          ENDP

00006e  0000              DCW      0x0000
                  |L5.112|
000070  2b434950          DCB      "+CIPSNTPTIME:",0
000074  534e5450
000078  54494d45
00007c  3a00    
00007e  00                DCB      0
00007f  00                DCB      0

                          AREA ||i.Get_Init_Flag||, CODE, READONLY, ALIGN=2

                  Get_Init_Flag PROC
;;;33     }
;;;34     FlagStatus Get_Init_Flag()
000000  4801              LDR      r0,|L6.8|
;;;35     {
;;;36         return Wifi_Init_OK;
000002  7800              LDRB     r0,[r0,#0]  ; Wifi_Init_OK
;;;37     }
000004  4770              BX       lr
;;;38     /*********************重启WIFI模块*****************************/
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      Wifi_Init_OK

                          AREA ||i.Get_Ntp_Time||, CODE, READONLY, ALIGN=2

                  Get_Ntp_Time PROC
;;;122    /*连接到NTP服务器*/
;;;123    int Get_Ntp_Time()
000000  b500              PUSH     {lr}
;;;124    {
000002  b099              SUB      sp,sp,#0x64
;;;125        int time;
;;;126        //char ntp_connect_buf[100] = {"AT+CIPSNTPCFG=0,1,\"pool.ntp.org\"\r\n\r\n"};
;;;127        char ntp_connect_buf_CN[100] = {"AT+CIPSNTPCFG=1,8,\"cn.ntp.org.cn\",\"ntp.sjtu.edu.cn\"\r\n\r\n\r\n"};
000004  2264              MOVS     r2,#0x64
000006  4908              LDR      r1,|L7.40|
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       __aeabi_memcpy4
;;;128        USART_TxStr(UART2, "连接NTP服务器...\r\n");
00000e  a107              ADR      r1,|L7.44|
000010  480c              LDR      r0,|L7.68|
000012  f7fffffe          BL       USART_TxStr
;;;129        USART_TxStr(UART1, ntp_connect_buf_CN);
000016  4669              MOV      r1,sp
000018  480b              LDR      r0,|L7.72|
00001a  f7fffffe          BL       USART_TxStr
;;;130        wait_OK();
00001e  f7fffffe          BL       wait_OK
;;;131        //Delay_ms(25000);//获取中国地区时间要在连接NTP服务器后等二十秒以上
;;;132        //Get_Time();//获取时间
;;;133        //wait_OK();
;;;134        return 0;
000022  2000              MOVS     r0,#0
;;;135    }
000024  b019              ADD      sp,sp,#0x64
000026  bd00              POP      {pc}
;;;136    /*获取时间*/
                          ENDP

                  |L7.40|
                          DCD      ||.constdata||+0x2bc
                  |L7.44|
00002c  e8bf9ee6          DCB      232,191,158,230,142,165,"NTP",230,156,141,229,138,161,229
000030  8ea54e54
000034  50e69c8d
000038  e58aa1e5
00003c  99a82e2e          DCB      153,168,"...\r\n",0
000040  2e0d0a00
                  |L7.68|
                          DCD      0x40021020
                  |L7.72|
                          DCD      0x40020080

                          AREA ||i.Get_Time||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  Get_Time PROC
;;;136    /*获取时间*/
;;;137    int Get_Time(void)
000000  b500              PUSH     {lr}
;;;138    {
000002  b09d              SUB      sp,sp,#0x74
;;;139        char ntp_time_buf[100] = {"AT+CIPSNTPTIME?\r\n\r\n"};
000004  2264              MOVS     r2,#0x64
000006  491d              LDR      r1,|L8.124|
000008  a804              ADD      r0,sp,#0x10
00000a  f7fffffe          BL       __aeabi_memcpy4
;;;140        USART_TxStr(UART2, "获取时间...\r\n");
00000e  a11c              ADR      r1,|L8.128|
000010  4820              LDR      r0,|L8.148|
000012  f7fffffe          BL       USART_TxStr
;;;141        USART_TxStr(UART1, ntp_time_buf);
000016  a904              ADD      r1,sp,#0x10
000018  481f              LDR      r0,|L8.152|
00001a  f7fffffe          BL       USART_TxStr
;;;142        Delay_ms(500);//调试用延时，等待搬运完
00001e  20ff              MOVS     r0,#0xff
000020  30f5              ADDS     r0,r0,#0xf5
000022  f7fffffe          BL       Delay_ms
;;;143        // 提取日期和时间
;;;144        ExtractDateTime(UART_RxBuffer, dateTime, sizeof(dateTime));
000026  2240              MOVS     r2,#0x40
000028  491c              LDR      r1,|L8.156|
00002a  481d              LDR      r0,|L8.160|
00002c  f7fffffe          BL       ExtractDateTime
;;;145    
;;;146        // 解析日期和时间
;;;147        ParseDateTime(dateTime, &year, &month, &day, &hour, &minute, &second);
000030  481c              LDR      r0,|L8.164|
000032  491d              LDR      r1,|L8.168|
000034  4a1d              LDR      r2,|L8.172|
000036  4b1e              LDR      r3,|L8.176|
000038  9200              STR      r2,[sp,#0]
00003a  9101              STR      r1,[sp,#4]
00003c  9002              STR      r0,[sp,#8]
00003e  4a1d              LDR      r2,|L8.180|
000040  491d              LDR      r1,|L8.184|
000042  4816              LDR      r0,|L8.156|
000044  f7fffffe          BL       ParseDateTime
;;;148    
;;;149        // 输出结果
;;;150        printf("Extracted DateTime: %s\n", dateTime);
000048  4914              LDR      r1,|L8.156|
00004a  a01c              ADR      r0,|L8.188|
00004c  f7fffffe          BL       __2printf
;;;151        printf("Year: %d, Month: %d, Day: %d, Hour: %d, Minute: %d, Second: %d\n",
000050  4814              LDR      r0,|L8.164|
000052  6800              LDR      r0,[r0,#0]  ; second
000054  4914              LDR      r1,|L8.168|
000056  6809              LDR      r1,[r1,#0]  ; minute
000058  4a14              LDR      r2,|L8.172|
00005a  6812              LDR      r2,[r2,#0]  ; hour
00005c  9200              STR      r2,[sp,#0]
00005e  9101              STR      r1,[sp,#4]
000060  9002              STR      r0,[sp,#8]
000062  4813              LDR      r0,|L8.176|
000064  6803              LDR      r3,[r0,#0]  ; day
000066  4813              LDR      r0,|L8.180|
000068  6802              LDR      r2,[r0,#0]  ; month
00006a  4813              LDR      r0,|L8.184|
00006c  6801              LDR      r1,[r0,#0]  ; year
00006e  a019              ADR      r0,|L8.212|
000070  f7fffffe          BL       __2printf
;;;152               year, month, day, hour, minute, second);
;;;153        return 0;
000074  2000              MOVS     r0,#0
;;;154    }
000076  b01d              ADD      sp,sp,#0x74
000078  bd00              POP      {pc}
;;;155    // 提取日期和时间的函数
                          ENDP

00007a  0000              DCW      0x0000
                  |L8.124|
                          DCD      ||.constdata||+0x320
                  |L8.128|
000080  e88eb7e5          DCB      232,142,183,229,143,150,230,151,182,233,151,180,"...\r\n"
000084  8f96e697
000088  b6e997b4
00008c  2e2e2e0d
000090  0a      
000091  00                DCB      0
000092  00                DCB      0
000093  00                DCB      0
                  |L8.148|
                          DCD      0x40021020
                  |L8.152|
                          DCD      0x40020080
                  |L8.156|
                          DCD      dateTime
                  |L8.160|
                          DCD      UART_RxBuffer
                  |L8.164|
                          DCD      second
                  |L8.168|
                          DCD      minute
                  |L8.172|
                          DCD      hour
                  |L8.176|
                          DCD      ||day||
                  |L8.180|
                          DCD      month
                  |L8.184|
                          DCD      year
                  |L8.188|
0000bc  45787472          DCB      "Extracted DateTime: %s\n",0
0000c0  61637465
0000c4  64204461
0000c8  74655469
0000cc  6d653a20
0000d0  25730a00
                  |L8.212|
0000d4  59656172          DCB      "Year: %d, Month: %d, Day: %d, Hour: %d, Minute: %d, Sec"
0000d8  3a202564
0000dc  2c204d6f
0000e0  6e74683a
0000e4  2025642c
0000e8  20446179
0000ec  3a202564
0000f0  2c20486f
0000f4  75723a20
0000f8  25642c20
0000fc  4d696e75
000100  74653a20
000104  25642c20
000108  536563  
00010b  6f6e643a          DCB      "ond: %d\n",0
00010f  2025640a
000113  00      

                          AREA ||i.Get_Weather||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  Get_Weather PROC
;;;240    }
;;;241    uint8_t Get_Weather(void)
000000  b510              PUSH     {r4,lr}
;;;242    {
;;;243        if (Flag_weather_received == SET)
000002  480a              LDR      r0,|L9.44|
000004  7800              LDRB     r0,[r0,#0]  ; Flag_weather_received
000006  2801              CMP      r0,#1
000008  d10e              BNE      |L9.40|
;;;244        {
;;;245            // 处理接收到的天气数据
;;;246            uint8_t weatherData = UART_RxBuffer[RxIndex - 2]; // 获取天气数据（尾帧前一个字节）
00000a  4809              LDR      r0,|L9.48|
00000c  7800              LDRB     r0,[r0,#0]  ; RxIndex
00000e  1e80              SUBS     r0,r0,#2
000010  4908              LDR      r1,|L9.52|
000012  5c0c              LDRB     r4,[r1,r0]
;;;247            printf("Received Weather Data: 0x%02X\n", weatherData);
000014  4621              MOV      r1,r4
000016  a008              ADR      r0,|L9.56|
000018  f7fffffe          BL       __2printf
;;;248    
;;;249            // 重置标志位和接收索引
;;;250            Flag_weather_received = RESET;
00001c  2000              MOVS     r0,#0
00001e  4903              LDR      r1,|L9.44|
000020  7008              STRB     r0,[r1,#0]
;;;251            RxIndex = 0;
000022  4903              LDR      r1,|L9.48|
000024  7008              STRB     r0,[r1,#0]
;;;252        }
000026  bf00              NOP      
                  |L9.40|
;;;253        return 0;
000028  2000              MOVS     r0,#0
;;;254    }
00002a  bd10              POP      {r4,pc}
;;;255    void CLR_Buf2(void)
                          ENDP

                  |L9.44|
                          DCD      Flag_weather_received
                  |L9.48|
                          DCD      RxIndex
                  |L9.52|
                          DCD      UART_RxBuffer
                  |L9.56|
000038  52656365          DCB      "Received Weather Data: 0x%02X\n",0
00003c  69766564
000040  20576561
000044  74686572
000048  20446174
00004c  613a2030
000050  78253032
000054  580a00  
000057  00                DCB      0

                          AREA ||i.Login_URL||, CODE, READONLY, ALIGN=2

                  Login_URL PROC
;;;70     /*********************登录网址******************************/
;;;71     void Login_URL(void)
000000  b500              PUSH     {lr}
;;;72     {
000002  b099              SUB      sp,sp,#0x64
;;;73         char login_url[100] = {"AT+CIPSNTPCFG=1,8,\"iot.console.aliyun.com\"\r\n\r\n"};
000004  2264              MOVS     r2,#0x64
000006  4907              LDR      r1,|L10.36|
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       __aeabi_memcpy4
;;;74         USART_TxStr(UART2,"连接阿里云服务器...\r\n");
00000e  a106              ADR      r1,|L10.40|
000010  480d              LDR      r0,|L10.72|
000012  f7fffffe          BL       USART_TxStr
;;;75         USART_TxStr(UART1,login_url);
000016  4669              MOV      r1,sp
000018  480c              LDR      r0,|L10.76|
00001a  f7fffffe          BL       USART_TxStr
;;;76     }
00001e  b019              ADD      sp,sp,#0x64
000020  bd00              POP      {pc}
;;;77     
                          ENDP

000022  0000              DCW      0x0000
                  |L10.36|
                          DCD      ||.constdata||
                  |L10.40|
000028  e8bf9ee6          DCB      232,191,158,230,142,165,233,152,191,233,135,140,228,186,145
00002c  8ea5e998
000030  bfe9878c
000034  e4ba91  
000037  e69c8de5          DCB      230,156,141,229,138,161,229,153,168,"...\r\n",0
00003b  8aa1e599
00003f  a82e2e2e
000043  0d0a00  
000046  00                DCB      0
000047  00                DCB      0
                  |L10.72|
                          DCD      0x40021020
                  |L10.76|
                          DCD      0x40020080

                          AREA ||i.ParseDateTime||, CODE, READONLY, ALIGN=2

                          REQUIRE _scanf_int
                          REQUIRE _scanf_string
                  ParseDateTime PROC
;;;180    // 解析日期和时间字符串，生成年、月、日、时、分、秒
;;;181    void ParseDateTime(const char* dateTime, int* year, int* month, int* day, int* hour, int* minute, int* second) 
000000  b5f0              PUSH     {r4-r7,lr}
;;;182    {
000002  b085              SUB      sp,sp,#0x14
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;183        // 使用 sscanf 解析日期和时间
;;;184        sscanf(dateTime, "%*s %*s %d %d:%d:%d %d", day, hour, minute, second, year);
00000c  990c              LDR      r1,[sp,#0x30]
00000e  980b              LDR      r0,[sp,#0x2c]
000010  9702              STR      r7,[sp,#8]
000012  9101              STR      r1,[sp,#4]
000014  9000              STR      r0,[sp,#0]
000016  462a              MOV      r2,r5
000018  a15f              ADR      r1,|L11.408|
00001a  4630              MOV      r0,r6
00001c  9b0a              LDR      r3,[sp,#0x28]
00001e  f7fffffe          BL       __0sscanf
;;;185    
;;;186        // 将月份字符串转换为数字
;;;187        char monthStr[4];  // 用于存储月份字符串（如 "Dec"）
;;;188        strncpy(monthStr, dateTime + 4, 3);  // 从第 5 个字符开始提取月份字符串
000022  2203              MOVS     r2,#3
000024  1d31              ADDS     r1,r6,#4
000026  a804              ADD      r0,sp,#0x10
000028  f7fffffe          BL       strncpy
;;;189        monthStr[3] = '\0';  // 确保字符串以 '\0' 结尾
00002c  2000              MOVS     r0,#0
00002e  4669              MOV      r1,sp
000030  74c8              STRB     r0,[r1,#0x13]
;;;190    
;;;191        if (strcmp(monthStr, "Jan") == 0) *month = 1;
000032  a15f              ADR      r1,|L11.432|
000034  a804              ADD      r0,sp,#0x10
000036  f7fffffe          BL       strcmp
00003a  2800              CMP      r0,#0
00003c  d102              BNE      |L11.68|
00003e  2001              MOVS     r0,#1
000040  6020              STR      r0,[r4,#0]
000042  e061              B        |L11.264|
                  |L11.68|
;;;192        else if (strcmp(monthStr, "Feb") == 0) *month = 2;
000044  a15b              ADR      r1,|L11.436|
000046  a804              ADD      r0,sp,#0x10
000048  f7fffffe          BL       strcmp
00004c  2800              CMP      r0,#0
00004e  d102              BNE      |L11.86|
000050  2002              MOVS     r0,#2
000052  6020              STR      r0,[r4,#0]
000054  e058              B        |L11.264|
                  |L11.86|
;;;193        else if (strcmp(monthStr, "Mar") == 0) *month = 3;
000056  a158              ADR      r1,|L11.440|
000058  a804              ADD      r0,sp,#0x10
00005a  f7fffffe          BL       strcmp
00005e  2800              CMP      r0,#0
000060  d102              BNE      |L11.104|
000062  2003              MOVS     r0,#3
000064  6020              STR      r0,[r4,#0]
000066  e04f              B        |L11.264|
                  |L11.104|
;;;194        else if (strcmp(monthStr, "Apr") == 0) *month = 4;
000068  a154              ADR      r1,|L11.444|
00006a  a804              ADD      r0,sp,#0x10
00006c  f7fffffe          BL       strcmp
000070  2800              CMP      r0,#0
000072  d102              BNE      |L11.122|
000074  2004              MOVS     r0,#4
000076  6020              STR      r0,[r4,#0]
000078  e046              B        |L11.264|
                  |L11.122|
;;;195        else if (strcmp(monthStr, "May") == 0) *month = 5;
00007a  a151              ADR      r1,|L11.448|
00007c  a804              ADD      r0,sp,#0x10
00007e  f7fffffe          BL       strcmp
000082  2800              CMP      r0,#0
000084  d102              BNE      |L11.140|
000086  2005              MOVS     r0,#5
000088  6020              STR      r0,[r4,#0]
00008a  e03d              B        |L11.264|
                  |L11.140|
;;;196        else if (strcmp(monthStr, "Jun") == 0) *month = 6;
00008c  a14d              ADR      r1,|L11.452|
00008e  a804              ADD      r0,sp,#0x10
000090  f7fffffe          BL       strcmp
000094  2800              CMP      r0,#0
000096  d102              BNE      |L11.158|
000098  2006              MOVS     r0,#6
00009a  6020              STR      r0,[r4,#0]
00009c  e034              B        |L11.264|
                  |L11.158|
;;;197        else if (strcmp(monthStr, "Jul") == 0) *month = 7;
00009e  a14a              ADR      r1,|L11.456|
0000a0  a804              ADD      r0,sp,#0x10
0000a2  f7fffffe          BL       strcmp
0000a6  2800              CMP      r0,#0
0000a8  d102              BNE      |L11.176|
0000aa  2007              MOVS     r0,#7
0000ac  6020              STR      r0,[r4,#0]
0000ae  e02b              B        |L11.264|
                  |L11.176|
;;;198        else if (strcmp(monthStr, "Aug") == 0) *month = 8;
0000b0  a146              ADR      r1,|L11.460|
0000b2  a804              ADD      r0,sp,#0x10
0000b4  f7fffffe          BL       strcmp
0000b8  2800              CMP      r0,#0
0000ba  d102              BNE      |L11.194|
0000bc  2008              MOVS     r0,#8
0000be  6020              STR      r0,[r4,#0]
0000c0  e022              B        |L11.264|
                  |L11.194|
;;;199        else if (strcmp(monthStr, "Sep") == 0) *month = 9;
0000c2  a143              ADR      r1,|L11.464|
0000c4  a804              ADD      r0,sp,#0x10
0000c6  f7fffffe          BL       strcmp
0000ca  2800              CMP      r0,#0
0000cc  d102              BNE      |L11.212|
0000ce  2009              MOVS     r0,#9
0000d0  6020              STR      r0,[r4,#0]
0000d2  e019              B        |L11.264|
                  |L11.212|
;;;200        else if (strcmp(monthStr, "Oct") == 0) *month = 10;
0000d4  a13f              ADR      r1,|L11.468|
0000d6  a804              ADD      r0,sp,#0x10
0000d8  f7fffffe          BL       strcmp
0000dc  2800              CMP      r0,#0
0000de  d102              BNE      |L11.230|
0000e0  200a              MOVS     r0,#0xa
0000e2  6020              STR      r0,[r4,#0]
0000e4  e010              B        |L11.264|
                  |L11.230|
;;;201        else if (strcmp(monthStr, "Nov") == 0) *month = 11;
0000e6  a13c              ADR      r1,|L11.472|
0000e8  a804              ADD      r0,sp,#0x10
0000ea  f7fffffe          BL       strcmp
0000ee  2800              CMP      r0,#0
0000f0  d102              BNE      |L11.248|
0000f2  200b              MOVS     r0,#0xb
0000f4  6020              STR      r0,[r4,#0]
0000f6  e007              B        |L11.264|
                  |L11.248|
;;;202        else if (strcmp(monthStr, "Dec") == 0) *month = 12;
0000f8  a138              ADR      r1,|L11.476|
0000fa  a804              ADD      r0,sp,#0x10
0000fc  f7fffffe          BL       strcmp
000100  2800              CMP      r0,#0
000102  d101              BNE      |L11.264|
000104  200c              MOVS     r0,#0xc
000106  6020              STR      r0,[r4,#0]
                  |L11.264|
;;;203    
;;;204        // 将星期几字符串转换为数字
;;;205        char weekDayStr[4];  // 用于存储星期几字符串（如 "Tue"）
;;;206        strncpy(weekDayStr, dateTime, 3);  // 提取前 3 个字符作为星期几
000108  2203              MOVS     r2,#3
00010a  4631              MOV      r1,r6
00010c  a803              ADD      r0,sp,#0xc
00010e  f7fffffe          BL       strncpy
;;;207        weekDayStr[3] = '\0';  // 确保字符串以 '\0' 结尾
000112  2000              MOVS     r0,#0
000114  4669              MOV      r1,sp
000116  73c8              STRB     r0,[r1,#0xf]
;;;208    
;;;209        if (strcmp(weekDayStr, "Mon") == 0) *day = 1;
000118  a131              ADR      r1,|L11.480|
00011a  a803              ADD      r0,sp,#0xc
00011c  f7fffffe          BL       strcmp
000120  2800              CMP      r0,#0
000122  d102              BNE      |L11.298|
000124  2001              MOVS     r0,#1
000126  6028              STR      r0,[r5,#0]
000128  e034              B        |L11.404|
                  |L11.298|
;;;210        else if (strcmp(weekDayStr, "Tue") == 0) *day = 2;
00012a  a12e              ADR      r1,|L11.484|
00012c  a803              ADD      r0,sp,#0xc
00012e  f7fffffe          BL       strcmp
000132  2800              CMP      r0,#0
000134  d102              BNE      |L11.316|
000136  2002              MOVS     r0,#2
000138  6028              STR      r0,[r5,#0]
00013a  e02b              B        |L11.404|
                  |L11.316|
;;;211        else if (strcmp(weekDayStr, "Wed") == 0) *day = 3;
00013c  a12a              ADR      r1,|L11.488|
00013e  a803              ADD      r0,sp,#0xc
000140  f7fffffe          BL       strcmp
000144  2800              CMP      r0,#0
000146  d102              BNE      |L11.334|
000148  2003              MOVS     r0,#3
00014a  6028              STR      r0,[r5,#0]
00014c  e022              B        |L11.404|
                  |L11.334|
;;;212        else if (strcmp(weekDayStr, "Thu") == 0) *day = 4;
00014e  a127              ADR      r1,|L11.492|
000150  a803              ADD      r0,sp,#0xc
000152  f7fffffe          BL       strcmp
000156  2800              CMP      r0,#0
000158  d102              BNE      |L11.352|
00015a  2004              MOVS     r0,#4
00015c  6028              STR      r0,[r5,#0]
00015e  e019              B        |L11.404|
                  |L11.352|
;;;213        else if (strcmp(weekDayStr, "Fri") == 0) *day = 5;
000160  a123              ADR      r1,|L11.496|
000162  a803              ADD      r0,sp,#0xc
000164  f7fffffe          BL       strcmp
000168  2800              CMP      r0,#0
00016a  d102              BNE      |L11.370|
00016c  2005              MOVS     r0,#5
00016e  6028              STR      r0,[r5,#0]
000170  e010              B        |L11.404|
                  |L11.370|
;;;214        else if (strcmp(weekDayStr, "Sat") == 0) *day = 6;
000172  a120              ADR      r1,|L11.500|
000174  a803              ADD      r0,sp,#0xc
000176  f7fffffe          BL       strcmp
00017a  2800              CMP      r0,#0
00017c  d102              BNE      |L11.388|
00017e  2006              MOVS     r0,#6
000180  6028              STR      r0,[r5,#0]
000182  e007              B        |L11.404|
                  |L11.388|
;;;215        else if (strcmp(weekDayStr, "Sun") == 0) *day = 7;
000184  a11c              ADR      r1,|L11.504|
000186  a803              ADD      r0,sp,#0xc
000188  f7fffffe          BL       strcmp
00018c  2800              CMP      r0,#0
00018e  d101              BNE      |L11.404|
000190  2007              MOVS     r0,#7
000192  6028              STR      r0,[r5,#0]
                  |L11.404|
;;;216    }
000194  b005              ADD      sp,sp,#0x14
000196  bdf0              POP      {r4-r7,pc}
;;;217    
                          ENDP

                  |L11.408|
000198  252a7320          DCB      "%*s %*s %d %d:%d:%d %d",0
00019c  252a7320
0001a0  25642025
0001a4  643a2564
0001a8  3a256420
0001ac  256400  
0001af  00                DCB      0
                  |L11.432|
0001b0  4a616e00          DCB      "Jan",0
                  |L11.436|
0001b4  46656200          DCB      "Feb",0
                  |L11.440|
0001b8  4d617200          DCB      "Mar",0
                  |L11.444|
0001bc  41707200          DCB      "Apr",0
                  |L11.448|
0001c0  4d617900          DCB      "May",0
                  |L11.452|
0001c4  4a756e00          DCB      "Jun",0
                  |L11.456|
0001c8  4a756c00          DCB      "Jul",0
                  |L11.460|
0001cc  41756700          DCB      "Aug",0
                  |L11.464|
0001d0  53657000          DCB      "Sep",0
                  |L11.468|
0001d4  4f637400          DCB      "Oct",0
                  |L11.472|
0001d8  4e6f7600          DCB      "Nov",0
                  |L11.476|
0001dc  44656300          DCB      "Dec",0
                  |L11.480|
0001e0  4d6f6e00          DCB      "Mon",0
                  |L11.484|
0001e4  54756500          DCB      "Tue",0
                  |L11.488|
0001e8  57656400          DCB      "Wed",0
                  |L11.492|
0001ec  54687500          DCB      "Thu",0
                  |L11.496|
0001f0  46726900          DCB      "Fri",0
                  |L11.500|
0001f4  53617400          DCB      "Sat",0
                  |L11.504|
0001f8  53756e00          DCB      "Sun",0

                          AREA ||i.Setting_Connect_Work||, CODE, READONLY, ALIGN=2

                  Setting_Connect_Work PROC
;;;61     **************************************************************/
;;;62     void Setting_Connect_Work(char *type)
000000  b51f              PUSH     {r0-r4,lr}
;;;63     {
000002  4604              MOV      r4,r0
;;;64         char wifi_mode_buf[13] = {"AT+CWMODE=x\r\n"};
000004  a308              ADR      r3,|L12.40|
000006  cb0f              LDM      r3,{r0-r3}
000008  9303              STR      r3,[sp,#0xc]
00000a  466b              MOV      r3,sp
00000c  c307              STM      r3!,{r0-r2}
;;;65         wifi_mode_buf[10] = *type;
00000e  7820              LDRB     r0,[r4,#0]
000010  4669              MOV      r1,sp
000012  7288              STRB     r0,[r1,#0xa]
;;;66         USART_TxStr(UART2,"设置工作模式...\r\n");
000014  a108              ADR      r1,|L12.56|
000016  480e              LDR      r0,|L12.80|
000018  f7fffffe          BL       USART_TxStr
;;;67         USART_TxStr(UART1,wifi_mode_buf);
00001c  4669              MOV      r1,sp
00001e  480d              LDR      r0,|L12.84|
000020  f7fffffe          BL       USART_TxStr
;;;68     }
000024  bd1f              POP      {r0-r4,pc}
;;;69     
                          ENDP

000026  0000              DCW      0x0000
                  |L12.40|
000028  41542b43          DCB      "AT+CWMODE=x\r\n",0
00002c  574d4f44
000030  453d780d
000034  0a00    
000036  00                DCB      0
000037  00                DCB      0
                  |L12.56|
000038  e8aebee7          DCB      232,174,190,231,189,174,229,183,165,228,189,156,230,168,161
00003c  bdaee5b7
000040  a5e4bd9c
000044  e6a8a1  
000047  e5bc8f2e          DCB      229,188,143,"...\r\n",0
00004b  2e2e0d0a
00004f  00      
                  |L12.80|
                          DCD      0x40021020
                  |L12.84|
                          DCD      0x40020080

                          AREA ||i.UART1_Handler||, CODE, READONLY, ALIGN=2

                  UART1_Handler PROC
;;;260    
;;;261    void UART1_Handler(void)
000000  b510              PUSH     {r4,lr}
;;;262    {
;;;263        while (UART_GetFlagStatus(UART1, UART_Flag_RX) == SET) // 接收中断收完再处理
000002  e02f              B        |L13.100|
                  |L13.4|
;;;264        {
;;;265            UART_ClearFlag(UART1, UART_Flag_RX);            // 清除接收标志
000004  2101              MOVS     r1,#1
000006  481b              LDR      r0,|L13.116|
000008  f7fffffe          BL       UART_ClearFlag
;;;266            uint8_t receivedChar = UART_ReceiveData(UART1); // 接收数据
00000c  4819              LDR      r0,|L13.116|
00000e  f7fffffe          BL       UART_ReceiveData
000012  b2c4              UXTB     r4,r0
;;;267    
;;;268            UART_RxBuffer[RxIndex++] = receivedChar; // 接收数据并存入缓冲区
000014  4918              LDR      r1,|L13.120|
000016  7808              LDRB     r0,[r1,#0]  ; RxIndex
000018  1c41              ADDS     r1,r0,#1
00001a  4a17              LDR      r2,|L13.120|
00001c  7011              STRB     r1,[r2,#0]
00001e  4917              LDR      r1,|L13.124|
000020  540c              STRB     r4,[r1,r0]
;;;269    
;;;270            if (RxIndex >= MAX_BUFFER_SIZE) // 防止缓冲区溢出
000022  4610              MOV      r0,r2
000024  7800              LDRB     r0,[r0,#0]  ; RxIndex
000026  2864              CMP      r0,#0x64
000028  db02              BLT      |L13.48|
;;;271            {
;;;272                RxIndex = 0; // 重置接收索引
00002a  2000              MOVS     r0,#0
00002c  4611              MOV      r1,r2
00002e  7008              STRB     r0,[r1,#0]
                  |L13.48|
;;;273            }
;;;274    
;;;275            // 检查是否接收到 "OK"
;;;276            if (RxIndex >= 2 && UART_RxBuffer[RxIndex - 2] == 'O' && UART_RxBuffer[RxIndex - 1] == 'K')
000030  4811              LDR      r0,|L13.120|
000032  7800              LDRB     r0,[r0,#0]  ; RxIndex
000034  2802              CMP      r0,#2
000036  db0f              BLT      |L13.88|
000038  480f              LDR      r0,|L13.120|
00003a  7800              LDRB     r0,[r0,#0]  ; RxIndex
00003c  1e80              SUBS     r0,r0,#2
00003e  490f              LDR      r1,|L13.124|
000040  5c08              LDRB     r0,[r1,r0]
000042  284f              CMP      r0,#0x4f
000044  d108              BNE      |L13.88|
000046  480c              LDR      r0,|L13.120|
000048  7800              LDRB     r0,[r0,#0]  ; RxIndex
00004a  1e40              SUBS     r0,r0,#1
00004c  5c08              LDRB     r0,[r1,r0]
00004e  284b              CMP      r0,#0x4b
000050  d102              BNE      |L13.88|
;;;277            {
;;;278                Flag_usart2_receive_OK = SET; // 设置接收OK标志位
000052  2001              MOVS     r0,#1
000054  490a              LDR      r1,|L13.128|
000056  7008              STRB     r0,[r1,#0]
                  |L13.88|
;;;279            }
;;;280            // 检查是否接收到天气数据的尾帧#
;;;281            if (receivedChar == WEATHER_FRAME_END)
000058  2c23              CMP      r4,#0x23
00005a  d102              BNE      |L13.98|
;;;282            {
;;;283                Flag_weather_received = SET; // 设置天气数据接收标志位
00005c  2001              MOVS     r0,#1
00005e  4909              LDR      r1,|L13.132|
000060  7008              STRB     r0,[r1,#0]
                  |L13.98|
;;;284            }
;;;285        }
000062  bf00              NOP      
                  |L13.100|
000064  2101              MOVS     r1,#1                 ;263
000066  4803              LDR      r0,|L13.116|
000068  f7fffffe          BL       UART_GetFlagStatus
00006c  2801              CMP      r0,#1                 ;263
00006e  d0c9              BEQ      |L13.4|
;;;286    }
000070  bd10              POP      {r4,pc}
;;;287    
                          ENDP

000072  0000              DCW      0x0000
                  |L13.116|
                          DCD      0x40020080
                  |L13.120|
                          DCD      RxIndex
                  |L13.124|
                          DCD      UART_RxBuffer
                  |L13.128|
                          DCD      Flag_usart2_receive_OK
                  |L13.132|
                          DCD      Flag_weather_received

                          AREA ||i.USART_TxStr||, CODE, READONLY, ALIGN=2

                  USART_TxStr PROC
;;;217    
;;;218    void USART_TxStr(UART_TypeDef* uart, const char *str)
000000  b570              PUSH     {r4-r6,lr}
;;;219    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;220        // 根据传入的串口类型选择发送的串口
;;;221        if (uart == UART1)
000006  4812              LDR      r0,|L14.80|
000008  4285              CMP      r5,r0
00000a  d108              BNE      |L14.30|
;;;222        {
;;;223            // 计算字符串长度
;;;224            uint16_t length = strlen(str);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       strlen
000012  b286              UXTH     r6,r0
;;;225    
;;;226            // 使用DMA发送
;;;227            UART_DMA_Send((uint8_t*)str, length);
000014  4631              MOV      r1,r6
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_DMA_Send
;;;228        }
00001c  e016              B        |L14.76|
                  |L14.30|
;;;229        else if (uart == UART2)
00001e  480d              LDR      r0,|L14.84|
000020  4285              CMP      r5,r0
000022  d113              BNE      |L14.76|
;;;230        {
;;;231            while (*str)
000024  e00f              B        |L14.70|
                  |L14.38|
;;;232            {
;;;233                UART_SendData(UART2, (uint8_t)*str); // 发送字符到UART2
000026  7821              LDRB     r1,[r4,#0]
000028  480a              LDR      r0,|L14.84|
00002a  f7fffffe          BL       UART_SendData
;;;234                while (UART_GetFlagStatus(UART2, UART_Flag_TX) == RESET)
00002e  bf00              NOP      
                  |L14.48|
000030  2102              MOVS     r1,#2
000032  4808              LDR      r0,|L14.84|
000034  f7fffffe          BL       UART_GetFlagStatus
000038  2800              CMP      r0,#0
00003a  d0f9              BEQ      |L14.48|
;;;235                    ;                                // 等待发送完成
;;;236                UART_ClearFlag(UART2, UART_Flag_TX); // 清除发送完成标志
00003c  2102              MOVS     r1,#2
00003e  4805              LDR      r0,|L14.84|
000040  f7fffffe          BL       UART_ClearFlag
;;;237                str++;
000044  1c64              ADDS     r4,r4,#1
                  |L14.70|
000046  7820              LDRB     r0,[r4,#0]            ;231
000048  2800              CMP      r0,#0                 ;231
00004a  d1ec              BNE      |L14.38|
                  |L14.76|
;;;238            }
;;;239        }
;;;240    }
00004c  bd70              POP      {r4-r6,pc}
;;;241    uint8_t Get_Weather(void)
                          ENDP

00004e  0000              DCW      0x0000
                  |L14.80|
                          DCD      0x40020080
                  |L14.84|
                          DCD      0x40021020

                          AREA ||i.USER_Connect||, CODE, READONLY, ALIGN=2

                  USER_Connect PROC
;;;90     /*********************用户设备连接*******************************/
;;;91     void USER_Connect(void)
000000  b500              PUSH     {lr}
;;;92     {
000002  b0b3              SUB      sp,sp,#0xcc
;;;93         char user_connect_buf[200] = {"AT+MQTTUSERCFG=0,1,\"NULL\",\"SC32F10TS8&k23m6LAJ0V9\",\"C2B81F691F8AFC60347A715F0155D0D97FAFE2FC\",0,0,\"\"\r\n\r\n"};
000004  22c8              MOVS     r2,#0xc8
000006  4907              LDR      r1,|L15.36|
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       __aeabi_memcpy4
;;;94         USART_TxStr(UART2,"用户设备连接...\r\n");
00000e  a106              ADR      r1,|L15.40|
000010  480b              LDR      r0,|L15.64|
000012  f7fffffe          BL       USART_TxStr
;;;95         USART_TxStr(UART1,user_connect_buf);
000016  a901              ADD      r1,sp,#4
000018  480a              LDR      r0,|L15.68|
00001a  f7fffffe          BL       USART_TxStr
;;;96     }
00001e  b033              ADD      sp,sp,#0xcc
000020  bd00              POP      {pc}
;;;97     
                          ENDP

000022  0000              DCW      0x0000
                  |L15.36|
                          DCD      ||.constdata||+0xc8
                  |L15.40|
000028  e794a8e6          DCB      231,148,168,230,136,183,232,174,190,229,164,135,232,191,158
00002c  88b7e8ae
000030  bee5a487
000034  e8bf9e  
000037  e68ea52e          DCB      230,142,165,"...\r\n",0
00003b  2e2e0d0a
00003f  00      
                  |L15.64|
                          DCD      0x40021020
                  |L15.68|
                          DCD      0x40020080

                          AREA ||i.WIFI_Connect||, CODE, READONLY, ALIGN=2

                  WIFI_Connect PROC
;;;78     /*********************连接WIFI******************************/
;;;79     void WIFI_Connect(char *name, char *password)
000000  b530              PUSH     {r4,r5,lr}
;;;80     {
000002  b099              SUB      sp,sp,#0x64
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;81         char wifi_connect_buf[100] = {"AT+CWJAP="};
000008  2264              MOVS     r2,#0x64
00000a  490f              LDR      r1,|L16.72|
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memcpy4
;;;82         strcat(wifi_connect_buf, name);
000012  4621              MOV      r1,r4
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       strcat
;;;83         strcat(wifi_connect_buf, ",");
00001a  a10c              ADR      r1,|L16.76|
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       strcat
;;;84         strcat(wifi_connect_buf, password);
000022  4629              MOV      r1,r5
000024  4668              MOV      r0,sp
000026  f7fffffe          BL       strcat
;;;85         strcat(wifi_connect_buf, "\r\n");
00002a  a109              ADR      r1,|L16.80|
00002c  4668              MOV      r0,sp
00002e  f7fffffe          BL       strcat
;;;86         USART_TxStr(UART2,"连接已知WiFi...\r\n");
000032  a108              ADR      r1,|L16.84|
000034  480d              LDR      r0,|L16.108|
000036  f7fffffe          BL       USART_TxStr
;;;87         USART_TxStr(UART1,wifi_connect_buf);
00003a  4669              MOV      r1,sp
00003c  480c              LDR      r0,|L16.112|
00003e  f7fffffe          BL       USART_TxStr
;;;88     }
000042  b019              ADD      sp,sp,#0x64
000044  bd30              POP      {r4,r5,pc}
;;;89     
                          ENDP

000046  0000              DCW      0x0000
                  |L16.72|
                          DCD      ||.constdata||+0x64
                  |L16.76|
00004c  2c00              DCB      ",",0
00004e  00                DCB      0
00004f  00                DCB      0
                  |L16.80|
000050  0d0a00            DCB      "\r\n",0
000053  00                DCB      0
                  |L16.84|
000054  e8bf9ee6          DCB      232,191,158,230,142,165,229,183,178,231,159,165,"WiFi..."
000058  8ea5e5b7
00005c  b2e79fa5
000060  57694669
000064  2e2e2e  
000067  0d0a00            DCB      "\r\n",0
00006a  00                DCB      0
00006b  00                DCB      0
                  |L16.108|
                          DCD      0x40021020
                  |L16.112|
                          DCD      0x40020080

                          AREA ||i.WIFI_Init||, CODE, READONLY, ALIGN=2

                  WIFI_Init PROC
;;;7      
;;;8      void WIFI_Init(void)
000000  b510              PUSH     {r4,lr}
;;;9      {
;;;10         WIFI_Rst();
000002  f7fffffe          BL       WIFI_Rst
;;;11         Setting_Connect_Work("1");
000006  a014              ADR      r0,|L17.88|
000008  f7fffffe          BL       Setting_Connect_Work
;;;12         wait_OK();
00000c  f7fffffe          BL       wait_OK
;;;13     
;;;14         Login_URL();
000010  f7fffffe          BL       Login_URL
;;;15         wait_OK();
000014  f7fffffe          BL       wait_OK
;;;16     
;;;17         WIFI_Connect("\"scy1\"", "\"123456789\"");
000018  a110              ADR      r1,|L17.92|
00001a  a013              ADR      r0,|L17.104|
00001c  f7fffffe          BL       WIFI_Connect
;;;18         wait_OK();
000020  f7fffffe          BL       wait_OK
;;;19     
;;;20         USER_Connect();
000024  f7fffffe          BL       USER_Connect
;;;21         wait_OK();
000028  f7fffffe          BL       wait_OK
;;;22     
;;;23         Client_Connect();
00002c  f7fffffe          BL       Client_Connect
;;;24         wait_OK();
000030  f7fffffe          BL       wait_OK
;;;25     
;;;26         Connect_Aliyun_Server();
000034  f7fffffe          BL       Connect_Aliyun_Server
;;;27         wait_OK();
000038  f7fffffe          BL       wait_OK
;;;28     
;;;29         Client_Subscribe();
00003c  f7fffffe          BL       Client_Subscribe
;;;30         wait_OK();
000040  f7fffffe          BL       wait_OK
;;;31         Get_Ntp_Time();
000044  f7fffffe          BL       Get_Ntp_Time
;;;32         if(Wifi_Init_OK == RESET) Wifi_Init_OK = SET;//初始化完成
000048  4809              LDR      r0,|L17.112|
00004a  7800              LDRB     r0,[r0,#0]  ; Wifi_Init_OK
00004c  2800              CMP      r0,#0
00004e  d102              BNE      |L17.86|
000050  2001              MOVS     r0,#1
000052  4907              LDR      r1,|L17.112|
000054  7008              STRB     r0,[r1,#0]
                  |L17.86|
;;;33     }
000056  bd10              POP      {r4,pc}
;;;34     FlagStatus Get_Init_Flag()
                          ENDP

                  |L17.88|
000058  3100              DCB      "1",0
00005a  00                DCB      0
00005b  00                DCB      0
                  |L17.92|
00005c  22313233          DCB      """123456789""",0
000060  34353637
000064  38392200
                  |L17.104|
000068  22736379          DCB      """scy1""",0
00006c  312200  
00006f  00                DCB      0
                  |L17.112|
                          DCD      Wifi_Init_OK

                          AREA ||i.WIFI_Rst||, CODE, READONLY, ALIGN=2

                  WIFI_Rst PROC
;;;39     /*********************重启WIFI模块*****************************/
;;;40     void WIFI_Rst(void)
000000  b50e              PUSH     {r1-r3,lr}
;;;41     {
;;;42         char rst_buff[11] = {"AT+RST\r\n\r\n"};
000002  a215              ADR      r2,|L18.88|
000004  ca07              LDM      r2,{r0-r2}
000006  466b              MOV      r3,sp
000008  c307              STM      r3!,{r0-r2}
;;;43         USART_TxStr(UART2,"重启模块...\r\n");
00000a  a116              ADR      r1,|L18.100|
00000c  481a              LDR      r0,|L18.120|
00000e  f7fffffe          BL       USART_TxStr
;;;44         USART_TxStr(UART1,rst_buff);  
000012  4669              MOV      r1,sp
000014  4819              LDR      r0,|L18.124|
000016  f7fffffe          BL       USART_TxStr
;;;45         Delay_ms(1000); // WIFI重启需要时间
00001a  207d              MOVS     r0,#0x7d
00001c  00c0              LSLS     r0,r0,#3
00001e  f7fffffe          BL       Delay_ms
;;;46         Delay_ms(1000);
000022  207d              MOVS     r0,#0x7d
000024  00c0              LSLS     r0,r0,#3
000026  f7fffffe          BL       Delay_ms
;;;47         Delay_ms(1000);
00002a  207d              MOVS     r0,#0x7d
00002c  00c0              LSLS     r0,r0,#3
00002e  f7fffffe          BL       Delay_ms
;;;48         Delay_ms(1000);
000032  207d              MOVS     r0,#0x7d
000034  00c0              LSLS     r0,r0,#3
000036  f7fffffe          BL       Delay_ms
;;;49         Delay_ms(1000);
00003a  207d              MOVS     r0,#0x7d
00003c  00c0              LSLS     r0,r0,#3
00003e  f7fffffe          BL       Delay_ms
;;;50         Delay_ms(1000);
000042  207d              MOVS     r0,#0x7d
000044  00c0              LSLS     r0,r0,#3
000046  f7fffffe          BL       Delay_ms
;;;51         CLR_Buf2(); // 清除串口接收缓存
00004a  f7fffffe          BL       CLR_Buf2
;;;52         Flag_usart2_receive_OK = RESET;
00004e  2000              MOVS     r0,#0
000050  490b              LDR      r1,|L18.128|
000052  7008              STRB     r0,[r1,#0]
;;;53     }
000054  bd0e              POP      {r1-r3,pc}
;;;54     
                          ENDP

000056  0000              DCW      0x0000
                  |L18.88|
000058  41542b52          DCB      "AT+RST\r\n\r\n",0
00005c  53540d0a
000060  0d0a00  
000063  00                DCB      0
                  |L18.100|
000064  e9878de5          DCB      233,135,141,229,144,175,230,168,161,229,157,151,"...\r\n"
000068  90afe6a8
00006c  a1e59d97
000070  2e2e2e0d
000074  0a      
000075  00                DCB      0
000076  00                DCB      0
000077  00                DCB      0
                  |L18.120|
                          DCD      0x40021020
                  |L18.124|
                          DCD      0x40020080
                  |L18.128|
                          DCD      Flag_usart2_receive_OK

                          AREA ||i.wait_OK||, CODE, READONLY, ALIGN=2

                  wait_OK PROC
;;;287    
;;;288    void wait_OK(void)
000000  b570              PUSH     {r4-r6,lr}
;;;289    {
;;;290        uint32_t timeout = 5000000; // 设置超时时间为5000ms
000002  4d0e              LDR      r5,|L19.60|
;;;291        uint32_t elapsed_time = 0; // 已经过的时间
000004  2400              MOVS     r4,#0
;;;292        while (!Flag_usart2_receive_OK) // 等待接收到OK字符串
000006  e00d              B        |L19.36|
                  |L19.8|
;;;293        {
;;;294            Delay_us(100); // 每次循环延时100微秒
000008  2064              MOVS     r0,#0x64
00000a  f7fffffe          BL       Delay_us
;;;295            elapsed_time += 100; // 更新已过时间
00000e  3464              ADDS     r4,r4,#0x64
;;;296    
;;;297            if (elapsed_time >= timeout) // 检查是否超时
000010  42ac              CMP      r4,r5
000012  d307              BCC      |L19.36|
;;;298            {
;;;299                // 超时处理
;;;300                wait_timeout = 1;
000014  2001              MOVS     r0,#1
000016  490a              LDR      r1,|L19.64|
000018  7008              STRB     r0,[r1,#0]
;;;301                USART_TxStr(UART2,"超时！！！\r\n");
00001a  a10a              ADR      r1,|L19.68|
00001c  480e              LDR      r0,|L19.88|
00001e  f7fffffe          BL       USART_TxStr
;;;302                break; // 跳出循环
000022  e003              B        |L19.44|
                  |L19.36|
000024  480d              LDR      r0,|L19.92|
000026  7800              LDRB     r0,[r0,#0]            ;292  ; Flag_usart2_receive_OK
000028  2800              CMP      r0,#0                 ;292
00002a  d0ed              BEQ      |L19.8|
                  |L19.44|
00002c  bf00              NOP      
;;;303            }
;;;304        }
;;;305        Flag_usart2_receive_OK = RESET; // 清除接收OK标志位
00002e  2000              MOVS     r0,#0
000030  490a              LDR      r1,|L19.92|
000032  7008              STRB     r0,[r1,#0]
;;;306        CLR_Buf2(); // 清除串口接收缓存
000034  f7fffffe          BL       CLR_Buf2
;;;307    }
000038  bd70              POP      {r4-r6,pc}
;;;308    
                          ENDP

00003a  0000              DCW      0x0000
                  |L19.60|
                          DCD      0x004c4b40
                  |L19.64|
                          DCD      wait_timeout
                  |L19.68|
000044  e8b685e6          DCB      232,182,133,230,151,182,239,188,129,239,188,129,239,188,129
000048  97b6efbc
00004c  81efbc81
000050  efbc81  
000053  5c720a00          DCB      "\\r\n",0
000057  00                DCB      0
                  |L19.88|
                          DCD      0x40021020
                  |L19.92|
                          DCD      Flag_usart2_receive_OK

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  UART_RxBuffer
                          %        100
                  UART_TxBuffer
                          %        100
                  dateTime
                          %        64

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  41542b43          DCB      0x41,0x54,0x2b,0x43
000004  4950534e          DCB      0x49,0x50,0x53,0x4e
000008  54504346          DCB      0x54,0x50,0x43,0x46
00000c  473d312c          DCB      0x47,0x3d,0x31,0x2c
000010  382c2269          DCB      0x38,0x2c,0x22,0x69
000014  6f742e63          DCB      0x6f,0x74,0x2e,0x63
000018  6f6e736f          DCB      0x6f,0x6e,0x73,0x6f
00001c  6c652e61          DCB      0x6c,0x65,0x2e,0x61
000020  6c697975          DCB      0x6c,0x69,0x79,0x75
000024  6e2e636f          DCB      0x6e,0x2e,0x63,0x6f
000028  6d220d0a          DCB      0x6d,0x22,0x0d,0x0a
00002c  0d0a0000          DCB      0x0d,0x0a,0x00,0x00
                          %        52
000064  41542b43          DCB      0x41,0x54,0x2b,0x43
000068  574a4150          DCB      0x57,0x4a,0x41,0x50
00006c  3d000000          DCB      0x3d,0x00,0x00,0x00
                          %        88
0000c8  41542b4d          DCB      0x41,0x54,0x2b,0x4d
0000cc  51545455          DCB      0x51,0x54,0x54,0x55
0000d0  53455243          DCB      0x53,0x45,0x52,0x43
0000d4  46473d30          DCB      0x46,0x47,0x3d,0x30
0000d8  2c312c22          DCB      0x2c,0x31,0x2c,0x22
0000dc  4e554c4c          DCB      0x4e,0x55,0x4c,0x4c
0000e0  222c2253          DCB      0x22,0x2c,0x22,0x53
0000e4  43333246          DCB      0x43,0x33,0x32,0x46
0000e8  31305453          DCB      0x31,0x30,0x54,0x53
0000ec  38266b32          DCB      0x38,0x26,0x6b,0x32
0000f0  336d364c          DCB      0x33,0x6d,0x36,0x4c
0000f4  414a3056          DCB      0x41,0x4a,0x30,0x56
0000f8  39222c22          DCB      0x39,0x22,0x2c,0x22
0000fc  43324238          DCB      0x43,0x32,0x42,0x38
000100  31463639          DCB      0x31,0x46,0x36,0x39
000104  31463841          DCB      0x31,0x46,0x38,0x41
000108  46433630          DCB      0x46,0x43,0x36,0x30
00010c  33343741          DCB      0x33,0x34,0x37,0x41
000110  37313546          DCB      0x37,0x31,0x35,0x46
000114  30313535          DCB      0x30,0x31,0x35,0x35
000118  44304439          DCB      0x44,0x30,0x44,0x39
00011c  37464146          DCB      0x37,0x46,0x41,0x46
000120  45324643          DCB      0x45,0x32,0x46,0x43
000124  222c302c          DCB      0x22,0x2c,0x30,0x2c
000128  302c2222          DCB      0x30,0x2c,0x22,0x22
00012c  0d0a0d0a          DCB      0x0d,0x0a,0x0d,0x0a
000130  00000000          DCB      0x00,0x00,0x00,0x00
                          %        92
000190  41542b4d          DCB      0x41,0x54,0x2b,0x4d
000194  51545443          DCB      0x51,0x54,0x54,0x43
000198  4c49454e          DCB      0x4c,0x49,0x45,0x4e
00019c  5449443d          DCB      0x54,0x49,0x44,0x3d
0001a0  302c2231          DCB      0x30,0x2c,0x22,0x31
0001a4  32333435          DCB      0x32,0x33,0x34,0x35
0001a8  7c736563          DCB      0x7c,0x73,0x65,0x63
0001ac  7572656d          DCB      0x75,0x72,0x65,0x6d
0001b0  6f64653d          DCB      0x6f,0x64,0x65,0x3d
0001b4  335c2c73          DCB      0x33,0x5c,0x2c,0x73
0001b8  69676e6d          DCB      0x69,0x67,0x6e,0x6d
0001bc  6574686f          DCB      0x65,0x74,0x68,0x6f
0001c0  643d686d          DCB      0x64,0x3d,0x68,0x6d
0001c4  61637368          DCB      0x61,0x63,0x73,0x68
0001c8  61317c22          DCB      0x61,0x31,0x7c,0x22
0001cc  0d0a0d0a          DCB      0x0d,0x0a,0x0d,0x0a
0001d0  00000000          DCB      0x00,0x00,0x00,0x00
                          %        32
0001f4  41542b4d          DCB      0x41,0x54,0x2b,0x4d
0001f8  51545443          DCB      0x51,0x54,0x54,0x43
0001fc  4f4e4e3d          DCB      0x4f,0x4e,0x4e,0x3d
000200  302c226b          DCB      0x30,0x2c,0x22,0x6b
000204  32336d36          DCB      0x32,0x33,0x6d,0x36
000208  4c414a30          DCB      0x4c,0x41,0x4a,0x30
00020c  56392e69          DCB      0x56,0x39,0x2e,0x69
000210  6f742d61          DCB      0x6f,0x74,0x2d,0x61
000214  732d6d71          DCB      0x73,0x2d,0x6d,0x71
000218  74742e63          DCB      0x74,0x74,0x2e,0x63
00021c  6e2d7368          DCB      0x6e,0x2d,0x73,0x68
000220  616e6768          DCB      0x61,0x6e,0x67,0x68
000224  61692e61          DCB      0x61,0x69,0x2e,0x61
000228  6c697975          DCB      0x6c,0x69,0x79,0x75
00022c  6e63732e          DCB      0x6e,0x63,0x73,0x2e
000230  636f6d22          DCB      0x63,0x6f,0x6d,0x22
000234  2c313838          DCB      0x2c,0x31,0x38,0x38
000238  332c310d          DCB      0x33,0x2c,0x31,0x0d
00023c  0a0d0a00          DCB      0x0a,0x0d,0x0a,0x00
                          %        24
000258  41542b4d          DCB      0x41,0x54,0x2b,0x4d
00025c  51545453          DCB      0x51,0x54,0x54,0x53
000260  55423d30          DCB      0x55,0x42,0x3d,0x30
000264  2c222f6b          DCB      0x2c,0x22,0x2f,0x6b
000268  32336d36          DCB      0x32,0x33,0x6d,0x36
00026c  4c414a30          DCB      0x4c,0x41,0x4a,0x30
000270  56392f53          DCB      0x56,0x39,0x2f,0x53
000274  43333246          DCB      0x43,0x33,0x32,0x46
000278  31305453          DCB      0x31,0x30,0x54,0x53
00027c  382f7573          DCB      0x38,0x2f,0x75,0x73
000280  65722f54          DCB      0x65,0x72,0x2f,0x54
000284  65737422          DCB      0x65,0x73,0x74,0x22
000288  2c310d0a          DCB      0x2c,0x31,0x0d,0x0a
00028c  0d0a0000          DCB      0x0d,0x0a,0x00,0x00
                          %        44
0002bc  41542b43          DCB      0x41,0x54,0x2b,0x43
0002c0  4950534e          DCB      0x49,0x50,0x53,0x4e
0002c4  54504346          DCB      0x54,0x50,0x43,0x46
0002c8  473d312c          DCB      0x47,0x3d,0x31,0x2c
0002cc  382c2263          DCB      0x38,0x2c,0x22,0x63
0002d0  6e2e6e74          DCB      0x6e,0x2e,0x6e,0x74
0002d4  702e6f72          DCB      0x70,0x2e,0x6f,0x72
0002d8  672e636e          DCB      0x67,0x2e,0x63,0x6e
0002dc  222c226e          DCB      0x22,0x2c,0x22,0x6e
0002e0  74702e73          DCB      0x74,0x70,0x2e,0x73
0002e4  6a74752e          DCB      0x6a,0x74,0x75,0x2e
0002e8  6564752e          DCB      0x65,0x64,0x75,0x2e
0002ec  636e220d          DCB      0x63,0x6e,0x22,0x0d
0002f0  0a0d0a0d          DCB      0x0a,0x0d,0x0a,0x0d
0002f4  0a000000          DCB      0x0a,0x00,0x00,0x00
                          %        40
000320  41542b43          DCB      0x41,0x54,0x2b,0x43
000324  4950534e          DCB      0x49,0x50,0x53,0x4e
000328  54505449          DCB      0x54,0x50,0x54,0x49
00032c  4d453f0d          DCB      0x4d,0x45,0x3f,0x0d
000330  0a0d0a00          DCB      0x0a,0x0d,0x0a,0x00
                          %        80

                          AREA ||.data||, DATA, ALIGN=2

                  RxIndex
000000  00                DCB      0x00
                  UART_RxComplete
000001  00                DCB      0x00
                  Flag_usart2_receive_OK
000002  00                DCB      0x00
                  Flag_weather_received
000003  00                DCB      0x00
                  Wifi_Init_OK
000004  00                DCB      0x00
                  wait_timeout
000005  000000            DCB      0x00,0x00,0x00
                  year
                          DCD      0x00000000
                  month
                          DCD      0x00000000
                  ||day||
                          DCD      0x00000000
                  hour
                          DCD      0x00000000
                  minute
                          DCD      0x00000000
                  second
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\Mqtt\\Src\\mqtt.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_mqtt_c_3425367c____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___6_mqtt_c_3425367c____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_mqtt_c_3425367c____REVSH|
#line 478
|__asm___6_mqtt_c_3425367c____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
