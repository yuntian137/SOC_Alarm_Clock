; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\adc_iap.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\adc_iap.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\Buzz\Inc -I..\Drivers\TKDriver\C -I..\ADC_IAP\Inc -ID:\keil\ARM\PACK\Keil\SC32F1xxx_DFP\1.0.6\Device\SC32F10xx\FWLib\SC32_Lib\inc -D__MICROLIB -D__UVISION_VERSION=534 -DSC32F10xx -DSC32f10xx --omf_browse=..\output\adc_iap.crf ..\ADC_IAP\Src\ADC_IAP.c]
                          THUMB

                          AREA ||i.adcToVoltage||, CODE, READONLY, ALIGN=2

                  adcToVoltage PROC
;;;24     // 将ADC值转换为电压
;;;25     float adcToVoltage(uint16_t adcValue) {
000000  b5f1              PUSH     {r0,r4-r7,lr}
000002  b082              SUB      sp,sp,#8
;;;26         return (adcValue * REFERENCE_VOLTAGE) / ADC_RESOLUTION;
000004  9802              LDR      r0,[sp,#8]
000006  f7fffffe          BL       __aeabi_ui2d
00000a  4604              MOV      r4,r0
00000c  4a06              LDR      r2,|L1.40|
00000e  4b07              LDR      r3,|L1.44|
000010  f7fffffe          BL       __aeabi_dmul
000014  2200              MOVS     r2,#0
000016  4b06              LDR      r3,|L1.48|
000018  9101              STR      r1,[sp,#4]
00001a  9000              STR      r0,[sp,#0]
00001c  f7fffffe          BL       __aeabi_ddiv
000020  4606              MOV      r6,r0
000022  f7fffffe          BL       __aeabi_d2f
;;;27     }
000026  bdfe              POP      {r1-r7,pc}
;;;28     
                          ENDP

                  |L1.40|
                          DCD      0x33333333
                  |L1.44|
                          DCD      0x40033333
                  |L1.48|
                          DCD      0x40cfff80

                          AREA ||i.checkPowerLoss||, CODE, READONLY, ALIGN=2

                  checkPowerLoss PROC
;;;29     // 检查电源电压是否低于阈值
;;;30     void checkPowerLoss(uint8_t cnt) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
;;;31         uint16_t adcValue = readADC(ADC_CHANNEL);
000004  201f              MOVS     r0,#0x1f
000006  f7fffffe          BL       readADC
00000a  9000              STR      r0,[sp,#0]
;;;32         float voltage = adcToVoltage(adcValue)*4;
00000c  9800              LDR      r0,[sp,#0]
00000e  f7fffffe          BL       adcToVoltage
000012  4605              MOV      r5,r0
000014  2181              MOVS     r1,#0x81
000016  05c9              LSLS     r1,r1,#23
000018  f7fffffe          BL       __aeabi_fmul
00001c  4607              MOV      r7,r0
;;;33         
;;;34         if (voltage < VOLTAGE_THRESHOLD) //如果电压低于4.0V
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       __aeabi_f2d
000024  4605              MOV      r5,r0
000026  2200              MOVS     r2,#0
000028  4b04              LDR      r3,|L2.60|
00002a  f7fffffe          BL       __aeabi_cdcmple
00002e  d204              BCS      |L2.58|
;;;35         {
;;;36             saveAlarmSettings(cnt);//存数据
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       saveAlarmSettings
;;;37             while(1);//防止多次写flash
000036  bf00              NOP      
                  |L2.56|
000038  e7fe              B        |L2.56|
                  |L2.58|
;;;38         }
;;;39     }
00003a  bdf8              POP      {r3-r7,pc}
;;;40     
                          ENDP

                  |L2.60|
                          DCD      0x40100000

                          AREA ||i.eraseFlashPage||, CODE, READONLY, ALIGN=1

                  eraseFlashPage PROC
;;;49     // 擦除Flash页
;;;50     void eraseFlashPage(uint32_t address) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;51         IAP_EraseSector((address - FLASH_BASE) / 512);//擦除地址所在扇区，每个扇区大小为512Byte
000004  2101              MOVS     r1,#1
000006  06c9              LSLS     r1,r1,#27
000008  1a61              SUBS     r1,r4,r1
00000a  0a48              LSRS     r0,r1,#9
00000c  f7fffffe          BL       IAP_EraseSector
;;;52     }
000010  bd10              POP      {r4,pc}
;;;53     
                          ENDP


                          AREA ||i.initIAP||, CODE, READONLY, ALIGN=2

                  initIAP PROC
;;;41     // IAP初始化
;;;42     void initIAP(void) {
000000  b510              PUSH     {r4,lr}
;;;43         // 配置IAP模块
;;;44         IAP_Unlock();//解锁IAP操作
000002  f7fffffe          BL       IAP_Unlock
;;;45         eraseFlashPage(FLASH_USER_ADDR);
000006  4803              LDR      r0,|L4.20|
000008  f7fffffe          BL       eraseFlashPage
;;;46         IAP_WriteCmd(ENABLE);//开启写使能
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       IAP_WriteCmd
;;;47     }
000012  bd10              POP      {r4,pc}
;;;48     
                          ENDP

                  |L4.20|
                          DCD      0x0801fe00

                          AREA ||i.loadAlarmSettings||, CODE, READONLY, ALIGN=2

                  loadAlarmSettings PROC
;;;80     // 读取闹钟设置
;;;81     AlarmSettings loadAlarmSettings(void) {
000000  b508              PUSH     {r3,lr}
;;;82         AlarmSettings settings;
;;;83         readFlash(FLASH_USER_ADDR, (uint8_t*)&settings, sizeof(settings));
000002  2203              MOVS     r2,#3
000004  4669              MOV      r1,sp
000006  4808              LDR      r0,|L5.40|
000008  f7fffffe          BL       readFlash
;;;84         setAlarm(settings.hour, settings.minute, settings.enabled);//导出数据内部处理
00000c  466b              MOV      r3,sp
00000e  789a              LDRB     r2,[r3,#2]
000010  7859              LDRB     r1,[r3,#1]
000012  7818              LDRB     r0,[r3,#0]
000014  f7fffffe          BL       setAlarm
;;;85         return settings;//外部数据处理
000018  466b              MOV      r3,sp
00001a  8819              LDRH     r1,[r3,#0]
00001c  4608              MOV      r0,r1
00001e  7899              LDRB     r1,[r3,#2]
000020  0409              LSLS     r1,r1,#16
000022  4308              ORRS     r0,r0,r1
;;;86     }
000024  bd08              POP      {r3,pc}
;;;87     
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      0x0801fe00

                          AREA ||i.readADC||, CODE, READONLY, ALIGN=2

                  readADC PROC
;;;13     // 读取ADC值
;;;14     uint16_t readADC(ADC_ChannelTypedef channel) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;15         if (channel != 0)//通道可以是零，方便调试故写判断，要用通道0条件改一下即可
000004  2c00              CMP      r4,#0
000006  d003              BEQ      |L6.16|
;;;16         {
;;;17             ADC_SetChannel(ADC, channel);
000008  4621              MOV      r1,r4
00000a  4809              LDR      r0,|L6.48|
00000c  f7fffffe          BL       ADC_SetChannel
                  |L6.16|
;;;18         } 
;;;19         while (ADC_GetFlagStatus(ADC, ADC_Flag_ADCIF) == RESET);
000010  bf00              NOP      
                  |L6.18|
000012  2101              MOVS     r1,#1
000014  4806              LDR      r0,|L6.48|
000016  f7fffffe          BL       ADC_GetFlagStatus
00001a  2800              CMP      r0,#0
00001c  d0f9              BEQ      |L6.18|
;;;20         ADC_ClearFlag(ADC, ADC_Flag_ADCIF);
00001e  2101              MOVS     r1,#1
000020  4803              LDR      r0,|L6.48|
000022  f7fffffe          BL       ADC_ClearFlag
;;;21         return ADC_GetConversionValue(ADC);
000026  4802              LDR      r0,|L6.48|
000028  f7fffffe          BL       ADC_GetConversionValue
;;;22     }
00002c  bd10              POP      {r4,pc}
;;;23     
                          ENDP

00002e  0000              DCW      0x0000
                  |L6.48|
                          DCD      0x40022110

                          AREA ||i.readFlash||, CODE, READONLY, ALIGN=1

                  readFlash PROC
;;;61     // 读取Flash
;;;62     void readFlash(uint32_t address, uint8_t* data, uint32_t length) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;63         for (uint32_t i = 0; i < length; i++) {
000008  2400              MOVS     r4,#0
00000a  e004              B        |L7.22|
                  |L7.12|
;;;64             data[i] = IAP_ReadByte(address + i);
00000c  1928              ADDS     r0,r5,r4
00000e  f7fffffe          BL       IAP_ReadByte
000012  5530              STRB     r0,[r6,r4]
000014  1c64              ADDS     r4,r4,#1              ;63
                  |L7.22|
000016  42bc              CMP      r4,r7                 ;63
000018  d3f8              BCC      |L7.12|
;;;65         }
;;;66     }
00001a  bdf8              POP      {r3-r7,pc}
;;;67     
                          ENDP


                          AREA ||i.saveAlarmSettings||, CODE, READONLY, ALIGN=2

                  saveAlarmSettings PROC
;;;68     // 保存闹钟设置
;;;69     void saveAlarmSettings(uint8_t cnt) {
000000  b538              PUSH     {r3-r5,lr}
000002  4604              MOV      r4,r0
;;;70         AlarmSettings settings_IN = {
000004  4807              LDR      r0,|L8.36|
000006  6800              LDR      r0,[r0,#0]  ; <Data1>
000008  9000              STR      r0,[sp,#0]
00000a  4668              MOV      r0,sp
00000c  7004              STRB     r4,[r0,#0]
;;;71             .hour = cnt,
;;;72             .minute = 30,
;;;73             .enabled = 1
;;;74         };
;;;75         initIAP();//准备IAP
00000e  f7fffffe          BL       initIAP
;;;76         writeFlash(FLASH_USER_ADDR, (uint8_t*)&settings_IN, sizeof(settings_IN));//开写
000012  2203              MOVS     r2,#3
000014  4669              MOV      r1,sp
000016  4804              LDR      r0,|L8.40|
000018  f7fffffe          BL       writeFlash
;;;77         IAP_Lock();//上锁IAP操作，并且复位IAP操作寄存器
00001c  f7fffffe          BL       IAP_Lock
;;;78     }
000020  bd38              POP      {r3-r5,pc}
;;;79     
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      ||.constdata||
                  |L8.40|
                          DCD      0x0801fe00

                          AREA ||i.setAlarm||, CODE, READONLY, ALIGN=1

                  setAlarm PROC
;;;88     // 设置闹钟
;;;89     void setAlarm(uint8_t hour, uint8_t minute, uint8_t enabled) {
000000  4770              BX       lr
;;;90         // 实现闹钟设置逻辑
;;;91     
;;;92     }
                          ENDP


                          AREA ||i.writeFlash||, CODE, READONLY, ALIGN=1

                  writeFlash PROC
;;;54     // 写入Flash
;;;55     void writeFlash(uint32_t address, uint8_t* data, uint32_t length) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;56         for (uint32_t i = 0; i < length; i++) {
000008  2400              MOVS     r4,#0
00000a  e004              B        |L10.22|
                  |L10.12|
;;;57             IAP_ProgramByte(address + i, data[i]);
00000c  5d31              LDRB     r1,[r6,r4]
00000e  1928              ADDS     r0,r5,r4
000010  f7fffffe          BL       IAP_ProgramByte
000014  1c64              ADDS     r4,r4,#1              ;56
                  |L10.22|
000016  42bc              CMP      r4,r7                 ;56
000018  d3f8              BCC      |L10.12|
;;;58         }
;;;59     }
00001a  bdf8              POP      {r3-r7,pc}
;;;60     
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  001e01            DCB      0x00,0x1e,0x01

;*** Start embedded assembler ***

#line 1 "..\\ADC_IAP\\Src\\ADC_IAP.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_ADC_IAP_c_readADC____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___9_ADC_IAP_c_readADC____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_ADC_IAP_c_readADC____REVSH|
#line 478
|__asm___9_ADC_IAP_c_readADC____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
