; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\adc_iap.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\adc_iap.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\Buzz\Inc -I..\Drivers\TKDriver\C -I..\ADC_IAP\Inc -ID:\keil\ARM\PACK\Keil\SC32F1xxx_DFP\1.0.6\Device\SC32F10xx\FWLib\SC32_Lib\inc -D__MICROLIB -D__UVISION_VERSION=534 -DSC32F10xx -DSC32f10xx --omf_browse=..\output\adc_iap.crf ..\ADC_IAP\Src\ADC_IAP.c]
                          THUMB

                          AREA ||i.adcToVoltage||, CODE, READONLY, ALIGN=2

                  adcToVoltage PROC
;;;24     // 将ADC值转换为电压
;;;25     float adcToVoltage(uint16_t adcValue) {
000000  b5f1              PUSH     {r0,r4-r7,lr}
000002  b082              SUB      sp,sp,#8
;;;26         return (adcValue * REFERENCE_VOLTAGE) / ADC_RESOLUTION;
000004  9802              LDR      r0,[sp,#8]
000006  f7fffffe          BL       __aeabi_ui2d
00000a  4604              MOV      r4,r0
00000c  4a06              LDR      r2,|L1.40|
00000e  4b07              LDR      r3,|L1.44|
000010  f7fffffe          BL       __aeabi_dmul
000014  2200              MOVS     r2,#0
000016  4b06              LDR      r3,|L1.48|
000018  9101              STR      r1,[sp,#4]
00001a  9000              STR      r0,[sp,#0]
00001c  f7fffffe          BL       __aeabi_ddiv
000020  4606              MOV      r6,r0
000022  f7fffffe          BL       __aeabi_d2f
;;;27     }
000026  bdfe              POP      {r1-r7,pc}
;;;28     
                          ENDP

                  |L1.40|
                          DCD      0x33333333
                  |L1.44|
                          DCD      0x40033333
                  |L1.48|
                          DCD      0x40cfff80

                          AREA ||i.checkPowerLoss||, CODE, READONLY, ALIGN=2

                  checkPowerLoss PROC
;;;29     // 检查电源电压是否低于阈值
;;;30     void checkPowerLoss(uint8_t cnt) {
000000  b5f8              PUSH     {r3-r7,lr}
;;;31         uint16_t adcValue = readADC(ADC_CHANNEL);
000002  201f              MOVS     r0,#0x1f
000004  f7fffffe          BL       readADC
000008  4606              MOV      r6,r0
;;;32         float voltage = adcToVoltage(adcValue);
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       adcToVoltage
000010  4607              MOV      r7,r0
;;;33         
;;;34         if (voltage < VOLTAGE_THRESHOLD) //如果电压低于1.0V
000012  4638              MOV      r0,r7
000014  f7fffffe          BL       __aeabi_f2d
000018  4604              MOV      r4,r0
00001a  2200              MOVS     r2,#0
00001c  4b04              LDR      r3,|L2.48|
00001e  f7fffffe          BL       __aeabi_cdcmple
000022  d203              BCS      |L2.44|
;;;35         {
;;;36             //saveAlarmSettings(cnt);//存数据
;;;37             initIAP();
000024  f7fffffe          BL       initIAP
;;;38             while(1);
000028  bf00              NOP      
                  |L2.42|
00002a  e7fe              B        |L2.42|
                  |L2.44|
;;;39         }
;;;40         //saveAlarmSettings(cnt);
;;;41         //initIAP();
;;;42         
;;;43     }
00002c  bdf8              POP      {r3-r7,pc}
;;;44     
                          ENDP

00002e  0000              DCW      0x0000
                  |L2.48|
                          DCD      0x40100000

                          AREA ||i.eraseFlashPage||, CODE, READONLY, ALIGN=1

                  eraseFlashPage PROC
;;;57     // 擦除Flash页
;;;58     void eraseFlashPage(uint32_t address) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;59         IAP_EraseSector((address - FLASH_BASE) / 512);//擦除地址所在扇区，每个扇区大小为512Byte
000004  2101              MOVS     r1,#1
000006  06c9              LSLS     r1,r1,#27
000008  1a61              SUBS     r1,r4,r1
00000a  0a48              LSRS     r0,r1,#9
00000c  f7fffffe          BL       IAP_EraseSector
;;;60         //IAP_EraseSector(255);
;;;61     }
000010  bd10              POP      {r4,pc}
;;;62     
                          ENDP


                          AREA ||i.initIAP||, CODE, READONLY, ALIGN=2

                  initIAP PROC
;;;45     // IAP初始化
;;;46     void initIAP(void) {
000000  b510              PUSH     {r4,lr}
;;;47         // 配置IAP模块
;;;48         IAP_Unlock();//解锁IAP操作
000002  f7fffffe          BL       IAP_Unlock
;;;49         IAP_EraseSector((FLASH_USER_ADDR - FLASH_BASE) / 512);//擦除地址所在扇区，每个扇区大小为512Byte
000006  20ff              MOVS     r0,#0xff
000008  f7fffffe          BL       IAP_EraseSector
;;;50        
;;;51         //eraseFlashPage(FLASH_USER_ADDR);
;;;52         IAP_WriteCmd(ENABLE);//开启写使能
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       IAP_WriteCmd
;;;53         IAP_ProgramWord(FLASH_USER_ADDR, 0x12345678);//字写入，目标地址FLASH_USER_ADDR
000012  4903              LDR      r1,|L4.32|
000014  4803              LDR      r0,|L4.36|
000016  f7fffffe          BL       IAP_ProgramWord
;;;54         IAP_Lock();//上锁IAP操作，并且复位IAP操作寄存器
00001a  f7fffffe          BL       IAP_Lock
;;;55     }
00001e  bd10              POP      {r4,pc}
;;;56     
                          ENDP

                  |L4.32|
                          DCD      0x12345678
                  |L4.36|
                          DCD      0x0801fe00

                          AREA ||i.loadAlarmSettings||, CODE, READONLY, ALIGN=2

                  loadAlarmSettings PROC
;;;91     // 读取闹钟设置
;;;92     AlarmSettings loadAlarmSettings(void) {
000000  b538              PUSH     {r3-r5,lr}
;;;93         
;;;94         uint32_t ReadWord = 0;//定义变量存放单字读数据
000002  2400              MOVS     r4,#0
;;;95         AlarmSettings settings;
;;;96         //readFlash(FLASH_USER_ADDR, (uint8_t*)&settings, sizeof(settings));
;;;97         ReadWord = IAP_ReadWord(FLASH_USER_ADDR);//字读，目标地址（0x803FE00）
000004  481e              LDR      r0,|L5.128|
000006  f7fffffe          BL       IAP_ReadWord
00000a  4604              MOV      r4,r0
;;;98             // 实现闹钟设置逻辑
;;;99             // 先关灯
;;;100            GPIO_SetBits(GPIOC, GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_10 | GPIO_Pin_11); // 先关闭所有 LED
00000c  21c3              MOVS     r1,#0xc3
00000e  0109              LSLS     r1,r1,#4
000010  481c              LDR      r0,|L5.132|
000012  f7fffffe          BL       GPIO_SetBits
;;;101            GPIO_SetBits(GPIOA, GPIO_Pin_7 | GPIO_Pin_8);                             // 先关闭所有 LED
000016  21ff              MOVS     r1,#0xff
000018  3181              ADDS     r1,r1,#0x81
00001a  481b              LDR      r0,|L5.136|
00001c  f7fffffe          BL       GPIO_SetBits
;;;102      
;;;103        // 根据 cnt 的值点亮相应数量的 LED
;;;104        if (ReadWord >= 1) 
000020  2c00              CMP      r4,#0
000022  d003              BEQ      |L5.44|
;;;105            GPIO_ResetBits(GPIOC, GPIO_Pin_4); // LED1
000024  2110              MOVS     r1,#0x10
000026  4817              LDR      r0,|L5.132|
000028  f7fffffe          BL       GPIO_ResetBits
                  |L5.44|
;;;106        if (ReadWord >= 2)
00002c  2c02              CMP      r4,#2
00002e  d303              BCC      |L5.56|
;;;107            GPIO_ResetBits(GPIOC, GPIO_Pin_5); // LED2
000030  2120              MOVS     r1,#0x20
000032  4814              LDR      r0,|L5.132|
000034  f7fffffe          BL       GPIO_ResetBits
                  |L5.56|
;;;108        if (ReadWord >= 3)
000038  2c03              CMP      r4,#3
00003a  d304              BCC      |L5.70|
;;;109            GPIO_ResetBits(GPIOC, GPIO_Pin_10); // LED3
00003c  2101              MOVS     r1,#1
00003e  0289              LSLS     r1,r1,#10
000040  4810              LDR      r0,|L5.132|
000042  f7fffffe          BL       GPIO_ResetBits
                  |L5.70|
;;;110        if (ReadWord >= 4)
000046  2c04              CMP      r4,#4
000048  d304              BCC      |L5.84|
;;;111            GPIO_ResetBits(GPIOC, GPIO_Pin_11); // LED4
00004a  2101              MOVS     r1,#1
00004c  02c9              LSLS     r1,r1,#11
00004e  480d              LDR      r0,|L5.132|
000050  f7fffffe          BL       GPIO_ResetBits
                  |L5.84|
;;;112        if (ReadWord >= 5)
000054  2c05              CMP      r4,#5
000056  d303              BCC      |L5.96|
;;;113            GPIO_ResetBits(GPIOA, GPIO_Pin_7); // LED5
000058  2180              MOVS     r1,#0x80
00005a  480b              LDR      r0,|L5.136|
00005c  f7fffffe          BL       GPIO_ResetBits
                  |L5.96|
;;;114        if (ReadWord >= 6)
000060  2c06              CMP      r4,#6
000062  d304              BCC      |L5.110|
;;;115            GPIO_ResetBits(GPIOA, GPIO_Pin_8); // LED6
000064  21ff              MOVS     r1,#0xff
000066  3101              ADDS     r1,#1
000068  4807              LDR      r0,|L5.136|
00006a  f7fffffe          BL       GPIO_ResetBits
                  |L5.110|
;;;116        //setAlarm((uint8_t)ReadWord, settings.minute, settings.enabled);
;;;117        return settings;
00006e  4669              MOV      r1,sp
000070  8809              LDRH     r1,[r1,#0]
000072  4608              MOV      r0,r1
000074  4669              MOV      r1,sp
000076  7889              LDRB     r1,[r1,#2]
000078  0409              LSLS     r1,r1,#16
00007a  4308              ORRS     r0,r0,r1
;;;118    }
00007c  bd38              POP      {r3-r5,pc}
;;;119    
                          ENDP

00007e  0000              DCW      0x0000
                  |L5.128|
                          DCD      0x0801fe00
                  |L5.132|
                          DCD      0x40011200
                  |L5.136|
                          DCD      0x40011000

                          AREA ||i.readADC||, CODE, READONLY, ALIGN=2

                  readADC PROC
;;;13     // 读取ADC值
;;;14     uint16_t readADC(ADC_ChannelTypedef channel) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;15         if (channel != 0)
000004  2c00              CMP      r4,#0
000006  d003              BEQ      |L6.16|
;;;16         {
;;;17             ADC_SetChannel(ADC, channel);
000008  4621              MOV      r1,r4
00000a  4809              LDR      r0,|L6.48|
00000c  f7fffffe          BL       ADC_SetChannel
                  |L6.16|
;;;18         } 
;;;19         while (ADC_GetFlagStatus(ADC, ADC_Flag_ADCIF) == RESET);
000010  bf00              NOP      
                  |L6.18|
000012  2101              MOVS     r1,#1
000014  4806              LDR      r0,|L6.48|
000016  f7fffffe          BL       ADC_GetFlagStatus
00001a  2800              CMP      r0,#0
00001c  d0f9              BEQ      |L6.18|
;;;20         ADC_ClearFlag(ADC, ADC_Flag_ADCIF);
00001e  2101              MOVS     r1,#1
000020  4803              LDR      r0,|L6.48|
000022  f7fffffe          BL       ADC_ClearFlag
;;;21         return ADC_GetConversionValue(ADC);
000026  4802              LDR      r0,|L6.48|
000028  f7fffffe          BL       ADC_GetConversionValue
;;;22     }
00002c  bd10              POP      {r4,pc}
;;;23     
                          ENDP

00002e  0000              DCW      0x0000
                  |L6.48|
                          DCD      0x40022110

                          AREA ||i.readFlash||, CODE, READONLY, ALIGN=1

                  readFlash PROC
;;;70     // 读取Flash
;;;71     void readFlash(uint32_t address, uint8_t* data, uint32_t length) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;72         for (uint32_t i = 0; i < length; i++) {
000008  2400              MOVS     r4,#0
00000a  e004              B        |L7.22|
                  |L7.12|
;;;73             data[i] = IAP_ReadByte(address + i);
00000c  1928              ADDS     r0,r5,r4
00000e  f7fffffe          BL       IAP_ReadByte
000012  5530              STRB     r0,[r6,r4]
000014  1c64              ADDS     r4,r4,#1              ;72
                  |L7.22|
000016  42bc              CMP      r4,r7                 ;72
000018  d3f8              BCC      |L7.12|
;;;74         }
;;;75     }
00001a  bdf8              POP      {r3-r7,pc}
;;;76     
                          ENDP


                          AREA ||i.saveAlarmSettings||, CODE, READONLY, ALIGN=2

                  saveAlarmSettings PROC
;;;77     // 保存闹钟设置
;;;78     void saveAlarmSettings(uint8_t cnt) {
000000  b538              PUSH     {r3-r5,lr}
000002  4604              MOV      r4,r0
;;;79         AlarmSettings settings_IN = {
000004  4806              LDR      r0,|L8.32|
000006  6800              LDR      r0,[r0,#0]  ; <Data1>
000008  9000              STR      r0,[sp,#0]
;;;80             .hour = 7,
;;;81             .minute = 30,
;;;82             .enabled = 1
;;;83         };
;;;84         initIAP();//准备IAP
00000a  f7fffffe          BL       initIAP
;;;85         writeFlash(FLASH_USER_ADDR, (uint8_t*)&settings_IN, sizeof(settings_IN));//开写
00000e  2203              MOVS     r2,#3
000010  4669              MOV      r1,sp
000012  4804              LDR      r0,|L8.36|
000014  f7fffffe          BL       writeFlash
;;;86         //IAP_ProgramByte(FLASH_USER_ADDR, 0x12233);
;;;87         IAP_Lock();//上锁IAP操作，并且复位IAP操作寄存器
000018  f7fffffe          BL       IAP_Lock
;;;88         //loadAlarmSettings();
;;;89     }
00001c  bd38              POP      {r3-r5,pc}
;;;90     
                          ENDP

00001e  0000              DCW      0x0000
                  |L8.32|
                          DCD      ||.constdata||
                  |L8.36|
                          DCD      0x0801fe00

                          AREA ||i.setAlarm||, CODE, READONLY, ALIGN=2

                  setAlarm PROC
;;;121    // 设置闹钟
;;;122    void setAlarm(uint8_t hour, uint8_t minute, uint8_t enabled) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;123        // 实现闹钟设置逻辑
;;;124            // 先关灯
;;;125            GPIO_SetBits(GPIOC, GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_10 | GPIO_Pin_11); // 先关闭所有 LED
000008  21c3              MOVS     r1,#0xc3
00000a  0109              LSLS     r1,r1,#4
00000c  4819              LDR      r0,|L9.116|
00000e  f7fffffe          BL       GPIO_SetBits
;;;126            GPIO_SetBits(GPIOA, GPIO_Pin_7 | GPIO_Pin_8);                             // 先关闭所有 LED
000012  21ff              MOVS     r1,#0xff
000014  3181              ADDS     r1,r1,#0x81
000016  4818              LDR      r0,|L9.120|
000018  f7fffffe          BL       GPIO_SetBits
;;;127      
;;;128        // 根据 cnt 的值点亮相应数量的 LED
;;;129        if (hour >= 1 || minute >= 1|| enabled >= 1) 
00001c  2c01              CMP      r4,#1
00001e  da03              BGE      |L9.40|
000020  2d01              CMP      r5,#1
000022  da01              BGE      |L9.40|
000024  2e01              CMP      r6,#1
000026  db03              BLT      |L9.48|
                  |L9.40|
;;;130            GPIO_ResetBits(GPIOC, GPIO_Pin_4); // LED1
000028  2110              MOVS     r1,#0x10
00002a  4812              LDR      r0,|L9.116|
00002c  f7fffffe          BL       GPIO_ResetBits
                  |L9.48|
;;;131        if (hour >= 2)
000030  2c02              CMP      r4,#2
000032  db03              BLT      |L9.60|
;;;132            GPIO_ResetBits(GPIOC, GPIO_Pin_5); // LED2
000034  2120              MOVS     r1,#0x20
000036  480f              LDR      r0,|L9.116|
000038  f7fffffe          BL       GPIO_ResetBits
                  |L9.60|
;;;133        if (hour >= 3)
00003c  2c03              CMP      r4,#3
00003e  db04              BLT      |L9.74|
;;;134            GPIO_ResetBits(GPIOC, GPIO_Pin_10); // LED3
000040  2101              MOVS     r1,#1
000042  0289              LSLS     r1,r1,#10
000044  480b              LDR      r0,|L9.116|
000046  f7fffffe          BL       GPIO_ResetBits
                  |L9.74|
;;;135        if (hour >= 4)
00004a  2c04              CMP      r4,#4
00004c  db04              BLT      |L9.88|
;;;136            GPIO_ResetBits(GPIOC, GPIO_Pin_11); // LED4
00004e  2101              MOVS     r1,#1
000050  02c9              LSLS     r1,r1,#11
000052  4808              LDR      r0,|L9.116|
000054  f7fffffe          BL       GPIO_ResetBits
                  |L9.88|
;;;137        if (hour >= 5)
000058  2c05              CMP      r4,#5
00005a  db03              BLT      |L9.100|
;;;138            GPIO_ResetBits(GPIOA, GPIO_Pin_7); // LED5
00005c  2180              MOVS     r1,#0x80
00005e  4806              LDR      r0,|L9.120|
000060  f7fffffe          BL       GPIO_ResetBits
                  |L9.100|
;;;139        if (hour >= 6)
000064  2c06              CMP      r4,#6
000066  db04              BLT      |L9.114|
;;;140            GPIO_ResetBits(GPIOA, GPIO_Pin_8); // LED6
000068  21ff              MOVS     r1,#0xff
00006a  3101              ADDS     r1,#1
00006c  4802              LDR      r0,|L9.120|
00006e  f7fffffe          BL       GPIO_ResetBits
                  |L9.114|
;;;141    }
000072  bd70              POP      {r4-r6,pc}
                          ENDP

                  |L9.116|
                          DCD      0x40011200
                  |L9.120|
                          DCD      0x40011000

                          AREA ||i.writeFlash||, CODE, READONLY, ALIGN=1

                  writeFlash PROC
;;;63     // 写入Flash
;;;64     void writeFlash(uint32_t address, uint8_t* data, uint32_t length) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;65         for (uint32_t i = 0; i < length; i++) {
000008  2400              MOVS     r4,#0
00000a  e004              B        |L10.22|
                  |L10.12|
;;;66             IAP_ProgramByte(address + i, data[i]);
00000c  5d31              LDRB     r1,[r6,r4]
00000e  1928              ADDS     r0,r5,r4
000010  f7fffffe          BL       IAP_ProgramByte
000014  1c64              ADDS     r4,r4,#1              ;65
                  |L10.22|
000016  42bc              CMP      r4,r7                 ;65
000018  d3f8              BCC      |L10.12|
;;;67         }
;;;68     }
00001a  bdf8              POP      {r3-r7,pc}
;;;69     
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  071e01            DCB      0x07,0x1e,0x01

                          AREA ||.data||, DATA, ALIGN=2

                  cnt01
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\ADC_IAP\\Src\\ADC_IAP.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_ADC_IAP_c_readADC____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___9_ADC_IAP_c_readADC____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_ADC_IAP_c_readADC____REVSH|
#line 478
|__asm___9_ADC_IAP_c_readADC____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
