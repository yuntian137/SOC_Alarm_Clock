; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\adc_iap.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\adc_iap.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\Buzz\Inc -I..\Drivers\TKDriver\C -I..\ADC_IAP\Inc -ID:\keil\ARM\PACK\Keil\SC32F1xxx_DFP\1.0.6\Device\SC32F10xx\FWLib\SC32_Lib\inc -D__MICROLIB -D__UVISION_VERSION=534 -DSC32F10xx -DSC32f10xx --omf_browse=..\output\adc_iap.crf ..\ADC_IAP\Src\ADC_IAP.c]
                          THUMB

                          AREA ||i.adcToVoltage||, CODE, READONLY, ALIGN=2

                  adcToVoltage PROC
;;;25     // 将ADC值转换为电压
;;;26     float adcToVoltage(uint16_t adcValue) {
000000  b5f1              PUSH     {r0,r4-r7,lr}
000002  b082              SUB      sp,sp,#8
;;;27         return (adcValue * REFERENCE_VOLTAGE) / ADC_RESOLUTION;
000004  9802              LDR      r0,[sp,#8]
000006  f7fffffe          BL       __aeabi_ui2d
00000a  4604              MOV      r4,r0
00000c  2200              MOVS     r2,#0
00000e  4b06              LDR      r3,|L1.40|
000010  f7fffffe          BL       __aeabi_dmul
000014  2200              MOVS     r2,#0
000016  4b05              LDR      r3,|L1.44|
000018  9101              STR      r1,[sp,#4]
00001a  9000              STR      r0,[sp,#0]
00001c  f7fffffe          BL       __aeabi_ddiv
000020  4606              MOV      r6,r0
000022  f7fffffe          BL       __aeabi_d2f
;;;28     }
000026  bdfe              POP      {r1-r7,pc}
;;;29     
                          ENDP

                  |L1.40|
                          DCD      0x40140000
                  |L1.44|
                          DCD      0x40cfff80

                          AREA ||i.checkPowerLoss||, CODE, READONLY, ALIGN=2

                  checkPowerLoss PROC
;;;30     // 检查电源电压是否低于阈值
;;;31     void checkPowerLoss(void) {
000000  b5f8              PUSH     {r3-r7,lr}
;;;32         uint16_t adcValue = readADC(ADC_CHANNEL);
000002  200d              MOVS     r0,#0xd
000004  f7fffffe          BL       readADC
000008  4606              MOV      r6,r0
;;;33         float voltage = adcToVoltage(adcValue);
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       adcToVoltage
000010  4607              MOV      r7,r0
;;;34     
;;;35         if (voltage < VOLTAGE_THRESHOLD) {
000012  4638              MOV      r0,r7
000014  f7fffffe          BL       __aeabi_f2d
000018  4604              MOV      r4,r0
00001a  2200              MOVS     r2,#0
00001c  4b03              LDR      r3,|L2.44|
00001e  f7fffffe          BL       __aeabi_cdcmple
000022  d201              BCS      |L2.40|
;;;36             saveAlarmSettings();
000024  f7fffffe          BL       saveAlarmSettings
                  |L2.40|
;;;37         }
;;;38     }
000028  bdf8              POP      {r3-r7,pc}
;;;39     
                          ENDP

00002a  0000              DCW      0x0000
                  |L2.44|
                          DCD      0x40120000

                          AREA ||i.eraseFlashPage||, CODE, READONLY, ALIGN=1

                  eraseFlashPage PROC
;;;48     // 擦除Flash页
;;;49     void eraseFlashPage(uint32_t address) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;50         IAP_EraseSector((address - FLASH_BASE) / 512);//擦除地址所在扇区，每个扇区大小为512Byte
000004  2101              MOVS     r1,#1
000006  06c9              LSLS     r1,r1,#27
000008  1a61              SUBS     r1,r4,r1
00000a  0a48              LSRS     r0,r1,#9
00000c  f7fffffe          BL       IAP_EraseSector
;;;51     }
000010  bd10              POP      {r4,pc}
;;;52     
                          ENDP


                          AREA ||i.initIAP||, CODE, READONLY, ALIGN=2

                  initIAP PROC
;;;40     // IAP初始化
;;;41     void initIAP(void) {
000000  b510              PUSH     {r4,lr}
;;;42         // 配置IAP模块
;;;43         IAP_Unlock();//解锁IAP操作
000002  f7fffffe          BL       IAP_Unlock
;;;44         eraseFlashPage(FLASH_USER_ADDR);
000006  4803              LDR      r0,|L4.20|
000008  f7fffffe          BL       eraseFlashPage
;;;45         IAP_WriteCmd(ENABLE);//开启写使能
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       IAP_WriteCmd
;;;46     }
000012  bd10              POP      {r4,pc}
;;;47     
                          ENDP

                  |L4.20|
                          DCD      0x0801fe00

                          AREA ||i.loadAlarmSettings||, CODE, READONLY, ALIGN=2

                  loadAlarmSettings PROC
;;;79     // 读取闹钟设置
;;;80     AlarmSettings loadAlarmSettings(void) {
000000  b508              PUSH     {r3,lr}
;;;81         AlarmSettings settings;
;;;82         readFlash(FLASH_USER_ADDR, (uint8_t*)&settings, sizeof(settings));
000002  2203              MOVS     r2,#3
000004  4669              MOV      r1,sp
000006  4808              LDR      r0,|L5.40|
000008  f7fffffe          BL       readFlash
;;;83     
;;;84         setAlarm(settings.hour, settings.minute, settings.enabled);
00000c  466b              MOV      r3,sp
00000e  789a              LDRB     r2,[r3,#2]
000010  7859              LDRB     r1,[r3,#1]
000012  7818              LDRB     r0,[r3,#0]
000014  f7fffffe          BL       setAlarm
;;;85         return settings;
000018  466b              MOV      r3,sp
00001a  8819              LDRH     r1,[r3,#0]
00001c  4608              MOV      r0,r1
00001e  7899              LDRB     r1,[r3,#2]
000020  0409              LSLS     r1,r1,#16
000022  4308              ORRS     r0,r0,r1
;;;86     }
000024  bd08              POP      {r3,pc}
;;;87     
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      0x0801fe00

                          AREA ||i.readADC||, CODE, READONLY, ALIGN=2

                  readADC PROC
;;;13     // 读取ADC值
;;;14     uint16_t readADC(ADC_ChannelTypedef channel) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;15         if (channel != 0)
000004  2c00              CMP      r4,#0
000006  d003              BEQ      |L6.16|
;;;16         {
;;;17             ADC_SetChannel(ADC, channel);
000008  4621              MOV      r1,r4
00000a  480a              LDR      r0,|L6.52|
00000c  f7fffffe          BL       ADC_SetChannel
                  |L6.16|
;;;18         } 
;;;19         ADC_SoftwareStartConv(ADC);
000010  4808              LDR      r0,|L6.52|
000012  f7fffffe          BL       ADC_SoftwareStartConv
;;;20         while (ADC_GetFlagStatus(ADC, ADC_Flag_ADCIF) == RESET);
000016  bf00              NOP      
                  |L6.24|
000018  2101              MOVS     r1,#1
00001a  4806              LDR      r0,|L6.52|
00001c  f7fffffe          BL       ADC_GetFlagStatus
000020  2800              CMP      r0,#0
000022  d0f9              BEQ      |L6.24|
;;;21         ADC_ClearFlag(ADC, ADC_Flag_ADCIF);
000024  2101              MOVS     r1,#1
000026  4803              LDR      r0,|L6.52|
000028  f7fffffe          BL       ADC_ClearFlag
;;;22         return ADC_GetConversionValue(ADC);
00002c  4801              LDR      r0,|L6.52|
00002e  f7fffffe          BL       ADC_GetConversionValue
;;;23     }
000032  bd10              POP      {r4,pc}
;;;24     
                          ENDP

                  |L6.52|
                          DCD      0x40022110

                          AREA ||i.readFlash||, CODE, READONLY, ALIGN=1

                  readFlash PROC
;;;60     // 读取Flash
;;;61     void readFlash(uint32_t address, uint8_t* data, uint32_t length) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;62         for (uint32_t i = 0; i < length; i++) {
000008  2400              MOVS     r4,#0
00000a  e004              B        |L7.22|
                  |L7.12|
;;;63             data[i] = IAP_ReadByte(address + i);
00000c  1928              ADDS     r0,r5,r4
00000e  f7fffffe          BL       IAP_ReadByte
000012  5530              STRB     r0,[r6,r4]
000014  1c64              ADDS     r4,r4,#1              ;62
                  |L7.22|
000016  42bc              CMP      r4,r7                 ;62
000018  d3f8              BCC      |L7.12|
;;;64         }
;;;65     }
00001a  bdf8              POP      {r3-r7,pc}
;;;66     
                          ENDP


                          AREA ||i.saveAlarmSettings||, CODE, READONLY, ALIGN=2

                  saveAlarmSettings PROC
;;;67     // 保存闹钟设置
;;;68     void saveAlarmSettings(void) {
000000  b508              PUSH     {r3,lr}
;;;69         AlarmSettings settings = {
000002  4806              LDR      r0,|L8.28|
000004  6800              LDR      r0,[r0,#0]  ; <Data1>
000006  9000              STR      r0,[sp,#0]
;;;70             .hour = 7,
;;;71             .minute = 30,
;;;72             .enabled = 1
;;;73         };
;;;74         initIAP();//准备IAP
000008  f7fffffe          BL       initIAP
;;;75         writeFlash(FLASH_USER_ADDR, (uint8_t*)&settings, sizeof(settings));//开写
00000c  2203              MOVS     r2,#3
00000e  4669              MOV      r1,sp
000010  4803              LDR      r0,|L8.32|
000012  f7fffffe          BL       writeFlash
;;;76         IAP_Lock();//上锁IAP操作，并且复位IAP操作寄存器
000016  f7fffffe          BL       IAP_Lock
;;;77     }
00001a  bd08              POP      {r3,pc}
;;;78     
                          ENDP

                  |L8.28|
                          DCD      ||.constdata||
                  |L8.32|
                          DCD      0x0801fe00

                          AREA ||i.setAlarm||, CODE, READONLY, ALIGN=1

                  setAlarm PROC
;;;88     // 设置闹钟
;;;89     void setAlarm(uint8_t hour, uint8_t minute, uint8_t enabled) {
000000  4770              BX       lr
;;;90         // 实现闹钟设置逻辑
;;;91         
;;;92     }
                          ENDP


                          AREA ||i.writeFlash||, CODE, READONLY, ALIGN=1

                  writeFlash PROC
;;;53     // 写入Flash
;;;54     void writeFlash(uint32_t address, uint8_t* data, uint32_t length) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;55         for (uint32_t i = 0; i < length; i++) {
000008  2400              MOVS     r4,#0
00000a  e004              B        |L10.22|
                  |L10.12|
;;;56             IAP_ProgramByte(address + i, data[i]);
00000c  5d31              LDRB     r1,[r6,r4]
00000e  1928              ADDS     r0,r5,r4
000010  f7fffffe          BL       IAP_ProgramByte
000014  1c64              ADDS     r4,r4,#1              ;55
                  |L10.22|
000016  42bc              CMP      r4,r7                 ;55
000018  d3f8              BCC      |L10.12|
;;;57         }
;;;58     }
00001a  bdf8              POP      {r3-r7,pc}
;;;59     
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  071e01            DCB      0x07,0x1e,0x01

;*** Start embedded assembler ***

#line 1 "..\\ADC_IAP\\Src\\ADC_IAP.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_ADC_IAP_c_readADC____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___9_ADC_IAP_c_readADC____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_ADC_IAP_c_readADC____REVSH|
#line 478
|__asm___9_ADC_IAP_c_readADC____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
