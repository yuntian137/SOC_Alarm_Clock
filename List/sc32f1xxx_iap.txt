; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\sc32f1xxx_iap.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\sc32f1xxx_iap.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\Buzz\Inc -I..\Drivers\TKDriver\C -I..\ADC_IAP\Inc -ID:\keil\ARM\PACK\Keil\SC32F1xxx_DFP\1.0.6\Device\SC32F10xx\FWLib\SC32_Lib\inc -D__MICROLIB -D__UVISION_VERSION=534 -DSC32F10xx -DSC32f10xx --omf_browse=..\output\sc32f1xxx_iap.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_iap.c]
                          THUMB

                          AREA ||i.IAP_EraseSector||, CODE, READONLY, ALIGN=2

                  IAP_EraseSector PROC
;;;107      */
;;;108    void IAP_EraseSector ( uint32_t IAP_Sector )
000000  4601              MOV      r1,r0
;;;109    {
;;;110        uint32_t tmpreg;
;;;111        IAP->IAP_SNB = 0x4C000000 | IAP_Sector;
000002  2213              MOVS     r2,#0x13
000004  0692              LSLS     r2,r2,#26
000006  430a              ORRS     r2,r2,r1
000008  4b08              LDR      r3,|L1.44|
00000a  605a              STR      r2,[r3,#4]
;;;112        tmpreg = IAP->IAP_CON;
00000c  461a              MOV      r2,r3
00000e  68d0              LDR      r0,[r2,#0xc]
;;;113        tmpreg &= ( uint32_t ) ~ ( IAP_CON_ERASE | IAP_CON_CMD | IAP_CON_PRG );
000010  2393              MOVS     r3,#0x93
000012  4602              MOV      r2,r0
000014  439a              BICS     r2,r2,r3
000016  4610              MOV      r0,r2
;;;114        tmpreg |= ( uint32_t ) ( IAP_CON_SERASE );
000018  2220              MOVS     r2,#0x20
00001a  4310              ORRS     r0,r0,r2
;;;115        IAP->IAP_CON = tmpreg;
00001c  4a03              LDR      r2,|L1.44|
00001e  60d0              STR      r0,[r2,#0xc]
;;;116        IAP->IAP_CON |= ( 0x02 << IAP_CON_CMD_Pos );
000020  68d2              LDR      r2,[r2,#0xc]
000022  2302              MOVS     r3,#2
000024  431a              ORRS     r2,r2,r3
000026  4b01              LDR      r3,|L1.44|
000028  60da              STR      r2,[r3,#0xc]
;;;117        //IAP->IAP_CON = 0x22;
;;;118    }
00002a  4770              BX       lr
;;;119    
                          ENDP

                  |L1.44|
                          DCD      0x400003c0

                          AREA ||i.IAP_Lock||, CODE, READONLY, ALIGN=2

                  IAP_Lock PROC
;;;71       */
;;;72     void IAP_Lock ( void )
000000  2001              MOVS     r0,#1
;;;73     {
;;;74         /* Set the LOCK Bit to lock the FLASH Registers access */
;;;75         IAP->IAP_CON = ( uint32_t ) IAP_CON_LOCK;
000002  07c0              LSLS     r0,r0,#31
000004  4901              LDR      r1,|L2.12|
000006  60c8              STR      r0,[r1,#0xc]
;;;76     }
000008  4770              BX       lr
;;;77     
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      0x400003c0

                          AREA ||i.IAP_ProgramByte||, CODE, READONLY, ALIGN=1

                  IAP_ProgramByte PROC
;;;190      */
;;;191    boolType IAP_ProgramByte ( uint32_t Address, uint8_t Data )
000000  4602              MOV      r2,r0
;;;192    {
;;;193        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;194    
;;;195        * ( uint8_t* ) Address = Data;
000002  7011              STRB     r1,[r2,#0]
;;;196        if ( Data == * ( uint8_t * ) Address )
000004  7810              LDRB     r0,[r2,#0]
000006  4288              CMP      r0,r1
000008  d101              BNE      |L3.14|
;;;197            return TRUE;
00000a  2001              MOVS     r0,#1
                  |L3.12|
;;;198        else
;;;199            return FALSE;
;;;200    }
00000c  4770              BX       lr
                  |L3.14|
00000e  2000              MOVS     r0,#0                 ;199
000010  e7fc              B        |L3.12|
;;;201    #elif defined (SC32f12xx)
                          ENDP


                          AREA ||i.IAP_ProgramByteArray||, CODE, READONLY, ALIGN=1

                  IAP_ProgramByteArray PROC
;;;424      */
;;;425    uint8_t IAP_ProgramByteArray ( uint32_t Address, uint8_t* ByteArray, uint16_t ArraySize )
000000  b530              PUSH     {r4,r5,lr}
;;;426    {
000002  4603              MOV      r3,r0
;;;427        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;428    
;;;429        uint8_t tmpCnt = 0;
000004  2000              MOVS     r0,#0
;;;430        do
000006  bf00              NOP      
                  |L4.8|
;;;431        {
;;;432            * ( __IO uint8_t* ) Address = ByteArray[tmpCnt];
000008  5c0c              LDRB     r4,[r1,r0]
00000a  701c              STRB     r4,[r3,#0]
;;;433    
;;;434            if ( ByteArray[tmpCnt] != * ( __IO uint8_t * ) Address )
00000c  5c0c              LDRB     r4,[r1,r0]
00000e  781d              LDRB     r5,[r3,#0]
000010  42ac              CMP      r4,r5
000012  d000              BEQ      |L4.22|
;;;435                break;
000014  e005              B        |L4.34|
                  |L4.22|
;;;436    
;;;437            Address = Address + 1;
000016  1c5b              ADDS     r3,r3,#1
;;;438    
;;;439        } while ( ++tmpCnt < ArraySize );
000018  1c44              ADDS     r4,r0,#1
00001a  b2e4              UXTB     r4,r4
00001c  4620              MOV      r0,r4
00001e  4294              CMP      r4,r2
000020  dbf2              BLT      |L4.8|
                  |L4.34|
000022  bf00              NOP                            ;435
;;;440    
;;;441        return tmpCnt;
;;;442    }
000024  bd30              POP      {r4,r5,pc}
;;;443    
                          ENDP


                          AREA ||i.IAP_ProgramHalfWord||, CODE, READONLY, ALIGN=1

                  IAP_ProgramHalfWord PROC
;;;170      */
;;;171    boolType IAP_ProgramHalfWord ( uint32_t Address, uint16_t Data )
000000  4602              MOV      r2,r0
;;;172    {
;;;173        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;174    
;;;175        * ( __IO uint16_t* ) Address = Data;
000002  8011              STRH     r1,[r2,#0]
;;;176        if ( Data == * ( __IO uint16_t * ) Address )
000004  8810              LDRH     r0,[r2,#0]
000006  4288              CMP      r0,r1
000008  d101              BNE      |L5.14|
;;;177            return TRUE;
00000a  2001              MOVS     r0,#1
                  |L5.12|
;;;178        else
;;;179            return FALSE;
;;;180    }
00000c  4770              BX       lr
                  |L5.14|
00000e  2000              MOVS     r0,#0                 ;179
000010  e7fc              B        |L5.12|
;;;181    
                          ENDP


                          AREA ||i.IAP_ProgramHalfWordArray||, CODE, READONLY, ALIGN=1

                  IAP_ProgramHalfWordArray PROC
;;;394    
;;;395    uint8_t IAP_ProgramHalfWordArray ( uint32_t Address, uint16_t* ByteArray, uint16_t ArraySize )
000000  b530              PUSH     {r4,r5,lr}
;;;396    {
000002  4603              MOV      r3,r0
;;;397        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;398    
;;;399        uint8_t tmpCnt = 0;
000004  2000              MOVS     r0,#0
;;;400        if ( ( Address & 0x01 ) == 0 )
000006  07dc              LSLS     r4,r3,#31
000008  0fe4              LSRS     r4,r4,#31
00000a  2c00              CMP      r4,#0
00000c  d110              BNE      |L6.48|
;;;401        {
;;;402            do
00000e  bf00              NOP      
                  |L6.16|
;;;403            {
;;;404    
;;;405                * ( __IO uint16_t* ) Address = ByteArray[tmpCnt];
000010  0044              LSLS     r4,r0,#1
000012  5b0c              LDRH     r4,[r1,r4]
000014  801c              STRH     r4,[r3,#0]
;;;406    
;;;407                if ( ByteArray[tmpCnt] != * ( __IO uint16_t * ) Address )
000016  0044              LSLS     r4,r0,#1
000018  5b0c              LDRH     r4,[r1,r4]
00001a  881d              LDRH     r5,[r3,#0]
00001c  42ac              CMP      r4,r5
00001e  d000              BEQ      |L6.34|
;;;408                    break;
000020  e005              B        |L6.46|
                  |L6.34|
;;;409    
;;;410                Address = Address + 2;
000022  1c9b              ADDS     r3,r3,#2
;;;411    
;;;412            } while ( ++tmpCnt < ArraySize );
000024  1c44              ADDS     r4,r0,#1
000026  b2e4              UXTB     r4,r4
000028  4620              MOV      r0,r4
00002a  4294              CMP      r4,r2
00002c  dbf0              BLT      |L6.16|
                  |L6.46|
00002e  bf00              NOP                            ;408
                  |L6.48|
;;;413        }
;;;414        return tmpCnt;
;;;415    }
000030  bd30              POP      {r4,r5,pc}
;;;416    
                          ENDP


                          AREA ||i.IAP_ProgramWord||, CODE, READONLY, ALIGN=1

                  IAP_ProgramWord PROC
;;;149      */
;;;150    boolType IAP_ProgramWord ( uint32_t Address, uint32_t Data )
000000  4602              MOV      r2,r0
;;;151    {
;;;152        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;153    
;;;154        * ( __IO uint32_t* ) Address = Data;
000002  6011              STR      r1,[r2,#0]
;;;155        if ( Data == * ( __IO uint32_t * ) Address )
000004  6810              LDR      r0,[r2,#0]
000006  4288              CMP      r0,r1
000008  d101              BNE      |L7.14|
;;;156            return TRUE;
00000a  2001              MOVS     r0,#1
                  |L7.12|
;;;157        else
;;;158            return FALSE;
;;;159    
;;;160    }
00000c  4770              BX       lr
                  |L7.14|
00000e  2000              MOVS     r0,#0                 ;158
000010  e7fc              B        |L7.12|
;;;161    #if defined (SC32f10xx) || defined(SC32f11xx)|| defined(SC32f15xx)
                          ENDP


                          AREA ||i.IAP_ProgramWordArray||, CODE, READONLY, ALIGN=1

                  IAP_ProgramWordArray PROC
;;;362      */
;;;363    uint8_t IAP_ProgramWordArray ( uint32_t Address, uint32_t* ByteArray, uint16_t ArraySize )
000000  b530              PUSH     {r4,r5,lr}
;;;364    {
000002  4603              MOV      r3,r0
;;;365        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;366    
;;;367        uint8_t tmpCnt = 0;
000004  2000              MOVS     r0,#0
;;;368    
;;;369        if ( ( Address & 0x03 ) == 0 )
000006  079c              LSLS     r4,r3,#30
000008  0fa4              LSRS     r4,r4,#30
00000a  2c00              CMP      r4,#0
00000c  d110              BNE      |L8.48|
;;;370        {
;;;371            do
00000e  bf00              NOP      
                  |L8.16|
;;;372            {
;;;373                * ( __IO uint32_t* ) Address = ByteArray[tmpCnt];
000010  0084              LSLS     r4,r0,#2
000012  590c              LDR      r4,[r1,r4]
000014  601c              STR      r4,[r3,#0]
;;;374    
;;;375                if ( ByteArray[tmpCnt] != * ( __IO uint32_t * ) Address )
000016  0084              LSLS     r4,r0,#2
000018  590c              LDR      r4,[r1,r4]
00001a  681d              LDR      r5,[r3,#0]
00001c  42ac              CMP      r4,r5
00001e  d000              BEQ      |L8.34|
;;;376                    break;
000020  e005              B        |L8.46|
                  |L8.34|
;;;377    
;;;378                Address = Address + 4;
000022  1d1b              ADDS     r3,r3,#4
;;;379    
;;;380            } while ( ++tmpCnt < ArraySize );
000024  1c44              ADDS     r4,r0,#1
000026  b2e4              UXTB     r4,r4
000028  4620              MOV      r0,r4
00002a  4294              CMP      r4,r2
00002c  dbf0              BLT      |L8.16|
                  |L8.46|
00002e  bf00              NOP                            ;376
                  |L8.48|
;;;381        }
;;;382        return tmpCnt;
;;;383    
;;;384    }
000030  bd30              POP      {r4,r5,pc}
;;;385    #if defined(SC32f10xx) || defined(SC32f11xx) || defined(SC32f15xx)
                          ENDP


                          AREA ||i.IAP_ReadByte||, CODE, READONLY, ALIGN=1

                  IAP_ReadByte PROC
;;;345      */
;;;346    uint8_t IAP_ReadByte ( uint32_t Address )
000000  4601              MOV      r1,r0
;;;347    {
;;;348        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;349    
;;;350        uint8_t Data;
;;;351        Data = * ( uint8_t* ) Address;
000002  7808              LDRB     r0,[r1,#0]
;;;352        return Data;
;;;353    }
000004  4770              BX       lr
;;;354    
                          ENDP


                          AREA ||i.IAP_ReadByteArray||, CODE, READONLY, ALIGN=1

                  IAP_ReadByteArray PROC
;;;502      */
;;;503    uint8_t IAP_ReadByteArray ( uint32_t Address, uint8_t* ByteArray, uint16_t ArraySize )
000000  b510              PUSH     {r4,lr}
;;;504    {
000002  4603              MOV      r3,r0
;;;505        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;506    
;;;507        uint8_t tmpCnt = 0;
000004  2000              MOVS     r0,#0
;;;508        do
000006  bf00              NOP      
                  |L10.8|
;;;509        {
;;;510            ByteArray[tmpCnt] = * ( __IO uint8_t* ) Address;
000008  781c              LDRB     r4,[r3,#0]
00000a  540c              STRB     r4,[r1,r0]
;;;511            Address = Address + 1;
00000c  1c5b              ADDS     r3,r3,#1
;;;512    
;;;513        } while ( ++tmpCnt < ArraySize );
00000e  1c44              ADDS     r4,r0,#1
000010  b2e4              UXTB     r4,r4
000012  4620              MOV      r0,r4
000014  4294              CMP      r4,r2
000016  dbf7              BLT      |L10.8|
;;;514    
;;;515        return tmpCnt;
;;;516    }
000018  bd10              POP      {r4,pc}
;;;517    
                          ENDP


                          AREA ||i.IAP_ReadHalfWord||, CODE, READONLY, ALIGN=1

                  IAP_ReadHalfWord PROC
;;;330      */
;;;331    uint16_t IAP_ReadHalfWord ( uint32_t Address )
000000  4601              MOV      r1,r0
;;;332    {
;;;333        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;334    
;;;335        uint16_t Data;
;;;336        Data = * ( __IO uint16_t* ) Address;
000002  8808              LDRH     r0,[r1,#0]
;;;337        return Data;
;;;338    }
000004  4770              BX       lr
;;;339    
                          ENDP


                          AREA ||i.IAP_ReadHalfWordArray||, CODE, READONLY, ALIGN=1

                  IAP_ReadHalfWordArray PROC
;;;477      */
;;;478    uint8_t IAP_ReadHalfWordArray ( uint32_t Address, uint16_t* ByteArray, uint16_t ArraySize )
000000  b530              PUSH     {r4,r5,lr}
;;;479    {
000002  4603              MOV      r3,r0
;;;480        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;481    
;;;482        uint8_t tmpCnt = 0;
000004  2000              MOVS     r0,#0
;;;483        if ( ( Address & 0x01 ) == 0 )
000006  07dc              LSLS     r4,r3,#31
000008  0fe4              LSRS     r4,r4,#31
00000a  2c00              CMP      r4,#0
00000c  d109              BNE      |L12.34|
;;;484        {
;;;485            do
00000e  bf00              NOP      
                  |L12.16|
;;;486            {
;;;487                ByteArray[tmpCnt] = * ( __IO uint16_t* ) Address;
000010  881c              LDRH     r4,[r3,#0]
000012  0045              LSLS     r5,r0,#1
000014  534c              STRH     r4,[r1,r5]
;;;488                Address = Address + 2;
000016  1c9b              ADDS     r3,r3,#2
;;;489    
;;;490            } while ( ++tmpCnt < ArraySize );
000018  1c44              ADDS     r4,r0,#1
00001a  b2e4              UXTB     r4,r4
00001c  4620              MOV      r0,r4
00001e  4294              CMP      r4,r2
000020  dbf6              BLT      |L12.16|
                  |L12.34|
;;;491        }
;;;492        return tmpCnt;
;;;493    }
000022  bd30              POP      {r4,r5,pc}
;;;494    
                          ENDP


                          AREA ||i.IAP_ReadWord||, CODE, READONLY, ALIGN=1

                  IAP_ReadWord PROC
;;;315      */
;;;316    uint32_t IAP_ReadWord ( uint32_t Address )
000000  4601              MOV      r1,r0
;;;317    {
;;;318        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;319    
;;;320        uint32_t Data;
;;;321        Data = * ( __IO uint32_t* ) Address;
000002  6808              LDR      r0,[r1,#0]
;;;322        return Data;
;;;323    }
000004  4770              BX       lr
;;;324    
                          ENDP


                          AREA ||i.IAP_ReadWordArray||, CODE, READONLY, ALIGN=1

                  IAP_ReadWordArray PROC
;;;452      */
;;;453    uint8_t IAP_ReadWordArray ( uint32_t Address, uint32_t* ByteArray, uint16_t ArraySize )
000000  b530              PUSH     {r4,r5,lr}
;;;454    {
000002  4603              MOV      r3,r0
;;;455        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;456    
;;;457        uint8_t tmpCnt = 0;
000004  2000              MOVS     r0,#0
;;;458        if ( ( Address & 0x03 ) == 0 )
000006  079c              LSLS     r4,r3,#30
000008  0fa4              LSRS     r4,r4,#30
00000a  2c00              CMP      r4,#0
00000c  d109              BNE      |L14.34|
;;;459        {
;;;460            do
00000e  bf00              NOP      
                  |L14.16|
;;;461            {
;;;462                ByteArray[tmpCnt] = * ( __IO uint32_t* ) Address;
000010  681c              LDR      r4,[r3,#0]
000012  0085              LSLS     r5,r0,#2
000014  514c              STR      r4,[r1,r5]
;;;463                Address = Address + 4;
000016  1d1b              ADDS     r3,r3,#4
;;;464    
;;;465            } while ( ++tmpCnt < ArraySize );
000018  1c44              ADDS     r4,r0,#1
00001a  b2e4              UXTB     r4,r4
00001c  4620              MOV      r0,r4
00001e  4294              CMP      r4,r2
000020  dbf6              BLT      |L14.16|
                  |L14.34|
;;;466        }
;;;467        return tmpCnt;
;;;468    }
000022  bd30              POP      {r4,r5,pc}
;;;469    
                          ENDP


                          AREA ||i.IAP_SoftwareReset||, CODE, READONLY, ALIGN=2

                  IAP_SoftwareReset PROC
;;;541      */
;;;542    void IAP_SoftwareReset ( IAP_BTLD_TypeDef IAP_BTLDType )
000000  21ff              MOVS     r1,#0xff
;;;543    {
;;;544        IAP->IAP_CON = ( IAP_BTLDType | IAP_CON_RST );
000002  3101              ADDS     r1,#1
000004  4301              ORRS     r1,r1,r0
000006  4a01              LDR      r2,|L15.12|
000008  60d1              STR      r1,[r2,#0xc]
;;;545    }
00000a  4770              BX       lr
;;;546    
                          ENDP

                  |L15.12|
                          DCD      0x400003c0

                          AREA ||i.IAP_Unlock||, CODE, READONLY, ALIGN=2

                  IAP_Unlock PROC
;;;46       */
;;;47     boolType IAP_Unlock ( void )
000000  b510              PUSH     {r4,lr}
;;;48     {
;;;49     
;;;50     #if defined(SC32f10xx)
;;;51         /* HIRC must be enabled before IAP operation */
;;;52         RCC_Unlock ( 0xFF );
000002  20ff              MOVS     r0,#0xff
000004  f7fffffe          BL       RCC_Unlock
;;;53         RCC_HIRCCmd ( ENABLE );
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       RCC_HIRCCmd
;;;54     #endif
;;;55         /* Authorize the FLASH Registers access */
;;;56         IAP->IAPKEY = IAP_KEY1;
00000e  4806              LDR      r0,|L16.40|
000010  4906              LDR      r1,|L16.44|
000012  6008              STR      r0,[r1,#0]
;;;57         IAP->IAPKEY = IAP_KEY2;
000014  4806              LDR      r0,|L16.48|
000016  6008              STR      r0,[r1,#0]
;;;58     
;;;59         if ( IAP->IAPKEY == 0x01 )
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  2801              CMP      r0,#1
00001e  d100              BNE      |L16.34|
                  |L16.32|
;;;60             /* Unlock success */
;;;61             return TRUE;
;;;62         else
;;;63             /* Unlock Error */
;;;64             return FALSE;
;;;65     }
000020  bd10              POP      {r4,pc}
                  |L16.34|
000022  2000              MOVS     r0,#0                 ;64
000024  e7fc              B        |L16.32|
;;;66     
                          ENDP

000026  0000              DCW      0x0000
                  |L16.40|
                          DCD      0x12345678
                  |L16.44|
                          DCD      0x400003c0
                  |L16.48|
                          DCD      0xa05f05fa

                          AREA ||i.IAP_WriteCmd||, CODE, READONLY, ALIGN=2

                  IAP_WriteCmd PROC
;;;84       */
;;;85     void IAP_WriteCmd ( FunctionalState NewState )
000000  2800              CMP      r0,#0
;;;86     {
;;;87         /* Check the parameters */
;;;88         assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;89     
;;;90         if ( NewState != DISABLE )
000002  d006              BEQ      |L17.18|
;;;91         {
;;;92             IAP->IAP_CON |= ( uint32_t ) IAP_CON_PRG;
000004  4906              LDR      r1,|L17.32|
000006  68c9              LDR      r1,[r1,#0xc]
000008  2210              MOVS     r2,#0x10
00000a  4311              ORRS     r1,r1,r2
00000c  4a04              LDR      r2,|L17.32|
00000e  60d1              STR      r1,[r2,#0xc]
000010  e005              B        |L17.30|
                  |L17.18|
;;;93         }
;;;94         else
;;;95         {
;;;96             IAP->IAP_CON &= ~ ( uint32_t ) IAP_CON_PRG;
000012  4903              LDR      r1,|L17.32|
000014  68c9              LDR      r1,[r1,#0xc]
000016  2210              MOVS     r2,#0x10
000018  4391              BICS     r1,r1,r2
00001a  4a01              LDR      r2,|L17.32|
00001c  60d1              STR      r1,[r2,#0xc]
                  |L17.30|
;;;97         }
;;;98     }
00001e  4770              BX       lr
;;;99     
                          ENDP

                  |L17.32|
                          DCD      0x400003c0

;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_iap.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_iap_c_14fd2dba____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___15_sc32f1xxx_iap_c_14fd2dba____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_iap_c_14fd2dba____REVSH|
#line 478
|__asm___15_sc32f1xxx_iap_c_14fd2dba____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
