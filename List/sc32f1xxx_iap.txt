; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\sc32f1xxx_iap.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\sc32f1xxx_iap.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\Buzz\Inc -I..\Drivers\TKDriver\C -I..\ADC_IAP\Inc -ID:\keil\ARM\PACK\Keil\SC32F1xxx_DFP\1.0.6\Device\SC32F10xx\FWLib\SC32_Lib\inc -D__MICROLIB -D__UVISION_VERSION=534 -DSC32F10xx -DSC32f10xx --omf_browse=..\output\sc32f1xxx_iap.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_iap.c]
                          THUMB

                          AREA ||i.IAP_EraseSector||, CODE, READONLY, ALIGN=2

                  IAP_EraseSector PROC
;;;107      */
;;;108    void IAP_EraseSector ( uint32_t IAP_Sector )
000000  4601              MOV      r1,r0
;;;109    {
;;;110        uint32_t tmpreg;
;;;111        IAP->IAP_SNB = 0x4C000000 | IAP_Sector;
000002  2213              MOVS     r2,#0x13
000004  0692              LSLS     r2,r2,#26
000006  430a              ORRS     r2,r2,r1
000008  4b08              LDR      r3,|L1.44|
00000a  605a              STR      r2,[r3,#4]
;;;112        tmpreg = IAP->IAP_CON;
00000c  461a              MOV      r2,r3
00000e  68d0              LDR      r0,[r2,#0xc]
;;;113        tmpreg &= ( uint32_t ) ~ ( IAP_CON_ERASE | IAP_CON_CMD | IAP_CON_PRG );
000010  2393              MOVS     r3,#0x93
000012  4602              MOV      r2,r0
000014  439a              BICS     r2,r2,r3
000016  4610              MOV      r0,r2
;;;114        tmpreg |= ( uint32_t ) ( IAP_CON_SERASE );
000018  2220              MOVS     r2,#0x20
00001a  4310              ORRS     r0,r0,r2
;;;115        IAP->IAP_CON = tmpreg;
00001c  4a03              LDR      r2,|L1.44|
00001e  60d0              STR      r0,[r2,#0xc]
;;;116        IAP->IAP_CON |= ( 0x02 << IAP_CON_CMD_Pos );
000020  68d2              LDR      r2,[r2,#0xc]
000022  2302              MOVS     r3,#2
000024  431a              ORRS     r2,r2,r3
000026  4b01              LDR      r3,|L1.44|
000028  60da              STR      r2,[r3,#0xc]
;;;117    }
00002a  4770              BX       lr
;;;118    
                          ENDP

                  |L1.44|
                          DCD      0x400003c0

                          AREA ||i.IAP_Lock||, CODE, READONLY, ALIGN=2

                  IAP_Lock PROC
;;;71       */
;;;72     void IAP_Lock ( void )
000000  2001              MOVS     r0,#1
;;;73     {
;;;74         /* Set the LOCK Bit to lock the FLASH Registers access */
;;;75         IAP->IAP_CON = ( uint32_t ) IAP_CON_LOCK;
000002  07c0              LSLS     r0,r0,#31
000004  4901              LDR      r1,|L2.12|
000006  60c8              STR      r0,[r1,#0xc]
;;;76     }
000008  4770              BX       lr
;;;77     
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      0x400003c0

                          AREA ||i.IAP_ProgramByte||, CODE, READONLY, ALIGN=1

                  IAP_ProgramByte PROC
;;;189      */
;;;190    boolType IAP_ProgramByte ( uint32_t Address, uint8_t Data )
000000  4602              MOV      r2,r0
;;;191    {
;;;192        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;193    
;;;194        * ( uint8_t* ) Address = Data;
000002  7011              STRB     r1,[r2,#0]
;;;195        if ( Data == * ( uint8_t * ) Address )
000004  7810              LDRB     r0,[r2,#0]
000006  4288              CMP      r0,r1
000008  d101              BNE      |L3.14|
;;;196            return TRUE;
00000a  2001              MOVS     r0,#1
                  |L3.12|
;;;197        else
;;;198            return FALSE;
;;;199    }
00000c  4770              BX       lr
                  |L3.14|
00000e  2000              MOVS     r0,#0                 ;198
000010  e7fc              B        |L3.12|
;;;200    #elif defined (SC32f12xx)
                          ENDP


                          AREA ||i.IAP_ProgramByteArray||, CODE, READONLY, ALIGN=1

                  IAP_ProgramByteArray PROC
;;;423      */
;;;424    uint8_t IAP_ProgramByteArray ( uint32_t Address, uint8_t* ByteArray, uint16_t ArraySize )
000000  b530              PUSH     {r4,r5,lr}
;;;425    {
000002  4603              MOV      r3,r0
;;;426        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;427    
;;;428        uint8_t tmpCnt = 0;
000004  2000              MOVS     r0,#0
;;;429        do
000006  bf00              NOP      
                  |L4.8|
;;;430        {
;;;431            * ( __IO uint8_t* ) Address = ByteArray[tmpCnt];
000008  5c0c              LDRB     r4,[r1,r0]
00000a  701c              STRB     r4,[r3,#0]
;;;432    
;;;433            if ( ByteArray[tmpCnt] != * ( __IO uint8_t * ) Address )
00000c  5c0c              LDRB     r4,[r1,r0]
00000e  781d              LDRB     r5,[r3,#0]
000010  42ac              CMP      r4,r5
000012  d000              BEQ      |L4.22|
;;;434                break;
000014  e005              B        |L4.34|
                  |L4.22|
;;;435    
;;;436            Address = Address + 1;
000016  1c5b              ADDS     r3,r3,#1
;;;437    
;;;438        } while ( ++tmpCnt < ArraySize );
000018  1c44              ADDS     r4,r0,#1
00001a  b2e4              UXTB     r4,r4
00001c  4620              MOV      r0,r4
00001e  4294              CMP      r4,r2
000020  dbf2              BLT      |L4.8|
                  |L4.34|
000022  bf00              NOP                            ;434
;;;439    
;;;440        return tmpCnt;
;;;441    }
000024  bd30              POP      {r4,r5,pc}
;;;442    
                          ENDP


                          AREA ||i.IAP_ProgramHalfWord||, CODE, READONLY, ALIGN=1

                  IAP_ProgramHalfWord PROC
;;;169      */
;;;170    boolType IAP_ProgramHalfWord ( uint32_t Address, uint16_t Data )
000000  4602              MOV      r2,r0
;;;171    {
;;;172        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;173    
;;;174        * ( __IO uint16_t* ) Address = Data;
000002  8011              STRH     r1,[r2,#0]
;;;175        if ( Data == * ( __IO uint16_t * ) Address )
000004  8810              LDRH     r0,[r2,#0]
000006  4288              CMP      r0,r1
000008  d101              BNE      |L5.14|
;;;176            return TRUE;
00000a  2001              MOVS     r0,#1
                  |L5.12|
;;;177        else
;;;178            return FALSE;
;;;179    }
00000c  4770              BX       lr
                  |L5.14|
00000e  2000              MOVS     r0,#0                 ;178
000010  e7fc              B        |L5.12|
;;;180    
                          ENDP


                          AREA ||i.IAP_ProgramHalfWordArray||, CODE, READONLY, ALIGN=1

                  IAP_ProgramHalfWordArray PROC
;;;393    
;;;394    uint8_t IAP_ProgramHalfWordArray ( uint32_t Address, uint16_t* ByteArray, uint16_t ArraySize )
000000  b530              PUSH     {r4,r5,lr}
;;;395    {
000002  4603              MOV      r3,r0
;;;396        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;397    
;;;398        uint8_t tmpCnt = 0;
000004  2000              MOVS     r0,#0
;;;399        if ( ( Address & 0x01 ) == 0 )
000006  07dc              LSLS     r4,r3,#31
000008  0fe4              LSRS     r4,r4,#31
00000a  2c00              CMP      r4,#0
00000c  d110              BNE      |L6.48|
;;;400        {
;;;401            do
00000e  bf00              NOP      
                  |L6.16|
;;;402            {
;;;403    
;;;404                * ( __IO uint16_t* ) Address = ByteArray[tmpCnt];
000010  0044              LSLS     r4,r0,#1
000012  5b0c              LDRH     r4,[r1,r4]
000014  801c              STRH     r4,[r3,#0]
;;;405    
;;;406                if ( ByteArray[tmpCnt] != * ( __IO uint16_t * ) Address )
000016  0044              LSLS     r4,r0,#1
000018  5b0c              LDRH     r4,[r1,r4]
00001a  881d              LDRH     r5,[r3,#0]
00001c  42ac              CMP      r4,r5
00001e  d000              BEQ      |L6.34|
;;;407                    break;
000020  e005              B        |L6.46|
                  |L6.34|
;;;408    
;;;409                Address = Address + 2;
000022  1c9b              ADDS     r3,r3,#2
;;;410    
;;;411            } while ( ++tmpCnt < ArraySize );
000024  1c44              ADDS     r4,r0,#1
000026  b2e4              UXTB     r4,r4
000028  4620              MOV      r0,r4
00002a  4294              CMP      r4,r2
00002c  dbf0              BLT      |L6.16|
                  |L6.46|
00002e  bf00              NOP                            ;407
                  |L6.48|
;;;412        }
;;;413        return tmpCnt;
;;;414    }
000030  bd30              POP      {r4,r5,pc}
;;;415    
                          ENDP


                          AREA ||i.IAP_ProgramWord||, CODE, READONLY, ALIGN=1

                  IAP_ProgramWord PROC
;;;148      */
;;;149    boolType IAP_ProgramWord ( uint32_t Address, uint32_t Data )
000000  4602              MOV      r2,r0
;;;150    {
;;;151        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;152    
;;;153        * ( __IO uint32_t* ) Address = Data;
000002  6011              STR      r1,[r2,#0]
;;;154        if ( Data == * ( __IO uint32_t * ) Address )
000004  6810              LDR      r0,[r2,#0]
000006  4288              CMP      r0,r1
000008  d101              BNE      |L7.14|
;;;155            return TRUE;
00000a  2001              MOVS     r0,#1
                  |L7.12|
;;;156        else
;;;157            return FALSE;
;;;158    
;;;159    }
00000c  4770              BX       lr
                  |L7.14|
00000e  2000              MOVS     r0,#0                 ;157
000010  e7fc              B        |L7.12|
;;;160    #if defined (SC32f10xx) || defined(SC32f11xx)|| defined(SC32f15xx)
                          ENDP


                          AREA ||i.IAP_ProgramWordArray||, CODE, READONLY, ALIGN=1

                  IAP_ProgramWordArray PROC
;;;361      */
;;;362    uint8_t IAP_ProgramWordArray ( uint32_t Address, uint32_t* ByteArray, uint16_t ArraySize )
000000  b530              PUSH     {r4,r5,lr}
;;;363    {
000002  4603              MOV      r3,r0
;;;364        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;365    
;;;366        uint8_t tmpCnt = 0;
000004  2000              MOVS     r0,#0
;;;367    
;;;368        if ( ( Address & 0x03 ) == 0 )
000006  079c              LSLS     r4,r3,#30
000008  0fa4              LSRS     r4,r4,#30
00000a  2c00              CMP      r4,#0
00000c  d110              BNE      |L8.48|
;;;369        {
;;;370            do
00000e  bf00              NOP      
                  |L8.16|
;;;371            {
;;;372                * ( __IO uint32_t* ) Address = ByteArray[tmpCnt];
000010  0084              LSLS     r4,r0,#2
000012  590c              LDR      r4,[r1,r4]
000014  601c              STR      r4,[r3,#0]
;;;373    
;;;374                if ( ByteArray[tmpCnt] != * ( __IO uint32_t * ) Address )
000016  0084              LSLS     r4,r0,#2
000018  590c              LDR      r4,[r1,r4]
00001a  681d              LDR      r5,[r3,#0]
00001c  42ac              CMP      r4,r5
00001e  d000              BEQ      |L8.34|
;;;375                    break;
000020  e005              B        |L8.46|
                  |L8.34|
;;;376    
;;;377                Address = Address + 4;
000022  1d1b              ADDS     r3,r3,#4
;;;378    
;;;379            } while ( ++tmpCnt < ArraySize );
000024  1c44              ADDS     r4,r0,#1
000026  b2e4              UXTB     r4,r4
000028  4620              MOV      r0,r4
00002a  4294              CMP      r4,r2
00002c  dbf0              BLT      |L8.16|
                  |L8.46|
00002e  bf00              NOP                            ;375
                  |L8.48|
;;;380        }
;;;381        return tmpCnt;
;;;382    
;;;383    }
000030  bd30              POP      {r4,r5,pc}
;;;384    #if defined(SC32f10xx) || defined(SC32f11xx) || defined(SC32f15xx)
                          ENDP


                          AREA ||i.IAP_ReadByte||, CODE, READONLY, ALIGN=1

                  IAP_ReadByte PROC
;;;344      */
;;;345    uint8_t IAP_ReadByte ( uint32_t Address )
000000  4601              MOV      r1,r0
;;;346    {
;;;347        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;348    
;;;349        uint8_t Data;
;;;350        Data = * ( uint8_t* ) Address;
000002  7808              LDRB     r0,[r1,#0]
;;;351        return Data;
;;;352    }
000004  4770              BX       lr
;;;353    
                          ENDP


                          AREA ||i.IAP_ReadByteArray||, CODE, READONLY, ALIGN=1

                  IAP_ReadByteArray PROC
;;;501      */
;;;502    uint8_t IAP_ReadByteArray ( uint32_t Address, uint8_t* ByteArray, uint16_t ArraySize )
000000  b510              PUSH     {r4,lr}
;;;503    {
000002  4603              MOV      r3,r0
;;;504        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;505    
;;;506        uint8_t tmpCnt = 0;
000004  2000              MOVS     r0,#0
;;;507        do
000006  bf00              NOP      
                  |L10.8|
;;;508        {
;;;509            ByteArray[tmpCnt] = * ( __IO uint8_t* ) Address;
000008  781c              LDRB     r4,[r3,#0]
00000a  540c              STRB     r4,[r1,r0]
;;;510            Address = Address + 1;
00000c  1c5b              ADDS     r3,r3,#1
;;;511    
;;;512        } while ( ++tmpCnt < ArraySize );
00000e  1c44              ADDS     r4,r0,#1
000010  b2e4              UXTB     r4,r4
000012  4620              MOV      r0,r4
000014  4294              CMP      r4,r2
000016  dbf7              BLT      |L10.8|
;;;513    
;;;514        return tmpCnt;
;;;515    }
000018  bd10              POP      {r4,pc}
;;;516    
                          ENDP


                          AREA ||i.IAP_ReadHalfWord||, CODE, READONLY, ALIGN=1

                  IAP_ReadHalfWord PROC
;;;329      */
;;;330    uint16_t IAP_ReadHalfWord ( uint32_t Address )
000000  4601              MOV      r1,r0
;;;331    {
;;;332        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;333    
;;;334        uint16_t Data;
;;;335        Data = * ( __IO uint16_t* ) Address;
000002  8808              LDRH     r0,[r1,#0]
;;;336        return Data;
;;;337    }
000004  4770              BX       lr
;;;338    
                          ENDP


                          AREA ||i.IAP_ReadHalfWordArray||, CODE, READONLY, ALIGN=1

                  IAP_ReadHalfWordArray PROC
;;;476      */
;;;477    uint8_t IAP_ReadHalfWordArray ( uint32_t Address, uint16_t* ByteArray, uint16_t ArraySize )
000000  b530              PUSH     {r4,r5,lr}
;;;478    {
000002  4603              MOV      r3,r0
;;;479        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;480    
;;;481        uint8_t tmpCnt = 0;
000004  2000              MOVS     r0,#0
;;;482        if ( ( Address & 0x01 ) == 0 )
000006  07dc              LSLS     r4,r3,#31
000008  0fe4              LSRS     r4,r4,#31
00000a  2c00              CMP      r4,#0
00000c  d109              BNE      |L12.34|
;;;483        {
;;;484            do
00000e  bf00              NOP      
                  |L12.16|
;;;485            {
;;;486                ByteArray[tmpCnt] = * ( __IO uint16_t* ) Address;
000010  881c              LDRH     r4,[r3,#0]
000012  0045              LSLS     r5,r0,#1
000014  534c              STRH     r4,[r1,r5]
;;;487                Address = Address + 2;
000016  1c9b              ADDS     r3,r3,#2
;;;488    
;;;489            } while ( ++tmpCnt < ArraySize );
000018  1c44              ADDS     r4,r0,#1
00001a  b2e4              UXTB     r4,r4
00001c  4620              MOV      r0,r4
00001e  4294              CMP      r4,r2
000020  dbf6              BLT      |L12.16|
                  |L12.34|
;;;490        }
;;;491        return tmpCnt;
;;;492    }
000022  bd30              POP      {r4,r5,pc}
;;;493    
                          ENDP


                          AREA ||i.IAP_ReadWord||, CODE, READONLY, ALIGN=1

                  IAP_ReadWord PROC
;;;314      */
;;;315    uint32_t IAP_ReadWord ( uint32_t Address )
000000  4601              MOV      r1,r0
;;;316    {
;;;317        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;318    
;;;319        uint32_t Data;
;;;320        Data = * ( __IO uint32_t* ) Address;
000002  6808              LDR      r0,[r1,#0]
;;;321        return Data;
;;;322    }
000004  4770              BX       lr
;;;323    
                          ENDP


                          AREA ||i.IAP_ReadWordArray||, CODE, READONLY, ALIGN=1

                  IAP_ReadWordArray PROC
;;;451      */
;;;452    uint8_t IAP_ReadWordArray ( uint32_t Address, uint32_t* ByteArray, uint16_t ArraySize )
000000  b530              PUSH     {r4,r5,lr}
;;;453    {
000002  4603              MOV      r3,r0
;;;454        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;455    
;;;456        uint8_t tmpCnt = 0;
000004  2000              MOVS     r0,#0
;;;457        if ( ( Address & 0x03 ) == 0 )
000006  079c              LSLS     r4,r3,#30
000008  0fa4              LSRS     r4,r4,#30
00000a  2c00              CMP      r4,#0
00000c  d109              BNE      |L14.34|
;;;458        {
;;;459            do
00000e  bf00              NOP      
                  |L14.16|
;;;460            {
;;;461                ByteArray[tmpCnt] = * ( __IO uint32_t* ) Address;
000010  681c              LDR      r4,[r3,#0]
000012  0085              LSLS     r5,r0,#2
000014  514c              STR      r4,[r1,r5]
;;;462                Address = Address + 4;
000016  1d1b              ADDS     r3,r3,#4
;;;463    
;;;464            } while ( ++tmpCnt < ArraySize );
000018  1c44              ADDS     r4,r0,#1
00001a  b2e4              UXTB     r4,r4
00001c  4620              MOV      r0,r4
00001e  4294              CMP      r4,r2
000020  dbf6              BLT      |L14.16|
                  |L14.34|
;;;465        }
;;;466        return tmpCnt;
;;;467    }
000022  bd30              POP      {r4,r5,pc}
;;;468    
                          ENDP


                          AREA ||i.IAP_SoftwareReset||, CODE, READONLY, ALIGN=2

                  IAP_SoftwareReset PROC
;;;540      */
;;;541    void IAP_SoftwareReset ( IAP_BTLD_TypeDef IAP_BTLDType )
000000  21ff              MOVS     r1,#0xff
;;;542    {
;;;543        IAP->IAP_CON = ( IAP_BTLDType | IAP_CON_RST );
000002  3101              ADDS     r1,#1
000004  4301              ORRS     r1,r1,r0
000006  4a01              LDR      r2,|L15.12|
000008  60d1              STR      r1,[r2,#0xc]
;;;544    }
00000a  4770              BX       lr
;;;545    
                          ENDP

                  |L15.12|
                          DCD      0x400003c0

                          AREA ||i.IAP_Unlock||, CODE, READONLY, ALIGN=2

                  IAP_Unlock PROC
;;;46       */
;;;47     boolType IAP_Unlock ( void )
000000  b510              PUSH     {r4,lr}
;;;48     {
;;;49     
;;;50     #if defined(SC32f10xx)
;;;51         /* HIRC must be enabled before IAP operation */
;;;52         RCC_Unlock ( 0xFF );
000002  20ff              MOVS     r0,#0xff
000004  f7fffffe          BL       RCC_Unlock
;;;53         RCC_HIRCCmd ( ENABLE );
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       RCC_HIRCCmd
;;;54     #endif
;;;55         /* Authorize the FLASH Registers access */
;;;56         IAP->IAPKEY = IAP_KEY1;
00000e  4806              LDR      r0,|L16.40|
000010  4906              LDR      r1,|L16.44|
000012  6008              STR      r0,[r1,#0]
;;;57         IAP->IAPKEY = IAP_KEY2;
000014  4806              LDR      r0,|L16.48|
000016  6008              STR      r0,[r1,#0]
;;;58     
;;;59         if ( IAP->IAPKEY == 0x01 )
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  2801              CMP      r0,#1
00001e  d100              BNE      |L16.34|
                  |L16.32|
;;;60             /* Unlock success */
;;;61             return TRUE;
;;;62         else
;;;63             /* Unlock Error */
;;;64             return FALSE;
;;;65     }
000020  bd10              POP      {r4,pc}
                  |L16.34|
000022  2000              MOVS     r0,#0                 ;64
000024  e7fc              B        |L16.32|
;;;66     
                          ENDP

000026  0000              DCW      0x0000
                  |L16.40|
                          DCD      0x12345678
                  |L16.44|
                          DCD      0x400003c0
                  |L16.48|
                          DCD      0xa05f05fa

                          AREA ||i.IAP_WriteCmd||, CODE, READONLY, ALIGN=2

                  IAP_WriteCmd PROC
;;;84       */
;;;85     void IAP_WriteCmd ( FunctionalState NewState )
000000  2800              CMP      r0,#0
;;;86     {
;;;87         /* Check the parameters */
;;;88         assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;89     
;;;90         if ( NewState != DISABLE )
000002  d006              BEQ      |L17.18|
;;;91         {
;;;92             IAP->IAP_CON |= ( uint32_t ) IAP_CON_PRG;
000004  4906              LDR      r1,|L17.32|
000006  68c9              LDR      r1,[r1,#0xc]
000008  2210              MOVS     r2,#0x10
00000a  4311              ORRS     r1,r1,r2
00000c  4a04              LDR      r2,|L17.32|
00000e  60d1              STR      r1,[r2,#0xc]
000010  e005              B        |L17.30|
                  |L17.18|
;;;93         }
;;;94         else
;;;95         {
;;;96             IAP->IAP_CON &= ~ ( uint32_t ) IAP_CON_PRG;
000012  4903              LDR      r1,|L17.32|
000014  68c9              LDR      r1,[r1,#0xc]
000016  2210              MOVS     r2,#0x10
000018  4391              BICS     r1,r1,r2
00001a  4a01              LDR      r2,|L17.32|
00001c  60d1              STR      r1,[r2,#0xc]
                  |L17.30|
;;;97         }
;;;98     }
00001e  4770              BX       lr
;;;99     
                          ENDP

                  |L17.32|
                          DCD      0x400003c0

;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_iap.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_iap_c_14fd2dba____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___15_sc32f1xxx_iap_c_14fd2dba____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_iap_c_14fd2dba____REVSH|
#line 478
|__asm___15_sc32f1xxx_iap_c_14fd2dba____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
