L 1 "..\User\SysFunVarDefine.c"
N/**
N *****************************************************************************************************
N  * @copyright	(c)  Shenzhen Saiyuan Microelectronics Co., Ltd
N  * @file	         SysFunVarDefine.c
N  * @author	 
N  * @version 	
N  * @date	
N  * @brief	         Store var control and function control define
N  * @details         
N *****************************************************************************************************
N * @attention
N *
N *****************************************************************************************************
N */
N#include "SC_Init.h"
L 1 "..\User\SC_Init.h" 1
N/**
N *****************************************************************************************************
N  * @copyright	(c)  Shenzhen Saiyuan Microelectronics Co., Ltd
N  * @file	         SC_Init.h
N  * @author	 
N  * @version 	     
N  * @date	         2024.03.11
N  * @brief	         Contains the MCU initialization function and its H file
N  * @details         
N *****************************************************************************************************
N * @attention
N *
N *****************************************************************************************************
N */
N
N#ifndef _SC_INIT_H_
N#define _SC_INIT_H_
N
N#include "sc32_conf.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32_conf.h" 1
N/**
N ******************************************************************************
N * @file    sc32_conf.h
N * @author  SOC AE Team
N * @version V1.6
N * @date    04-09-2024
N * @brief   
N *
N *******************************************************************************
N * @attention
N *
N *1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only 
N *intended for use with SinOne products. No other uses are authorized. This 
N *software is owned by SinOne Microelectronics Co.,Ltd. and is protected under 
N *all applicable laws, including copyright laws. 
N *2.The software which is for guidance only aims at providing customers with 
N *coding information regarding their products in order for them to save time. 
N *As a result, SinOne shall not be held liable for any direct, indirect or 
N *consequential damages with respect to any claims arising from the content of 
N *such software and/or the use made by customers of the coding information 
N *contained herein in connection with their products.
N *
N *  COPYRIGHT 2024 SinOne Microelectronics
N */
N#ifndef _sc32_CONF_H_
N#define _sc32_CONF_H_
N#include "sc32f1xxx.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx.h" 1
N/**
N  ******************************************************************************
N  * @file    SC32F1XXX.h
N  * @author  SOC SA Team
N  * @brief   CMSIS SC32F1xxx Device Peripheral Access Layer Header File.
N  *          The file is the unique include file that the application programmer
N  *          is using in the C source code, usually in main.c. This file contains:
N  *           - Configuration section that allows to select:
N  *              - The SC32F1xxx device used in the target application
N  *
N  ******************************************************************************
N	* @attention
N	*
N	*1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only 
N	*intended for use with SinOne products. No other uses are authorized. This 
N	*software is owned by SinOne Microelectronics Co.,Ltd. and is protected under 
N	*all applicable laws, including copyright laws. 
N	*2.The software which is for guidance only aims at providing customers with 
N	*coding information regarding their products in order for them to save time. 
N	*As a result, SinOne shall not be held liable for any direct, indirect or 
N	*consequential damages with respect to any claims arising from the content of 
N	*such software and/or the use made by customers of the coding information 
N	*contained herein in connection with their products.
N	*
N	*  COPYRIGHT 2024 SinOne Microelectronics
N	*/
N
N
N/** @addtogroup CMSIS_Device
N  * @{
N  */
N
N/** @addtogroup sc32f1xxx
N  * @{
N  */
N
N#ifndef SC32F1XXX_H
N#define SC32F1XXX_H
N
N
N#ifdef __cplusplus
Sextern "C" {
N#endif /* __cplusplus */
N
N/** @addtogroup Library_configuration_section
N  * @{
N  */
N
N#if !defined  (SC32F1)
X#if !0L
N#define SC32F1
N#endif /* SC32F1 */
N
N
N#if defined(SC32f10xx)
X#if 1L
N  #include "SC32f10xx.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\SC32f10xx.h" 1
N/**
N  ******************************************************************************
N  * @file    SC32F10XX.h
N  * @author  SOC SA Team
N  * @brief   CMSIS Cortex-M0+ Device Peripheral Access Layer Header File.
N  *          This file contains all the peripheral register's definitions, bits
N  *          definitions and memory mapping for SC32F10XX devices.
N  *
N  *          This file contains:
N  *           - Data structures and the address mapping for all peripherals
N  *           - Peripheral's registers declarations and bits definition
N  *           - Macros to access peripheral's registers hardware
N  *
N  ******************************************************************************
N * @attention
N *
N *1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only 
N *intended for use with SinOne products. No other uses are authorized. This 
N *software is owned by SinOne Microelectronics Co.,Ltd. and is protected under 
N *all applicable laws, including copyright laws. 
N *2.The software which is for guidance only aims at providing customers with 
N *coding information regarding their products in order for them to save time. 
N *As a result, SinOne shall not be held liable for any direct, indirect or 
N *consequential damages with respect to any claims arising from the content of 
N *such software and/or the use made by customers of the coding information 
N *contained herein in connection with their products.
N *
N *  COPYRIGHT 2024 SinOne Microelectronics
N */
N
N/** @addtogroup CMSIS_Device
N  * @{
N  */
N
N/** @addtogroup sc32f10xx
N  * @{
N  */
N
N#ifndef sc32f10xx_H
N#define sc32f10xx_H
N
N
N
N#ifdef __cplusplus
Sextern "C" {
N#endif /* __cplusplus */
N
N/** @addtogroup Configuration_section_for_CMSIS
N  * @{
N  */
N#if !defined  (LXT_VALUE) 
X#if !0L 
N  #define LXT_VALUE    ((uint32_t)32768) /*!< Default value of the External oscillator in Hz */
N#endif /* LXT_VALUE */
N#if !defined  (HXT_VALUE) 
X#if !0L 
N  #define HXT_VALUE    ((uint32_t)16000000) /*!< Default value of the External oscillator in Hz */
N#endif /* HXT_VALUE */
N#if !defined  (HIRC_VALUE) 
X#if !0L 
N  #define HIRC_VALUE    ((uint32_t)32000000) /*!< Default value of the External oscillator in Hz */
N#endif /* HIRC_VALUE */
N#if !defined  (LIRC_VALUE) 
X#if !0L 
N  #define LIRC_VALUE    ((uint32_t)32000) /*!< Default value of the External oscillator in Hz */
N#endif /* LIRC_VALUE */
N
N/**
N  * @brief Configuration of the Cortex-M0+ Processor and Core Peripherals
N   */
N#define __CM0PLUS_REV             0U /*!< Core Revision r0p0                            */
N#define __MPU_PRESENT             1U /*!< Coretex Mo+  provides an MPU                  */
N#define __VTOR_PRESENT            1U /*!< Vector  Table  Register supported             */
N#define __NVIC_PRIO_BITS          2U /*!< sc32f10xx uses 2 Bits for the Priority Levels 			*/
N#define __Vendor_SysTickConfig    0U /*!< Set to 1 if different SysTick Config is used  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup Peripheral_interrupt_number_definition
N  * @{
N  */
N
N/**
N * @brief sc32f10xx Interrupt Number Definition, according to the selected device
N *        in @ref Library_configuration_section
N */
N
N/*!< Interrupt Number Definition */
Ntypedef enum
N{
N  /******  Cortex-M0+ Processor Exceptions Numbers ***************************************************************/
N  NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                                          */
N  HardFault_IRQn              = -13,    /*!< 3 Cortex-M Hard Fault Interrupt                                   */
N  SVC_IRQn                    = -5,     /*!< 11 Cortex-M SV Call Interrupt                                     */
N  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M Pend SV Interrupt                                     */
N  SysTick_IRQn                = -1,     /*!< 15 Cortex-M System Tick Interrupt                                 */
N  /******  sc32f10xx specific Interrupt Numbers ****************************************************************/
N  INT0_IRQn                  = 0,      /*!< INT  0 Interrupt                                         	*/
N  INT1_7_IRQn                = 1,      /*!< INT Line from 1 to 7  Interrupt                       		*/
N  INT8_11_IRQn               = 2,      /*!< INT Line from 8 to 11  Interrupt                          */
N  INT12_15_IRQn              = 3,      /*!< INT Line from 12 to 15  Interrupt                         */
N  RCC_IRQn                    = 4,      /*!< RCC shut down Interrupts                                   */
N  BTM_IRQn                	  = 6,      /*!< BTM  Interrupts                                      			*/
N  UART0_2_IRQn                = 7,      /*!< UART0 and UART2 Interrupts                                 */
N  UART1_3_IRQn                = 8,      /*!< UART1 and UART3 Interrupts                                 */
N  SPI0_IRQn                		= 9,     	/*!< SPI0 Interrupts                           									*/
N  SPI1_IRQn                   = 10,     /*!< SPI1 Interrupts        																		*/
N  DMA0_IRQn                   = 11,     /*!< DMA0 Interrupts                                            */
N  DMA1_IRQn    			      		= 12,     /*!< DMA1 Interrupts            																*/
N  DMA2_IRQn                   = 13,     /*!< DMA2 Interrupts                                    				*/
N  DMA3_IRQn                   = 14,     /*!< DMA3 Interrupts                                            */
N  TIMER0_IRQn                 = 15,     /*!< TIMER0 global Interrupts                                   */
N  TIMER1_IRQn                 = 16,     /*!< TIMER1 global Interrupt                                    */
N  TIMER2_IRQn                 = 17,     /*!< TIMER2 global Interrupt                                    */
N  TIMER3_IRQn                 = 18,     /*!< TIMER3 global Interrupt                                    */
N  TIMER4_5_IRQn               = 19,     /*!< TIMER4 and TIMER5 global Interrupt                         */
N  TIMER6_7_IRQn               = 20,     /*!< TIMER6 global TIMER7 Interrupt                             */
N  PWM0_IRQn                  	= 21,     /*!< PWM0 Interrupt                                            	*/
N  LEDPWM_IRQn                 = 22,     /*!< LEDPWM Interrupt                                            	*/
N  TWI0_IRQn                  	= 23,     /*!< TWI0 Interrupt                                            	*/
N  TWI1_IRQn                  	= 24,     /*!< TWI1 Interrupt                                            	*/
N  ADC_IRQn                  	= 29,     /*!< ADC  Interrupt                                            	*/
N  CMP_IRQn                  	= 30,     /*!< CMP  Interrupt                                            	*/
N  TK_IRQn											= 31,     /*!< TouchKey  Interrupt                                   			*/
N} IRQn_Type;
N
N/**
N  * @}
N  */
N
N#include "core_cm0plus.h"               /* Cortex-M0+ processor and core peripherals */
L 1 "..\CMSIS\core_cm0plus.h" 1
N/**************************************************************************//**
N * @file     core_cm0plus.h
N * @brief    CMSIS Cortex-M0+ Core Peripheral Access Layer Header File
N * @version  V5.0.6
N * @date     28. May 2018
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM0PLUS_H_GENERIC
N#define __CORE_CM0PLUS_H_GENERIC
N
N#include <stdint.h>
L 1 "D:\keil\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 35 "..\CMSIS\core_cm0plus.h" 2
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex-M0+
N  @{
N */
N
N#include "cmsis_version.h"
L 1 "..\CMSIS\cmsis_version.h" 1
N/**************************************************************************//**
N * @file     cmsis_version.h
N * @brief    CMSIS Core(M) Version definitions
N * @version  V5.0.2
N * @date     19. April 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CMSIS_VERSION_H
N#define __CMSIS_VERSION_H
N
N/*  CMSIS Version definitions */
N#define __CM_CMSIS_VERSION_MAIN  ( 5U)                                      /*!< [31:16] CMSIS Core(M) main version */
N#define __CM_CMSIS_VERSION_SUB   ( 1U)                                      /*!< [15:0]  CMSIS Core(M) sub version */
N#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) | \
N                                   __CM_CMSIS_VERSION_SUB           )       /*!< CMSIS Core(M) version number */
X#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) |                                    __CM_CMSIS_VERSION_SUB           )        
N#endif
L 64 "..\CMSIS\core_cm0plus.h" 2
N 
N/*  CMSIS CM0+ definitions */
N#define __CM0PLUS_CMSIS_VERSION_MAIN (__CM_CMSIS_VERSION_MAIN)                  /*!< \deprecated [31:16] CMSIS HAL main version */
N#define __CM0PLUS_CMSIS_VERSION_SUB  (__CM_CMSIS_VERSION_SUB)                   /*!< \deprecated [15:0]  CMSIS HAL sub version */
N#define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) | \
N                                       __CM0PLUS_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL version number */
X#define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) |                                        __CM0PLUS_CMSIS_VERSION_SUB           )   
N
N#define __CORTEX_M                   (0U)                                       /*!< Cortex-M Core */
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0U
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TI_ARM__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
N#endif
N
N#include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
L 1 "..\CMSIS\cmsis_compiler.h" 1
N/**************************************************************************//**
N * @file     cmsis_compiler.h
N * @brief    CMSIS compiler generic header file
N * @version  V5.0.4
N * @date     10. January 2018
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_COMPILER_H
N#define __CMSIS_COMPILER_H
N
N#include <stdint.h>
N
N/*
N * Arm Compiler 4/5
N */
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "..\CMSIS\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS compiler ARMCC (Arm Compiler 5) header file
N * @version  V5.0.4
N * @date     10. January 2018
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060960 < 400677)
S  #error "Please use Arm Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* CMSIS compiler control architecture macros */
N#if ((defined (__TARGET_ARCH_6_M  ) && (__TARGET_ARCH_6_M   == 1)) || \
N     (defined (__TARGET_ARCH_6S_M ) && (__TARGET_ARCH_6S_M  == 1))   )
X#if ((0L && (__TARGET_ARCH_6_M   == 1)) ||      (1L && (1  == 1))   )
N  #define __ARM_ARCH_6M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7_M ) && (__TARGET_ARCH_7_M  == 1))
X#if (0L && (__TARGET_ARCH_7_M  == 1))
S  #define __ARM_ARCH_7M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7E_M) && (__TARGET_ARCH_7E_M == 1))
X#if (0L && (__TARGET_ARCH_7E_M == 1))
S  #define __ARM_ARCH_7EM__          1
N#endif
N
N  /* __ARM_ARCH_8M_BASE__  not applicable */
N  /* __ARM_ARCH_8M_MAIN__  not applicable */
N
N
N/* CMSIS compiler specific defines */
N#ifndef   __ASM
N  #define __ASM                                  __asm
N#endif
N#ifndef   __INLINE
N  #define __INLINE                               __inline
N#endif
N#ifndef   __STATIC_INLINE
N  #define __STATIC_INLINE                        static __inline
N#endif
N#ifndef   __STATIC_FORCEINLINE                 
N  #define __STATIC_FORCEINLINE                   static __forceinline
N#endif           
N#ifndef   __NO_RETURN
N  #define __NO_RETURN                            __declspec(noreturn)
N#endif
N#ifndef   __USED
N  #define __USED                                 __attribute__((used))
N#endif
N#ifndef   __WEAK
N  #define __WEAK                                 __attribute__((weak))
N#endif
N#ifndef   __PACKED
N  #define __PACKED                               __attribute__((packed))
N#endif
N#ifndef   __PACKED_STRUCT
N  #define __PACKED_STRUCT                        __packed struct
N#endif
N#ifndef   __PACKED_UNION
N  #define __PACKED_UNION                         __packed union
N#endif
N#ifndef   __UNALIGNED_UINT32        /* deprecated */
N  #define __UNALIGNED_UINT32(x)                  (*((__packed uint32_t *)(x)))
N#endif
N#ifndef   __UNALIGNED_UINT16_WRITE
N  #define __UNALIGNED_UINT16_WRITE(addr, val)    ((*((__packed uint16_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT16_READ
N  #define __UNALIGNED_UINT16_READ(addr)          (*((const __packed uint16_t *)(addr)))
N#endif
N#ifndef   __UNALIGNED_UINT32_WRITE
N  #define __UNALIGNED_UINT32_WRITE(addr, val)    ((*((__packed uint32_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT32_READ
N  #define __UNALIGNED_UINT32_READ(addr)          (*((const __packed uint32_t *)(addr)))
N#endif
N#ifndef   __ALIGNED
N  #define __ALIGNED(x)                           __attribute__((aligned(x)))
N#endif
N#ifndef   __RESTRICT
N  #define __RESTRICT                             __restrict
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/**
N  \brief   Enable IRQ Interrupts
N  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __enable_irq();     */
N
N
N/**
N  \brief   Disable IRQ Interrupts
N  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   Enable FIQ
S  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/**
S  \brief   Disable FIQ
S  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/**
S  \brief   Get Base Priority
S  \details Returns the current value of the Base Priority register.
S  \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/**
S  \brief   Set Base Priority
S  \details Assigns the given value to the Base Priority register.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Set Base Priority with condition
S  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
S           or the new value increases the BASEPRI priority level.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
S{
S  register uint32_t __regBasePriMax      __ASM("basepri_max");
S  __regBasePriMax = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Get Fault Mask
S  \details Returns the current value of the Fault Mask register.
S  \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/**
S  \brief   Set Fault Mask
S  \details Assigns the given value to the Fault Mask register.
S  \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1U);
S}
S
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N
N/**
N  \brief   Get FPSCR
N  \details Returns the current value of the Floating Point Status/Control register.
N  \return               Floating Point Status/Control register value
N */
N__STATIC_INLINE uint32_t __get_FPSCR(void)
Xstatic __inline uint32_t __get_FPSCR(void)
N{
N#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
N     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((0L && (__FPU_PRESENT == 1U)) &&      (1L && (0U    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
N#else
N   return(0U);
N#endif
N}
N
N
N/**
N  \brief   Set FPSCR
N  \details Assigns the given value to the Floating Point Status/Control register.
N  \param [in]    fpscr  Floating Point Status/Control value to set
N */
N__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
Xstatic __inline void __set_FPSCR(uint32_t fpscr)
N{
N#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
N     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((0L && (__FPU_PRESENT == 1U)) &&      (1L && (0U    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
N#else
N  (void)fpscr;
N#endif
N}
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0U)
N
N                  
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x78563412.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 0x34127856.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For example, 0x0080 becomes 0x8000.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int16_t __REVSH(int16_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int16_t __REVSH(int16_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    op1  Value to rotate
N  \param [in]    op2  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S  #define __RBIT                          __rbit
N#else
N__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
X__attribute__((always_inline)) static __inline uint32_t __RBIT(uint32_t value)
N{
N  uint32_t result;
N  uint32_t s = (4U /*sizeof(v)*/ * 8U) - 1U; /* extra shift needed at end */
N
N  result = value;                      /* r will be reversed bits of v; first get LSB of v */
N  for (value >>= 1U; value != 0U; value >>= 1U)
N  {
N    result <<= 1U;
N    result |= value & 1U;
N    s--;
N  }
N  result <<= s;                        /* shift when v's highest bits are zero */
N  return result;
N}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   LDR Exclusive (8 bit)
S  \details Executes a exclusive LDR instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
S#else
S  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (16 bit)
S  \details Executes a exclusive LDR instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
S#else
S  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (32 bit)
S  \details Executes a exclusive LDR instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
S#else
S  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (8 bit)
S  \details Executes a exclusive STR instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (16 bit)
S  \details Executes a exclusive STR instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (32 bit)
S  \details Executes a exclusive STR instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   Remove the exclusive lock
S  \details Removes the exclusive lock which is created by LDREX.
S */
S#define __CLREX                           __clrex
S
S
S/**
S  \brief   Signed Saturate
S  \details Saturates a signed value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (1..32)
S  \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/**
S  \brief   Unsigned Saturate
S  \details Saturates an unsigned value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (0..31)
S  \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/**
S  \brief   Rotate Right with Extend (32 bit)
S  \details Moves each bit of a bitstring right by one bit.
S           The carry input is shifted in at the left end of the bitstring.
S  \param [in]    value  Value to rotate
S  \return               Rotated value
S */
S#ifndef __NO_EMBEDDED_ASM
S__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
S{
S  rrx r0, r0
S  bx lr
S}
S#endif
S
S
S/**
S  \brief   LDRT Unprivileged (8 bit)
S  \details Executes a Unprivileged LDRT instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (16 bit)
S  \details Executes a Unprivileged LDRT instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (32 bit)
S  \details Executes a Unprivileged LDRT instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
S
S
S/**
S  \brief   STRT Unprivileged (8 bit)
S  \details Executes a Unprivileged STRT instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRBT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (16 bit)
S  \details Executes a Unprivileged STRT instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRHT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (32 bit)
S  \details Executes a Unprivileged STRT instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRT(value, ptr)                __strt(value, ptr)
S
N#else  /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#else   
N
N/**
N  \brief   Signed Saturate
N  \details Saturates a signed value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (1..32)
N  \return             Saturated value
N */
N__attribute__((always_inline)) __STATIC_INLINE int32_t __SSAT(int32_t val, uint32_t sat)
X__attribute__((always_inline)) static __inline int32_t __SSAT(int32_t val, uint32_t sat)
N{
N  if ((sat >= 1U) && (sat <= 32U))
N  {
N    const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);
N    const int32_t min = -1 - max ;
N    if (val > max)
N    {
N      return max;
N    }
N    else if (val < min)
N    {
N      return min;
N    }
N  }
N  return val;
N}
N
N/**
N  \brief   Unsigned Saturate
N  \details Saturates an unsigned value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (0..31)
N  \return             Saturated value
N */
N__attribute__((always_inline)) __STATIC_INLINE uint32_t __USAT(int32_t val, uint32_t sat)
X__attribute__((always_inline)) static __inline uint32_t __USAT(int32_t val, uint32_t sat)
N{
N  if (sat <= 31U)
N  {
N    const uint32_t max = ((1U << sat) - 1U);
N    if (val > (int32_t)max)
N    {
N      return max;
N    }
N    else if (val < 0)
N    {
N      return 0U;
N    }
N  }
N  return (uint32_t)val;
N}
N
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S
S#define __SADD8                           __sadd8
S#define __QADD8                           __qadd8
S#define __SHADD8                          __shadd8
S#define __UADD8                           __uadd8
S#define __UQADD8                          __uqadd8
S#define __UHADD8                          __uhadd8
S#define __SSUB8                           __ssub8
S#define __QSUB8                           __qsub8
S#define __SHSUB8                          __shsub8
S#define __USUB8                           __usub8
S#define __UQSUB8                          __uqsub8
S#define __UHSUB8                          __uhsub8
S#define __SADD16                          __sadd16
S#define __QADD16                          __qadd16
S#define __SHADD16                         __shadd16
S#define __UADD16                          __uadd16
S#define __UQADD16                         __uqadd16
S#define __UHADD16                         __uhadd16
S#define __SSUB16                          __ssub16
S#define __QSUB16                          __qsub16
S#define __SHSUB16                         __shsub16
S#define __USUB16                          __usub16
S#define __UQSUB16                         __uqsub16
S#define __UHSUB16                         __uhsub16
S#define __SASX                            __sasx
S#define __QASX                            __qasx
S#define __SHASX                           __shasx
S#define __UASX                            __uasx
S#define __UQASX                           __uqasx
S#define __UHASX                           __uhasx
S#define __SSAX                            __ssax
S#define __QSAX                            __qsax
S#define __SHSAX                           __shsax
S#define __USAX                            __usax
S#define __UQSAX                           __uqsax
S#define __UHSAX                           __uhsax
S#define __USAD8                           __usad8
S#define __USADA8                          __usada8
S#define __SSAT16                          __ssat16
S#define __USAT16                          __usat16
S#define __UXTB16                          __uxtb16
S#define __UXTAB16                         __uxtab16
S#define __SXTB16                          __sxtb16
S#define __SXTAB16                         __sxtab16
S#define __SMUAD                           __smuad
S#define __SMUADX                          __smuadx
S#define __SMLAD                           __smlad
S#define __SMLADX                          __smladx
S#define __SMLALD                          __smlald
S#define __SMLALDX                         __smlaldx
S#define __SMUSD                           __smusd
S#define __SMUSDX                          __smusdx
S#define __SMLSD                           __smlsd
S#define __SMLSDX                          __smlsdx
S#define __SMLSLD                          __smlsld
S#define __SMLSLDX                         __smlsldx
S#define __SEL                             __sel
S#define __QADD                            __qadd
S#define __QSUB                            __qsub
S
S#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
S                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
S
S#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
S                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
S
S#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
S                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
S
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 35 "..\CMSIS\cmsis_compiler.h" 2
N
N
N/*
N * Arm Compiler 6 (armclang)
N */
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armclang.h"
S
S
S/*
S * GNU Compiler
S */
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S
S/*
S * IAR Compiler
S */
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iccarm.h>
S
S
S/*
S * TI Arm Compiler
S */
S#elif defined ( __TI_ARM__ )
S  #include <cmsis_ccs.h>
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __attribute__((packed))
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __attribute__((packed)) T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void*)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)                           __attribute__((aligned(x)))
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S
S
S/*
S * TASKING Compiler
S */
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __packed__
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __packed__
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __packed__
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __packed__ T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)              __align(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S
S
S/*
S * COSMIC Compiler
S */
S#elif defined ( __CSMC__ )
S   #include <cmsis_csm.h>
S
S #ifndef   __ASM
S    #define __ASM                                  _asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    // NO RETURN is automatically detected hence no warning here
S    #define __NO_RETURN
S  #endif
S  #ifndef   __USED
S    #warning No compiler specific solution for __USED. __USED is ignored.
S    #define __USED
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __weak
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               @packed
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        @packed struct
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         @packed union
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    @packed struct T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S
S
S#else
S  #error Unknown compiler.
N#endif
N
N
N#endif /* __CMSIS_COMPILER_H */
N
L 116 "..\CMSIS\core_cm0plus.h" 2
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0PLUS_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0PLUS_H_DEPENDANT
N#define __CORE_CM0PLUS_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0PLUS_REV
S    #define __CM0PLUS_REV             0x0000U
S    #warning "__CM0PLUS_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __VTOR_PRESENT
S    #define __VTOR_PRESENT            0U
S    #warning "__VTOR_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex-M0+ */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core MPU Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
N    uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[1U];                
N        uint32_t RESERVED0[31U];
N  __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[1U];                
N        uint32_t RSERVED1[31U];
N  __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[1U];                
N        uint32_t RESERVED2[31U];
N  __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[1U];                
N        uint32_t RESERVED3[31U];
N        uint32_t RESERVED4[64U];
N  __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
X  volatile uint32_t IP[8U];                  
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N#if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
X#if 1L && (1U == 1U)
N  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
X  volatile uint32_t VTOR;                    
N#else
S        uint32_t RESERVED0;
N#endif
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N        uint32_t RESERVED1;
N  __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED */
X  volatile uint32_t SHP[2U];                 
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N#if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
X#if 1L && (1U == 1U)
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_VTOR_TBLOFF_Pos                 8U                                            /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0xFFFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
N#endif
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (1U == 1U)
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
N  \brief    Type definitions for the Memory Protection Unit (MPU)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Memory Protection Unit (MPU).
N */
Ntypedef struct
N{
N  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
X  volatile const  uint32_t TYPE;                    
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
X  volatile uint32_t RNR;                     
N  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
X  volatile uint32_t RBAR;                    
N  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
X  volatile uint32_t RASR;                    
N} MPU_Type;
N
N#define MPU_TYPE_RALIASES                  1U
N
N/* MPU Type Register Definitions */
N#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register Definitions */
N#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register Definitions */
N#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register Definitions */
N#define MPU_RBAR_ADDR_Pos                   8U                                            /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0xFFFFFFUL << MPU_RBAR_ADDR_Pos)              /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register Definitions */
N#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
N#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
N
N#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
N#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
N
N#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
N#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
N#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
N
N#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
N#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
N
N#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
N#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
N
N#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
N#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
N
N#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@} end of group CMSIS_MPU */
N#endif
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Cortex-M0+ Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible over DAP and not via processor.
N            Therefore they are not covered by the Cortex-M0+ header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Core Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (1U == 1U)
N  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
N  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N#ifdef CMSIS_NVIC_VIRTUAL
S  #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
S    #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
S  #endif
S  #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
N  #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
N  #define NVIC_EnableIRQ              __NVIC_EnableIRQ
N  #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
N  #define NVIC_DisableIRQ             __NVIC_DisableIRQ
N  #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
N  #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
N  #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
N/*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0+ */
N  #define NVIC_SetPriority            __NVIC_SetPriority
N  #define NVIC_GetPriority            __NVIC_GetPriority
N  #define NVIC_SystemReset            __NVIC_SystemReset
N#endif /* CMSIS_NVIC_VIRTUAL */
N
N#ifdef CMSIS_VECTAB_VIRTUAL
S  #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
S    #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
S  #endif
S  #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetVector              __NVIC_SetVector
N  #define NVIC_GetVector              __NVIC_GetVector
N#endif  /* (CMSIS_VECTAB_VIRTUAL) */
N
N#define NVIC_USER_IRQ_OFFSET          16
N
N
N/* The following EXC_RETURN values are saved the LR on exception entry */
N#define EXC_RETURN_HANDLER         (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */
N#define EXC_RETURN_THREAD_MSP      (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */
N#define EXC_RETURN_THREAD_PSP      (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */
N
N
N/* Interrupt Priorities are WORD accessible only under Armv6-M                  */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
N#define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
N#define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
N
N#define __NVIC_SetPriorityGrouping(X) (void)(X)
N#define __NVIC_GetPriorityGrouping()  (0U)
N
N/**
N  \brief   Enable Interrupt
N  \details Enables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Enable status
N  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt is not enabled.
N  \return             1  Interrupt is enabled.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISER[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Disable Interrupt
N  \details Disables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N    __ISB();
X    do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N  }
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N  \note    The priority cannot be set for every processor exception.
N */
N__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  = ((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2U)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N  else
N  {
N    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] = ((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2U)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2U)));
N  }
N  else
N  {
N    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2U)));
N  }
N}
N
N
N/**
N  \brief   Encode Priority
N  \details Encodes the priority for an interrupt with the given priority group,
N           preemptive priority value, and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]     PriorityGroup  Used priority group.
N  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N  \param [in]       SubPriority  Subpriority value (starting from 0).
N  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(2U)) ? (uint32_t)(2U) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(2U)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(2U));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/**
N  \brief   Decode Priority
N  \details Decodes an interrupt priority value with a given priority group to
N           preemptive priority value and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N  \param [in]     PriorityGroup  Used priority group.
N  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N  \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(2U)) ? (uint32_t)(2U) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(2U)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(2U));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N/**
N  \brief   Set Interrupt Vector
N  \details Sets an interrupt vector in SRAM based interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N           VTOR must been relocated to SRAM before.
N           If VTOR is not present address 0 must be mapped to SRAM.
N  \param [in]   IRQn      Interrupt number
N  \param [in]   vector    Address of interrupt handler function
N */
N__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
Xstatic __inline void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
N{
N#if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
X#if 1L && (1U == 1U)
N  uint32_t *vectors = (uint32_t *)SCB->VTOR;
X  uint32_t *vectors = (uint32_t *)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR;
N#else
S    uint32_t *vectors = (uint32_t *)0x0U;
N#endif
N  vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;
X  vectors[(int32_t)IRQn + 16] = vector;
N}
N
N
N/**
N  \brief   Get Interrupt Vector
N  \details Reads an interrupt vector from interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn      Interrupt number.
N  \return                 Address of interrupt handler function
N */
N__STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetVector(IRQn_Type IRQn)
N{
N#if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
X#if 1L && (1U == 1U)
N  uint32_t *vectors = (uint32_t *)SCB->VTOR;
X  uint32_t *vectors = (uint32_t *)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR;
N#else
S  uint32_t *vectors = (uint32_t *)0x0U;
N#endif
N  return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];
X  return vectors[(int32_t)IRQn + 16];
N
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
X__declspec(noreturn) static __inline void __NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FAUL << 16U) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2U));
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N/* ##########################  MPU functions  #################################### */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (1U == 1U)
N
N#include "mpu_armv7.h"
L 1 "..\CMSIS\mpu_armv7.h" 1
N/******************************************************************************
N * @file     mpu_armv7.h
N * @brief    CMSIS MPU API for Armv7-M MPU
N * @version  V5.0.4
N * @date     10. January 2018
N ******************************************************************************/
N/*
N * Copyright (c) 2017-2018 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N 
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header    /* treat file as system include file */
N#endif
N 
N#ifndef ARM_MPU_ARMV7_H
N#define ARM_MPU_ARMV7_H
N
N#define ARM_MPU_REGION_SIZE_32B      ((uint8_t)0x04U) ///!< MPU Region Size 32 Bytes
N#define ARM_MPU_REGION_SIZE_64B      ((uint8_t)0x05U) ///!< MPU Region Size 64 Bytes
N#define ARM_MPU_REGION_SIZE_128B     ((uint8_t)0x06U) ///!< MPU Region Size 128 Bytes
N#define ARM_MPU_REGION_SIZE_256B     ((uint8_t)0x07U) ///!< MPU Region Size 256 Bytes
N#define ARM_MPU_REGION_SIZE_512B     ((uint8_t)0x08U) ///!< MPU Region Size 512 Bytes
N#define ARM_MPU_REGION_SIZE_1KB      ((uint8_t)0x09U) ///!< MPU Region Size 1 KByte
N#define ARM_MPU_REGION_SIZE_2KB      ((uint8_t)0x0AU) ///!< MPU Region Size 2 KBytes
N#define ARM_MPU_REGION_SIZE_4KB      ((uint8_t)0x0BU) ///!< MPU Region Size 4 KBytes
N#define ARM_MPU_REGION_SIZE_8KB      ((uint8_t)0x0CU) ///!< MPU Region Size 8 KBytes
N#define ARM_MPU_REGION_SIZE_16KB     ((uint8_t)0x0DU) ///!< MPU Region Size 16 KBytes
N#define ARM_MPU_REGION_SIZE_32KB     ((uint8_t)0x0EU) ///!< MPU Region Size 32 KBytes
N#define ARM_MPU_REGION_SIZE_64KB     ((uint8_t)0x0FU) ///!< MPU Region Size 64 KBytes
N#define ARM_MPU_REGION_SIZE_128KB    ((uint8_t)0x10U) ///!< MPU Region Size 128 KBytes
N#define ARM_MPU_REGION_SIZE_256KB    ((uint8_t)0x11U) ///!< MPU Region Size 256 KBytes
N#define ARM_MPU_REGION_SIZE_512KB    ((uint8_t)0x12U) ///!< MPU Region Size 512 KBytes
N#define ARM_MPU_REGION_SIZE_1MB      ((uint8_t)0x13U) ///!< MPU Region Size 1 MByte
N#define ARM_MPU_REGION_SIZE_2MB      ((uint8_t)0x14U) ///!< MPU Region Size 2 MBytes
N#define ARM_MPU_REGION_SIZE_4MB      ((uint8_t)0x15U) ///!< MPU Region Size 4 MBytes
N#define ARM_MPU_REGION_SIZE_8MB      ((uint8_t)0x16U) ///!< MPU Region Size 8 MBytes
N#define ARM_MPU_REGION_SIZE_16MB     ((uint8_t)0x17U) ///!< MPU Region Size 16 MBytes
N#define ARM_MPU_REGION_SIZE_32MB     ((uint8_t)0x18U) ///!< MPU Region Size 32 MBytes
N#define ARM_MPU_REGION_SIZE_64MB     ((uint8_t)0x19U) ///!< MPU Region Size 64 MBytes
N#define ARM_MPU_REGION_SIZE_128MB    ((uint8_t)0x1AU) ///!< MPU Region Size 128 MBytes
N#define ARM_MPU_REGION_SIZE_256MB    ((uint8_t)0x1BU) ///!< MPU Region Size 256 MBytes
N#define ARM_MPU_REGION_SIZE_512MB    ((uint8_t)0x1CU) ///!< MPU Region Size 512 MBytes
N#define ARM_MPU_REGION_SIZE_1GB      ((uint8_t)0x1DU) ///!< MPU Region Size 1 GByte
N#define ARM_MPU_REGION_SIZE_2GB      ((uint8_t)0x1EU) ///!< MPU Region Size 2 GBytes
N#define ARM_MPU_REGION_SIZE_4GB      ((uint8_t)0x1FU) ///!< MPU Region Size 4 GBytes
N
N#define ARM_MPU_AP_NONE 0U ///!< MPU Access Permission no access
N#define ARM_MPU_AP_PRIV 1U ///!< MPU Access Permission privileged access only
N#define ARM_MPU_AP_URO  2U ///!< MPU Access Permission unprivileged access read-only
N#define ARM_MPU_AP_FULL 3U ///!< MPU Access Permission full access
N#define ARM_MPU_AP_PRO  5U ///!< MPU Access Permission privileged access read-only
N#define ARM_MPU_AP_RO   6U ///!< MPU Access Permission read-only access
N
N/** MPU Region Base Address Register Value
N*
N* \param Region The region to be configured, number 0 to 15.
N* \param BaseAddress The base address for the region.
N*/
N#define ARM_MPU_RBAR(Region, BaseAddress) \
N  (((BaseAddress) & MPU_RBAR_ADDR_Msk) |  \
N   ((Region) & MPU_RBAR_REGION_Msk)    |  \
N   (MPU_RBAR_VALID_Msk))
X#define ARM_MPU_RBAR(Region, BaseAddress)   (((BaseAddress) & MPU_RBAR_ADDR_Msk) |     ((Region) & MPU_RBAR_REGION_Msk)    |     (MPU_RBAR_VALID_Msk))
N
N/**
N* MPU Memory Access Attributes
N* 
N* \param TypeExtField      Type extension field, allows you to configure memory access type, for example strongly ordered, peripheral.
N* \param IsShareable       Region is shareable between multiple bus masters.
N* \param IsCacheable       Region is cacheable, i.e. its value may be kept in cache.
N* \param IsBufferable      Region is bufferable, i.e. using write-back caching. Cacheable but non-bufferable regions use write-through policy.
N*/  
N#define ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable)   \
N  ((((TypeExtField ) << MPU_RASR_TEX_Pos) & MPU_RASR_TEX_Msk)                 | \
N   (((IsShareable ) << MPU_RASR_S_Pos) & MPU_RASR_S_Msk)                      | \
N   (((IsCacheable ) << MPU_RASR_C_Pos) & MPU_RASR_C_Msk)                      | \
N   (((IsBufferable ) << MPU_RASR_B_Pos) & MPU_RASR_B_Msk))
X#define ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable)     ((((TypeExtField ) << MPU_RASR_TEX_Pos) & MPU_RASR_TEX_Msk)                 |    (((IsShareable ) << MPU_RASR_S_Pos) & MPU_RASR_S_Msk)                      |    (((IsCacheable ) << MPU_RASR_C_Pos) & MPU_RASR_C_Msk)                      |    (((IsBufferable ) << MPU_RASR_B_Pos) & MPU_RASR_B_Msk))
N
N/**
N* MPU Region Attribute and Size Register Value
N* 
N* \param DisableExec       Instruction access disable bit, 1= disable instruction fetches.
N* \param AccessPermission  Data access permissions, allows you to configure read/write access for User and Privileged mode.
N* \param AccessAttributes  Memory access attribution, see \ref ARM_MPU_ACCESS_.
N* \param SubRegionDisable  Sub-region disable field.
N* \param Size              Region size of the region to be configured, for example 4K, 8K.
N*/
N#define ARM_MPU_RASR_EX(DisableExec, AccessPermission, AccessAttributes, SubRegionDisable, Size)      \
N  ((((DisableExec ) << MPU_RASR_XN_Pos) & MPU_RASR_XN_Msk)                                          | \
N   (((AccessPermission) << MPU_RASR_AP_Pos) & MPU_RASR_AP_Msk)                                      | \
N   (((AccessAttributes) ) & (MPU_RASR_TEX_Msk | MPU_RASR_S_Msk | MPU_RASR_C_Msk | MPU_RASR_B_Msk)))
X#define ARM_MPU_RASR_EX(DisableExec, AccessPermission, AccessAttributes, SubRegionDisable, Size)        ((((DisableExec ) << MPU_RASR_XN_Pos) & MPU_RASR_XN_Msk)                                          |    (((AccessPermission) << MPU_RASR_AP_Pos) & MPU_RASR_AP_Msk)                                      |    (((AccessAttributes) ) & (MPU_RASR_TEX_Msk | MPU_RASR_S_Msk | MPU_RASR_C_Msk | MPU_RASR_B_Msk)))
N  
N/**
N* MPU Region Attribute and Size Register Value
N* 
N* \param DisableExec       Instruction access disable bit, 1= disable instruction fetches.
N* \param AccessPermission  Data access permissions, allows you to configure read/write access for User and Privileged mode.
N* \param TypeExtField      Type extension field, allows you to configure memory access type, for example strongly ordered, peripheral.
N* \param IsShareable       Region is shareable between multiple bus masters.
N* \param IsCacheable       Region is cacheable, i.e. its value may be kept in cache.
N* \param IsBufferable      Region is bufferable, i.e. using write-back caching. Cacheable but non-bufferable regions use write-through policy.
N* \param SubRegionDisable  Sub-region disable field.
N* \param Size              Region size of the region to be configured, for example 4K, 8K.
N*/                         
N#define ARM_MPU_RASR(DisableExec, AccessPermission, TypeExtField, IsShareable, IsCacheable, IsBufferable, SubRegionDisable, Size) \
N  ARM_MPU_RASR_EX(DisableExec, AccessPermission, ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable), SubRegionDisable, Size)
X#define ARM_MPU_RASR(DisableExec, AccessPermission, TypeExtField, IsShareable, IsCacheable, IsBufferable, SubRegionDisable, Size)   ARM_MPU_RASR_EX(DisableExec, AccessPermission, ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable), SubRegionDisable, Size)
N
N/**
N* MPU Memory Access Attribute for strongly ordered memory.
N*  - TEX: 000b
N*  - Shareable
N*  - Non-cacheable
N*  - Non-bufferable
N*/ 
N#define ARM_MPU_ACCESS_ORDERED ARM_MPU_ACCESS_(0U, 1U, 0U, 0U)
N
N/**
N* MPU Memory Access Attribute for device memory.
N*  - TEX: 000b (if non-shareable) or 010b (if shareable)
N*  - Shareable or non-shareable
N*  - Non-cacheable
N*  - Bufferable (if shareable) or non-bufferable (if non-shareable)
N*
N* \param IsShareable Configures the device memory as shareable or non-shareable.
N*/ 
N#define ARM_MPU_ACCESS_DEVICE(IsShareable) ((IsShareable) ? ARM_MPU_ACCESS_(0U, 1U, 0U, 1U) : ARM_MPU_ACCESS_(2U, 0U, 0U, 0U))
N
N/**
N* MPU Memory Access Attribute for normal memory.
N*  - TEX: 1BBb (reflecting outer cacheability rules)
N*  - Shareable or non-shareable
N*  - Cacheable or non-cacheable (reflecting inner cacheability rules)
N*  - Bufferable or non-bufferable (reflecting inner cacheability rules)
N*
N* \param OuterCp Configures the outer cache policy.
N* \param InnerCp Configures the inner cache policy.
N* \param IsShareable Configures the memory as shareable or non-shareable.
N*/ 
N#define ARM_MPU_ACCESS_NORMAL(OuterCp, InnerCp, IsShareable) ARM_MPU_ACCESS_((4U | (OuterCp)), IsShareable, ((InnerCp) & 2U), ((InnerCp) & 1U))
N
N/**
N* MPU Memory Access Attribute non-cacheable policy.
N*/
N#define ARM_MPU_CACHEP_NOCACHE 0U
N
N/**
N* MPU Memory Access Attribute write-back, write and read allocate policy.
N*/
N#define ARM_MPU_CACHEP_WB_WRA 1U
N
N/**
N* MPU Memory Access Attribute write-through, no write allocate policy.
N*/
N#define ARM_MPU_CACHEP_WT_NWA 2U
N
N/**
N* MPU Memory Access Attribute write-back, no write allocate policy.
N*/
N#define ARM_MPU_CACHEP_WB_NWA 3U
N
N
N/**
N* Struct for a single MPU Region
N*/
Ntypedef struct {
N  uint32_t RBAR; //!< The region base address register value (RBAR)
N  uint32_t RASR; //!< The region attribute and size register value (RASR) \ref MPU_RASR
N} ARM_MPU_Region_t;
N    
N/** Enable the MPU.
N* \param MPU_Control Default access permissions for unconfigured regions.
N*/
N__STATIC_INLINE void ARM_MPU_Enable(uint32_t MPU_Control)
Xstatic __inline void ARM_MPU_Enable(uint32_t MPU_Control)
N{
N  __DSB();
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N  __ISB();
X  do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->CTRL = MPU_Control | (1UL );
N#ifdef SCB_SHCSR_MEMFAULTENA_Msk
S  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
N#endif
N}
N
N/** Disable the MPU.
N*/
N__STATIC_INLINE void ARM_MPU_Disable(void)
Xstatic __inline void ARM_MPU_Disable(void)
N{
N  __DSB();
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N  __ISB();
X  do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N#ifdef SCB_SHCSR_MEMFAULTENA_Msk
S  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
N#endif
N  MPU->CTRL  &= ~MPU_CTRL_ENABLE_Msk;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->CTRL  &= ~(1UL );
N}
N
N/** Clear and disable the given MPU region.
N* \param rnr Region number to be cleared.
N*/
N__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
Xstatic __inline void ARM_MPU_ClrRegion(uint32_t rnr)
N{
N  MPU->RNR = rnr;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RNR = rnr;
N  MPU->RASR = 0U;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RASR = 0U;
N}
N
N/** Configure an MPU region.
N* \param rbar Value for RBAR register.
N* \param rsar Value for RSAR register.
N*/   
N__STATIC_INLINE void ARM_MPU_SetRegion(uint32_t rbar, uint32_t rasr)
Xstatic __inline void ARM_MPU_SetRegion(uint32_t rbar, uint32_t rasr)
N{
N  MPU->RBAR = rbar;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RBAR = rbar;
N  MPU->RASR = rasr;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RASR = rasr;
N}
N
N/** Configure the given MPU region.
N* \param rnr Region number to be configured.
N* \param rbar Value for RBAR register.
N* \param rsar Value for RSAR register.
N*/   
N__STATIC_INLINE void ARM_MPU_SetRegionEx(uint32_t rnr, uint32_t rbar, uint32_t rasr)
Xstatic __inline void ARM_MPU_SetRegionEx(uint32_t rnr, uint32_t rbar, uint32_t rasr)
N{
N  MPU->RNR = rnr;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RNR = rnr;
N  MPU->RBAR = rbar;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RBAR = rbar;
N  MPU->RASR = rasr;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RASR = rasr;
N}
N
N/** Memcopy with strictly ordered memory access, e.g. for register targets.
N* \param dst Destination data is copied to.
N* \param src Source data is copied from.
N* \param len Amount of data words to be copied.
N*/
N__STATIC_INLINE void orderedCpy(volatile uint32_t* dst, const uint32_t* __RESTRICT src, uint32_t len)
Xstatic __inline void orderedCpy(volatile uint32_t* dst, const uint32_t* __restrict src, uint32_t len)
N{
N  uint32_t i;
N  for (i = 0U; i < len; ++i) 
N  {
N    dst[i] = src[i];
N  }
N}
N
N/** Load the given number of MPU regions from a table.
N* \param table Pointer to the MPU configuration table.
N* \param cnt Amount of regions to be configured.
N*/
N__STATIC_INLINE void ARM_MPU_Load(ARM_MPU_Region_t const* table, uint32_t cnt) 
Xstatic __inline void ARM_MPU_Load(ARM_MPU_Region_t const* table, uint32_t cnt) 
N{
N  const uint32_t rowWordSize = sizeof(ARM_MPU_Region_t)/4U;
N  while (cnt > MPU_TYPE_RALIASES) {
X  while (cnt > 1U) {
N    orderedCpy(&(MPU->RBAR), &(table->RBAR), MPU_TYPE_RALIASES*rowWordSize);
X    orderedCpy(&(((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RBAR), &(table->RBAR), 1U*rowWordSize);
N    table += MPU_TYPE_RALIASES;
X    table += 1U;
N    cnt -= MPU_TYPE_RALIASES;
X    cnt -= 1U;
N  }
N  orderedCpy(&(MPU->RBAR), &(table->RBAR), cnt*rowWordSize);
X  orderedCpy(&(((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RBAR), &(table->RBAR), cnt*rowWordSize);
N}
N
N#endif
L 1004 "..\CMSIS\core_cm0plus.h" 2
N
N#endif
N
N/* ##########################  FPU functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_FpuFunctions FPU Functions
N  \brief    Function that provides FPU type.
N  @{
N */
N
N/**
N  \brief   get FPU type
N  \details returns the FPU type
N  \returns
N   - \b  0: No FPU
N   - \b  1: Single precision FPU
N   - \b  2: Double + Single precision FPU
N */
N__STATIC_INLINE uint32_t SCB_GetFPUType(void)
Xstatic __inline uint32_t SCB_GetFPUType(void)
N{
N    return 0U;           /* No FPU */
N}
N
N
N/*@} end of CMSIS_Core_FpuFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
X#if 1L && (0U == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  __NVIC_SetPriority (SysTick_IRQn, (1UL << 2U) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0PLUS_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 130 "..\FWLib\SC32F1XXX_Lib\inc\SC32f10xx.h" 2
N#include "system_sc32f1xxx.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\system_sc32f1xxx.h" 1
N/**
N******************************************************************************
N* @file    SYSTEM_sc32f1xxx.h
N* @author  SOC SA Team
N* @brief   CMSIS Cortex-M0+ Device System Source File for sc32f1xxx devices.
N******************************************************************************
N* @attention
N*
N*1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only 
N*intended for use with SinOne products. No other uses are authorized. This 
N*software is owned by SinOne Microelectronics Co.,Ltd. and is protected under 
N*all applicable laws, including copyright laws. 
N*2.The software which is for guidance only aims at providing customers with 
N*coding information regarding their products in order for them to save time. 
N*As a result, SinOne shall not be held liable for any direct, indirect or 
N*consequential damages with respect to any claims arising from the content of 
N*such software and/or the use made by customers of the coding information 
N*contained herein in connection with their products.
N*
N*  COPYRIGHT 2024 SinOne Microelectronics
N*/
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup sc32f10xx_system
N  * @{
N  */
N
N/**
N  * @brief Define to prevent recursive inclusion
N  */
N#ifndef SYSTEM_SOC0003_H
N#define SYSTEM_SOC0003_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/** @addtogroup sc32f10xx_System_Includes
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N
N/** @addtogroup sc32f10xx_System_Exported_types
N  * @{
N  */
Nextern uint32_t SystemCoreClock;         /*!< System Clock Frequency (Core Clock) */
N
Nextern const uint32_t AHBPrescTable[16];  /*!<  AHB prescalers table values */
Nextern const uint32_t APBPrescTable[8];   /*!< APB prescalers table values */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32G0xx_System_Exported_Constants
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32G0xx_System_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32G0xx_System_Exported_Functions
N  * @{
N  */
N
Nextern void SystemInit(void);
Nextern void SystemCoreClockUpdate(void);
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*SYSTEM_STM32G0XX_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 131 "..\FWLib\SC32F1XXX_Lib\inc\SC32f10xx.h" 2
N#include <stdint.h>
N
N
N/** @addtogroup Exported_types
N  * @{
N  */
Ntypedef enum
N{
N  RESET = 0,
N  SET = !RESET
N} FlagStatus, ITStatus;
N
Ntypedef enum
N{
N  DISABLE = 0,
N  ENABLE = !DISABLE
N} FunctionalState;
N
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum
N{
N  SUCCESS = 0,
N  ERROR = !SUCCESS
N} ErrorStatus;
N
Ntypedef enum
N{
N  FALSE = 0,
N  TRUE = !FALSE
N} boolType;
N
Ntypedef enum
N{
N  Status_OK	 = 0,
N  Status_ERROR,
N  Status_BUSY,
N  Status_TIMEOUT
N} StatusTypeDef;
N
N/** @addtogroup Exported_macros
N  * @{
N  */
N#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
N
N#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
N
N#define READ_BIT(REG, BIT)    ((REG) & (BIT))
N
N#define CLEAR_REG(REG)        ((REG) = (0x0))
N
N#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
N
N#define READ_REG(REG)         ((REG))
N
N
N
N/* Peripheral for APB0=0x40020000
N	 Peripheral for APB1=0x40021000
N   Peripheral for APB2=0x40022000
N*/
N/**
N  * @brief RCCAPB0 for APB0,Peripheral offset =0x00
N  */
Ntypedef struct
N{
N  __IO uint32_t APB0_CFG;       	 /*!< APB0 Config register,      Address offset: 0x00 */
X  volatile uint32_t APB0_CFG;       	  
N  __IO uint32_t APB0_RST;          /*!< APB0 Reset register,       Address offset: 0x04 */
X  volatile uint32_t APB0_RST;           
N} RCCAPB0_TypeDef;
N
N/**
N  * @brief RCCAPB1 for APB1,Peripheral offset =0x00
N  */
Ntypedef struct
N{
N  __IO uint32_t APB1_CFG;       	 /*!< APB1 Config register,      Address offset: 0x00 */
X  volatile uint32_t APB1_CFG;       	  
N  __IO uint32_t APB1_RST;          /*!< APB1 Reset register,       Address offset: 0x04 */
X  volatile uint32_t APB1_RST;           
N} RCCAPB1_TypeDef;
N
N/**
N  * @brief RCCAPB2 for APB2,Peripheral offset =0x00
N  */
Ntypedef struct
N{
N  __IO uint32_t APB2_CFG;       	 /*!< APB2 Config register,      Address offset: 0x00 */
X  volatile uint32_t APB2_CFG;       	  
N  __IO uint32_t APB2_RST;          /*!< APB2 Reset register,       Address offset: 0x04 */
X  volatile uint32_t APB2_RST;           
N} RCCAPB2_TypeDef;
N
N
N/** @addtogroup Peripheral_registers_structures
N  * @{
N  */
N/**
N  * @brief UART0-1 for APB0,UART2 for APB1,UART3 for APB2,UART0/2/3 Peripheral offset =0x20,UART1 Peripheral offset=0x80
N  */
Ntypedef struct
N{
N  __IO uint32_t UART_CON;       	 /*!< UART Config register,      	Address offset: 0x00 */
X  volatile uint32_t UART_CON;       	  
N  __IO uint32_t UART_STS;          /*!< UART Status register,       Address offset: 0x04 */
X  volatile uint32_t UART_STS;           
N  __IO uint32_t UART_BAUD;         /*!< UART BaudRate register, 		Address offset: 0x08 */
X  volatile uint32_t UART_BAUD;          
N  __IO uint32_t UART_DATA;         /*!< UART Data register,   			Address offset: 0x0C */
X  volatile uint32_t UART_DATA;          
N  __IO uint32_t UART_IDE;     		 /*!< UART Interrupt /Dma Enable register,   Address offset: 0x10 */
X  volatile uint32_t UART_IDE;     		  
N} UART_TypeDef;
N
N/**
N  * @brief SPI0 for APB0,SPI1 for APB1 ,Peripheral offset =0x40
N  */
Ntypedef struct
N{
N  __IO uint32_t SPI_CON;       	  /*!< SPI Control register,      Address offset: 0x00 */
X  volatile uint32_t SPI_CON;       	   
N  __IO uint32_t SPI_STS;          /*!< SPI Status register,       Address offset: 0x04 */
X  volatile uint32_t SPI_STS;           
N  __IO uint32_t RESERVED;         /*!< Reserved, 									Address offset: 0x08 */
X  volatile uint32_t RESERVED;          
N  __IO uint32_t SPI_DATA;         /*!< SPI Data register,   			Address offset: 0x0C */
X  volatile uint32_t SPI_DATA;          
N  __IO uint32_t SPI_IDE;     		  /*!< SPI Interrupt /Dma Enable register,   Address offset: 0x10 */
X  volatile uint32_t SPI_IDE;     		   
N} SPI_TypeDef;
N
N/**
N  * @brief TWI0 for APB0,TWI1 for APB1 ,Peripheral offset =0x60
N  */
Ntypedef struct
N{
N  __IO uint32_t TWI_CON;       	  /*!< TWI Config register,      	Address offset: 0x00 */
X  volatile uint32_t TWI_CON;       	   
N  __IO uint32_t TWI_STS;          /*!< TWI Status register,       Address offset: 0x04 */
X  volatile uint32_t TWI_STS;           
N  __IO uint32_t TWI_ADD;          /*!< TWI Adress register, 			Address offset: 0x08 */
X  volatile uint32_t TWI_ADD;           
N  __IO uint32_t TWI_DATA;         /*!< TWI Data register,   			Address offset: 0x0C */
X  volatile uint32_t TWI_DATA;          
N  __IO uint32_t TWI_IDE;     		  /*!< TWI Interrupt /Dma Enable register,   Address offset: 0x10 */
X  volatile uint32_t TWI_IDE;     		   
N} TWI_TypeDef;
N
N/**
N  * @brief TIEMR0123 for APB0,TIEMR4567 for APB1, Peripheral offset=0x100+0x40*n(n=0,1,2,3)
N  */
Ntypedef struct
N{
N  __IO uint32_t TIM_CON;       		/*!< TCON register,      Address offset: 0x00 */
X  volatile uint32_t TIM_CON;       		 
N  __IO uint32_t TIM_CNT;          /*!< TCNT register,       Address offset: 0x04 */
X  volatile uint32_t TIM_CNT;           
N  __IO uint32_t TIM_RLD;          /*!< TIMER ReLoad register, Address offset: 0x08 */
X  volatile uint32_t TIM_RLD;           
N  __IO uint32_t TIM_STS;          /*!< TIMER Status register,   Address offset: 0x0C */
X  volatile uint32_t TIM_STS;           
N  __IO uint32_t TIM_PDTA_RCAP;    /*!< TIMER Rise Caputre Key register,   Address offset: 0x10 */
X  volatile uint32_t TIM_PDTA_RCAP;     
N  __IO uint32_t TIM_PDTB_FCAP;    /*!< TIMER fall Caputre register,   Address offset: 0x14 */
X  volatile uint32_t TIM_PDTB_FCAP;     
N  __IO uint32_t TIM_IDE;          /*!< TIMER Interrupt /Dma Enable register,  Address offset: 0x18 */
X  volatile uint32_t TIM_IDE;           
N} TIM_TypeDef;
N
N/**
N  * @brief PWM0 for APB0,PWM0 Peripheral offset=0x200,
N  */
Ntypedef struct
N{
N  __IO uint32_t PWM_CON;       		 /*!< Pwm Control register,      	Address offset: 0x00 */
X  volatile uint32_t PWM_CON;       		  
N  __IO uint32_t PWM_CHN;           /*!< PWM Channel register,       	Address offset: 0x04 */
X  volatile uint32_t PWM_CHN;            
N  __IO uint32_t PWM_STS;           /*!< PWM Status register, 				Address offset: 0x08 */
X  volatile uint32_t PWM_STS;            
N  __IO uint32_t PWM_INV;           /*!< PWM Inverse register,   			Address offset: 0x0C */
X  volatile uint32_t PWM_INV;            
N  __IO uint32_t PWM_DFR;    			 /*!< PWM Dead space register,   	Address offset: 0x10 */
X  volatile uint32_t PWM_DFR;    			  
N  __IO uint32_t PWM_FLT;    			 /*!< PWM FaiLure detection register,   Address offset: 0x14 */
X  volatile uint32_t PWM_FLT;    			  
N  __IO uint32_t PWM_CYCLE;         /*!< PWM Cycles register,  			Address offset: 0x18 */
X  volatile uint32_t PWM_CYCLE;          
N  __IO uint32_t RESERVED[5];       /*!< Reserved, 									Address offset: 0x1C */
X  volatile uint32_t RESERVED[5];        
N  __IO uint32_t PWM_DT[8];        /*!< PWM Duty register,@PWM0 PWM_DT[8] is Valied, 	Address offset: 0x30 */
X  volatile uint32_t PWM_DT[8];         
N} PWM_TypeDef;
N
N/**
N  * @brief LEDPWM for APB2,LEDPWM Peripheral offset=0x300,
N  */
Ntypedef struct
N{
N  __IO uint32_t LEDPWM_CON;       		 /*!< LEDPWM Control register,      	Address offset: 0x00 */
X  volatile uint32_t LEDPWM_CON;       		  
N  __IO uint32_t LEDPWM_CHN;           /*!< LEDPWM Channel register,       	Address offset: 0x04 */
X  volatile uint32_t LEDPWM_CHN;            
N  __IO uint32_t LEDPWM_STS;           /*!< LEDPWM Status register, 				Address offset: 0x08 */
X  volatile uint32_t LEDPWM_STS;            
N  __IO uint32_t LEDPWM_INV;           /*!< LEDPWM Inverse register,   			Address offset: 0x0C */
X  volatile uint32_t LEDPWM_INV;            
N  __IO uint32_t RESERVED0[2];       /*!< Reserved, 									Address offset: 0x1C */
X  volatile uint32_t RESERVED0[2];        
N  __IO uint32_t LEDPWM_CYCLE;         /*!< LEDPWM Cycles register,  			Address offset: 0x18 */
X  volatile uint32_t LEDPWM_CYCLE;          
N  __IO uint32_t RESERVED1[5];       /*!< Reserved, 									Address offset: 0x1C */
X  volatile uint32_t RESERVED1[5];        
N  __IO uint32_t LEDPWM_DT[32];        /*!< LEDPWM Duty register,@LEDPWM0 LEDPWM_DT[8] is Valied, 	Address offset: 0x30 */
X  volatile uint32_t LEDPWM_DT[32];         
N} LEDPWM_TypeDef;
N
N/**
N  * @brief BTM for APB2,Peripheral offset=0x100
N  */
Ntypedef struct
N{
N  __IO uint32_t BTM_CON;       	  /*!< ADC Control register,      Address offset: 0x00 */
X  volatile uint32_t BTM_CON;       	   
N  __IO uint32_t BTM_STS;          /*!< ADC Status register,       Address offset: 0x04 */
X  volatile uint32_t BTM_STS;           
N} BTM_TypeDef;
N
N/**
N  * @brief ADC for APB2,Peripheral offset=0x110
N  */
Ntypedef struct
N{
N  __IO uint32_t ADC_CON;       	  /*!< ADC Control register,      Address offset: 0x00 */
X  volatile uint32_t ADC_CON;       	   
N  __IO uint32_t ADC_STS;          /*!< ADC Status register,       Address offset: 0x04 */
X  volatile uint32_t ADC_STS;           
N  __IO uint32_t ADC_VALUE;        /*!< ADC Value register, 				Address offset: 0x08 */
X  volatile uint32_t ADC_VALUE;         
N  __IO uint32_t ADC_CFG;          /*!< ADC Config register,   		Address offset: 0x0C */
X  volatile uint32_t ADC_CFG;           
N} ADC_TypeDef;
N
N/**
N  * @brief CMP for APB2,Peripheral offset=0x130
N  */
Ntypedef struct
N{
N  __IO uint32_t CMP_STS;          /*!< CMP Status register,       Address offset: 0x00 */
X  volatile uint32_t CMP_STS;           
N  __IO uint32_t CMP_CFG;          /*!< CMP Config register, 				Address offset: 0x04 */
X  volatile uint32_t CMP_CFG;           
N} CMP_TypeDef;
N
N/**
N  * @brief TK for APB2,Peripheral offset=0x200
N  */
Ntypedef struct 
N{
N  __IO uint32_t TK_CHN;           /*!< TK Channel register,          	Address offset: 0x00 */
X  volatile uint32_t TK_CHN;            
N  __IO uint32_t RESERVED[2];      /*!< Reserved, 									  	Address offset: 0x04 */
X  volatile uint32_t RESERVED[2];       
N  __IO uint32_t TK_CON;           /*!< TK Control register, 				  Address offset: 0x0C */
X  volatile uint32_t TK_CON;            
N  __IO uint32_t TK_CFG;           /*!< TK Config register, 				  	Address offset: 0x10 */
X  volatile uint32_t TK_CFG;            
N  __IO uint32_t RESERVED0;			  /*!< Reserved, 									    Address offset: 0x14 */
X  volatile uint32_t RESERVED0;			   
N  __IO uint32_t TK_CNT;           /*!< TK RawData register, 				  Address offset: 0x18 */
X  volatile uint32_t TK_CNT;            
N  __IO uint32_t TK_TM;            /*!< TK TM register, 				 				Address offset: 0x1C */
X  volatile uint32_t TK_TM;             
N} TK_TypeDef;
N
N
N/**
N  * @brief LCD/LED for APB2,Peripheral offset=0x280
N  */
Ntypedef struct
N{
N  __IO uint32_t DDR_CON;          /*!< Display Drive Control register,                      Address offset: 0x00 */
X  volatile uint32_t DDR_CON;           
N  __IO uint32_t DDR_CFG;      		/*!< Display Drive Config register, 			                Address offset: 0x04 */
X  volatile uint32_t DDR_CFG;      		 
N  __IO uint32_t SEG_EN;           /*!< Segment IO Enable register, 				                  Address offset: 0x08 */
X  volatile uint32_t SEG_EN;            
N  __IO uint32_t RESERVED0;			  /*!< Reserved, 									    			                Address offset: 0x0C */
X  volatile uint32_t RESERVED0;			   
N  __IO uint32_t COM_EN;           /*!< COM IO Enable register register, 	                	Address offset: 0x10 */
X  volatile uint32_t COM_EN;            
N  __IO uint32_t RESERVED1[39];  /*!< Reserved,                                            Address offset: 0x14 */
X  volatile uint32_t RESERVED1[39];   
N  __IO uint32_t SEGRn[28];        /*!< COM port display drive output function register, 		Address offset: 0x50 */
X  volatile uint32_t SEGRn[28];         
N} LCD_LED_TypeDef;
N
N
N/*
N	 Peripheral for IOPORT=0x40011000
N*/
N/**
N  * @brief GPIO for IOPORT,Peripheral offset=0x100*n(n=0,1,2)
N  */
Ntypedef struct
N{
N  __IO uint32_t PIN;        			/*!< GPIOA,B,C register,               Address offset: 0x00         */
X  volatile uint32_t PIN;        			 
N  __IO uint32_t RESERVED0[7];		/*!< Reserved, 						   Address offset: 0x04 		*/
X  volatile uint32_t RESERVED0[7];		 
N  __IO uint32_t PXCON;     			/*!< GPIO port Control register,       Address offset: 0x20     	*/
X  volatile uint32_t PXCON;     			 
N  __IO uint32_t RESERVED1[7];		/*!< Reserved, 						   Address offset: 0x24 		*/
X  volatile uint32_t RESERVED1[7];		 
N  __IO uint32_t PXPH;       		/*!< GPIO port pull-up/pull-down register, Address offset: 0x40     */
X  volatile uint32_t PXPH;       		 
N  __IO uint32_t RESERVED2[7];		/*!< Reserved, 						   Address offset: 0x44 		*/
X  volatile uint32_t RESERVED2[7];		 
N  __IO uint32_t PXLEV;  			/*!< GPIO port Level register, 	       Address offset: 0x60    	    */
X  volatile uint32_t PXLEV;  			 
N} GPIO_TypeDef;
N
Ntypedef struct
N{
N  __IO uint8_t PIN_BIT[16];          /*!< GPIOA,B,C Bit register,               Address offset: 0x00      */
X  volatile uint8_t PIN_BIT[16];           
N  __IO uint8_t PIN_XR[16];       	 /*!< GPIOA,B,C Bit register,               Address offset: 0x20      */
X  volatile uint8_t PIN_XR[16];       	  
N
N} GPIO_BIT_TypeDef;
N
N
N/**
N  * @brief INT for IOPORT,Peripheral offset=0x300
N  */
Ntypedef struct
N{
N  __IO uint32_t INTF_IE;        /*!< INT Fall edge Enable register,   Address offset: 0x00      */
X  volatile uint32_t INTF_IE;         
N  __IO uint32_t RESERVED0[7];		/*!< Reserved, 									    	 Address offset: 0x04 			*/
X  volatile uint32_t RESERVED0[7];		 
N  __IO uint32_t INTR_IE;     		/*!< INT Rise edge Enable register register,       Address offset: 0x20     	*/
X  volatile uint32_t INTR_IE;     		 
N  __IO uint32_t RESERVED1[7];		/*!< Reserved, 									    	 Address offset: 0x24 			*/
X  volatile uint32_t RESERVED1[7];		 
N  __IO uint32_t INT_SEL0;       /*!< INT0-7 Port Select register, Address offset: 0x40    */
X  volatile uint32_t INT_SEL0;        
N  __IO uint32_t RESERVED2[7];		/*!< Reserved, 									    	 Address offset: 0x44 			*/
X  volatile uint32_t RESERVED2[7];		 
N  __IO uint32_t INT_SEL1;       /*!< INT8-15 Port Select register, Address offset: 0x60    */
X  volatile uint32_t INT_SEL1;        
N  __IO uint32_t RESERVED3[7];		/*!< Reserved, 									    	 Address offset: 0x64 			*/
X  volatile uint32_t RESERVED3[7];		 
N  __IO uint32_t INTF_CON;       /*!< INT Fall Control  register, Address offset: 0x80    */
X  volatile uint32_t INTF_CON;        
N  __IO uint32_t RESERVED4[7];		/*!< Reserved, 									    	 Address offset: 0x84 			*/
X  volatile uint32_t RESERVED4[7];		 
N  __IO uint32_t INTR_CON;       /*!< INT Rise Control register, Address offset: 0xA0    */
X  volatile uint32_t INTR_CON;        
N  __IO uint32_t RESERVED5[7];		/*!< Reserved, 									    	 Address offset: 0xA4 			*/
X  volatile uint32_t RESERVED5[7];		 
N  __IO uint32_t INTF_STS;       /*!< INT Fall Status  register, Address offset: 0xC0    */
X  volatile uint32_t INTF_STS;        
N  __IO uint32_t RESERVED6[7];		/*!< Reserved, 									    	 Address offset: 0xC4 			*/
X  volatile uint32_t RESERVED6[7];		 
N  __IO uint32_t INTR_STS;       /*!< INT Rise status register, Address offset: 0xE0    */
X  volatile uint32_t INTR_STS;        
N  __IO uint32_t RESERVED7[7];		/*!< Reserved, 									    	 Address offset: 0xE4 			*/
X  volatile uint32_t RESERVED7[7];		 
N} INT_TypeDef;
N
N/*
N	 Peripheral for AHB=0x40000000
N*/
N/**
N  * @brief WDT for AHB,Peripheral offset=0x330
N  */
Ntypedef struct
N{
N  __IO uint32_t RESERVED0[3];     /*!< Reserved,      Address offset: 0x00 */
X  volatile uint32_t RESERVED0[3];      
N  __IO uint32_t WDT_CON;      		/*!< WDT Control register, 			Address offset: 0x0C */
X  volatile uint32_t WDT_CON;      		 
N  __IO uint32_t WDT_CFG;          /*!< WDT Config register, 			Address offset: 0x10 */
X  volatile uint32_t WDT_CFG;           
N} WDT_TypeDef;
N
N/**
N  * @brief IAP for AHB,Peripheral offset=0x3C0
N  */
Ntypedef struct
N{
N  __IO uint32_t IAPKEY;     			/*!< IAP KEY register,      		Address offset: 0x00 */
X  volatile uint32_t IAPKEY;     			 
N  __IO uint32_t IAP_SNB;      		/*!< IAP Sector Number register, 			Address offset: 0x04 */
X  volatile uint32_t IAP_SNB;      		 
N  __IO uint32_t RESERVED0;     		/*!< Reserved,      Address offset: 0x08 */
X  volatile uint32_t RESERVED0;     		 
N  __IO uint32_t IAP_CON;          /*!< IAP Control register, 			Address offset: 0x0C */
X  volatile uint32_t IAP_CON;           
N} IAP_TypeDef;
N
N
N/**
N  * @brief OPT for AHB,Peripheral offset=0x3F8
N  */
Ntypedef struct
N{
N  __IO uint32_t OPINX;     			/*!< IAP KEY register,      		Address offset: 0x00 */
X  volatile uint32_t OPINX;     			 
N  __IO uint32_t OPREG;      		/*!< IAP Sector Number register, 			Address offset: 0x04 */
X  volatile uint32_t OPREG;      		 
N} OPT_TypeDef;
N
N/**
N  * @brief CRC for AHB,Peripheral offset=0x2000
N  */
Ntypedef struct
N{
N  __IO uint32_t CRC_DR;     			/*!< CRC Data register,      		Address offset: 0x00 */
X  volatile uint32_t CRC_DR;     			 
N  __IO uint32_t CRC_CON;      		/*!< CRC Config register, 			Address offset: 0x04 */
X  volatile uint32_t CRC_CON;      		 
N  __IO uint32_t CRC_INT;     		  /*!< CRC Inital register,      Address offset: 0x08 */
X  volatile uint32_t CRC_INT;     		   
N  __IO uint32_t CRC_POL;          /*!< CRC Poly  register, 			Address offset: 0x0C */
X  volatile uint32_t CRC_POL;           
N} CRC_TypeDef;
N
N
N/**
N  * @brief RCCAHB for AHB,Peripheral offset =0x3000
N  */
Ntypedef struct
N{
N  __IO uint32_t AHB_CFG;       	 /*!< APB2 Config register,      Address offset: 0x00 */
X  volatile uint32_t AHB_CFG;       	  
N  __IO uint32_t AHB_RST;          /*!< APB2 Reset register,       Address offset: 0x04 */
X  volatile uint32_t AHB_RST;           
N} RCCAHB_TypeDef;
N
N/**
N  * @brief RCC for AHB,Peripheral offset=0x3014
N  */
Ntypedef struct
N{
N  __IO uint32_t RCC_KEY;          /*!< RCC Key register,    Address offset: 0x0C */
X  volatile uint32_t RCC_KEY;           
N  __IO uint32_t RESERVED0;        /*!< Reserved, 		Address offset: 0x10 */
X  volatile uint32_t RESERVED0;         
N  __IO uint32_t RCC_CFG0;     		/*!< RCC Config0 register,    Address offset: 0x14 */
X  volatile uint32_t RCC_CFG0;     		 
N  __IO uint32_t RCC_CFG1;      		/*!< RCC Config1 register, 		Address offset: 0x18 */
X  volatile uint32_t RCC_CFG1;      		 
N  __IO uint32_t PLL_CFG;     		  /*!< PLL Config register,     Address offset: 0x1C */
X  volatile uint32_t PLL_CFG;     		   
N  __IO uint32_t RCC_STS;          /*!< RCC Status  register, 		Address offset: 0x20 */
X  volatile uint32_t RCC_STS;           
N  __IO uint32_t RESERVED1;        /*!< Reserved, 			Address offset: 0x24 */
X  volatile uint32_t RESERVED1;         
N  __IO uint32_t SYST_CALIB;       /*!< RCC Calib  register, 			Address offset: 0x28 */
X  volatile uint32_t SYST_CALIB;        
N  __IO uint32_t NMI_CFG;          /*!< NMI CFG  register, 			Address offset: 0x2C */
X  volatile uint32_t NMI_CFG;           
N} RCC_TypeDef;			//V0.12
N
N
N/*
N	 Peripheral for DMA=AHB+0x10800
N*/
N/**
N  * @brief DMA0..DMA3 Peripheral offset=0x40*n(n=0,1,2,3)
N  */
Ntypedef struct
N{
N  __IO uint32_t DMA_SADR;     		/*!< DMA Source Adress register,    Address offset: 0x00 */
X  volatile uint32_t DMA_SADR;     		 
N  __IO uint32_t DMA_DADR;      		/*!< DMA Destination Adress register, 		Address offset: 0x04 */
X  volatile uint32_t DMA_DADR;      		 
N  __IO uint32_t DMA_CFG;     		  /*!< DMA Config register,     Address offset: 0x08 */
X  volatile uint32_t DMA_CFG;     		   
N  __IO uint32_t DMA_CNT;          /*!< DMA Count  register, 		Address offset: 0x0C */
X  volatile uint32_t DMA_CNT;           
N  __IO uint32_t DMA_STS;          /*!< DMA Status register, 		Address offset: 0x10 */
X  volatile uint32_t DMA_STS;           
N} DMA_TypeDef;
N
N
N
N
N/** @addtogroup Peripheral_memory_map
N  * @{
N  */
N#define FLASH_BASE            (0x08000000UL)  /*!< FLASH base address */
N#define SRAM_BASE             (0x20000000UL)  /*!< SRAM base address */
N#define PERIPH_BASE           (0x40000000UL)  /*!< Peripheral base address */
N#define IOPORT_BASE           (0x40011000UL)  /*!< IOPORT base address */
N#define ERAM_BASE             (0x50000000UL)  /*!< Extern Ram base address */
N#define SRAM_SIZE_MAX         (0x00008000UL)  /*!< maximum SRAM size (up to 32 KBytes) */
N#define PWMDUTY_OFFSET		    (0x00000040UL)	/*!< PwmDuty offset */
N#define	LXDRAM_OFFSET		      (0x00000040UL)
N
N//===============================================
N#define SECTOR_SIZE						512
N#define FLASH_SIZE            (SECTOR_SIZE*2*256)
N#define LDROM_SIZE						(SECTOR_SIZE*2*2)
N
N/*!< Peripheral memory map */
N#define AHBPERIPH_BASE				 (PERIPH_BASE)
N#define APB0PERIPH_BASE        (PERIPH_BASE+0x20000)
N#define APB1PERIPH_BASE        (PERIPH_BASE+0x21000)
N#define APB2PERIPH_BASE        (PERIPH_BASE+0x22000)
N#define DMAPERIPH_BASE         (PERIPH_BASE+0x10800)
N#define IOPORTPERIPH_BASE      (PERIPH_BASE+0x11000)
N
N/*!< AHB peripherals */
N#define WDT_BASE					     (AHBPERIPH_BASE +(0x00000330UL))
N#define IAP_BASE               (AHBPERIPH_BASE +(0x000003C0UL))
N#define OPT_BASE               (AHBPERIPH_BASE +(0x000003F8UL))
N#define CRC_BASE               (AHBPERIPH_BASE +(0x00002000UL))
N#define RCCAHB_BASE            (AHBPERIPH_BASE +(0x00003000UL))
N#define RCC_BASE               (AHBPERIPH_BASE +(0x0000300CUL))
N/*!< APB0 peripherals */
N#define RCCAPB0_BASE           (APB0PERIPH_BASE +(0x00000000UL))
N#define UART0_BASE             (APB0PERIPH_BASE +(0x00000020UL))
N#define UART1_BASE             (APB0PERIPH_BASE +(0x00000080UL))
N#define SPI0_BASE              (APB0PERIPH_BASE +(0x00000040UL))
N#define TWI0_BASE              (APB0PERIPH_BASE +(0x00000060UL))
N#define TIM0_BASE              (APB0PERIPH_BASE +(0x00000100UL))
N#define TIM1_BASE              (APB0PERIPH_BASE +(0x00000140UL))
N#define TIM2_BASE              (APB0PERIPH_BASE +(0x00000180UL))
N#define TIM3_BASE              (APB0PERIPH_BASE +(0x000001C0UL))
N#define PWM0_BASE              (APB0PERIPH_BASE +(0x00000200UL))
N/*!< APB1 peripherals */
N#define RCCAPB1_BASE           (APB1PERIPH_BASE +(0x00000000UL))
N#define UART2_BASE             (APB1PERIPH_BASE +(0x00000020UL))
N#define SPI1_BASE              (APB1PERIPH_BASE +(0x00000040UL))
N#define TWI1_BASE              (APB1PERIPH_BASE +(0x00000060UL))
N#define TIM4_BASE              (APB1PERIPH_BASE +(0x00000100UL))
N#define TIM5_BASE              (APB1PERIPH_BASE +(0x00000140UL))
N#define TIM6_BASE              (APB1PERIPH_BASE +(0x00000180UL))
N#define TIM7_BASE              (APB1PERIPH_BASE +(0x000001C0UL))
N/*!< APB2 peripherals */
N#define RCCAPB2_BASE           (APB2PERIPH_BASE +(0x00000000UL))
N#define UART3_BASE             (APB2PERIPH_BASE +(0x00000020UL))
N#define LEDPWM_BASE            (APB2PERIPH_BASE +(0x00000300UL))
N#define BTM_BASE               (APB2PERIPH_BASE +(0x00000100UL))
N#define ADC_BASE               (APB2PERIPH_BASE +(0x00000110UL))
N#define CMP_BASE               (APB2PERIPH_BASE +(0x00000130UL))
N#define TK_BASE                (APB2PERIPH_BASE +(0x00000200UL))
N#define LCD_LED_BASE           (APB2PERIPH_BASE +(0x00000280UL))
N/*!< DMA */
N#define DMA0_BASE              (DMAPERIPH_BASE +(0x00000000UL))
N#define DMA1_BASE              (DMAPERIPH_BASE +(0x00000040UL))
N#define DMA2_BASE              (DMAPERIPH_BASE +(0x00000080UL))
N#define DMA3_BASE              (DMAPERIPH_BASE +(0x000000C0UL))
N/*!< IOPORT */
N#define GPIOA_BASE             (IOPORTPERIPH_BASE +(0x00000000UL))
N#define GPIOB_BASE             (IOPORTPERIPH_BASE +(0x00000100UL))
N#define GPIOC_BASE             (IOPORTPERIPH_BASE +(0x00000200UL))
N#define INT_BASE               (IOPORTPERIPH_BASE +(0x00000300UL))
N#define FT_BIT_BASE            (IOPORTPERIPH_BASE +(0x000003C0UL))
N#define RT_BIT_BASE            (IOPORTPERIPH_BASE +(0x000003E0UL))
N/*!< IOPORT-Bit */
N#define GPIOA_BIT_BASE         (GPIOA_BASE+(0x00000000UL))
N#define GPIOB_BIT_BASE         (GPIOB_BASE+(0x00000000UL))
N#define GPIOC_BIT_BASE         (GPIOC_BASE+(0x00000000UL))
N/*!< IOPORT-OverTurn */
N#define GPIOA_OT_BASE          (GPIOA_BASE+(0x00000010UL))
N#define GPIOB_OT_BASE          (GPIOB_BASE+(0x00000010UL))
N#define GPIOC_OT_BASE          (GPIOC_BASE+(0x00000010UL))
N/*<PA.SetBit:n=0...15>*/
N#define PA_BIT(n)              (*((uint8_t*)((GPIOA_BIT_BASE + (n)))))
N#define PB_BIT(n)              (*((uint8_t*)((GPIOB_BIT_BASE + (n)))))
N#define PC_BIT(n)              (*((uint8_t*)((GPIOC_BIT_BASE + (n)))))
N/*<PA.OverTurn:n=0...15>*/
N#define PA_OT(n)               (*((uint8_t*)((GPIOA_OT_BASE + (n)))) = 1)
N#define PB_OT(n)               (*((uint8_t*)((GPIOB_OT_BASE + (n)))) = 1)
N#define PC_OT(n)               (*((uint8_t*)((GPIOC_OT_BASE + (n)))) = 1)
N/*<INTF/INTR.SetBit:n=0...15>*/
N#define FT_BIT(n)              (*((uint8_t*)((FT_BIT_BASE + (n)))))
N#define RT_BIT(n)              (*((uint8_t*)((RT_BIT_BASE + (n)))))
N
N/** @addtogroup Peripheral_declaration
N  * @{
N  */
N#define	RCC								 	((RCC_TypeDef *) RCC_BASE)
N#define RCCAHB             	((RCCAHB_TypeDef *) RCCAHB_BASE)
N#define RCCAPB0						  ((RCCAPB0_TypeDef *) RCCAPB0_BASE)
N#define RCCAPB1						  ((RCCAPB1_TypeDef *) RCCAPB1_BASE)
N#define RCCAPB2						  ((RCCAPB2_TypeDef *) RCCAPB2_BASE)
N#define UART0								((UART_TypeDef *) UART0_BASE)
N#define UART1								((UART_TypeDef *) UART1_BASE)
N#define UART2								((UART_TypeDef *) UART2_BASE)
N#define UART3								((UART_TypeDef *) UART3_BASE)
N#define SPI0								((SPI_TypeDef *) SPI0_BASE)
N#define SPI1								((SPI_TypeDef *) SPI1_BASE)
N#define TWI0								((TWI_TypeDef *) TWI0_BASE)
N#define TWI1								((TWI_TypeDef *) TWI1_BASE)
N#define TIM0								((TIM_TypeDef *) TIM0_BASE)
N#define TIM1								((TIM_TypeDef *) TIM1_BASE)
N#define TIM2								((TIM_TypeDef *) TIM2_BASE)
N#define TIM3								((TIM_TypeDef *) TIM3_BASE)
N#define TIM4								((TIM_TypeDef *) TIM4_BASE)
N#define TIM5								((TIM_TypeDef *) TIM5_BASE)
N#define TIM6								((TIM_TypeDef *) TIM6_BASE)
N#define TIM7								((TIM_TypeDef *) TIM7_BASE)
N#define PWM0								((PWM_TypeDef *) PWM0_BASE)
N#define LEDPWM							((LEDPWM_TypeDef *) LEDPWM_BASE)
N#define BTM									((BTM_TypeDef *) BTM_BASE)
N#define ADC									((ADC_TypeDef *) ADC_BASE)
N#define CMP									((CMP_TypeDef *) CMP_BASE)
N#define TK									((TK_TypeDef *) TK_BASE)
N#define LCD_LED							((LCD_LED_TypeDef *) LCD_LED_BASE)
N#define INT                 ((INT_TypeDef *) INT_BASE)
N#define WDT                	((WDT_TypeDef *) WDT_BASE)
N#define IAP                	((IAP_TypeDef *) IAP_BASE)
N#define CRC                	((CRC_TypeDef *) CRC_BASE)
N#define DMA0								((DMA_TypeDef *) DMA0_BASE)
N#define DMA1								((DMA_TypeDef *) DMA1_BASE)
N#define DMA2								((DMA_TypeDef *) DMA2_BASE)
N#define DMA3								((DMA_TypeDef *) DMA3_BASE)
N#define GPIOA								((GPIO_TypeDef *) GPIOA_BASE)
N#define GPIOB								((GPIO_TypeDef *) GPIOB_BASE)
N#define GPIOC								((GPIO_TypeDef *) GPIOC_BASE)
N//----------------------------------------------------------
N#define OPT                ((OPT_TypeDef *) OPT_BASE)
N//----------------------------------------------------------
N/** @addtogroup Peripheral_Registers_Bits_Definition
N* @{
N*/
N
N/******************************************************************************/
N/*                         Peripheral Registers Bits Definition               */
N/******************************************************************************/
N
N/******************************************************************************/
N/*                                                                            */
N/*                      RCC                    */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for RCC_CFG0 register  ********************/
N#define RCC_CFG0_LXTEN_Pos         				(0U)
N#define	RCC_CFG0_LXTEN_Msk								(0x1UL << RCC_CFG0_LXTEN_Pos)
N#define RCC_CFG0_LXTEN           					RCC_CFG0_LXTEN_Msk
N
N#define RCC_CFG0_LIRCEN_Pos        				(1U)
N#define	RCC_CFG0_LIRCEN_Msk								(0x1UL << RCC_CFG0_LIRCEN_Pos)
N#define RCC_CFG0_LIRCEN           				RCC_CFG0_LIRCEN_Msk
N
N#define RCC_CFG0_CRYHF_Pos         				(4U)
N#define	RCC_CFG0_CRYHF_Msk								(0x1UL << RCC_CFG0_CRYHF_Pos)
N#define RCC_CFG0_CRYHF           					RCC_CFG0_CRYHF_Msk
N
N#define RCC_CFG0_HXTEN_Pos         				(5U)
N#define	RCC_CFG0_HXTEN_Msk								(0x1UL << RCC_CFG0_HXTEN_Pos)
N#define RCC_CFG0_HXTEN          					RCC_CFG0_HXTEN_Msk
N
N#define RCC_CFG0_HIRCEN_Pos        				(6U)
N#define	RCC_CFG0_HIRCEN_Msk								(0x1UL << RCC_CFG0_HIRCEN_Pos)
N#define RCC_CFG0_HIRCEN          					RCC_CFG0_HIRCEN_Msk
N
N#define RCC_CFG0_SYSCLKSW_Pos      				(7U)
N#define	RCC_CFG0_SYSCLKSW_Msk							(0x1UL << RCC_CFG0_SYSCLKSW_Pos)
N#define RCC_CFG0_SYSCLKSW          				RCC_CFG0_SYSCLKSW_Msk
N
N#define RCC_CFG0_SYSCLKSEL_Pos     				(8U)
N#define	RCC_CFG0_SYSCLKSEL_Msk						(0x3UL << RCC_CFG0_SYSCLKSEL_Pos)
N#define RCC_CFG0_SYSCLKSEL         				RCC_CFG0_SYSCLKSEL_Msk
N
N#define RCC_CFG0_HPLDODP_Pos         			(11U)
N#define	RCC_CFG0_HPLDOD_Msk								(0x1UL << RCC_CFG0_HPLDODP_Pos)         
N#define RCC_CFG0_HPLDOD         					RCC_CFG0_HPLDOD_Msk
N
N#define RCC_CFG0_WAIT_Pos          				(12U)
N#define	RCC_CFG0_WAIT_Msk                 (0x3UL << RCC_CFG0_WAIT_Pos)
N#define RCC_CFG0_WAIT                     RCC_CFG0_WAIT_Msk
N
N#define RCC_CFG0_HIRC72EN_Pos            (14U)
N#define	RCC_CFG0_HIRC72EN_Msk            (0x1UL << RCC_CFG0_HIRC72EN_Pos)         
N#define RCC_CFG0_HIRC72EN         				RCC_CFG0_HIRC72EN_Msk
N
N#define RCC_CFG0_INTEN_Pos         				(15U)
N#define	RCC_CFG0_INTEN_Msk								(0x1UL << RCC_CFG0_INTEN_Pos)
N#define RCC_CFG0_INTEN         						RCC_CFG0_INTEN_Msk
N
N/********************  Bit definition for RCC_CFG1 register  ********************/
N#define RCC_CFG1_BTMCLKSEL_Pos         		(0U)
N#define	RCC_CFG1_BTMCLKSEL_Msk						(0x1UL << RCC_CFG1_BTMCLKSEL_Pos)
N#define RCC_CFG1_BTMCLKSEL           			RCC_CFG1_BTMCLKSEL_Msk
N
N#define RCC_CFG1_LCDCLKSEL_Pos         		(1U)
N#define	RCC_CFG1_LCDCLKSEL_Msk						(0x1UL << RCC_CFG1_LCDCLKSEL_Pos)
N#define RCC_CFG1_LCDCLKSEL           			RCC_CFG1_LCDCLKSEL_Msk
N
N#define RCC_CFG1_PWM0CLKSEL_Pos         	(2U)
N#define	RCC_CFG1_PWM0CLKSEL_Msk						(0x1UL << RCC_CFG1_PWM0CLKSEL_Pos)
N#define RCC_CFG1_PWM0CLKSEL           		RCC_CFG1_PWM0CLKSEL_Msk
N
N#define RCC_CFG1_STCLKSEL_Pos         		(5U)
N#define	RCC_CFG1_STCLKSEL_Msk							(0x3UL << RCC_CFG1_STCLKSEL_Pos)
N#define RCC_CFG1_STCLKSEL           			RCC_CFG1_STCLKSEL_Msk
N
N/********************  Bit definition for PLL_CFG register  ********************/
N#define PLL_CFG_PDIVP_Pos         				(0U)
N#define	PLL_CFG_PDIVP_Msk									(0x3UL << PLL_CFG_PDIVP_Pos)
N#define PLL_CFG_PDIVP           					PLL_CFG_PDIVP_Msk
N
N#define PLL_CFG_PLLQEN_Pos         				(5U)
N#define	PLL_CFG_PLLQEN_Msk								(0x1UL << PLL_CFG_PLLQEN_Pos)
N#define PLL_CFG_PLLQEN           					PLL_CFG_PLLQEN_Msk
N
N#define PLL_CFG_PLLREN_Pos         				(6U)
N#define	PLL_CFG_PLLREN_Msk								(0x1UL << PLL_CFG_PLLREN_Pos)
N#define PLL_CFG_PLLREN           					PLL_CFG_PLLREN_Msk
N
N#define PLL_CFG_PLLON_Pos         				(7U)
N#define	PLL_CFG_PLLON_Msk									(0x1UL << PLL_CFG_PLLON_Pos)
N#define PLL_CFG_PLLON           					PLL_CFG_PLLON_Msk
N
N#define PLL_CFG_NDIVN_Pos         				(8U)
N#define	PLL_CFG_NDIVN_Msk									(0xFFUL << PLL_CFG_NDIVN_Pos)
N#define PLL_CFG_NDIVN           					PLL_CFG_NDIVN_Msk
N
N#define PLL_CFG_MDIVM_Pos         				(16U)
N#define	PLL_CFG_MDIVM_Msk									(0x1FUL << PLL_CFG_MDIVM_Pos)
N#define PLL_CFG_MDIVM           					PLL_CFG_MDIVM_Msk
N
N#define PLL_CFG_PLLCLKSEL_Pos         		(23U)
N#define	PLL_CFG_PLLCLKSEL_Msk           	(0x1UL << PLL_CFG_PLLCLKSEL_Pos)
N#define PLL_CFG_PLLCLKSEL           			PLL_CFG_PLLCLKSEL_Msk
N
N/********************  Bit definition for RCC_STS register  ********************/
N#define RCC_STS_CLKFIF_Pos         				(0U)
N#define	RCC_STS_CLKFIF_Msk								(0x1UL << RCC_STS_CLKFIF_Pos)
N#define RCC_STS_CLKFIF           					RCC_STS_CLKFIF_Msk
N
N#define RCC_STS_LOCKERR_Pos         			(1U)
N#define	RCC_STS_LOCKERR_Msk								(0x1UL << RCC_STS_LOCKERR_Pos)
N#define RCC_STS_LOCKERR           				RCC_STS_LOCKERR_Msk
N
N#define RCC_STS_PLLRDY_Pos         				(2U)
N#define	RCC_STS_PLLRDY_Msk								(0x1UL << RCC_STS_PLLRDY_Pos)
N#define RCC_STS_PLLRDY          					RCC_STS_PLLRDY_Msk
N
N/********************  Bit definition for AHB_CFG register  ********************/
N#define AHB_CFG_DMAEN_Pos         				(0U)
N#define	AHB_CFG_DMAEN_Msk									(0x1UL << AHB_CFG_DMAEN_Pos)
N#define AHB_CFG_DMAEN           					AHB_CFG_DMAEN_Msk
N
N#define AHB_CFG_CRCEN_Pos         				(1U)
N#define	AHB_CFG_CRCEN_Msk									(0x1UL << AHB_CFG_CRCEN_Pos)
N#define AHB_CFG_CRCEN           					AHB_CFG_CRCEN_Msk
N
N#define AHB_CFG_IFBEN_Pos         				(2U)
N#define	AHB_CFG_IFBEN_Msk								(0x1UL << AHB_CFG_IFBEN_Pos)          
N#define AHB_CFG_IFBEN           					AHB_CFG_IFBEN_Msk
N
N#define AHB_CFG_CLKDIV_Pos         				(20U)
N#define	AHB_CFG_CLKDIV_Msk								(0x7UL << AHB_CFG_CLKDIV_Pos)
N#define AHB_CFG_CLKDIV           					AHB_CFG_CLKDIV_Msk
N
N/********************  Bit definition for AHB_RST register  ********************/
N#define AHB_RST_DMARST_Pos         				(0U)
N#define	AHB_RST_DMARST_Msk								(0x1UL << AHB_RST_DMARST_Pos)
N#define AHB_RST_DMARST           					AHB_RST_DMARST_Msk
N
N#define AHB_RST_CRCRST_Pos         				(1U)
N#define	AHB_RST_CRCRST_Msk								(0x1UL << AHB_RST_CRCRST_Pos)
N#define AHB_RST_CRCRST           					AHB_RST_CRCRST_Msk
N
N/********************  Bit definition for APB0_CFG register  ********************/
N#define APB0_CFG_TIM0EN_Pos         			(0U)
N#define	APB0_CFG_TIM0EN_Msk								(0x1UL << APB0_CFG_TIM0EN_Pos)
N#define APB0_CFG_TIM0EN           				APB0_CFG_TIM0EN_Msk
N
N#define APB0_CFG_TIM1EN_Pos         			(1U)
N#define	APB0_CFG_TIM1EN_Msk								(0x1UL << APB0_CFG_TIM1EN_Pos)
N#define APB0_CFG_TIM1EN           				APB0_CFG_TIM1EN_Msk
N
N#define APB0_CFG_TIM2EN_Pos         			(2U)
N#define	APB0_CFG_TIM2EN_Msk								(0x1UL << APB0_CFG_TIM2EN_Pos)
N#define APB0_CFG_TIM2EN           				APB0_CFG_TIM2EN_Msk
N
N#define APB0_CFG_TIM3EN_Pos         			(3U)
N#define	APB0_CFG_TIM3EN_Msk								(0x1UL << APB0_CFG_TIM3EN_Pos)
N#define APB0_CFG_TIM3EN           				APB0_CFG_TIM3EN_Msk
N
N#define APB0_CFG_TWI0EN_Pos         			(4U)
N#define	APB0_CFG_TWI0EN_Msk								(0x1UL << APB0_CFG_TWI0EN_Pos)
N#define APB0_CFG_TWI0EN           				APB0_CFG_TWI0EN_Msk
N
N#define APB0_CFG_SPI0EN_Pos         			(5U)
N#define	APB0_CFG_SPI0EN_Msk								(0x1UL << APB0_CFG_SPI0EN_Pos)
N#define APB0_CFG_SPI0EN           				APB0_CFG_SPI0EN_Msk
N
N#define APB0_CFG_UART0EN_Pos         			(6U)
N#define	APB0_CFG_UART0EN_Msk							(0x1UL << APB0_CFG_UART0EN_Pos)
N#define APB0_CFG_UART0EN           				APB0_CFG_UART0EN_Msk
N
N#define APB0_CFG_UART1EN_Pos         			(7U)
N#define	APB0_CFG_UART1EN_Msk							(0x1UL << APB0_CFG_UART1EN_Pos)
N#define APB0_CFG_UART1EN           				APB0_CFG_UART1EN_Msk
N
N#define APB0_CFG_PWM0EN_Pos         			(8U)
N#define	APB0_CFG_PWM0EN_Msk								(0x1UL << APB0_CFG_PWM0EN_Pos)
N#define APB0_CFG_PWM0EN           				APB0_CFG_PWM0EN_Msk
N
N#define APB0_CFG_CLKDIV_Pos         			(20U)
N#define	APB0_CFG_CLKDIV_Msk								(0x7UL << APB0_CFG_CLKDIV_Pos)
N#define APB0_CFG_CLKDIV           				APB0_CFG_CLKDIV_Msk
N
N#define APB0_CFG_ENAPB_Pos         				(23U)
N#define	APB0_CFG_ENAPB_Msk								(0x1UL << APB0_CFG_ENAPB_Pos)
N#define APB0_CFG_ENAPB           					APB0_CFG_ENAPB_Msk
N
N/********************  Bit definition for APB0_RST register  ********************/
N#define APB0_RST_TIM0RST_Pos         			(0U)
N#define	APB0_RST_TIM0RST_Msk							(0x1UL << APB0_RST_TIM0RST_Pos)
N#define APB0_RST_TIM0RST           				APB0_RST_TIM0RST_Msk
N
N#define APB0_RST_TIM1RST_Pos         			(1U)
N#define	APB0_RST_TIM1RST_Msk							(0x1UL << APB0_RST_TIM1RST_Pos)
N#define APB0_RST_TIM1RST           				APB0_RST_TIM1RST_Msk
N
N#define APB0_RST_TIM2RST_Pos         			(2U)
N#define	APB0_RST_TIM2RST_Msk							(0x1UL << APB0_RST_TIM2RST_Pos)
N#define APB0_RST_TIM2RST           				APB0_RST_TIM2RST_Msk
N
N#define APB0_RST_TIM3RST_Pos         			(3U)
N#define	APB0_RST_TIM3RST_Msk							(0x1UL << APB0_RST_TIM3RST_Pos)
N#define APB0_RST_TIM3RST           				APB0_RST_TIM3RST_Msk
N
N#define APB0_RST_TWI0RST_Pos         			(4U)
N#define	APB0_RST_TWI0RST_Msk							(0x1UL << APB0_RST_TWI0RST_Pos)
N#define APB0_RST_TWI0RST           				APB0_RST_TWI0RST_Msk
N
N#define APB0_RST_SPI0RST_Pos         			(5U)
N#define	APB0_RST_SPI0RST_Msk							(0x1UL << APB0_RST_SPI0RST_Pos)
N#define APB0_RST_SPI0RST           				APB0_RST_SPI0RST_Msk
N
N#define APB0_RST_UART0RST_Pos         		(6U)
N#define	APB0_RST_UART0RST_Msk							(0x1UL << APB0_RST_UART0RST_Pos)
N#define APB0_RST_UART0RST           			APB0_RST_UART0RST_Msk
N
N#define APB0_RST_UART1RST_Pos         		(7U)
N#define	APB0_RST_UART1RST_Msk							(0x1UL << APB0_RST_UART1RST_Pos)
N#define APB0_RST_UART1RST           			APB0_RST_UART1RST_Msk
N
N#define APB0_RST_PWM0RST_Pos         			(8U)
N#define	APB0_RST_PWM0RST_Msk							(0x1UL << APB0_RST_PWM0RST_Pos)
N#define APB0_RST_PWM0RST           				APB0_RST_PWM0RST_Msk
N
N
N/********************  Bit definition for APB1_CFG register  ********************/
N#define APB1_CFG_TIM4EN_Pos         			(0U)
N#define	APB1_CFG_TIM4EN_Msk								(0x1UL << APB1_CFG_TIM4EN_Pos)
N#define APB1_CFG_TIM4EN           				APB1_CFG_TIM4EN_Msk
N
N#define APB1_CFG_TIM5EN_Pos         			(1U)
N#define	APB1_CFG_TIM5EN_Msk								(0x1UL << APB1_CFG_TIM5EN_Pos)
N#define APB1_CFG_TIM5EN           				APB1_CFG_TIM5EN_Msk
N
N#define APB1_CFG_TIM6EN_Pos         			(2)
N#define	APB1_CFG_TIM6EN_Msk								(0x1UL << APB1_CFG_TIM6EN_Pos)
N#define APB1_CFG_TIM6EN           				APB1_CFG_TIM6EN_Msk
N
N#define APB1_CFG_TIM7EN_Pos         			(3U)
N#define	APB1_CFG_TIM7EN_Msk								(0x1UL << APB1_CFG_TIM7EN_Pos)
N#define APB1_CFG_TIM7EN           				APB1_CFG_TIM7EN_Msk
N
N#define APB1_CFG_TWI1EN_Pos         			(4U)
N#define	APB1_CFG_TWI1EN_Msk								(0x1UL << APB1_CFG_TWI1EN_Pos)
N#define APB1_CFG_TWI1EN           				APB1_CFG_TWI1EN_Msk
N
N#define APB1_CFG_UART2EN_Pos         			(7U)
N#define	APB1_CFG_UART2EN_Msk							(0x1UL << APB1_CFG_UART2EN_Pos)
N#define APB1_CFG_UART2EN           				APB1_CFG_UART2EN_Msk
N
N#define APB1_CFG_CLKDIV_Pos         			(20U)
N#define	APB1_CFG_CLKDIV_Msk								(0x7UL << APB1_CFG_CLKDIV_Pos)
N#define APB1_CFG_CLKDIV           				APB1_CFG_CLKDIV_Msk
N
N#define APB1_CFG_ENAPB_Pos         				(23U)
N#define	APB1_CFG_ENAPB_Msk								(0x1UL << APB1_CFG_ENAPB_Pos)
N#define APB1_CFG_ENAPB           					APB1_CFG_ENAPB_Msk
N
N/********************  Bit definition for APB1_RST register  ********************/
N#define APB1_RST_TIM4EN_Pos         			(0U)
N#define	APB1_RST_TIM4EN_Msk								(0x1UL << APB1_RST_TIM4EN_Pos)
N#define APB1_RST_TIM4EN           				APB1_RST_TIM4EN_Msk
N
N#define APB1_RST_TIM5EN_Pos         			(1U)
N#define	APB1_RST_TIM5EN_Msk								(0x1UL << APB1_RST_TIM5EN_Pos)
N#define APB1_RST_TIM5EN           				APB1_RST_TIM5EN_Msk
N
N#define APB1_RST_TIM6EN_Pos         			(2)
N#define	APB1_RST_TIM6EN_Msk								(0x1UL << APB1_RST_TIM6EN_Pos)
N#define APB1_RST_TIM6EN           				APB1_RST_TIM6EN_Msk
N
N#define APB1_RST_TIM7EN_Pos         			(3U)
N#define	APB1_RST_TIM7EN_Msk								(0x1UL << APB1_RST_TIM7EN_Pos)
N#define APB1_RST_TIM7EN           				APB1_RST_TIM7EN_Msk
N
N#define APB1_RST_TWI1EN_Pos         			(4U)
N#define	APB1_RST_TWI1EN_Msk								(0x1UL << APB1_RST_TWI1EN_Pos)
N#define APB1_RST_TWI1EN           				APB1_RST_TWI1EN_Msk
N
N#define APB1_RST_UART2EN_Pos         			(7U)
N#define	APB1_RST_UART2EN_Msk							(0x1UL << APB1_RST_UART2EN_Pos)
N#define APB1_RST_UART2EN           				APB1_RST_UART2EN_Msk
N
N/********************  Bit definition for APB2_CFG register  ********************/
N#define APB2_CFG_LEDPWMEN_Pos         			(0U)
N#define	APB2_CFG_LEDPWMEN_Msk								(0x1UL << APB2_CFG_LEDPWMEN_Pos)
N#define APB2_CFG_LEDPWMEN           				APB2_CFG_LEDPWMEN_Msk
N
N#define APB2_CFG_LCDEN_Pos         				(0U)
N#define	APB2_CFG_LCDEN_Msk								(0x3UL << APB2_CFG_LCDEN_Pos)
N#define APB2_CFG_LCDEN           					APB2_CFG_LCDEN_Msk
N
N#define APB2_CFG_UART3EN_Pos         			(2U)
N#define	APB2_CFG_UART3EN_Msk							(0x1UL << APB2_CFG_UART3EN_Pos)
N#define APB2_CFG_UART3EN           				APB2_CFG_UART3EN_Msk
N
N#define APB2_CFG_CLKDIV_Pos         			(20U)
N#define	APB2_CFG_CLKDIV_Msk								(0x7UL << APB2_CFG_CLKDIV_Pos)
N#define APB2_CFG_CLKDIV           				APB2_CFG_CLKDIV_Msk
N
N#define APB2_CFG_ENAPB_Pos         				(23U)
N#define	APB2_CFG_ENAPB_Msk								(0x1UL << APB2_CFG_ENAPB_Pos)
N#define APB2_CFG_ENAPB           					APB2_CFG_ENAPB_Msk
N
N/********************  Bit definition for APB2_RST register  ********************/
N#define APB2_RST_LEDPWMRST_Pos         			(0U)
N#define	APB2_RST_LEDPWMRST_Msk							(0x1UL << APB2_RST_LEDPWMRST_Pos)
N#define APB2_RST_LEDPWMRST          				APB2_CFG_LEDPWMEN_Msk
N
N#define APB2_RST_LCDRST_Pos         			(1U)
N#define	APB2_RST_LCDRST_Msk								(0x1UL << APB2_RST_LCDRST_Pos)
N#define APB2_RST_LCDRST           				APB2_RST_LCDRST_Msk
N
N#define APB2_RST_UART3RST_Pos         		(2U)
N#define	APB2_RST_UART3RST_Msk							(0x1UL << APB2_RST_UART3RST_Pos)
N#define APB2_RST_UART3RST           			APB2_RST_UART3RST_Msk
N
N
N/************private bit *************************************/
N#define APB0_CFG_RDMODE_Pos         			(31U)
N#define	APB0_CFG_RDMODE_Msk								(0x1UL << APB0_CFG_RDMODE_Pos)
N#define APB0_CFG_RDMODE           				APB0_CFG_RDMODE_Msk
N
N#define APB1_CFG_RDMODE_Pos         			(31U)
N#define	APB1_CFG_RDMODE_Msk								(0x1UL << APB1_CFG_RDMODE_Pos)
N#define APB1_CFG_RDMODE           				APB1_CFG_RDMODE_Msk
N
N#define APB2_CFG_RDMODE_Pos         			(31U)
N#define	APB2_CFG_RDMODE_Msk								(0x1UL << APB2_CFG_RDMODE_Pos)
N#define APB2_CFG_RDMODE           				APB2_CFG_RDMODE_Msk
N/********************  Bit definition for NMI_CFG register  ********************/ 
N#define NMI_CFG_CSSEN_Pos         			  (0U)
N#define	NMI_CFG_CSSEN_Msk							    (0x1UL << NMI_CFG_CSSEN_Pos)          
N#define NMI_CFG_CSSEN          			    	NMI_CFG_CSSEN_Msk
N
N#define NMI_CFG_CMPEN_Pos         			  (1U)
N#define	NMI_CFG_CMPEN_Msk							    (0x1UL << NMI_CFG_CMPEN_Pos)          
N#define NMI_CFG_CMPEN          			    	NMI_CFG_CMPEN_Msk
N
N#define NMI_CFG_INT0EN_Pos         			  (2U)
N#define	NMI_CFG_INT0EN_Msk							  (0x1UL << NMI_CFG_INT0EN_Pos)          
N#define NMI_CFG_INT0EN          			    NMI_CFG_INT0EN_Msk
N/******************************************************************************/
N/*                                                                            */
N/*                      ADC                    */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for ADC_CON register  ********************/
N#define ADC_CON_ADCIS_Pos         				(0U)
N#define	ADC_CON_ADCIS_Msk									(0x1FUL << ADC_CON_ADCIS_Pos)
N#define ADC_CON_ADCIS          						ADC_CON_ADCIS_Msk
N
N#define ADC_CON_ADCS_Pos         					(7U)
N#define	ADC_CON_ADCS_Msk									(0x1UL << ADC_CON_ADCS_Pos)
N#define ADC_CON_ADCS          						ADC_CON_ADCS_Msk
N
N#define ADC_CON_INTEN_Pos         				(8U)
N#define	ADC_CON_INTEN_Msk									(0x1UL << ADC_CON_INTEN_Pos)
N#define ADC_CON_INTEN          						ADC_CON_INTEN_Msk
N
N#define ADC_CON_CONT_Pos         					(11U)
N#define	ADC_CON_CONT_Msk									(0x1UL << ADC_CON_CONT_Pos)
N#define ADC_CON_CONT          						ADC_CON_CONT_Msk
N
N#define ADC_CON_DMAEN_Pos         				(12U)
N#define	ADC_CON_DMAEN_Msk									(0x1UL << ADC_CON_DMAEN_Pos)
N#define ADC_CON_DMAEN          						ADC_CON_DMAEN_Msk
N
N#define ADC_CON_ADCEN_Pos         				(15U)
N#define	ADC_CON_ADCEN_Msk									(0x1UL << ADC_CON_ADCEN_Pos)
N#define ADC_CON_ADCEN          						ADC_CON_ADCEN_Msk
N
N#define ADC_CON_LOWSP_Pos         				(16U)
N#define	ADC_CON_LOWSP_Msk									(0x7UL << ADC_CON_LOWSP_Pos)
N#define ADC_CON_LOWSP          						ADC_CON_LOWSP_Msk
N
N#define ADC_CON_VREFS_Pos         				(20U)
N#define	ADC_CON_VREFS_Msk									(0x3UL << ADC_CON_VREFS_Pos)
N#define ADC_CON_VREFS          						ADC_CON_VREFS_Msk
N/********************  Bit definition for ADC_STS register  ********************/
N#define ADC_STS_EOC_Pos         					(0U)
N#define	ADC_STS_EOC_Msk										(0x01UL << ADC_STS_EOC_Pos)
N#define ADC_STS_EOC          							ADC_STS_EOC_Msk
N
N/********************  Bit definition for ADC_CFG register  ********************/
N#define ADC_CFG_AIN0_Pos         					(0U)
N#define	ADC_CFG_AIN0_Msk									(0x1L << ADC_CFG_AIN0_Pos)
N#define ADC_CFG_AIN0          						ADC_CFG_AIN0_Msk
N
N#define ADC_CFG_AIN1_Pos         					(1U)
N#define	ADC_CFG_AIN1_Msk									(0x1L << ADC_CFG_AIN1_Pos)
N#define ADC_CFG_AIN1          						ADC_CFG_AIN1_Msk
N
N#define ADC_CFG_AIN2_Pos         					(2U)
N#define	ADC_CFG_AIN2_Msk									(0x1L << ADC_CFG_AIN2_Pos)
N#define ADC_CFG_AIN2          						ADC_CFG_AIN2_Msk
N
N#define ADC_CFG_AIN3_Pos         					(3U)
N#define	ADC_CFG_AIN3_Msk									(0x1L << ADC_CFG_AIN3_Pos)
N#define ADC_CFG_AIN3          						ADC_CFG_AIN3_Msk
N
N#define ADC_CFG_AIN4_Pos         					(4U)
N#define	ADC_CFG_AIN4_Msk									(0x1L << ADC_CFG_AIN4_Pos)
N#define ADC_CFG_AIN4          						ADC_CFG_AIN4_Msk
N
N#define ADC_CFG_AIN5_Pos         					(5U)
N#define	ADC_CFG_AIN5_Msk									(0x1L << ADC_CFG_AIN5_Pos)
N#define ADC_CFG_AIN5          						ADC_CFG_AIN5_Msk
N
N#define ADC_CFG_AIN6_Pos         					(6U)
N#define	ADC_CFG_AIN6_Msk									(0x1L << ADC_CFG_AIN6_Pos)
N#define ADC_CFG_AIN6          						ADC_CFG_AIN6_Msk
N
N#define ADC_CFG_AIN7_Pos         					(7U)
N#define	ADC_CFG_AIN7_Msk									(0x1L << ADC_CFG_AIN7_Pos)
N#define ADC_CFG_AIN7          						ADC_CFG_AIN7_Msk
N
N#define ADC_CFG_AIN8_Pos         					(8U)
N#define	ADC_CFG_AIN8_Msk									(0x1L << ADC_CFG_AIN8_Pos)
N#define ADC_CFG_AIN8          						ADC_CFG_AIN8_Msk
N
N#define ADC_CFG_AIN9_Pos         					(9U)
N#define	ADC_CFG_AIN9_Msk									(0x1L << ADC_CFG_AIN9_Pos)
N#define ADC_CFG_AIN9          						ADC_CFG_AIN9_Msk
N
N#define ADC_CFG_AIN10_Pos         				(10U)
N#define	ADC_CFG_AIN10_Msk									(0x1L << ADC_CFG_AIN10_Pos)
N#define ADC_CFG_AIN10          						ADC_CFG_AIN10_Msk
N
N#define ADC_CFG_AIN11_Pos         				(11U)
N#define	ADC_CFG_AIN11_Msk									(0x1L << ADC_CFG_AIN11_Pos)
N#define ADC_CFG_AIN11          						ADC_CFG_AIN11_Msk
N
N#define ADC_CFG_AIN12_Pos         				(12U)
N#define	ADC_CFG_AIN12_Msk									(0x1L << ADC_CFG_AIN12_Pos)
N#define ADC_CFG_AIN12          						ADC_CFG_AIN12_Msk
N
N#define ADC_CFG_AIN13_Pos         				(13U)
N#define	ADC_CFG_AIN13_Msk									(0x1L << ADC_CFG_AIN13_Pos)
N#define ADC_CFG_AIN13          						ADC_CFG_AIN13_Msk
N
N#define ADC_CFG_AIN14_Pos         				(14U)
N#define	ADC_CFG_AIN14_Msk									(0x1L << ADC_CFG_AIN14_Pos)
N#define ADC_CFG_AIN14          						ADC_CFG_AIN14_Msk
N
N#define ADC_CFG_AIN15_Pos         				(15U)
N#define	ADC_CFG_AIN15_Msk									(0x1L << ADC_CFG_AIN15_Pos)
N#define ADC_CFG_AIN15          						ADC_CFG_AIN15_Msk
N
N#define ADC_CFG_AIN16_Pos         				(16U)
N#define	ADC_CFG_AIN16_Msk									(0x1L << ADC_CFG_AIN16_Pos)
N#define ADC_CFG_AIN16          						ADC_CFG_AIN16_Msk
N
N/********************  Bit definition for ADC_ADCV register  ********************/
N#define ADC_ADCV_OVERRUN_Pos         			(31U)
N#define	ADC_CFG_OVERRUN_Msk								(0x1L << ADC_ADCV_OVERRUN_Pos)
N#define ADC_CFG_OVERRUN          					ADC_CFG_OVERRUN_Msk
N
N/******************************************************************************/
N/*                                                                            */
N/*                      BTM                    */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for BTM_CON register  ********************/
N#define BTM_CON_BTMFS_Pos         				(0U)
N#define	BTM_CON_BTMFS_Msk									(0x0FL << BTM_CON_BTMFS_Pos)
N#define BTM_CON_BTMFS          						BTM_CON_BTMFS_Msk
N
N#define BTM_CON_INTEN_Pos         				(6U)
N#define	BTM_CON_INTEN_Msk									(0x1L << BTM_CON_INTEN_Pos)
N#define BTM_CON_INTEN          						BTM_CON_INTEN_Msk
N
N#define BTM_CON_BTMEN_Pos         				(7U)
N#define	BTM_CON_BTMEN_Msk									(0x1L << BTM_CON_BTMEN_Pos)
N#define BTM_CON_BTMEN          						BTM_CON_BTMEN_Msk
N
N/********************  Bit definition for BTM_STS register  ********************/
N#define BTM_STS_BTMIF_Pos         				(0U)
N#define	BTM_STS_BTMIF_Msk                 (0x1L << BTM_STS_BTMIF_Pos)
N#define BTM_STS_BTMIF                     BTM_STS_BTMIF_Msk
N
N/******************************************************************************/
N/*                                                                            */
N/*                      CMP                    */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for CMP_CFG register  ********************/
N#define CMP_CFG_CMPIS_Pos         				(0U)
N#define	CMP_CFG_CMPIS_Msk									(0x3L << CMP_CFG_CMPIS_Pos)
N#define CMP_CFG_CMPIS          						CMP_CFG_CMPIS_Msk
N
N#define CMP_CFG_CMPP_Pos         					(4U)
N#define	CMP_CFG_CMPP_Msk									(0x1L << CMP_CFG_CMPP_Pos)
N#define CMP_CFG_CMPP          						CMP_CFG_CMPP_Msk
N
N#define CMP_CFG_CMPIM_Pos         				(5U)
N#define	CMP_CFG_CMPIM_Msk									(0x3L << CMP_CFG_CMPIM_Pos)
N#define CMP_CFG_CMPIM          						CMP_CFG_CMPIM_Msk
N
N#define CMP_CFG_CMPEN_Pos         				(7U)
N#define	CMP_CFG_CMPEN_Msk									(0x1L << CMP_CFG_CMPEN_Pos)
N#define CMP_CFG_CMPEN         						CMP_CFG_CMPEN_Msk
N
N#define CMP_CFG_CMPRF_Pos         				(8U)
N#define	CMP_CFG_CMPRF_Msk									(0x0FL << CMP_CFG_CMPRF_Pos)
N#define CMP_CFG_CMPRF        							CMP_CFG_CMPRF_Msk
N/********************  Bit definition for CMP_STS register  ********************/
N#define CMP_STS_CMPIF_Pos         				(0U)
N#define	CMP_STS_CMPIF_Msk									(0x1L << CMP_STS_CMPIF_Pos)
N#define CMP_STS_CMPIF          						CMP_STS_CMPIF_Msk
N
N#define CMP_STS_CMPSTA_Pos         				(1U)
N#define	CMP_STS_CMPSTA_Msk								(0x1L << CMP_STS_CMPSTA_Pos)
N#define CMP_STS_CMPSTA          					CMP_STS_CMPSTA_Msk
N/******************************************************************************/
N/*                                                                            */
N/*                      CRC                   */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for CRC_CON register  ********************/
N#define CRC_CON_CRCRST_Pos         				(0U)
N#define	CRC_CON_CRCRST_Msk								(0x1L << CRC_CON_CRCRST_Pos)
N#define CRC_CON_CRCRST          					CRC_CON_CRCRST_Msk
N
N#define CRC_CON_POLYSIZE_Pos         			(6U)
N#define	CRC_CON_POLYSIZE_Msk							(0x3L << CRC_CON_POLYSIZE_Pos)
N#define CRC_CON_POLYSIZE          				CRC_CON_POLYSIZE_Msk
N
N/******************************************************************************/
N/*                                                                            */
N/*                      DMA                   																*/
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for DMA_CFG register  ********************/
N#define DMA_CFG_PL_Pos         						(0U)
N#define	DMA_CFG_PL_Msk										(0x3L << DMA_CFG_PL_Pos)
N#define DMA_CFG_PL          							DMA_CFG_PL_Msk
N
N#define DMA_CFG_TXWIDTH_Pos         			(2U)
N#define	DMA_CFG_TXWIDTH_Msk							(0x3L << DMA_CFG_TXWIDTH_Pos)
N#define DMA_CFG_TXWIDTH          				DMA_CFG_TXWIDTH_Msk
N
N#define DMA_CFG_CIRC_Pos         					(4U)
N#define	DMA_CFG_CIRC_Msk									(0x1L << DMA_CFG_CIRC_Pos)
N#define DMA_CFG_CIRC          						DMA_CFG_CIRC_Msk
N
N#define DMA_CFG_PAUSE_Pos         				(5U)
N#define	DMA_CFG_PAUSE_Msk									(0x1L << DMA_CFG_PAUSE_Pos)
N#define DMA_CFG_PAUSE          						DMA_CFG_PAUSE_Msk
N
N#define DMA_CFG_CHRST_Pos         				(6U)
N#define	DMA_CFG_CHRST_Msk									(0x1L << DMA_CFG_CHRST_Pos)
N#define DMA_CFG_CHRST          						DMA_CFG_CHRST_Msk
N
N#define DMA_CFG_CHEN_Pos         					(7U)
N#define	DMA_CFG_CHEN_Msk									(0x1L << DMA_CFG_CHEN_Pos)
N#define DMA_CFG_CHEN          						DMA_CFG_CHEN_Msk
N
N#define DMA_CFG_DAINC_Pos         				(8U)
N#define	DMA_CFG_DAINC_Msk									(0x3L << DMA_CFG_DAINC_Pos)
N#define DMA_CFG_DAINC         						DMA_CFG_DAINC_Msk
N
N#define DMA_CFG_SAINC_Pos         				(10U)
N#define	DMA_CFG_SAINC_Msk									(0x3L << DMA_CFG_SAINC_Pos)
N#define DMA_CFG_SAINC         						DMA_CFG_SAINC_Msk
N
N#define DMA_CFG_BURSIZE_Pos         			(12U)
N#define	DMA_CFG_BURSIZE_Msk								(0x7L << DMA_CFG_BURSIZE_Pos)
N#define DMA_CFG_BURSIZE         					DMA_CFG_BURSIZE_Msk
N
N#define DMA_CFG_TPTYPE_Pos         				(15U)
N#define	DMA_CFG_TPTYPE_Msk								(0x1L << DMA_CFG_TPTYPE_Pos)
N#define DMA_CFG_TPTYPE        						DMA_CFG_TPTYPE_Msk
N
N#define DMA_CFG_INTEN_Pos         				(16U)
N#define	DMA_CFG_INTEN_Msk									(0x1L << DMA_CFG_INTEN_Pos)
N#define DMA_CFG_INTEN        							DMA_CFG_INTEN_Msk
N
N#define DMA_CFG_TCIE_Pos         					(17U)
N#define	DMA_CFG_TCIE_Msk									(0x1L << DMA_CFG_TCIE_Pos)
N#define DMA_CFG_TCIE        							DMA_CFG_TCIE_Msk
N
N#define DMA_CFG_HTIE_Pos         					(18U)
N#define	DMA_CFG_HTIE_Msk									(0x1L << DMA_CFG_HTIE_Pos)
N#define DMA_CFG_HTIE        							DMA_CFG_HTIE_Msk
N
N#define DMA_CFG_TEIE_Pos         					(19U)
N#define	DMA_CFG_TEIE_Msk									(0x1L << DMA_CFG_TEIE_Pos)
N#define DMA_CFG_TEIE        							DMA_CFG_TEIE_Msk
N
N#define DMA_CFG_CHRQ_Pos         					(23U)
N#define	DMA_CFG_CHRQ_Msk									(0x1L << DMA_CFG_CHRQ_Pos)
N#define DMA_CFG_CHRQ        							DMA_CFG_CHRQ_Msk
N
N
N#define DMA_CFG_REQSRC_Pos         				(24U)
N#define	DMA_CFG_REQSRC_Msk								(0x3FL << DMA_CFG_CHRQ_Pos)
N#define DMA_CFG_REQSRC        						DMA_CFG_CHRQ_Msk
N
N/********************  Bit definition for DMA_STS register  ********************/
N#define DMA_STS_GIF_Pos         					(0U)
N#define	DMA_STS_GIF_Msk										(0x1L << DMA_STS_GIF_Pos)
N#define DMA_STS_GIF        								DMA_STS_GIF_Msk
N
N#define DMA_STS_TCIF_Pos         					(1U)
N#define	DMA_STS_TCIF_Msk									(0x1L << DMA_STS_TCIF_Pos)
N#define DMA_STS_TCIF        							DMA_STS_TCIF_Msk
N
N#define DMA_STS_HTIF_Pos         					(2U)
N#define	DMA_STS_HTIF_Msk									(0x1L << DMA_STS_HTIF_Pos)
N#define DMA_STS_HTIF        							DMA_STS_HTIF_Msk
N
N#define DMA_STS_TEIF_Pos         					(3U)
N#define	DMA_STS_TEIF_Msk									(0x1L << DMA_STS_TEIF_Pos)
N#define DMA_STS_TEIF        							DMA_STS_TEIF_Msk
N
N#define DMA_STS_STATUS_Pos         				(4U)
N#define	DMA_STS_STATUS_Msk								(0x0FL << DMA_STS_STATUS_Pos)
N#define DMA_STS_STATUS        						DMA_STS_STATUS_Msk
N
N#define DMA_STS_SWREQ_Pos         				(8U)
N#define	DMA_STS_SWREQ_Msk									(0x1L << DMA_STS_SWREQ_Pos)
N#define DMA_STS_SWREQ       							DMA_STS_SWREQ_Msk
N
N/******************************************************************************/
N/*                                                                            */
N/*                      IAP                   																*/
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for IAP_CON register  ********************/
N#define IAP_CON_CMD_Pos         					(0U)
N#define	IAP_CON_CMD_Msk										(0x3L << IAP_CON_CMD_Pos)
N#define IAP_CON_CMD          							IAP_CON_CMD_Msk
N
N#define IAP_CON_PRG_Pos         					(4U)
N#define	IAP_CON_PRG_Msk										(0x1L << IAP_CON_PRG_Pos)
N#define IAP_CON_PRG         							IAP_CON_PRG_Msk
N
N#define IAP_CON_SERASE_Pos         				(5U)
N#define	IAP_CON_SERASE_Msk								(0x1L << IAP_CON_SERASE_Pos)
N#define IAP_CON_SERASE         						IAP_CON_SERASE_Msk
N
N#define IAP_CON_ERASE_Pos         				(7U)
N#define	IAP_CON_ERASE_Msk									(0x1L << IAP_CON_ERASE_Pos)
N#define IAP_CON_ERASE         						IAP_CON_ERASE_Msk
N
N#define IAP_CON_RST_Pos         					(8U)
N#define	IAP_CON_RST_Msk										(0x1L << IAP_CON_RST_Pos)
N#define IAP_CON_RST         							IAP_CON_RST_Msk
N
N#define IAP_CON_BTLD_Pos         					(9U)
N#define	IAP_CON_BTLD_Msk									(0x3L << IAP_CON_BTLD_Pos)
N#define IAP_CON_BTLD         							IAP_CON_BTLD_Msk
N
N#define IAP_CON_LOCK_Pos         					(31)
N#define	IAP_CON_LOCK_Msk									(0x1UL << IAP_CON_LOCK_Pos)     	//V0.12     
N#define IAP_CON_LOCK         							IAP_CON_LOCK_Msk
N
N/******************************************************************************/
N/*                                                                            */
N/*                      INT                   																*/
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for INT_FIE register  ********************/
N#define INT_FIE_ENF0_Pos         				(0U)
N#define	INT_FIE_ENF0_Msk									(0x1L << INT_FIE_ENF0_Pos)
N#define INT_FIE_ENF0          						INT_FIE_ENF0_Msk
N
N#define INT_FIE_ENF1_Pos         				(1U)
N#define	INT_FIE_ENF1_Msk									(0x1L << INT_FIE_ENF1_Pos)
N#define INT_FIE_ENF1          						INT_FIE_ENF1_Msk
N
N#define INT_FIE_ENF2_Pos         				(2U)
N#define	INT_FIE_ENF2_Msk									(0x1L << INT_FIE_ENF2_Pos)
N#define INT_FIE_ENF2          						INT_FIE_ENF2_Msk
N
N#define INT_FIE_ENF3_Pos         				(3U)
N#define	INT_FIE_ENF3_Msk									(0x1L << INT_FIE_ENF3_Pos)
N#define INT_FIE_ENF3          						INT_FIE_ENF3_Msk
N
N#define INT_FIE_ENF4_Pos         				(4U)
N#define	INT_FIE_ENF4_Msk									(0x1L << INT_FIE_ENF4_Pos)
N#define INT_FIE_ENF4          						INT_FIE_ENF4_Msk
N
N#define INT_FIE_ENF5_Pos         				(5U)
N#define	INT_FIE_ENF5_Msk									(0x1L << INT_FIE_ENF5_Pos)
N#define INT_FIE_ENF5          						INT_FIE_ENF5_Msk
N
N#define INT_FIE_ENF6_Pos         				(6U)
N#define	INT_FIE_ENF6_Msk									(0x1L << INT_FIE_ENF6_Pos)
N#define INT_FIE_ENF6          						INT_FIE_ENF6_Msk
N
N#define INT_FIE_ENF7_Pos         				(7U)
N#define	INT_FIE_ENF7_Msk									(0x1L << INT_FIE_ENF7_Pos)
N#define INT_FIE_ENF7          						INT_FIE_ENF7_Msk
N
N#define INT_FIE_ENF8_Pos         				(8U)
N#define	INT_FIE_ENF8_Msk									(0x1L << INT_FIE_ENF8_Pos)
N#define INT_FIE_ENF8          						INT_FIE_ENF8_Msk
N
N#define INT_FIE_ENF9_Pos         				(9U)
N#define	INT_FIE_ENF9_Msk									(0x1L << INT_FIE_ENF9_Pos)
N#define INT_FIE_ENF9          						INT_FIE_ENF9_Msk
N
N#define INT_FIE_ENF10_Pos         				(10U)
N#define	INT_FIE_ENF10_Msk								(0x1L << INT_FIE_ENF10_Pos)
N#define INT_FIE_ENF10          					INT_FIE_ENF10_Msk
N
N#define INT_FIE_ENF11_Pos         				(11U)
N#define	INT_FIE_ENF11_Msk								(0x1L << INT_FIE_ENF11_Pos)
N#define INT_FIE_ENF11          					INT_FIE_ENF11_Msk
N
N#define INT_FIE_ENF12_Pos         				(12U)
N#define	INT_FIE_ENF12_Msk								(0x1L << INT_FIE_ENF12_Pos)
N#define INT_FIE_ENF12          					INT_FIE_ENF12_Msk
N
N#define INT_FIE_ENF13_Pos         				(13U)
N#define	INT_FIE_ENF13_Msk								(0x1L << INT_FIE_ENF13_Pos)
N#define INT_FIE_ENF13          					INT_FIE_ENF13_Msk
N
N#define INT_FIE_ENF14_Pos         				(14U)
N#define	INT_FIE_ENF14_Msk								(0x1L << INT_FIE_ENF14_Pos)
N#define INT_FIE_ENF14          					INT_FIE_ENF14_Msk
N
N#define INT_FIE_ENF15_Pos         				(15U)
N#define	INT_FIE_ENF15_Msk								(0x1L << INT_FIE_ENF15_Pos)
N#define INT_FIE_ENF15          					INT_FIE_ENF15_Msk
N/********************  Bit definition for INT_RIE register  ********************/
N#define INT_RIE_ENR0_Pos         				(0U)
N#define	INT_RIE_ENR0_Msk									(0x1L << INT_RIE_ENR0_Pos)
N#define INT_RIE_ENR0          						INT_RIE_ENR0_Msk
N
N#define INT_RIE_ENR1_Pos         				(1U)
N#define	INT_RIE_ENR1_Msk									(0x1L << INT_RIE_ENR1_Pos)
N#define INT_RIE_ENR1          						INT_RIE_ENR1_Msk
N
N#define INT_RIE_ENR2_Pos         				(2U)
N#define	INT_RIE_ENR2_Msk									(0x1L << INT_RIE_ENR2_Pos)
N#define INT_RIE_ENR2          						INT_RIE_ENR2_Msk
N
N#define INT_RIE_ENR3_Pos         				(3U)
N#define	INT_RIE_ENR3_Msk									(0x1L << INT_RIE_ENR3_Pos)
N#define INT_RIE_ENR3          						INT_RIE_ENR3_Msk
N
N#define INT_RIE_ENR4_Pos         				(4U)
N#define	INT_RIE_ENR4_Msk									(0x1L << INT_RIE_ENR4_Pos)
N#define INT_RIE_ENR4          						INT_RIE_ENR4_Msk
N
N#define INT_RIE_ENR5_Pos         				(5U)
N#define	INT_RIE_ENR5_Msk									(0x1L << INT_RIE_ENR5_Pos)
N#define INT_RIE_ENR5          						INT_RIE_ENR5_Msk
N
N#define INT_RIE_ENR6_Pos         				(6U)
N#define	INT_RIE_ENR6_Msk									(0x1L << INT_RIE_ENR6_Pos)
N#define INT_RIE_ENR6          						INT_RIE_ENR6_Msk
N
N#define INT_RIE_ENR7_Pos         				(7U)
N#define	INT_RIE_ENR7_Msk									(0x1L << INT_RIE_ENR7_Pos)
N#define INT_RIE_ENR7          						INT_RIE_ENR7_Msk
N
N#define INT_RIE_ENR8_Pos         				(8U)
N#define	INT_RIE_ENR8_Msk									(0x1L << INT_RIE_ENR8_Pos)
N#define INT_RIE_ENR8          						INT_RIE_ENR8_Msk
N
N#define INT_RIE_ENR9_Pos         				(9U)
N#define	INT_RIE_ENR9_Msk									(0x1L << INT_RIE_ENR9_Pos)
N#define INT_RIE_ENR9          						INT_RIE_ENR9_Msk
N
N#define INT_RIE_ENR10_Pos         				(10U)
N#define	INT_RIE_ENR10_Msk								(0x1L << INT_RIE_ENR10_Pos)
N#define INT_RIE_ENR10          					INT_RIE_ENR10_Msk
N
N#define INT_RIE_ENR11_Pos         				(11U)
N#define	INT_RIE_ENR11_Msk								(0x1L << INT_RIE_ENR11_Pos)
N#define INT_RIE_ENR11          					INT_RIE_ENR11_Msk
N
N#define INT_RIE_ENR12_Pos         				(12U)
N#define	INT_RIE_ENR12_Msk								(0x1L << INT_RIE_ENR12_Pos)
N#define INT_RIE_ENR12          					INT_RIE_ENR12_Msk
N
N#define INT_RIE_ENR13_Pos         				(13U)
N#define	INT_RIE_ENR13_Msk								(0x1L << INT_RIE_ENR13_Pos)
N#define INT_RIE_ENR13          					INT_RIE_ENR13_Msk
N
N#define INT_RIE_ENR14_Pos         				(14U)
N#define	INT_RIE_ENR14_Msk								(0x1L << INT_RIE_ENR14_Pos)
N#define INT_RIE_ENR14          					INT_RIE_ENR14_Msk
N
N#define INT_RIE_ENR15_Pos         				(15U)
N#define	INT_RIE_ENR15_Msk								(0x1L << INT_RIE_ENR15_Pos)
N#define INT_RIE_ENR15          					INT_RIE_ENR15_Msk
N
N/********************  Bit definition for INT_SEL0 register  ********************/
N#define INT_SEL0_INT0SEL_Pos         		(0U)
N#define	INT_SEL0_INT0SEL_Msk							(0x0FL << INT_SEL0_INT0SEL_Pos)
N#define INT_SEL0_INT0SEL          				INT_SEL0_INT0SEL_Msk
N
N#define INT_SEL0_INT1SEL_Pos         		(4U)
N#define	INT_SEL0_INT1SEL_Msk							(0x0FL << INT_SEL0_INT1SEL_Pos)
N#define INT_SEL0_INT1SEL          				INT_SEL0_INT1SEL_Msk
N
N#define INT_SEL0_INT2SEL_Pos         		(8U)
N#define	INT_SEL0_INT2SEL_Msk							(0x0FL << INT_SEL0_INT2SEL_Pos)
N#define INT_SEL0_INT2SEL          				INT_SEL0_INT2SEL_Msk
N
N#define INT_SEL0_INT3SEL_Pos         		(12U)
N#define	INT_SEL0_INT3SEL_Msk							(0x0FL << INT_SEL0_INT3SEL_Pos)
N#define INT_SEL0_INT3SEL          				INT_SEL0_INT3SEL_Msk
N
N#define INT_SEL0_INT4SEL_Pos         		(16U)
N#define	INT_SEL0_INT4SEL_Msk							(0x0FL << INT_SEL0_INT4SEL_Pos)
N#define INT_SEL0_INT4SEL          				INT_SEL0_INT4SEL_Msk
N
N#define INT_SEL0_INT5SEL_Pos         		(20U)
N#define	INT_SEL0_INT5SEL_Msk							(0x0FL << INT_SEL0_INT5SEL_Pos)
N#define INT_SEL0_INT5SEL          				INT_SEL0_INT5SEL_Msk
N
N#define INT_SEL0_INT6SEL_Pos         		(24U)
N#define	INT_SEL0_INT6SEL_Msk							(0x0FL << INT_SEL0_INT6SEL_Pos)
N#define INT_SEL0_INT6SEL          				INT_SEL0_INT6SEL_Msk
N
N#define INT_SEL0_INT7SEL_Pos         		(28U)
N#define	INT_SEL0_INT7SEL_Msk							(0x0FL << INT_SEL0_INT7SEL_Pos)
N#define INT_SEL0_INT7SEL          				INT_SEL0_INT7SEL_Msk
N
N/********************  Bit definition for INT_SEL1 register  ********************/
N#define INT_SEL1_INT8SEL_Pos         		(0U)
N#define	INT_SEL1_INT8SEL_Msk							(0x0FL << INT_SEL1_INT8SEL_Pos)
N#define INT_SEL1_INT8SEL          				INT_SEL1_INT8SEL_Msk
N
N#define INT_SEL1_INT9SEL_Pos         		(4U)
N#define	INT_SEL1_INT9SEL_Msk							(0x0FL << INT_SEL1_INT9SEL_Pos)
N#define INT_SEL1_INT9SEL          				INT_SEL1_INT9SEL_Msk
N
N#define INT_SEL1_INT10SEL_Pos         		(8U)
N#define	INT_SEL1_INT10SEL_Msk						(0x0FL << INT_SEL1_INT10SEL_Pos)
N#define INT_SEL1_INT10SEL          			INT_SEL1_INT10SEL_Msk
N
N#define INT_SEL1_INT11SEL_Pos         		(12U)
N#define	INT_SEL1_INT11SEL_Msk						(0x0FL << INT_SEL1_INT11SEL_Pos)
N#define INT_SEL1_INT11SEL          			INT_SEL1_INT11SEL_Msk
N
N#define INT_SEL1_INT12SEL_Pos         		(16U)
N#define	INT_SEL1_INT12SEL_Msk						(0x0FL << INT_SEL1_INT12SEL_Pos)
N#define INT_SEL1_INT12SEL          			INT_SEL1_INT12SEL_Msk
N
N#define INT_SEL1_INT13SEL_Pos         		(20U)
N#define	INT_SEL1_INT13SEL_Msk						(0x0FL << INT_SEL1_INT13SEL_Pos)
N#define INT_SEL1_INT13SEL          			INT_SEL1_INT13SEL_Msk
N
N#define INT_SEL1_INT14SEL_Pos         		(24U)
N#define	INT_SEL1_INT14SEL_Msk						(0x0FL << INT_SEL1_INT14SEL_Pos)
N#define INT_SEL1_INT14SEL          			INT_SEL1_INT14SEL_Msk
N
N#define INT_SEL1_INT15SEL_Pos         		(28U)
N#define	INT_SEL1_INT15SEL_Msk						(0x0FL << INT_SEL1_INT15SEL_Pos)
N#define INT_SEL1_INT15SEL          			INT_SEL1_INT15SEL_Msk
N
N
N/********************  Bit definition for INT_RCON register  ********************/
N#define INT_RCON_FT0_Pos         				(0U)
N#define	INT_RCON_FT0_Msk									(0x1L << INT_RCON_FT0_Pos)
N#define INT_RCON_FT0          						INT_RCON_FT0_Msk
N
N#define INT_RCON_FT1_Pos         				(1U)
N#define	INT_RCON_FT_Msk									(0x1L << INT_RCON_FT1_Pos)
N#define INT_RCON_FT1          						INT_RCON_FT_Msk
N
N#define INT_RCON_FT2_Pos         				(2U)
N#define	INT_RCON_FT2_Msk									(0x1L << INT_RCON_FT2_Pos)
N#define INT_RCON_FT2          						INT_RCON_FT2_Msk
N
N#define INT_RCON_FT3_Pos         				(3U)
N#define	INT_RCON_FT3_Msk									(0x1L << INT_RCON_FT3_Pos)
N#define INT_RCON_FT3          						INT_RCON_FT3_Msk
N
N#define INT_RCON_FT4_Pos         				(4U)
N#define	INT_RCON_FT4_Msk									(0x1L << INT_RCON_FT4_Pos)
N#define INT_RCON_FT4          						INT_RCON_FT4_Msk
N
N#define INT_RCON_FT5_Pos         				(5U)
N#define	INT_RCON_FT5_Msk									(0x1L << INT_RCON_FT5_Pos)
N#define INT_RCON_FT5          						INT_RCON_FT5_Msk
N
N#define INT_RCON_FT6_Pos         				(6U)
N#define	INT_RCON_FT6_Msk									(0x1L << INT_RCON_FT6_Pos)
N#define INT_RCON_FT6          						INT_RCON_FT6_Msk
N
N#define INT_RCON_FT7_Pos         				(7U)
N#define	INT_RCON_FT7_Msk									(0x1L << INT_RCON_FT7_Pos)
N#define INT_RCON_FT          						INT_RCON_FT7_Msk
N
N#define INT_RCON_FT8_Pos         				(8U)
N#define	INT_RCON_FT8_Msk									(0x1L << INT_RCON_FT8_Pos)
N#define INT_RCON_FT8          						INT_RCON_FT8_Msk
N
N#define INT_RCON_FT9_Pos         				(9U)
N#define	INT_RCON_FT9_Msk									(0x1L << INT_RCON_FT9_Pos)
N#define INT_RCON_FT9          						INT_RCON_FT9_Msk
N
N#define INT_RCON_FT10_Pos         				(10U)
N#define	INT_RCON_FT10_Msk								(0x1L << INT_RCON_FT10_Pos)
N#define INT_RCON_FT10          					INT_RCON_FT10_Msk
N
N#define INT_RCON_FT11_Pos         				(11U)
N#define	INT_RCON_FT11_Msk								(0x1L << INT_RCON_FT11_Pos)
N#define INT_RCON_FT11          					INT_RCON_FT11_Msk
N
N#define INT_RCON_FT12_Pos         				(12U)
N#define	INT_RCON_FT12_Msk								(0x1L << INT_RCON_FT12_Pos)
N#define INT_RCON_FT12          					INT_RCON_FT12_Msk
N
N#define INT_RCON_FT13_Pos         				(13U)
N#define	INT_RCON_FT13_Msk								(0x1L << INT_RCON_FT13_Pos)
N#define INT_RCON_FT13          					INT_RCON_FT13_Msk
N
N#define INT_RCON_FT14_Pos         				(14U)
N#define	INT_RCON_FT14_Msk								(0x1L << INT_RCON_FT14_Pos)
N#define INT_RCON_FT14          					INT_RCON_FT14_Msk
N
N#define INT_RCON_FT15_Pos         				(15U)
N#define	INT_RCON_FT15_Msk								(0x1L << INT_RCON_FT15_Pos)
N#define INT_RCON_FT15          					INT_RCON_FT15_Msk
N
N/********************  Bit definition for INT_RCON register  ********************/
N#define INT_RCON_RT0_Pos         				(0U)
N#define	INT_RCON_RT0_Msk									(0x1L << INT_RCON_RT0_Pos)
N#define INT_RCON_RT0          						INT_RCON_RT0_Msk
N
N#define INT_RCON_RT1_Pos         				(1U)
N#define	INT_RCON_RT_Msk									(0x1L << INT_RCON_RT1_Pos)
N#define INT_RCON_RT1          						INT_RCON_RT_Msk
N
N#define INT_RCON_RT2_Pos         				(2U)
N#define	INT_RCON_RT2_Msk									(0x1L << INT_RCON_RT2_Pos)
N#define INT_RCON_RT2          						INT_RCON_RT2_Msk
N
N#define INT_RCON_RT3_Pos         				(3U)
N#define	INT_RCON_RT3_Msk									(0x1L << INT_RCON_RT3_Pos)
N#define INT_RCON_RT3          						INT_RCON_RT3_Msk
N
N#define INT_RCON_RT4_Pos         				(4U)
N#define	INT_RCON_RT4_Msk									(0x1L << INT_RCON_RT4_Pos)
N#define INT_RCON_RT4          						INT_RCON_RT4_Msk
N
N#define INT_RCON_RT5_Pos         				(5U)
N#define	INT_RCON_RT5_Msk									(0x1L << INT_RCON_RT5_Pos)
N#define INT_RCON_RT5          						INT_RCON_RT5_Msk
N
N#define INT_RCON_RT6_Pos         				(6U)
N#define	INT_RCON_RT6_Msk									(0x1L << INT_RCON_RT6_Pos)
N#define INT_RCON_RT6          						INT_RCON_RT6_Msk
N
N#define INT_RCON_RT7_Pos         				(7U)
N#define	INT_RCON_RT7_Msk									(0x1L << INT_RCON_RT7_Pos)
N#define INT_RCON_RT          						INT_RCON_RT7_Msk
N
N#define INT_RCON_RT8_Pos         				(8U)
N#define	INT_RCON_RT8_Msk									(0x1L << INT_RCON_RT8_Pos)
N#define INT_RCON_RT8          						INT_RCON_RT8_Msk
N
N#define INT_RCON_RT9_Pos         				(9U)
N#define	INT_RCON_RT9_Msk									(0x1L << INT_RCON_RT9_Pos)
N#define INT_RCON_RT9          						INT_RCON_RT9_Msk
N
N#define INT_RCON_RT10_Pos         				(10U)
N#define	INT_RCON_RT10_Msk								(0x1L << INT_RCON_RT10_Pos)
N#define INT_RCON_RT10          					INT_RCON_RT10_Msk
N
N#define INT_RCON_RT11_Pos         				(11U)
N#define	INT_RCON_RT11_Msk								(0x1L << INT_RCON_RT11_Pos)
N#define INT_RCON_RT11          					INT_RCON_RT11_Msk
N
N#define INT_RCON_RT12_Pos         				(12U)
N#define	INT_RCON_RT12_Msk								(0x1L << INT_RCON_RT12_Pos)
N#define INT_RCON_RT12          					INT_RCON_RT12_Msk
N
N#define INT_RCON_RT13_Pos         				(13U)
N#define	INT_RCON_RT13_Msk								(0x1L << INT_RCON_RT13_Pos)
N#define INT_RCON_RT13          					INT_RCON_RT13_Msk
N
N#define INT_RCON_RT14_Pos         				(14U)
N#define	INT_RCON_RT14_Msk								(0x1L << INT_RCON_RT14_Pos)
N#define INT_RCON_RT14          					INT_RCON_RT14_Msk
N
N#define INT_RCON_RT15_Pos         				(15U)
N#define	INT_RCON_RT15_Msk								(0x1L << INT_RCON_RT15_Pos)
N#define INT_RCON_RT15          					INT_RCON_RT15_Msk
N
N/********************  Bit definition for INT_FSTS register  ********************/
N#define INT_FSTS_FIF0_Pos         				(0U)
N#define	INT_FSTS_FIF0_Msk								(0x1L << INT_FSTS_FIF0_Pos)
N#define INT_FSTS_FIF0          					INT_FSTS_FIF0_Msk
N
N#define INT_FSTS_FIF1_Pos         				(1U)
N#define	INT_FSTS_FIF_Msk									(0x1L << INT_FSTS_FIF1_Pos)
N#define INT_FSTS_FIF1          					INT_FSTS_FIF_Msk
N
N#define INT_FSTS_FIF2_Pos         				(2U)
N#define	INT_FSTS_FIF2_Msk								(0x1L << INT_FSTS_FIF2_Pos)
N#define INT_FSTS_FIF2          					INT_FSTS_FIF2_Msk
N
N#define INT_FSTS_FIF3_Pos         				(3U)
N#define	INT_FSTS_FIF3_Msk								(0x1L << INT_FSTS_FIF3_Pos)
N#define INT_FSTS_FIF3          					INT_FSTS_FIF3_Msk
N
N#define INT_FSTS_FIF4_Pos         				(4U)
N#define	INT_FSTS_FIF4_Msk								(0x1L << INT_FSTS_FIF4_Pos)
N#define INT_FSTS_FIF4          					INT_FSTS_FIF4_Msk
N
N#define INT_FSTS_FIF5_Pos         				(5U)
N#define	INT_FSTS_FIF5_Msk								(0x1L << INT_FSTS_FIF5_Pos)
N#define INT_FSTS_FIF5          					INT_FSTS_FIF5_Msk
N
N#define INT_FSTS_FIF6_Pos         				(6U)
N#define	INT_FSTS_FIF6_Msk								(0x1L << INT_FSTS_FIF6_Pos)
N#define INT_FSTS_FIF6          					INT_FSTS_FIF6_Msk
N
N#define INT_FSTS_FIF7_Pos         				(7U)
N#define	INT_FSTS_FIF7_Msk								(0x1L << INT_FSTS_FIF7_Pos)
N#define INT_FSTS_FIF          						INT_FSTS_FIF7_Msk
N
N#define INT_FSTS_FIF8_Pos         				(8U)
N#define	INT_FSTS_FIF8_Msk								(0x1L << INT_FSTS_FIF8_Pos)
N#define INT_FSTS_FIF8          					INT_FSTS_FIF8_Msk
N
N#define INT_FSTS_FIF9_Pos         				(9U)
N#define	INT_FSTS_FIF9_Msk								(0x1L << INT_FSTS_FIF9_Pos)
N#define INT_FSTS_FIF9          					INT_FSTS_FIF9_Msk
N
N#define INT_FSTS_FIF10_Pos         			(10U)
N#define	INT_FSTS_FIF10_Msk								(0x1L << INT_FSTS_FIF10_Pos)
N#define INT_FSTS_FIF10          					INT_FSTS_FIF10_Msk
N
N#define INT_FSTS_FIF11_Pos         			(11U)
N#define	INT_FSTS_FIF11_Msk								(0x1L << INT_FSTS_FIF11_Pos)
N#define INT_FSTS_FIF11          					INT_FSTS_FIF11_Msk
N
N#define INT_FSTS_FIF12_Pos         			(12U)
N#define	INT_FSTS_FIF12_Msk								(0x1L << INT_FSTS_FIF12_Pos)
N#define INT_FSTS_FIF12          					INT_FSTS_FIF12_Msk
N
N#define INT_FSTS_FIF13_Pos         			(13U)
N#define	INT_FSTS_FIF13_Msk								(0x1L << INT_FSTS_FIF13_Pos)
N#define INT_FSTS_FIF13          					INT_FSTS_FIF13_Msk
N
N#define INT_FSTS_FIF14_Pos         			(14U)
N#define	INT_FSTS_FIF14_Msk								(0x1L << INT_FSTS_FIF14_Pos)
N#define INT_FSTS_FIF14          					INT_FSTS_FIF14_Msk
N
N#define INT_FSTS_FIF15_Pos         			(15U)
N#define	INT_FSTS_FIF15_Msk								(0x1L << INT_FSTS_FIF15_Pos)
N#define INT_FSTS_FIF15          					INT_FSTS_FIF15_Msk
N
N/********************  Bit definition for INT_FSTS register  ********************/
N#define INT_FSTS_RIF0_Pos         				(0U)
N#define	INT_FSTS_RIF0_Msk								(0x1L << INT_FSTS_RIF0_Pos)
N#define INT_FSTS_RIF0          					INT_FSTS_RIF0_Msk
N
N#define INT_FSTS_RIF1_Pos         				(1U)
N#define	INT_FSTS_RIF_Msk									(0x1L << INT_FSTS_RIF1_Pos)
N#define INT_FSTS_RIF1          					INT_FSTS_RIF_Msk
N
N#define INT_FSTS_RIF2_Pos         				(2U)
N#define	INT_FSTS_RIF2_Msk								(0x1L << INT_FSTS_RIF2_Pos)
N#define INT_FSTS_RIF2          					INT_FSTS_RIF2_Msk
N
N#define INT_FSTS_RIF3_Pos         				(3U)
N#define	INT_FSTS_RIF3_Msk								(0x1L << INT_FSTS_RIF3_Pos)
N#define INT_FSTS_RIF3          					INT_FSTS_RIF3_Msk
N
N#define INT_FSTS_RIF4_Pos         				(4U)
N#define	INT_FSTS_RIF4_Msk								(0x1L << INT_FSTS_RIF4_Pos)
N#define INT_FSTS_RIF4          					INT_FSTS_RIF4_Msk
N
N#define INT_FSTS_RIF5_Pos         				(5U)
N#define	INT_FSTS_RIF5_Msk								(0x1L << INT_FSTS_RIF5_Pos)
N#define INT_FSTS_RIF5          					INT_FSTS_RIF5_Msk
N
N#define INT_FSTS_RIF6_Pos         				(6U)
N#define	INT_FSTS_RIF6_Msk								(0x1L << INT_FSTS_RIF6_Pos)
N#define INT_FSTS_RIF6          					INT_FSTS_RIF6_Msk
N
N#define INT_FSTS_RIF7_Pos         				(7U)
N#define	INT_FSTS_RIF7_Msk								(0x1L << INT_FSTS_RIF7_Pos)
N#define INT_FSTS_RIF          						INT_FSTS_RIF7_Msk
N
N#define INT_FSTS_RIF8_Pos         				(8U)
N#define	INT_FSTS_RIF8_Msk								(0x1L << INT_FSTS_RIF8_Pos)
N#define INT_FSTS_RIF8          					INT_FSTS_RIF8_Msk
N
N#define INT_FSTS_RIF9_Pos         				(9U)
N#define	INT_FSTS_RIF9_Msk								(0x1L << INT_FSTS_RIF9_Pos)
N#define INT_FSTS_RIF9          					INT_FSTS_RIF9_Msk
N
N#define INT_FSTS_RIF10_Pos         			(10U)
N#define	INT_FSTS_RIF10_Msk								(0x1L << INT_FSTS_RIF10_Pos)
N#define INT_FSTS_RIF10          					INT_FSTS_RIF10_Msk
N
N#define INT_FSTS_RIF11_Pos         			(11U)
N#define	INT_FSTS_RIF11_Msk								(0x1L << INT_FSTS_RIF11_Pos)
N#define INT_FSTS_RIF11          					INT_FSTS_RIF11_Msk
N
N#define INT_FSTS_RIF12_Pos         			(12U)
N#define	INT_FSTS_RIF12_Msk								(0x1L << INT_FSTS_RIF12_Pos)
N#define INT_FSTS_RIF12          					INT_FSTS_RIF12_Msk
N
N#define INT_FSTS_RIF13_Pos         			(13U)
N#define	INT_FSTS_RIF13_Msk								(0x1L << INT_FSTS_RIF13_Pos)
N#define INT_FSTS_RIF13          					INT_FSTS_RIF13_Msk
N
N#define INT_FSTS_RIF14_Pos         			(14U)
N#define	INT_FSTS_RIF14_Msk								(0x1L << INT_FSTS_RIF14_Pos)
N#define INT_FSTS_RIF14          					INT_FSTS_RIF14_Msk
N
N#define INT_FSTS_RIF15_Pos         			(15U)
N#define	INT_FSTS_RIF15_Msk								(0x1L << INT_FSTS_RIF15_Pos)
N#define INT_FSTS_RIF15          					INT_FSTS_RIF15
N/******************************************************************************/
N/*                                                                            */
N/*                      LCD                  																*/
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for DDR_CON register  ********************/
N#define DDR_CON_DMOD_Pos         					(0U)
N#define	DDR_CON_DMOD_Msk									(0x1L << DDR_CON_DMOD_Pos)
N#define DDR_CON_DMOD          						DDR_CON_DMOD_Msk
N
N#define DDR_CON_BIAS_Pos         					(1U)
N#define	DDR_CON_BIAS_Msk									(0x1L << DDR_CON_BIAS_Pos)
N#define DDR_CON_BIAS          						DDR_CON_BIAS_Msk
N
N#define DDR_CON_VOIRSF_Pos         				(3U)
N#define	DDR_CON_VOIRSF_Msk								(0x1L << DDR_CON_VOIRSF_Pos)
N#define DDR_CON_VOIRSF          					DDR_CON_VOIRSF_Msk
N
N#define DDR_CON_TYPE_Pos         					(4U)
N#define	DDR_CON_TYPE_Msk									(0x1L << DDR_CON_TYPE_Pos)
N#define DDR_CON_TYPE          						DDR_CON_TYPE_Msk
N
N#define DDR_CON_DDRON_Pos         				(7U)
N#define	DDR_CON_DDRON_Msk									(0x1L << DDR_CON_DDRON_Pos)
N#define DDR_CON_DDRON          						DDR_CON_DDRON_Msk
N
N#define DDR_CON_DDRCK_Pos         				(8U)
N#define	DDR_CON_DDRCK_Msk									(0x3L << DDR_CON_DDRCK_Pos)
N#define DDR_CON_DDRCK          						DDR_CON_DDRCK_Msk
N
N#define DDR_CON_TRICOM_Pos         				(14U)
N#define	DDR_CON_TRICOM_Msk								(0x1L << DDR_CON_TRICOM_Pos)
N#define DDR_CON_TRICOM          					DDR_CON_TRICOM_Msk
N
N#define DDR_CON_TRIMODE_Pos         			(15U)
N#define	DDR_CON_TRIMODE_Msk								(0x1L << DDR_CON_TRIMODE_Pos)
N#define DDR_CON_TRIMODE          					DDR_CON_TRIMODE_Msk
N
N/********************  Bit definition for DDR_CFG register  ********************/
N#define DDR_CFG_DMOD_Pos         					(0U)
N#define	DDR_CFG_DMOD_Msk									(0x3L << DDR_CFG_DMOD_Pos)
N#define DDR_CFG_DMOD          						DDR_CFG_DMOD_Msk
N
N#define DDR_CFG_DUTY_Pos         					(4U)
N#define	DDR_CFG_DUTY_Msk									(0x3L << DDR_CFG_DUTY_Pos)
N#define DDR_CFG_DUTY          						DDR_CFG_DUTY_Msk
N
N#define DDR_CFG_SCS_Pos         					(7U)
N#define	DDR_CFG_SCS_Msk										(0x1L << DDR_CFG_SCS_Pos)
N#define DDR_CFG_SCS          							DDR_CFG_SCS_Msk
N
N#define DDR_CFG_VLCD_Pos         					(8U)
N#define	DDR_CFG_VLCD_Msk									(0x0FL << DDR_CFG_VLCD_Pos)
N#define DDR_CFG_VLCD          						DDR_CFG_VLCD_Msk
N/******************************************************************************/
N/*                                                                            */
N/*                      PWM0                 																*/
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for PWM_CON register  ********************/
N#define PWM_CON_PWMCLK_Pos         				(0U)
N#define	PWM_CON_PWMCLK_Msk									(0xFL << PWM_CON_PWMCLK_Pos)
N#define PWM_CON_PWMCLK          						PWM_CON_PWMCLK_Msk
N
N#define PWM_CON_PWMMD1_Pos         				(5U)
N#define	PWM_CON_PWMMD1_Msk									(0x1L << PWM_CON_PWMMD1_Pos)
N#define PWM_CON_PWMMD1          						PWM_CON_PWMMD1_Msk
N
N#define PWM_CON_PWMMD0_Pos         				(6U)
N#define	PWM_CON_PWMMD0_Msk									(0x1L << PWM_CON_PWMMD0_Pos)
N#define PWM_CON_PWMMD0          						PWM_CON_PWMMD0_Msk
N
N#define PWM_CON_ENPWM_Pos         					(7U)
N#define	PWM_CON_ENPWM_Msk									(0x1L << PWM_CON_ENPWM_Pos)
N#define PWM_CON_ENPWM          						PWM_CON_ENPWM_Msk
N
N#define PWM_CON_INTEN_Pos         					(8U)
N#define	PWM_CON_INTEN_Msk									(0x1L << PWM_CON_INTEN_Pos)
N#define PWM_CON_INTEN          						PWM_CON_INTEN_Msk
N/********************  Bit definition for PWM0_CHN register  ********************/
N#define PWM_CHN_ENPWM_Pos         				(0U)
N#define	PWM_CHN_ENPWM_Msk									(0x1L << PWM_CHN_ENPWM_Pos)
N#define PWM_CHN_ENPWM          						PWM_CHN_ENPWM_Msk
N
N#define PWM_CHN_ENLEDPWM_Pos         				(1U)
N#define	PWM_CHN_ENLEDPWM_Msk									(0x1L << PWM_CHN_ENLEDPWM_Pos)
N#define PWM_CHN_ENLEDPWM          						PWM_CHN_ENLEDPWM_Msk
N
N#define PWM_CHN_ENPWM2_Pos         				(2U)
N#define	PWM_CHN_ENPWM2_Msk									(0x1L << PWM_CHN_ENPWM2_Pos)
N#define PWM_CHN_ENPWM2          						PWM_CHN_ENPWM2_Msk
N
N#define PWM_CHN_ENPWM3_Pos         				(3U)
N#define	PWM_CHN_ENPWM3_Msk									(0x1L << PWM_CHN_ENPWM3_Pos)
N#define PWM_CHN_ENPWM3          						PWM_CHN_ENPWM3_Msk
N
N#define PWM_CHN_ENPWM4_Pos         				(4U)
N#define	PWM_CHN_ENPWM4_Msk									(0x1L << PWM_CHN_ENPWM4_Pos)
N#define PWM_CHN_ENPWM4          						PWM_CHN_ENPWM4_Msk
N
N#define PWM_CHN_ENPWM5_Pos         				(5U)
N#define	PWM_CHN_ENPWM5_Msk									(0x1L << PWM_CHN_ENPWM5_Pos)
N#define PWM_CHN_ENPWM5          						PWM_CHN_ENPWM5_Msk
N
N#define PWM_CHN_ENPWM6_Pos         				(6U)
N#define	PWM_CHN_ENPWM6_Msk									(0x1L << PWM_CHN_ENPWM6_Pos)
N#define PWM_CHN_ENPWM6          						PWM_CHN_ENPWM6_Msk
N
N#define PWM_CHN_ENPWM7_Pos         				(7U)
N#define	PWM_CHN_ENPWM7_Msk									(0x1L << PWM_CHN_ENPWM7_Pos)
N#define PWM_CHN_ENPWM7          						PWM_CHN_ENPWM7_Msk
N/********************  Bit definition for PWM_STS register  ********************/
N#define PWM_STS_PWMIF_Pos         					(0U)
N#define	PWM_STS_PWMIF_Msk									(0x1L << PWM_STS_PWMIF_Pos)
N#define PWM_STS_PWMIF         							PWM_STS_PWMIF_Msk
N
N#define PWM_STS_FLTSTA_Pos         				(1U)
N#define	PWM_STS_FLTSTA_Msk									(0x1L << PWM_STS_FLTSTA_Pos)
N#define PWM_STS_FLTSTA         						PWM_STS_FLTSTA_Msk
N/********************  Bit definition for PWM_INV register  ********************/
N#define PWM_INV_INV_Pos         					  (0U)
N#define	PWM_INV_INV_Msk										(0xFL << PWM_INV_INV_Pos)
N#define PWM_INV_INV          							PWM_INV_INV_Msk
N
N#define PWM_INV_INV0_Pos         					(0U)
N#define	PWM_INV_INV0_Msk										(0x1L << PWM_INV_INV0_Pos)
N#define PWM_INV_INV0          							PWM_INV_INV0_Msk
N
N#define PWM_INV_INV1_Pos         					(1U)
N#define	PWM_INV_INV1_Msk										(0x1L << PWM_INV_INV1_Pos)
N#define PWM_INV_INV1          							PWM_INV_INV1_Msk
N
N#define PWM_INV_INV2_Pos         					(2U)
N#define	PWM_INV_INV2_Msk										(0x1L << PWM_INV_INV2_Pos)
N#define PWM_INV_INV2          							PWM_INV_INV2_Msk
N
N#define PWM_INV_INV3_Pos         					(3U)
N#define	PWM_INV_INV3_Msk										(0x1L << PWM_INV_INV3_Pos)
N#define PWM_INV_INV3          							PWM_INV_INV3_Msk
N
N#define PWM_INV_INV4_Pos         					(4U)
N#define	PWM_INV_INV4_Msk										(0x1L << PWM_INV_INV4_Pos)
N#define PWM_INV_INV4          							PWM_INV_INV4_Msk
N
N#define PWM_INV_INV5_Pos         					(5U)
N#define	PWM_INV_INV5_Msk										(0x1L << PWM_INV_INV5_Pos)
N#define PWM_INV_INV5          							PWM_INV_INV5_Msk
N
N#define PWM_INV_INV6_Pos         					(6U)
N#define	PWM_INV_INV6_Msk										(0x1L << PWM_INV_INV6_Pos)
N#define PWM_INV_INV6          							PWM_INV_INV6_Msk
N
N#define PWM_INV_INV7_Pos         					(7U)
N#define	PWM_INV_INV7_Msk										(0x1L << PWM_INV_INV7_Pos)
N#define PWM_INV_INV7          							PWM_INV_INV7_Msk
N/********************  Bit definition for PWM_DFR register  ********************/
N#define PWM_DFR_PDR_Pos         						(0U)
N#define	PWM_DFR_PDR_Msk										(0x0FL << PWM_DFR_PDR_Pos)
N#define PWM_DFR_PDR          							PWM_DFR_PDR_Msk
N
N#define PWM_DFR_PDF_Pos         						(8U)
N#define	PWM_DFR_PDF_Msk										(0x0FL << PWM_DFR_PDF_Pos)
N#define PWM_DFR_PDF          							PWM_DFR_PDF_Msk
N/********************  Bit definition for PWM_FLT register  ********************/
N#define PWM_FLT_FLTDT_Pos         					(0U)
N#define	PWM_FLT_FLTDT_Msk									(0x03L << PWM_FLT_FLTDT_Pos)
N#define PWM_FLT_FLTDT          						PWM_FLT_FLTDT_Msk
N
N#define PWM_FLT_FLTTV_Pos         					(4U)
N#define	PWM_FLT_FLTTV_Msk									(0x1L << PWM_FLT_FLTTV_Pos)
N#define PWM_FLT_FLTTV          						PWM_FLT_FLTTV_Msk
N
N#define PWM_FLT_FLTMD_Pos         					(5U)
N#define	PWM_FLT_FLTMD_Msk									(0x1L << PWM_FLT_FLTMD_Pos)
N#define PWM_FLT_FLTMD          						PWM_FLT_FLTMD_Msk
N
N#define PWM_FLT_FLTEN_Pos         					(7U)
N#define	PWM_FLT_FLTEN_Msk									(0x1L << PWM_FLT_FLTEN_Pos)
N#define PWM_FLT_FLTEN         							PWM_FLT_FLTEN_Msk
N/******************************************************************************/
N/*                                                                            */
N/*                      LEDPWM                 																*/
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for PWM_CON register  ********************/
N#define LEDPWM_CON_PWMCLK_Pos								(0U)
N#define LEDPWM_CON_PWMCLK_Msk								(0xFL << LEDPWM_CON_PWMCLK_Pos)
N#define LEDPWM_CON_PWMCLK										LEDPWM_CON_PWMCLK_Msk
N
N#define LEDPWM_CON_PWMMD0_Pos								(6U)
N#define LEDPWM_CON_PWMMD0_Msk								(0x1L << LEDPWM_CON_PWMMD0_Pos)
N#define LEDPWM_CON_PWMMD0										LEDPWM_CON_PWMMD0_Msk
N
N#define LEDPWM_CON_ENPWM_Pos								(7U)
N#define LEDPWM_CON_ENPWM_Msk								(0x1L << LEDPWM_CON_ENPWM_Pos)
N#define LEDPWM_CON_ENPWM										LEDPWM_CON_ENPWM_Msk
N
N#define LEDPWM_CON_INTEN_Pos								(8U)
N#define LEDPWM_CON_INTEN_Msk								(0x1L << LEDPWM_CON_INTEN_Pos)
N#define LEDPWM_CON_INTEN										LEDPWM_CON_INTEN_Msk
N
N/********************  Bit definition for LEDPWM_STS register  ********************/
N#define LEDPWM_STS_PWMIF_Pos								(0U)
N#define LEDPWM_STS_PWMIF_Msk								(0x1L << LEDPWM_STS_PWMIF_Pos)
N#define LEDPWM_STS_PWMIF										LEDPWM_STS_PWMIF_Msk
N
N/******************************************************************************/
N/*                                                                            */
N/*                      SPI0                 																*/
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for SPI_CON register  ********************/
N#define SPI_CON_MSTR_Pos         					(0U)
N#define	SPI_CON_MSTR_Msk										(0x1L << SPI_CON_MSTR_Pos)
N#define SPI_CON_MSTR          							SPI_CON_MSTR_Msk
N
N#define SPI_CON_SPMD_Pos         					(1U)
N#define	SPI_CON_SPMD_Msk										(0x1L << SPI_CON_SPMD_Pos)
N#define SPI_CON_SPMD          							SPI_CON_SPMD_Msk
N
N#define SPI_CON_DORD_Pos         					(2U)
N#define	SPI_CON_DORD_Msk										(0x1L << SPI_CON_DORD_Pos)
N#define SPI_CON_DORD          							SPI_CON_DORD_Msk
N
N#define SPI_CON_CPHA_Pos         					(3U)
N#define	SPI_CON_CPHA_Msk										(0x1L << SPI_CON_CPHA_Pos)
N#define SPI_CON_CPHA          							SPI_CON_CPHA_Msk
N
N#define SPI_CON_CPOL_Pos         					(4U)
N#define	SPI_CON_CPOL_Msk										(0x1L << SPI_CON_CPOL_Pos)
N#define SPI_CON_CPOL          							SPI_CON_CPOL_Msk
N
N#define SPI_CON_SPEN_Pos         					(7U)
N#define	SPI_CON_SPEN_Msk										(0x1L << SPI_CON_SPEN_Pos)
N#define SPI_CON_SPEN          							SPI_CON_SPEN_Msk
N
N#define SPI_CON_SPR_Pos         						(8U)
N#define	SPI_CON_SPR_Msk										(0x0FL << SPI_CON_SPR_Pos)
N#define SPI_CON_SPR          							SPI_CON_SPR_Msk
N
N#define SPI_CON_SPOS_Pos         					(14U)
N#define	SPI_CON_SPOS_Msk										(0x3L << SPI_CON_SPOS_Pos)
N#define SPI_CON_SPOS          							SPI_CON_SPOS_Msk
N/********************  Bit definition for SPI_STS register  ********************/
N#define SPI_STS_SPIF_Pos         					(0U)
N#define	SPI_STS_SPIF_Msk										(0x1L << SPI_STS_SPIF_Pos)
N#define SPI_STS_SPIF          							SPI_STS_SPIF_Msk
N
N#define SPI_STS_RINEIF_Pos         				(1U)
N#define	SPI_STS_RINEIF_Msk									(0x1L << SPI_STS_RINEIF_Pos)
N#define SPI_STS_RINEIF          						SPI_STS_RINEIF_Msk
N
N#define SPI_STS_TXEIF_Pos         					(2U)
N#define	SPI_STS_TXEIF_Msk									(0x1L << SPI_STS_TXEIF_Pos)
N#define SPI_STS_TXEIF          						SPI_STS_TXEIF_Msk
N
N#define SPI_STS_RXFIF_Pos         					(3U)
N#define	SPI_STS_RXFIF_Msk									(0x1L << SPI_STS_RXFIF_Pos)
N#define SPI_STS_RXFIF          						SPI_STS_RXFIF_Msk
N
N#define SPI_STS_RXHIF_Pos         					(4U)
N#define	SPI_STS_RXHIF_Msk									(0x1L << SPI_STS_RXHIF_Pos)
N#define SPI_STS_RXHIF          						SPI_STS_RXHIF_Msk
N
N#define SPI_STS_TXHIF_Pos         					(5U)
N#define	SPI_STS_TXHIF_Msk										(0x1L << SPI_STS_TXHIF_Pos)
N#define SPI_STS_TXHIF          							SPI_STS_TXHIF_Msk
N
N#define SPI_STS_WCOL_Pos         					(7U)
N#define	SPI_STS_WCOL_Msk										(0x1L << SPI_STS_WCOL_Pos)
N#define SPI_STS_WCOL          							SPI_STS_WCOL_Msk
N/********************  Bit definition for SPI_IDE register  ********************/
N#define SPI_IDE_INTEN_Pos         					(0U)
N#define	SPI_IDE_INTEN_Msk									(0x1L << SPI_IDE_INTEN_Pos)
N#define SPI_IDE_INTEN         							SPI_IDE_INTEN_Msk
N
N#define SPI_IDE_RXNEIE_Pos         				(1U)
N#define	SPI_IDE_RXNEIE_Msk									(0x1L << SPI_IDE_RXNEIE_Pos)
N#define SPI_IDE_RXNEIE         						SPI_IDE_RXNEIE_Msk
N
N#define SPI_IDE_TBIE_Pos         					(2U)
N#define	SPI_IDE_TBIE_Msk										(0x1L << SPI_IDE_TBIE_Pos)
N#define SPI_IDE_TBIE        								SPI_IDE_TBIE_Msk
N
N#define SPI_IDE_RXIE_Pos         					(3U)
N#define	SPI_IDE_RXIE_Msk										(0x1L << SPI_IDE_RXIE_Pos)
N#define SPI_IDE_RXIE        								SPI_IDE_RXIE_Msk
N
N#define SPI_IDE_RXHIE_Pos         					(4U)
N#define	SPI_IDE_RXHIE_Msk									(0x1L << SPI_IDE_RXHIE_Pos)
N#define SPI_IDE_RXHIE        							SPI_IDE_RXHIE_Msk
N
N#define SPI_IDE_TXHIE_Pos         					(5U)
N#define	SPI_IDE_TXHIE_Msk									(0x1L << SPI_IDE_TXHIE_Pos)
N#define SPI_IDE_TXHIE        							SPI_IDE_TXHIE_Msk
N
N#define SPI_IDE_RXDMAEN_Pos         				(6U)
N#define	SPI_IDE_RXDMAEN_Msk								(0x1L << SPI_IDE_RXDMAEN_Pos)
N#define SPI_IDE_RXDMAEN        						SPI_IDE_RXDMAEN_Msk
N
N#define SPI_IDE_TXDMAEN_Pos         				(7U)
N#define	SPI_IDE_TXDMAEN_Msk								(0x1L << SPI_IDE_TXDMAEN_Pos)
N#define SPI_IDE_TXDMAEN        						SPI_IDE_TXDMAEN_Msk
N/******************************************************************************/
N/*                                                                            */
N/*                      TIM                																*/
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for TIM_CON register  ********************/
N#define TIM_CON_CPRL_Pos         						(0U)
N#define	TIM_CON_CPRL_Msk										(0x1L << TIM_CON_CPRL_Pos)
N#define TIM_CON_CPRL         								TIM_CON_CPRL_Msk
N
N#define TIM_CON_CTSEL_Pos         					(1U)
N#define	TIM_CON_CTSEL_Msk										(0x1L << TIM_CON_CTSEL_Pos)
N#define TIM_CON_CTSEL         							TIM_CON_CTSEL_Msk
N
N#define TIM_CON_EXENR_Pos         					(2U)
N#define	TIM_CON_EXENR_Msk										(0x1L << TIM_CON_EXENR_Pos)
N#define TIM_CON_EXENR         							TIM_CON_EXENR_Msk
N
N#define TIM_CON_EXENF_Pos         					(3U)
N#define	TIM_CON_EXENF_Msk										(0x1L << TIM_CON_EXENF_Pos)
N#define TIM_CON_EXENF         							TIM_CON_EXENF_Msk
N
N#define TIM_CON_FSEL_Pos         						(4U)
N#define	TIM_CON_FSEL_Msk										(0x1L << TIM_CON_FSEL_Pos)
N#define TIM_CON_FSEL        								TIM_CON_FSEL_Msk
N
N#define TIM_CON_EXENX_Pos         					(5U)
N#define	TIM_CON_EXENX_Msk										(0x1L << TIM_CON_EXENX_Pos)
N#define TIM_CON_EXENX        								TIM_CON_EXENX_Msk
N
N#define TIM_CON_DEC_Pos         						(6U)
N#define	TIM_CON_DEC_Msk											(0x1L << TIM_CON_DEC_Pos)
N#define TIM_CON_DEC        									TIM_CON_DEC_Msk
N
N#define TIM_CON_TR_Pos         							(7U)
N#define	TIM_CON_TR_Msk											(0x1L << TIM_CON_TR_Pos)
N#define TIM_CON_TR        									TIM_CON_TR_Msk
N
N#define TIM_CON_TIMCLK_Pos         					(8U)
N#define	TIM_CON_TIMCLK_Msk									(0x7L << TIM_CON_TIMCLK_Pos)
N#define TIM_CON_TIMCLK         							TIM_CON_TIMCLK_Msk
N
N#define TIM_CON_INVNB_Pos         					(11U)
N#define	TIM_CON_INVNB_Msk										(0x1L << TIM_CON_INVNB_Pos)
N#define TIM_CON_INVNB         							TIM_CON_INVNB_Msk
N
N#define TIM_CON_INVNA_Pos         					(12U)
N#define	TIM_CON_INVNA_Msk										(0x1L << TIM_CON_INVNA_Pos)
N#define TIM_CON_INVNA         							TIM_CON_INVNA_Msk
N
N#define TIM_CON_EPWMNB_Pos         					(13U)
N#define	TIM_CON_EPWMNB_Msk									(0x1L << TIM_CON_EPWMNB_Pos)
N#define TIM_CON_EPWMNB         							TIM_CON_EPWMNB_Msk
N
N#define TIM_CON_EPWMNA_Pos         					(14U)
N#define	TIM_CON_EPWMNA_Msk									(0x1L << TIM_CON_EPWMNA_Pos)
N#define TIM_CON_EPWMNA         							TIM_CON_EPWMNA_Msk
N
N#define TIM_CON_TXOE_Pos         						(15U)
N#define	TIM_CON_TXOE_Msk										(0x1L << TIM_CON_TXOE_Pos)
N#define TIM_CON_TXOE         								TIM_CON_TXOE_Msk
N
N#define TIM_CON_SPOS_Pos         						(19U)
N#define	TIM_CON_SPOS_Msk										(0x1L << TIM_CON_SPOS_Pos)
N#define TIM_CON_SPOS         								TIM_CON_SPOS_Msk
N/********************  Bit definition for TIM_STS register  ********************/
N#define TIM_STS_TIF_Pos         						(0U)
N#define	TIM_STS_TIF_Msk											(0x1L << TIM_STS_TIF_Pos)
N#define TIM_STS_TIF         								TIM_STS_TIF_Msk
N
N#define TIM_STS_EXIR_Pos         						(1U)
N#define	TIM_STS_EXIR_Msk										(0x1L << TIM_STS_EXIR_Pos)
N#define TIM_STS_EXIR         								TIM_STS_EXIR_Msk
N
N#define TIM_STS_EXIF_Pos         						(2U)
N#define	TIM_STS_EXIF_Msk										(0x1L << TIM_STS_EXIF_Pos)
N#define TIM_STS_EXIF        								TIM_STS_EXIF_Msk
N/********************  Bit definition for TIM_IDE register  ********************/
N#define TIM_IDE_INTEN_Pos         					(0U)
N#define	TIM_IDE_INTEN_Msk										(0x1L << TIM_IDE_INTEN_Pos)
N#define TIM_IDE_INTEN         							TIM_IDE_INTEN_Msk
N
N#define TIM_IDE_TIE_Pos         						(1U)
N#define	TIM_IDE_TIE_Msk											(0x1L << TIM_IDE_TIE_Pos)
N#define TIM_IDE_TIE         								TIM_IDE_TIE_Msk
N
N#define TIM_IDE_EXIRE_Pos         					(2U)
N#define	TIM_IDE_EXIRE_Msk										(0x1L << TIM_IDE_EXIRE_Pos)
N#define TIM_IDE_EXIRE         							TIM_IDE_EXIRE_Msk
N
N#define TIM_IDE_EXIFE_Pos         					(3U)
N#define	TIM_IDE_EXIFE_Msk										(0x1L << TIM_IDE_EXIFE_Pos)
N#define TIM_IDE_EXIFE         							TIM_IDE_EXIFE_Msk
N
N#define TIM_IDE_TIDE_Pos         						(4U)
N#define	TIM_IDE_TIDE_Msk										(0x1L << TIM_IDE_TIDE_Pos)
N#define TIM_IDE_TIDE         								TIM_IDE_TIDE_Msk
N
N#define TIM_IDE_CAPRDE_Pos         					(5)
N#define	TIM_IDE_CAPRDE_Msk									(0x1L << TIM_IDE_CAPRDE_Pos)
N#define TIM_IDE_CAPRDE        							TIM_IDE_CAPRDE_Msk
N
N#define TIM_IDE_CAPFDE_Pos         					(6U)
N#define	TIM_IDE_CAPFDE_Msk									(0x1L << TIM_IDE_CAPFDE_Pos)
N#define TIM_IDE_CAPFDE        							TIM_IDE_CAPFDE_Msk
N
N/******************************************************************************/
N/*                                                                            */
N/*                      TWI               																*/
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for TWI_CON register  ********************/
N#define TWI_CON_STRETCH_Pos         					(0U)
N#define	TWI_CON_STRETCH_Msk										(0x1L << TWI_CON_STRETCH_Pos)
N#define TWI_CON_STRETCH         							TWI_CON_STRETCH_Msk
N
N#define TWI_CON_AA_Pos         								(1U)
N#define	TWI_CON_AA_Msk												(0x1L << TWI_CON_AA_Pos)
N#define TWI_CON_AA         										TWI_CON_AA_Msk
N
N#define TWI_CON_STO_Pos         							(4U)
N#define	TWI_CON_STO_Msk												(0x1L << TWI_CON_STO_Pos)
N#define TWI_CON_STO         									TWI_CON_STO_Msk
N
N#define TWI_CON_STA_Pos         							(5U)
N#define	TWI_CON_STA_Msk												(0x1L << TWI_CON_STA_Pos)
N#define TWI_CON_STA         									TWI_CON_STA_Msk
N
N#define TWI_CON_TWEN_Pos         							(7U)
N#define	TWI_CON_TWEN_Msk											(0x1L << TWI_CON_TWEN_Pos)
N#define TWI_CON_TWEN         									TWI_CON_TWEN_Msk
N
N#define TWI_CON_TWCK_Pos         							(8U)
N#define	TWI_CON_TWCK_Msk											(0x0FL << TWI_CON_TWCK_Pos)
N#define TWI_CON_TWCK         									TWI_CON_TWCK_Msk
N
N#define TWI_CON_SPOS_Pos         							(14U)
N#define	TWI_CON_SPOS_Msk											(0x3L << TWI_CON_SPOS_Pos)
N#define TWI_CON_SPOS         									TWI_CON_SPOS_Msk
N/********************  Bit definition for TWI_STS register  ********************/
N#define TWI_STS_TWIF_Pos         							(0U)
N#define	TWI_STS_TWIF_Msk											(0x1L << TWI_STS_TWIF_Pos)
N#define TWI_STS_TWIF         									TWI_STS_TWIF_Msk
N
N#define TWI_STS_TXERXE_Pos         						(1U)
N#define	TWI_STS_TXERXE_Msk										(0x1L << TWI_STS_TXERXE_Pos)
N#define TWI_STS_TXERXE         								TWI_STS_TXERXE_Msk
N
N#define TWI_STS_GCA_Pos         							(2U)
N#define	TWI_STS_GCA_Msk												(0x1L << TWI_STS_GCA_Pos)
N#define TWI_STS_GCA         									TWI_STS_GCA_Msk
N
N#define TWI_STS_MSTR_Pos         							(3U)
N#define	TWI_STS_MSTR_Msk											(0x1L << TWI_STS_MSTR_Pos)
N#define TWI_STS_MSTR         									TWI_STS_MSTR_Msk
N
N#define TWI_STS_STATE_Pos         						(8U)
N#define	TWI_STS_STATE_Msk											(0x7L << TWI_STS_STATE_Pos)
N#define TWI_STS_STATE         								TWI_STS_STATE_Msk
N
N#define TWI_STS_NBYTES_Pos         						(16U)
N#define	TWI_STS_NBYTES_Msk										(0xFFL << TWI_STS_NBYTES_Pos)
N#define TWI_STS_NBYTES         								TWI_STS_NBYTES_Msk
N/********************  Bit definition for TWI_ADD register  ********************/
N#define TWI_ADD_GC_Pos         							  (0U)
N#define	TWI_ADD_GC_Msk											  (0x1L << TWI_ADD_GC_Pos)
N#define TWI_ADD_GC         									  TWI_ADD_GC_Msk
N
N#define TWI_ADD_TWA_Pos         						  (1U)
N#define	TWI_ADD_TWA_Msk										    (0x7FL << TWI_ADD_TWA_Pos)
N#define TWI_ADD_TWA         								  TWI_ADD_TWA_Msk
N/********************  Bit definition for TWI_IDE register  ********************/
N#define TWI_IDE_INTEN_Pos         						(0U)
N#define	TWI_IDE_INTEN_Msk											(0x1L << TWI_IDE_INTEN_Pos)
N#define TWI_IDE_INTEN         								TWI_IDE_INTEN_Msk
N
N#define TWI_IDE_RXDMAEN_Pos         					(6U)
N#define	TWI_IDE_RXDMAEN_Msk										(0x1L << TWI_IDE_RXDMAEN_Pos)
N#define TWI_IDE_RXDMAEN         							TWI_IDE_RXDMAEN_Msk
N
N#define TWI_IDE_TXDMAEN_Pos         					(7U)
N#define	TWI_IDE_TXDMAEN_Msk										(0x1L << TWI_IDE_TXDMAEN_Pos)
N#define TWI_IDE_TXDMAEN        								TWI_IDE_TXDMAEN_Msk
N
N/******************************************************************************/
N/*                                                                            */
N/*                      UART               																*/
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for UART_CON register  ********************/
N#define UART_CON_SM01_Pos         					(0U)
N#define	UART_CON_SM01_Msk										(0x3L << UART_CON_SM01_Pos)
N#define UART_CON_SM01         							UART_CON_SM01_Msk
N
N#define UART_CON_SM2_Pos         						(2U)
N#define	UART_CON_SM2_Msk										(0x1L << UART_CON_SM2_Pos)
N#define UART_CON_SM2         								UART_CON_SM2_Msk
N
N#define UART_CON_BTKR_Pos         					(3U)
N#define	UART_CON_BTKR_Msk										(0x1L << UART_CON_BTKR_Pos)
N#define UART_CON_BTKR         							UART_CON_BTKR_Msk
N
N#define UART_CON_PERSCALER_Pos         			(4U)
N#define	UART_CON_PERSCALER_Msk							(0x1L << UART_CON_PERSCALER_Pos)
N#define UART_CON_PERSCALER         					UART_CON_PERSCALER_Msk
N
N
N#define UART_CON_RXEN_Pos         					(6U)
N#define	UART_CON_RXEN_Msk										(0x1L << UART_CON_RXEN_Pos)
N#define UART_CON_RXEN         							UART_CON_RXEN_Msk
N
N#define UART_CON_TXEN_Pos         					(7U)
N#define	UART_CON_TXEN_Msk										(0x1L << UART_CON_TXEN_Pos)
N#define UART_CON_TXEN         							UART_CON_TXEN_Msk
N
N#define UART_CON_LBDL_Pos         					(11U)
N#define	UART_CON_LBDL_Msk										(0x1L << UART_CON_LBDL_Pos)
N#define UART_CON_LBDL         							UART_CON_LBDL_Msk
N
N#define UART_CON_SPOS_Pos         					(14U)
N#define	UART_CON_SPOS_Msk										(0x3L << UART_CON_SPOS_Pos)
N#define UART_CON_SPOS         							UART_CON_SPOS_Msk
N
N/********************  Bit definition for UART_STS register  ********************/
N#define UART_STS_RXIF_Pos         					(0U)
N#define	UART_STS_RXIF_Msk										(0x1L << UART_STS_RXIF_Pos)
N#define UART_STS_RXIF         							UART_STS_RXIF_Msk
N
N#define UART_STS_TXIF_Pos         					(1U)
N#define	UART_STS_TXIF_Msk										(0x1L << UART_STS_TXIF_Pos)
N#define UART_STS_TXIF         							UART_STS_TXIF_Msk
N
N#define UART_STS_BKIF_Pos         					(3U)
N#define	UART_STS_BKIF_Msk										(0x1L << UART_STS_BKIF_Pos)
N#define UART_STS_BKIF         							UART_STS_BKIF_Msk
N
N#define UART_STS_WKIF_Pos         					(4U)
N#define	UART_STS_WKIF_Msk										(0x1L << UART_STS_WKIF_Pos)
N#define UART_STS_WKIF         							UART_STS_WKIF_Msk
N/********************  Bit definition for UART_IDE register  ********************/
N#define UART_IDE_INTEN_Pos         					(0U)
N#define	UART_IDE_INTEN_Msk									(0x1L << UART_IDE_INTEN_Pos)
N#define UART_IDE_INTEN         							UART_IDE_INTEN_Msk
N
N#define UART_IDE_RXIE_Pos         					(1U)
N#define	UART_IDE_RXIE_Msk										(0x1L << UART_IDE_RXIE_Pos)
N#define UART_IDE_RXIE         							UART_IDE_RXIE_Msk
N
N#define UART_IDE_TXIE_Pos         					(2U)
N#define	UART_IDE_TXIE_Msk										(0x1L << UART_IDE_TXIE_Pos)
N#define UART_IDE_TXIE         							UART_IDE_TXIE_Msk
N
N#define UART_IDE_BKIE_Pos         					(3U)
N#define	UART_IDE_BKIE_Msk										(0x1L << UART_IDE_BKIE_Pos)
N#define UART_IDE_BKIE         							UART_IDE_BKIE_Msk
N
N#define UART_IDE_WKIE_Pos         					(4U)
N#define	UART_IDE_WKIE_Msk										(0x1L << UART_IDE_WKIE_Pos)
N#define UART_IDE_WKIE         							UART_IDE_WKIE_Msk
N
N#define UART_IDE_RXDMAEN_Pos         				(6U)
N#define	UART_IDE_RXDMAEN_Msk								(0x1L << UART_IDE_RXDMAEN_Pos)
N#define UART_IDE_RXDMAEN         						UART_IDE_RXDMAEN_Msk
N
N#define UART_IDE_TXDMAEN_Pos         				(7U)
N#define	UART_IDE_TXDMAEN_Msk								(0x1L << UART_IDE_TXDMAEN_Pos)
N#define UART_IDE_TXDMAEN         						UART_IDE_TXDMAEN_Msk
N
N/******************************************************************************/
N/*                                                                            */
N/*                      WDT               																		*/
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for WDT_CON register  ********************/
N#define WDT_CON_CLRWDT_Pos         					(0U)
N#define	WDT_CON_CLRWDT_Msk									(0x1L << WDT_CON_CLRWDT_Pos)
N#define WDT_CON_CLRWDT         							WDT_CON_CLRWDT_Msk
N
N/********************  Bit definition for WDT_CFG register  ********************/
N#define WDT_CFG_WDTCKS_Pos         					(0U)
N#define	WDT_CFG_WDTCKS_Msk									(0x7L << WDT_CFG_WDTCKS_Pos)
N#define WDT_CFG_WDTCKS         							WDT_CFG_WDTCKS_Msk
N
N#define SC32F10xSx_NIO_Init() {*(uint32_t*)(GPIOA_BIT_BASE+0X00000020)|= 0X00000006;\
N                               *(uint32_t*)(GPIOB_BIT_BASE+0X00000020)|= 0X00009000;}
X#define SC32F10xSx_NIO_Init() {*(uint32_t*)(GPIOA_BIT_BASE+0X00000020)|= 0X00000006;                               *(uint32_t*)(GPIOB_BIT_BASE+0X00000020)|= 0X00009000;}
N
N#define SC32F10xKx_NIO_Init() {*(uint32_t*)(GPIOA_BIT_BASE+0X00000020)|= 0X0000003E;\
N	                             *(uint32_t*)(GPIOB_BIT_BASE+0X00000020)|= 0X000090F4;\
N	                             *(uint32_t*)(GPIOC_BIT_BASE+0X00000020)|= 0X00002032;} 
X#define SC32F10xKx_NIO_Init() {*(uint32_t*)(GPIOA_BIT_BASE+0X00000020)|= 0X0000003E;	                             *(uint32_t*)(GPIOB_BIT_BASE+0X00000020)|= 0X000090F4;	                             *(uint32_t*)(GPIOC_BIT_BASE+0X00000020)|= 0X00002032;} 
N	
N#define SC32F10xGx_NIO_Init() {*(uint32_t*)(GPIOA_BIT_BASE+0X00000020)|= 0X0000003F;\
N	                             *(uint32_t*)(GPIOB_BIT_BASE+0X00000020)|= 0X000091F4;\
N	                             *(uint32_t*)(GPIOC_BIT_BASE+0X00000020)|= 0X00003033;} 
X#define SC32F10xGx_NIO_Init() {*(uint32_t*)(GPIOA_BIT_BASE+0X00000020)|= 0X0000003F;	                             *(uint32_t*)(GPIOB_BIT_BASE+0X00000020)|= 0X000091F4;	                             *(uint32_t*)(GPIOC_BIT_BASE+0X00000020)|= 0X00003033;} 
N
N/** @addtogroup Exported_macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N * @}
N */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /* sc32f10xx_H */
N
N/**
N  * @}
N  */
N
N/**
N* @}
N*/
N
N/************************ (C) COPYRIGHT SIN ONE CHIP *****END OF FILE****/
L 56 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx.h" 2
N#elif defined(SC32f11xx)
S  #include "SC32f11xx.h"
S#elif defined(SC32f12xx)
S  #include "SC32f12xx.h"
S#elif defined(SC32f15xx)
S  #include "sc32f15Gx.h"
S#else
S #error "Please select first the target SC32F1xxx device used in your application (in SC32F1xxx.h file)"
N#endif
N
N
N
N#ifdef __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /* SC32F1xxx_H */
N
N/**
N  * @}
N  */
N
N/**
N* @}
N*/
N
L 28 "..\FWLib\SC32F1XXX_Lib\inc\sc32_conf.h" 2
N#include "sc32f1xxx_rcc.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx_rcc.h" 1
N/**
N ******************************************************************************
N * @file    sc32f1xxx_rcc.h
N * @author  SOC AE Team
N * @version V1.6
N * @date    04-09-2024
N * @brief   This file contains all the functions prototypes for the RCC
N *
N ******************************************************************************
N * @attention
N *
N *1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only
N *intended for use with SinOne products. No other uses are authorized. This
N *software is owned by SinOne Microelectronics Co.,Ltd. and is protected under
N *all applicable laws, including copyright laws.
N *2.The software which is for guidance only aims at providing customers with
N *coding information regarding their products in order for them to save time.
N *As a result, SinOne shall not be held liable for any direct, indirect or
N *consequential damages with respect to any claims arising from the content of
N *such software and/or the use made by customers of the coding information
N *contained herein in connection with their products.
N *
N *  COPYRIGHT 2024 SinOne Microelectronics
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __sc32f1xxx_RCC_H
N#define __sc32f1xxx_RCC_H
N
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/*!< Includes ----------------------------------------------------------------*/
N#include "sc32f1xxx.h"
N#include "sc32.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32.h" 1
N/**
N******************************************************************************
N* @file    SC32.h
N* @author  SOC AE Team
N* @version V1.6
N* @date    04-09-2024
N* @brief
N*
N******************************************************************************
N* @attention
N*
N*1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only 
N*intended for use with SinOne products. No other uses are authorized. This 
N*software is owned by SinOne Microelectronics Co.,Ltd. and is protected under 
N*all applicable laws, including copyright laws. 
N*2.The software which is for guidance only aims at providing customers with 
N*coding information regarding their products in order for them to save time. 
N*As a result, SinOne shall not be held liable for any direct, indirect or 
N*consequential damages with respect to any claims arising from the content of 
N*such software and/or the use made by customers of the coding information 
N*contained herein in connection with their products.
N*
N*  COPYRIGHT 2024 SinOne Microelectronics
N*/
N/** @addtogroup CMSIS_Device
N* @{
N*/
N
N/** @addtogroup sc32
N  * @{
N  */
N
N#ifndef SC32_H
N#define SC32_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#include <stdint.h>
N
N/* Exported macro ------------------------------------------------------------*/
N#ifdef  USE_FULL_ASSERT
S/**
S  * @brief  The assert_param macro is used for function's parameters check.
S  * @param  expr: If expr is false, it calls assert_failed function
S  *         which reports the name of the source file and the source
S  *         line number of the call that failed.
S  *         If expr is true, it returns no value.
S  * @retval None
S  */
S#define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
S/* Exported functions ------------------------------------------------------- */
Svoid assert_failed(uint8_t* file, uint32_t line);
N#else
N#define assert_param(expr) ((void)0U)
N#endif /* USE_FULL_ASSERT */
N
N
N#ifdef __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /* SC32_H */
N
N/**
N  * @}
N  */
N
N/**
N* @}
N*/
N
N/************************ (C) COPYRIGHT SIN ONE CHIP *****END OF FILE****/
L 39 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx_rcc.h" 2
N
N/** @addtogroup sc32f1xxx_StdPeriph_Driver
N * @{
N */
N
N/** @addtogroup RCC
N * @{
N */
N
N/* Exported types ------------------------------------------------------------*/
N/** @brief RCC_SYSCLKSource System Clock Source
N * @{
N */
N#if defined(SC32f10xx)
X#if 1L
Ntypedef enum
N{
N    RCC_SYSCLKSource_HIRC   = ( uint16_t ) ( ~RCC_CFG0_SYSCLKSW ), /*!< SYSCLK Source  HIRC */
X    RCC_SYSCLKSource_HIRC   = ( uint16_t ) ( ~(0x1UL << (7U)) ),  
N    RCC_SYSCLKSource_LIRC    =
N        ( uint16_t ) ( ( 0x00 << RCC_CFG0_SYSCLKSEL_Pos ) ), /*!< SYSCLK Source  LIRC */
X        ( uint16_t ) ( ( 0x00 << (8U) ) ),  
N    RCC_SYSCLKSource_HXT    =
N        ( uint16_t ) ( ( 0x01 << RCC_CFG0_SYSCLKSEL_Pos ) ), /*!< SYSCLK Source  HXT */
X        ( uint16_t ) ( ( 0x01 << (8U) ) ),  
N    RCC_SYSCLKSource_PLLRCLK =
N        ( uint16_t ) ( ( 0x02 << RCC_CFG0_SYSCLKSEL_Pos ) ), /*!< SYSCLK Source  PLLCK */
X        ( uint16_t ) ( ( 0x02 << (8U) ) ),  
N    RCC_SYSCLKSource_LXT    =
N        ( uint16_t ) ( ( 0x03 << RCC_CFG0_SYSCLKSEL_Pos ) ), /*!< SYSCLK Source  LXT */
X        ( uint16_t ) ( ( 0x03 << (8U) ) ),  
N} RCC_SYSCLKSource_TypeDef;
N
N#define IS_RCC_SYSCLKSOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HIRC) || \
N                                     ((SOURCE) == RCC_SYSCLKSource_LIRC) || \
N                                     ((SOURCE) == RCC_SYSCLKSource_HXT)  || \
N                                     ((SOURCE) == RCC_SYSCLKSource_PLLRCLK) || \
N                                     ((SOURCE) == RCC_SYSCLKSource_LXT))
X#define IS_RCC_SYSCLKSOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HIRC) ||                                      ((SOURCE) == RCC_SYSCLKSource_LIRC) ||                                      ((SOURCE) == RCC_SYSCLKSource_HXT)  ||                                      ((SOURCE) == RCC_SYSCLKSource_PLLRCLK) ||                                      ((SOURCE) == RCC_SYSCLKSource_LXT))
N#elif defined(SC32f11xx) || defined(SC32f12xx)
Stypedef enum
S{
S    RCC_SYSCLKSource_HIRC_2   = ( uint16_t ) ( ~RCC_CFG0_SYSCLKSW ), /*!< SYSCLK Source  HIRC/2 */
S    RCC_SYSCLKSource_LIRC    =
S        ( uint16_t ) ( ( 0x00 << RCC_CFG0_SYSCLKSEL_Pos ) ), /*!< SYSCLK Source  LIRC */
S    RCC_SYSCLKSource_HXT    =
S        ( uint16_t ) ( ( 0x01 << RCC_CFG0_SYSCLKSEL_Pos ) ), /*!< SYSCLK Source  HXT */
S    RCC_SYSCLKSource_HIRC =
S        ( uint16_t ) ( ( 0x02 << RCC_CFG0_SYSCLKSEL_Pos ) ), /*!< SYSCLK Source  HIRC */
S    RCC_SYSCLKSource_LXT    =
S        ( uint16_t ) ( ( 0x03 << RCC_CFG0_SYSCLKSEL_Pos ) ), /*!< SYSCLK Source  LXT */
S} RCC_SYSCLKSource_TypeDef;
S
S#define IS_RCC_SYSCLKSOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HIRC_2) || \
S                                     ((SOURCE) == RCC_SYSCLKSource_LIRC) || \
S                                     ((SOURCE) == RCC_SYSCLKSource_HXT)  || \
S                                     ((SOURCE) == RCC_SYSCLKSource_HIRC) || \
S                                     ((SOURCE) == RCC_SYSCLKSource_LXT))
X#define IS_RCC_SYSCLKSOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HIRC_2) ||                                      ((SOURCE) == RCC_SYSCLKSource_LIRC) ||                                      ((SOURCE) == RCC_SYSCLKSource_HXT)  ||                                      ((SOURCE) == RCC_SYSCLKSource_HIRC) ||                                      ((SOURCE) == RCC_SYSCLKSource_LXT))
S#elif defined(SC32f15xx)
S/** @defgroup RCC_SysTickSource SysTick Clock Source
S * @{
S */
Stypedef enum
S{
S  RCC_SYSCLKSource_HIRC_2   = (uint16_t)(~RCC_CFG0_SYSCLKSW),    /*!< SYSCLK Source  HIRC/2 */
S  RCC_SYSCLKSource_LIRC    =
S    (uint16_t)((0x00 << RCC_CFG0_SYSCLKSEL_Pos)),/*!< SYSCLK Source  LIRC */
S  RCC_SYSCLKSource_HIRC =
S    (uint16_t)((0x02 << RCC_CFG0_SYSCLKSEL_Pos)),/*!< SYSCLK Source  HIRC */
S  RCC_SYSCLKSource_LXT    =
S    (uint16_t)((0x03 << RCC_CFG0_SYSCLKSEL_Pos)),/*!< SYSCLK Source  LXT */
S} RCC_SYSCLKSource_TypeDef;
S
S#define IS_RCC_SYSCLKSOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HIRC) || \
S                                     ((SOURCE) == RCC_SYSCLKSource_LIRC) || \
S                                     ((SOURCE) == RCC_SYSCLKSource_HIRC_2) || \
S                                     ((SOURCE) == RCC_SYSCLKSource_LXT))
X#define IS_RCC_SYSCLKSOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HIRC) ||                                      ((SOURCE) == RCC_SYSCLKSource_LIRC) ||                                      ((SOURCE) == RCC_SYSCLKSource_HIRC_2) ||                                      ((SOURCE) == RCC_SYSCLKSource_LXT))
S
N#endif
N/**
N * @}
N */
N
N/** @brief RCC_SysTickSource SysTick Clock Source
N * @{
N */
Ntypedef enum
N{
N    RCC_SysTickSource_HCLK_DIV8 =
N        ( uint8_t ) ( 0X00 << RCC_CFG1_STCLKSEL_Pos ), /*!< SysTickCLK clock = HCLK/8 */
X        ( uint8_t ) ( 0X00 << (5U) ),  
N    RCC_SysTickSource_HIRC_DIV2  =
N        ( uint8_t ) ( 0X01 << RCC_CFG1_STCLKSEL_Pos ), /*!< SysTickCLK clock = HIRC/2 */
X        ( uint8_t ) ( 0X01 << (5U) ),  
N    RCC_SysTickSource_HXT_DIV2  =
N        ( uint8_t ) ( 0X02 << RCC_CFG1_STCLKSEL_Pos ), /*!< SysTickCLK clock = HXT/2 */
X        ( uint8_t ) ( 0X02 << (5U) ),  
N    RCC_SysTickSource_LIRC  =
N        ( uint8_t ) ( 0X03 << RCC_CFG1_STCLKSEL_Pos ), /*!< SysTickCLK clock = LIRC */
X        ( uint8_t ) ( 0X03 << (5U) ),  
N    RCC_SysTickSource_LXT  =
N        ( uint8_t ) ( 0X04 << RCC_CFG1_STCLKSEL_Pos ), /*!< SysTickCLK clock = LXT */
X        ( uint8_t ) ( 0X04 << (5U) ),  
N    RCC_SysTickSource_HCLK = ( uint8_t ) ( 0X01 ), /*!< SysTickCLK clock = HCLK */
N} RCC_SysTickSource_TypeDef;
N
N#define IS_RCC_SYSTICKSOURCE(SOURCE) (((SOURCE) == RCC_SysTickSource_HCLK_DIV8) || \
N                                      ((SOURCE) == RCC_SysTickSource_HIRC_DIV2) || \
N                                      ((SOURCE) == RCC_SysTickSource_HXT_DIV2) || \
N                                      ((SOURCE) == RCC_SysTickSource_LIRC) || \
N                                      ((SOURCE) == RCC_SysTickSource_LXT)|| \
N                                      ((SOURCE) == RCC_SysTickSource_HCLK))
X#define IS_RCC_SYSTICKSOURCE(SOURCE) (((SOURCE) == RCC_SysTickSource_HCLK_DIV8) ||                                       ((SOURCE) == RCC_SysTickSource_HIRC_DIV2) ||                                       ((SOURCE) == RCC_SysTickSource_HXT_DIV2) ||                                       ((SOURCE) == RCC_SysTickSource_LIRC) ||                                       ((SOURCE) == RCC_SysTickSource_LXT)||                                       ((SOURCE) == RCC_SysTickSource_HCLK))
N/**
N * @}
N */
N
N/** @brief RCC_HCLK HCLK clock Source
N * @{
N */
Ntypedef enum
N{
N    RCC_SYSCLK_Div1  = ( uint32_t ) ( 0x00 << AHB_CFG_CLKDIV_Pos ), /*!< AHB clock = SYSCLK */
X    RCC_SYSCLK_Div1  = ( uint32_t ) ( 0x00 << (20U) ),  
N    RCC_SYSCLK_Div2  = ( uint32_t ) ( 0x01 << AHB_CFG_CLKDIV_Pos ), /*!< AHB clock = SYSCLK/2 */
X    RCC_SYSCLK_Div2  = ( uint32_t ) ( 0x01 << (20U) ),  
N    RCC_SYSCLK_Div4  = ( uint32_t ) ( 0x02 << AHB_CFG_CLKDIV_Pos ), /*!< AHB clock = SYSCLK/4 */
X    RCC_SYSCLK_Div4  = ( uint32_t ) ( 0x02 << (20U) ),  
N    RCC_SYSCLK_Div8  = ( uint32_t ) ( 0x03 << AHB_CFG_CLKDIV_Pos ), /*!< AHB clock = SYSCLK/8 */
X    RCC_SYSCLK_Div8  = ( uint32_t ) ( 0x03 << (20U) ),  
N    RCC_SYSCLK_Div16 = ( uint32_t ) ( 0x04 << AHB_CFG_CLKDIV_Pos ), /*!< AHB clock = SYSCLK/16 */
X    RCC_SYSCLK_Div16 = ( uint32_t ) ( 0x04 << (20U) ),  
N} RCC_HCLK_TypeDef;
N
N#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || \
N                           ((HCLK) == RCC_SYSCLK_Div2) || \
N                           ((HCLK) == RCC_SYSCLK_Div4) || \
N                           ((HCLK) == RCC_SYSCLK_Div8) || \
N                           ((HCLK) == RCC_SYSCLK_Div16))
X#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) ||                            ((HCLK) == RCC_SYSCLK_Div2) ||                            ((HCLK) == RCC_SYSCLK_Div4) ||                            ((HCLK) == RCC_SYSCLK_Div8) ||                            ((HCLK) == RCC_SYSCLK_Div16))
N
N/**
N * @}
N */
N
N/** @brief RCC_PCLK  RCC PCLK
N * @{
N */
N
Ntypedef enum
N{
N    RCC_HCLK_Div1		= ( uint32_t ) ( 0x00 << AHB_CFG_CLKDIV_Pos ), /*!< APB clock = AHB */
X    RCC_HCLK_Div1		= ( uint32_t ) ( 0x00 << (20U) ),  
N    RCC_HCLK_Div2		= ( uint32_t ) ( 0x01 << AHB_CFG_CLKDIV_Pos ), /*!< APB clock = AHB/2 */
X    RCC_HCLK_Div2		= ( uint32_t ) ( 0x01 << (20U) ),  
N    RCC_HCLK_Div4		= ( uint32_t ) ( 0x02 << AHB_CFG_CLKDIV_Pos ), /*!< APB clock = AHB/4 */
X    RCC_HCLK_Div4		= ( uint32_t ) ( 0x02 << (20U) ),  
N    RCC_HCLK_Div8  	= ( uint32_t ) ( 0x03 << AHB_CFG_CLKDIV_Pos ), /*!< APB clock = AHB/8 */
X    RCC_HCLK_Div8  	= ( uint32_t ) ( 0x03 << (20U) ),  
N    RCC_HCLK_Div16 	= ( uint32_t ) ( 0x04 << AHB_CFG_CLKDIV_Pos ), /*!< APB clock = AHB/16 */
X    RCC_HCLK_Div16 	= ( uint32_t ) ( 0x04 << (20U) ),  
N    RCC_HCLK_Div32 	= ( uint32_t ) ( 0x05 << AHB_CFG_CLKDIV_Pos ), /*!< APB clock = AHB/32 */
X    RCC_HCLK_Div32 	= ( uint32_t ) ( 0x05 << (20U) ),  
N    RCC_HCLK_Div64 	= ( uint32_t ) ( 0x06 << AHB_CFG_CLKDIV_Pos ), /*!< APB clock = AHB/64 */
X    RCC_HCLK_Div64 	= ( uint32_t ) ( 0x06 << (20U) ),  
N    RCC_HCLK_Div128 = ( uint32_t ) ( 0x07 << AHB_CFG_CLKDIV_Pos ), /*!< APB clock = AHB/128 */
X    RCC_HCLK_Div128 = ( uint32_t ) ( 0x07 << (20U) ),  
N} RCC_PCLK_TypeDef;
N
N#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || \
N                           ((PCLK) == RCC_HCLK_Div2) || \
N                           ((PCLK) == RCC_HCLK_Div4) || \
N                           ((PCLK) == RCC_HCLK_Div8) || \
N                           ((PCLK) == RCC_HCLK_Div16)|| \
N                           ((PCLK) == RCC_HCLK_Div32)|| \
N                           ((PCLK) == RCC_HCLK_Div64)|| \
N                           ((PCLK) == RCC_HCLK_Div128))
X#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) ||                            ((PCLK) == RCC_HCLK_Div2) ||                            ((PCLK) == RCC_HCLK_Div4) ||                            ((PCLK) == RCC_HCLK_Div8) ||                            ((PCLK) == RCC_HCLK_Div16)||                            ((PCLK) == RCC_HCLK_Div32)||                            ((PCLK) == RCC_HCLK_Div64)||                            ((PCLK) == RCC_HCLK_Div128))
N/**
N * @}
N */
N
N/** @brief RCC_LCDLEDCLKSource LCDLED clock Source
N * @{
N */
N#if defined(SC32f11xx) || defined(SC32f12xx)|| defined(SC32f10xx)
X#if 0L || 0L|| 1L
Ntypedef enum
N{
N    RCC_LCDLEDCLKSource_LIRC = ( uint32_t ) ( 0x00 << RCC_CFG1_LCDCLKSEL_Pos ), /*!< LCD_LED clock = LIRC */
X    RCC_LCDLEDCLKSource_LIRC = ( uint32_t ) ( 0x00 << (1U) ),  
N    RCC_LCDLEDCLKSource_LXT  = ( uint32_t ) ( 0x01 << RCC_CFG1_LCDCLKSEL_Pos ), /*!< LCD_LED clock = LXT */
X    RCC_LCDLEDCLKSource_LXT  = ( uint32_t ) ( 0x01 << (1U) ),  
N} RCC_LCDLEDCLKSource_TypeDef;
N
N#define RCC_LCDLEDCLKSOURCE(SOURCE) (((SOURCE) == RCC_LCDLEDCLKSource_LIRC) || \
N																		((SOURCE) == RCC_LCDLEDCLKSource_LXT))
X#define RCC_LCDLEDCLKSOURCE(SOURCE) (((SOURCE) == RCC_LCDLEDCLKSource_LIRC) || 																		((SOURCE) == RCC_LCDLEDCLKSource_LXT))
N#endif
N/**
N * @}
N */
N
N/** @brief RCC_BTMCLKSource BTM clock Source
N* @{
N*/
Ntypedef enum
N{
N    RCC_BTMCLKSource_LIRC = ( uint32_t ) ( 0x00 << RCC_CFG1_BTMCLKSEL_Pos ), /*!< BTM clock = LIRC */
X    RCC_BTMCLKSource_LIRC = ( uint32_t ) ( 0x00 << (0U) ),  
N    RCC_BTMCLKSource_LXT  = ( uint32_t ) ( 0x01 << RCC_CFG1_BTMCLKSEL_Pos ), /*!< BTM clock = LXT */
X    RCC_BTMCLKSource_LXT  = ( uint32_t ) ( 0x01 << (0U) ),  
N} RCC_BTMCLKSource_TypeDef;
N
N#define RCC_BTMCLKSOURCE(SOURCE) (((SOURCE) == RCC_BTMCLKSource_LIRC) || \
N                                  ((SOURCE) == RCC_BTMCLKSource_LXT))
X#define RCC_BTMCLKSOURCE(SOURCE) (((SOURCE) == RCC_BTMCLKSource_LIRC) ||                                   ((SOURCE) == RCC_BTMCLKSource_LXT))
N
N/**
N * @}
N */
N#if defined(SC32f10xx)
X#if 1L
N/** @brief RCC_PLLCLKSource PLL clock Source
N* @{
N*/
Ntypedef enum
N{
N    RCC_PLLCLKSource_HIRC  = ( uint32_t ) ( 0x00 << PLL_CFG_PLLCLKSEL_Pos ), /*!< PLL clock = HIRC */
X    RCC_PLLCLKSource_HIRC  = ( uint32_t ) ( 0x00 << (23U) ),  
N    RCC_PLLCLKSource_HXT   = ( uint32_t ) ( 0x01 << PLL_CFG_PLLCLKSEL_Pos ), /*!< PLL clock = HXT */
X    RCC_PLLCLKSource_HXT   = ( uint32_t ) ( 0x01 << (23U) ),  
N} RCC_PLLCLKSource_TypeDef;
N
N#define RCC_PLLCLKSOURCE(SOURCE) (((SOURCE) == RCC_PLLCLKSource_HXT) || \
N                                  ((SOURCE) == RCC_PLLCLKSource_HIRC))
X#define RCC_PLLCLKSOURCE(SOURCE) (((SOURCE) == RCC_PLLCLKSource_HXT) ||                                   ((SOURCE) == RCC_PLLCLKSource_HIRC))
N/**
N * @}
N */
N#endif
N/** @defgroup RCC_PWM0CLKSELSource PWM0 clock Source
N * @{
N */
N
N
N#if defined(SC32f12xx) || defined(SC32f11xx)
X#if 0L || 0L
Stypedef enum
S{
S    RCC_PWM0CLKSource_PCLK = ( uint32_t ) ( 0x00 << RCC_CFG1_PWM0CLKSEL_Pos ), /*!< PWM0 clock = PCLK */
S    RCC_PWM0CLKSource_Div1HIRC = ( uint32_t ) ( 0x01 << RCC_CFG1_PWM0CLKSEL_Pos ), /*!< PWM0 clock = HIRC */
S} RCC_PWM0CLKSource_TypeDef;
S
S#define RCC_PWM0CLKSOURCE(SOURCE) (((SOURCE) == RCC_PWM0CLKSource_PCLK) || \
S                                   ((SOURCE) == RCC_PWM0CLKSource_Div1HIRC))
X#define RCC_PWM0CLKSOURCE(SOURCE) (((SOURCE) == RCC_PWM0CLKSource_PCLK) ||                                    ((SOURCE) == RCC_PWM0CLKSource_Div1HIRC))
N#elif defined(SC32f10xx)
X#elif 1L
Ntypedef enum
N{
N    RCC_PWM0CLKSource_PCLK = ( uint32_t ) ( 0x00 << RCC_CFG1_PWM0CLKSEL_Pos ), /*!< PWM0 clock = PCLK */
X    RCC_PWM0CLKSource_PCLK = ( uint32_t ) ( 0x00 << (2U) ),  
N    RCC_PWM0CLKSource_PLLQ = ( uint32_t ) ( 0x01 << RCC_CFG1_PWM0CLKSEL_Pos ), /*!< PWM0 clock = PLL */
X    RCC_PWM0CLKSource_PLLQ = ( uint32_t ) ( 0x01 << (2U) ),  
N} RCC_PWM0CLKSource_TypeDef;
N
N#define RCC_PWM0CLKSOURCE(SOURCE) (((SOURCE) == RCC_PWM0CLKSource_PCLK) || \
N                                   ((SOURCE) == RCC_PWM0CLKSource_PLLQ))
X#define RCC_PWM0CLKSOURCE(SOURCE) (((SOURCE) == RCC_PWM0CLKSource_PCLK) ||                                    ((SOURCE) == RCC_PWM0CLKSource_PLLQ))
N#endif
N/**
N * @}
N */
N/** @brief RCC_AHBPeriph AHB Periph
N * @{
N */
N#if defined(SC32f10xx) || defined(SC32f12xx)
X#if 1L || 0L
Ntypedef enum
N{
N    RCC_AHBPeriph_DMA = ( uint8_t ) AHB_CFG_DMAEN,
X    RCC_AHBPeriph_DMA = ( uint8_t ) (0x1UL << (0U)),
N    RCC_AHBPeriph_CRC = ( uint8_t ) AHB_CFG_CRCEN,
X    RCC_AHBPeriph_CRC = ( uint8_t ) (0x1UL << (1U)),
N    RCC_AHBPeriph_IFB = ( uint8_t ) AHB_CFG_IFBEN,
X    RCC_AHBPeriph_IFB = ( uint8_t ) (0x1UL << (2U)),
N    RCC_AHBPeriph_ALL = ( uint8_t ) 0X07,
N} RCC_AHBPeriph_TypeDef;
N#define IS_RCC_AHBPERIPH(PERIPH) ((((PERIPH) & (uint8_t)0xF8) == 0x00) && ((PERIPH) != (uint8_t)0x00))
N#elif defined(SC32f11xx) || defined(SC32f15xx)
Stypedef enum
S{
S    RCC_AHBPeriph_DMA = ( uint8_t ) AHB_CFG_DMAEN,
S    RCC_AHBPeriph_CRC = ( uint8_t ) AHB_CFG_CRCEN,
S    RCC_AHBPeriph_IFB = ( uint8_t ) AHB_CFG_IFBEN,
S    RCC_AHBPeriph_CAN = ( uint8_t ) AHB_CFG_CANEN,
S    RCC_AHBPeriph_ALL = ( uint8_t ) 0X17,
S} RCC_AHBPeriph_TypeDef;
S#define IS_RCC_AHBPERIPH(PERIPH) ((((PERIPH) & (uint8_t)0xE8) == 0x00) && ((PERIPH) != (uint8_t)0x00))
N#endif
N/**
N * @}
N */
N
N/** @brief RCC_APB0Periph APB0 Periph
N* @{
N*/
N#if defined(SC32f10xx)
X#if 1L
Ntypedef enum
N{
N    RCC_APB0Periph_TIM0  = ( uint16_t ) APB0_CFG_TIM0EN,
X    RCC_APB0Periph_TIM0  = ( uint16_t ) (0x1UL << (0U)),
N    RCC_APB0Periph_TIM1  = ( uint16_t ) APB0_CFG_TIM1EN,
X    RCC_APB0Periph_TIM1  = ( uint16_t ) (0x1UL << (1U)),
N    RCC_APB0Periph_TIM2  = ( uint16_t ) APB0_CFG_TIM2EN,
X    RCC_APB0Periph_TIM2  = ( uint16_t ) (0x1UL << (2U)),
N    RCC_APB0Periph_TIM3  = ( uint16_t ) APB0_CFG_TIM3EN,
X    RCC_APB0Periph_TIM3  = ( uint16_t ) (0x1UL << (3U)),
N    RCC_APB0Periph_TWI0  = ( uint16_t ) APB0_CFG_TWI0EN,
X    RCC_APB0Periph_TWI0  = ( uint16_t ) (0x1UL << (4U)),
N    RCC_APB0Periph_SPI0  = ( uint16_t ) APB0_CFG_SPI0EN,
X    RCC_APB0Periph_SPI0  = ( uint16_t ) (0x1UL << (5U)),
N    RCC_APB0Periph_UART0 = ( uint16_t ) APB0_CFG_UART0EN,
X    RCC_APB0Periph_UART0 = ( uint16_t ) (0x1UL << (6U)),
N    RCC_APB0Periph_UART1 = ( uint16_t ) APB0_CFG_UART1EN,
X    RCC_APB0Periph_UART1 = ( uint16_t ) (0x1UL << (7U)),
N    RCC_APB0Periph_PWM0  = ( uint16_t ) APB0_CFG_PWM0EN,
X    RCC_APB0Periph_PWM0  = ( uint16_t ) (0x1UL << (8U)),
N    RCC_APB0Periph_ALL   = ( uint16_t ) 0X01FF,
N} RCC_APB0Periph_TypeDef;
N#define IS_RCC_APB0PERIPH(PERIPH) ((((PERIPH) & (uint8_t)0xFE00) == 0x00) && ((PERIPH) != (uint16_t)0x00))
N
N
N#elif defined(SC32f11xx) || defined(SC32f12xx)
Stypedef enum
S{
S    RCC_APB0Periph_TIM0  = ( uint16_t ) APB0_CFG_TIM0EN,
S    RCC_APB0Periph_TIM1  = ( uint16_t ) APB0_CFG_TIM1EN,
S    RCC_APB0Periph_TIM2  = ( uint16_t ) APB0_CFG_TIM2EN,
S    RCC_APB0Periph_TIM3  = ( uint16_t ) APB0_CFG_TIM3EN,
S    RCC_APB0Periph_TWI0  = ( uint16_t ) APB0_CFG_TWI0EN,
S    RCC_APB0Periph_SPI0  = ( uint16_t ) APB0_CFG_SPI0EN,
S    RCC_APB0Periph_UART0 = ( uint16_t ) APB0_CFG_UART0EN,
S    RCC_APB0Periph_UART1 = ( uint16_t ) APB0_CFG_UART1EN,
S    RCC_APB0Periph_PWM0  = ( uint16_t ) APB0_CFG_PWM0EN,
S    RCC_APB0Periph_UART5 = ( uint16_t ) APB0_CFG_UART5EN,
S    RCC_APB0Periph_ALL   = ( uint16_t ) 0X03FF,
S} RCC_APB0Periph_TypeDef;
S#define IS_RCC_APB0PERIPH(PERIPH) ((((PERIPH) & (uint8_t)0xFC00) == 0x00) && ((PERIPH) != (uint16_t)0x00))
S#elif defined(SC32f15xx) 
S
Stypedef enum
S{
S  RCC_APB0Periph_TIM0   = (uint16_t)APB0_CFG_TIM0EN,
S  RCC_APB0Periph_TIM1   = (uint16_t)APB0_CFG_TIM1EN,
S  RCC_APB0Periph_TWI0   = (uint16_t)APB0_CFG_TWI0EN,
S  RCC_APB0Periph_SPI0   = (uint16_t)APB0_CFG_SPI0EN,
S  RCC_APB0Periph_UART0  = (uint16_t)APB0_CFG_UART0EN,
S  RCC_APB0Periph_UART1  = (uint16_t)APB0_CFG_UART1EN,
S  RCC_APB0Periph_ALL    = (uint16_t)0X00F3,
S} RCC_APB0Periph_TypeDef;
S#define IS_RCC_APB0PERIPH(PERIPH) ((((PERIPH) & (uint8_t)0x0C) == 0x00) && ((PERIPH) != (uint16_t)0x00))
N#endif
N
N/**
N * @}
N */
N
N/** @brief RCC_APB1Periph APB1 Periph
N* @{
N*/
N#if defined(SC32f10xx)
X#if 1L
Ntypedef enum
N{
N    RCC_APB1Periph_TIM4  = ( uint16_t ) APB1_CFG_TIM4EN,
X    RCC_APB1Periph_TIM4  = ( uint16_t ) (0x1UL << (0U)),
N    RCC_APB1Periph_TIM5  = ( uint16_t ) APB1_CFG_TIM5EN,
X    RCC_APB1Periph_TIM5  = ( uint16_t ) (0x1UL << (1U)),
N    RCC_APB1Periph_TIM6  = ( uint16_t ) APB1_CFG_TIM6EN,
X    RCC_APB1Periph_TIM6  = ( uint16_t ) (0x1UL << (2)),
N    RCC_APB1Periph_TIM7  = ( uint16_t ) APB1_CFG_TIM7EN,
X    RCC_APB1Periph_TIM7  = ( uint16_t ) (0x1UL << (3U)),
N    RCC_APB1Periph_TWI1  = ( uint16_t ) APB1_CFG_TWI1EN,
X    RCC_APB1Periph_TWI1  = ( uint16_t ) (0x1UL << (4U)),
N    RCC_APB1Periph_UART2  = ( uint16_t ) APB1_CFG_UART2EN,
X    RCC_APB1Periph_UART2  = ( uint16_t ) (0x1UL << (7U)),
N    RCC_APB1Periph_ALL   = ( uint16_t ) 0X009F,
N} RCC_APB1Periph_TypeDef;
N#define IS_RCC_APB1PERIPH(PERIPH) ((((PERIPH) & (uint8_t)0xFF60) == 0x00) && ((PERIPH) != (uint16_t)0x00))
N
N#elif defined(SC32f11xx)
Stypedef enum
S{
S    RCC_APB1Periph_TIM4  = ( uint16_t ) APB1_CFG_TIM4EN,
S    RCC_APB1Periph_TIM5  = ( uint16_t ) APB1_CFG_TIM5EN,
S    RCC_APB1Periph_TIM6  = ( uint16_t ) APB1_CFG_TIM6EN,
S    RCC_APB1Periph_TIM7  = ( uint16_t ) APB1_CFG_TIM7EN,
S    RCC_APB1Periph_TWI1  = ( uint16_t ) APB1_CFG_TWI1EN,
S    RCC_APB1Periph_UART4  = ( uint16_t ) APB1_CFG_UART4EN,
S    RCC_APB1Periph_UART2  = ( uint16_t ) APB1_CFG_UART2EN,
S    RCC_APB1Periph_ALL   = ( uint16_t ) 0X00DF,
S} RCC_APB1Periph_TypeDef;
S#define IS_RCC_APB1PERIPH(PERIPH) ((((PERIPH) & (uint8_t)0xFF20) == 0x00) && ((PERIPH) != (uint16_t)0x00))
S
S#elif defined(SC32f12xx)
Stypedef enum
S{
S    RCC_APB1Periph_TIM4  = ( uint16_t ) APB1_CFG_TIM4EN,
S    RCC_APB1Periph_TIM5  = ( uint16_t ) APB1_CFG_TIM5EN,
S    RCC_APB1Periph_TIM6  = ( uint16_t ) APB1_CFG_TIM6EN,
S    RCC_APB1Periph_TIM7  = ( uint16_t ) APB1_CFG_TIM7EN,
S    RCC_APB1Periph_TWI1  = ( uint16_t ) APB1_CFG_TWI1EN,
S    RCC_APB1Periph_SPI1  = ( uint16_t ) APB1_CFG_SPI1EN,
S    RCC_APB1Periph_UART4  = ( uint16_t ) APB1_CFG_UART4EN,
S    RCC_APB1Periph_UART2  = ( uint16_t ) APB1_CFG_UART2EN,
S    RCC_APB1Periph_SPI2  = ( uint16_t ) APB1_CFG_SPI2EN,
S    RCC_APB1Periph_ALL   = ( uint16_t ) 0X01FF,
S} RCC_APB1Periph_TypeDef;
S#define IS_RCC_APB1PERIPH(PERIPH) ((((PERIPH) & (uint8_t)0xFE00) == 0x00) && ((PERIPH) != (uint16_t)0x00))
S#elif defined(SC32f15xx)
S
S/** @defgroup RCC_APB1Periph APB1 Periph
S* @{
S*/
Stypedef enum
S{
S  RCC_APB1Periph_TIM2       = (uint16_t)APB1_CFG_TIM2EN,
S  RCC_APB1Periph_TIM3       = (uint16_t)APB1_CFG_TIM3EN,
S  RCC_APB1Periph_SPI1_TWI1  = (uint16_t)APB1_CFG_SPI1_TWI1EN,
S  RCC_APB1Periph_UART2      = (uint16_t)APB1_CFG_UART2EN,
S  RCC_APB1Periph_ALL        = (uint16_t)0X0093,
S} RCC_APB1Periph_TypeDef;
S#define IS_RCC_APB1PERIPH(PERIPH) ((((PERIPH) & (uint8_t)0xFF6C) == 0x00) && ((PERIPH) != (uint16_t)0x00))
S
N#endif
N/**
N * @}
N */
N
N/** @brief RCC_APB2Periph APB2 Periph
N* @{
N*/
N#if defined(SC32f10xx) ||  defined(SC32f11xx)||  defined(SC32f12xx)
X#if 1L ||  0L||  0L
Ntypedef enum
N{
N    RCC_APB2Periph_LEDPWM   = ( uint16_t ) APB2_CFG_LEDPWMEN,
X    RCC_APB2Periph_LEDPWM   = ( uint16_t ) (0x1UL << (0U)),
N    RCC_APB2Periph_LCD_LED  = ( uint16_t ) APB2_CFG_LCDEN,
X    RCC_APB2Periph_LCD_LED  = ( uint16_t ) (0x3UL << (0U)),
N    RCC_APB2Periph_UART3    = ( uint16_t ) APB2_CFG_UART3EN,
X    RCC_APB2Periph_UART3    = ( uint16_t ) (0x1UL << (2U)),
N    RCC_APB2Periph_ALL      = ( uint16_t ) 0X0007,
N} RCC_APB2Periph_TypeDef;
N#define IS_RCC_APB2PERIPH(PERIPH) ((((PERIPH) & (uint8_t)0xFFF8) == 0x00) && ((PERIPH) != (uint16_t)0x00))
N#elif defined(SC32f15xx) 
S/** @defgroup RCC_APB2Periph APB2 Periph
S* @{
S*/
Stypedef enum
S{
S  RCC_APB2Periph_QEP0  = (uint16_t)APB2_CFG_QEP0EN,
S  RCC_APB2Periph_QEP1  = (uint16_t)APB2_CFG_QEP1EN,
S  RCC_APB2Periph_ADC   = (uint16_t)APB2_CFG_ADCEN,
S  RCC_APB2Periph_ALL   = (uint16_t)0X004C,
S} RCC_APB2Periph_TypeDef;
S#define IS_RCC_APB2PERIPH(PERIPH) ((((PERIPH) & (uint8_t)0xFFA0) == 0x00) && ((PERIPH) != (uint16_t)0x00))
N#endif
N/**
N * @}
N */
N/** @defgroup NMI_CFG Periph NMI Periph
N* @{
N*/
N#if defined(SC32f10xx) ||  defined(SC32f11xx)||  defined(SC32f12xx)
X#if 1L ||  0L||  0L
Ntypedef enum
N{
N    RCC_NMIPeriph_CSS = ( uint16_t ) NMI_CFG_CSSEN,
X    RCC_NMIPeriph_CSS = ( uint16_t ) (0x1UL << (0U)),
N    RCC_NMIPeriph_CMP = ( uint16_t ) NMI_CFG_CMPEN,
X    RCC_NMIPeriph_CMP = ( uint16_t ) (0x1UL << (1U)),
N    RCC_NMIPeriph_INT0    = ( uint16_t ) NMI_CFG_INT0EN,
X    RCC_NMIPeriph_INT0    = ( uint16_t ) (0x1UL << (2U)),
N#if defined(SC32f11xx) || defined(SC32f12xx)
X#if 0L || 0L
S    RCC_NMIPeriph_SRAMPE      = ( uint16_t ) NMI_CFG_SRAMPEEN,
N#endif
N    RCC_NMIPeriph_ALL  = ( uint16_t ) 0X0F,
N} RCC_NMIPeriph_TypeDef;
N#define IS_RCC_NMIPeriph(NMIPeriph) ((((NMIPeriph) & (uint8_t)0xFF00) == 0x00) && ((NMIPeriph) != (uint16_t)0x00))
N#elif defined(SC32f15xx) 
Stypedef enum
S{
S  RCC_NMIPeriph_INT0    = (uint16_t)NMI_CFG_INT0EN,
S  RCC_NMIPeriph_SRAMPE      = (uint16_t)NMI_CFG_SRAMPEEN,
S  RCC_NMIPeriph_OP2  = (uint16_t)NMI_CFG_OP2EN,
S  RCC_NMIPeriph_OP1      = (uint16_t)NMI_CFG_OP1EN,
S  RCC_NMIPeriph_CMP3      = (uint16_t)NMI_CFG_CMP3EN,
S	RCC_NMIPeriph_CMP0    = (uint16_t)NMI_CFG_CMP0EN,
S	RCC_NMIPeriph_ALL  = (uint16_t)0XFC,
S} RCC_NMIPeriph_TypeDef;
S#define IS_RCC_NMIPeriph(NMIPeriph) ((((NMIPeriph) & (uint8_t)0xFF00) == 0x00) && ((NMIPeriph) != (uint16_t)0x00))
N#endif
N
N
Ntypedef enum
N{
N    RCC_WAIT_0 = ( uint16_t ) 0x00 << RCC_CFG0_WAIT_Pos, /*!< Wait number selection 0 */
X    RCC_WAIT_0 = ( uint16_t ) 0x00 << (12U),  
N    RCC_WAIT_1 = ( uint16_t ) 0x01 << RCC_CFG0_WAIT_Pos, /*!< Wait number selection 1 */
X    RCC_WAIT_1 = ( uint16_t ) 0x01 << (12U),  
N    RCC_WAIT_2 = ( uint16_t ) 0x02 << RCC_CFG0_WAIT_Pos, /*!< Wait number selection 2 */
X    RCC_WAIT_2 = ( uint16_t ) 0x02 << (12U),  
N    RCC_WAIT_3 = ( uint16_t ) 0x03 << RCC_CFG0_WAIT_Pos, /*!< Wait number selection 3 */
X    RCC_WAIT_3 = ( uint16_t ) 0x03 << (12U),  
N} RCC_Wait_TypeDef;
N#define IS_RCC_Wait(Wait) (((Wait) == RCC_WAIT_0) ||  \
N                           ((Wait) == RCC_WAIT_1)||\
N                           ((Wait) == RCC_WAIT_2)||\
N                           ((Wait) == RCC_WAIT_3))
X#define IS_RCC_Wait(Wait) (((Wait) == RCC_WAIT_0) ||                             ((Wait) == RCC_WAIT_1)||                           ((Wait) == RCC_WAIT_2)||                           ((Wait) == RCC_WAIT_3))
N/** @brief RCC_FLAG RCC FLAG
N* @{
N*/
N#if defined(SC32f10xx)
X#if 1L
Ntypedef enum
N{
N    RCC_FLAG_CLKIF   = ( uint8_t ) RCC_STS_CLKFIF, /*!< RCC FLAG: Clock source exception flag */
X    RCC_FLAG_CLKIF   = ( uint8_t ) (0x1UL << (0U)),  
N    RCC_FLAG_LOCKERR = ( uint8_t ) RCC_STS_LOCKERR, /*!< RCC FLAG: PLL out-of-lock record flag */
X    RCC_FLAG_LOCKERR = ( uint8_t ) (0x1UL << (1U)),  
N    RCC_FLAG_PLLRDY  = ( uint8_t ) RCC_STS_PLLRDY, /*!< RCC FLAG: PLL Clock Ready Flag */
X    RCC_FLAG_PLLRDY  = ( uint8_t ) (0x1UL << (2U)),  
N} RCC_FLAG_TypeDef;
N
N#define IS_RCC_FLAG(FLAG) ((((FLAG) & (uint8_t)0xFFF8) == 0x00) && ((FLAG) != (uint16_t)0x00))
N#define IS_GET_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_CLKIF) ||  \
N                               ((FLAG) == RCC_FLAG_LOCKERR) || \
N                               ((FLAG) == RCC_FLAG_PLLRDY))
X#define IS_GET_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_CLKIF) ||                                 ((FLAG) == RCC_FLAG_LOCKERR) ||                                ((FLAG) == RCC_FLAG_PLLRDY))
N#elif  defined(SC32f11xx) ||  defined(SC32f12xx) ||defined(SC32f15xx)
Stypedef enum
S{
S	#if defined(SC32f11xx) ||  defined(SC32f12xx)
S    RCC_FLAG_CLKIF   = ( uint8_t ) RCC_STS_CLKFIF, /*!< CLKIF FLAG: Clock source exception flag */
S	#endif
S    RCC_FLAG_SRAMPEIF = ( uint8_t ) RCC_STS_SRAMPEIF, /*!< SRAMPEIF FLAG: SRAM parity error flag */
S} RCC_FLAG_TypeDef;
S#if  defined(SC32f11xx) ||  defined(SC32f12xx)
S#define IS_RCC_FLAG(FLAG) ((((FLAG) & (uint8_t)0xFFF6) == 0x00) && ((FLAG) != (uint16_t)0x00))
S#define IS_GET_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_CLKIF) ||  \
S                               ((FLAG) == RCC_FLAG_SRAMPEIF))
X#define IS_GET_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_CLKIF) ||                                 ((FLAG) == RCC_FLAG_SRAMPEIF))
S#elif  defined(SC32f15xx)
S#define IS_RCC_FLAG(FLAG) ((((FLAG) & (uint8_t)0xFFF6) == 0x00) && ((FLAG) != (uint16_t)0x00))
S#define IS_GET_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_SRAMPEIF))
S#endif
N#endif
N/**
N * @}
N */
N#if defined(SC32f10xx)
X#if 1L
N/** @defgroup RLL_Factor  RLL Factor
N * @{
N */
N/** @brief RLL_Factor  RLL Factor
N * @{
N */
N
Ntypedef struct
N{
N    uint32_t PLLM; /*!<	Prescaler M */
N    uint32_t PLLN; /*!< PLL multiplication factor N */
N    uint32_t PLLP; /*!< PLLRCLK Clock output dividing Coefficient */
N} RLL_Factor_TypeDef;
N#endif
N
N/** @brief RCC_ClocksTypeDef
N * @{
N */
N
Ntypedef struct
N{
N    uint32_t SYSCLK_Frequency; /*!<  SYSCLK clock frequency expressed in Hz */
N    uint32_t HCLK_Frequency;   /*!<  HCLK clock frequency expressed in Hz   */
N    uint32_t PCLK0_Frequency;  /*!<  PCLK0 clock frequency expressed in Hz  */
N    uint32_t PCLK1_Frequency;  /*!<  PCLK1 clock frequency expressed in Hz  */
N    uint32_t PCLK2_Frequency;  /*!<  PCLK2 clock frequency expressed in Hz  */
N} RCC_ClocksTypeDef;
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N/* End of struct -----------------------------------------------------*/
N
N
N/* Configuration of the RCC computation unit **********************************/
Nvoid RCC_DeInit ( void );
N
N/* Internal/external clocks, PLL configuration functions *********/
N
NErrorStatus RCC_Unlock ( uint8_t TimeLimit );
N
N#if !defined(SC32f15xx)
X#if !0L
Nvoid RCC_HXTCmd ( FunctionalState NewState );
N#endif
Nvoid RCC_LXTCmd ( FunctionalState NewState );
Nvoid RCC_HIRCCmd ( FunctionalState NewState );
Nvoid RCC_LIRCCmd ( FunctionalState NewState );
N
N#if defined(SC32f10xx)
X#if 1L
Nvoid RCC_PLLCmd ( FunctionalState NewState );
Nvoid RCC_PLLRCmd ( FunctionalState NewState );
Nvoid RCC_PLLConfig ( RCC_PLLCLKSource_TypeDef RCC_PLLCLKSource, RLL_Factor_TypeDef* PLL_Factor );
N#endif
N#if defined(SC32f11xx)||defined(SC32f12xx)||defined(SC32f15xx)
X#if 0L||0L||0L
Svoid RCC_HIRCDIV1Cmd ( FunctionalState NewState );
N#endif
Nvoid RCC_APB0Cmd ( FunctionalState NewState );
Nvoid RCC_APB1Cmd ( FunctionalState NewState );
Nvoid RCC_APB2Cmd ( FunctionalState NewState );
N
N
N/* System, AHB and APB busses clocks configuration functions ******************/
NErrorStatus RCC_SYSCLKConfig ( RCC_SYSCLKSource_TypeDef RCC_SYSCLKSource );
NRCC_SYSCLKSource_TypeDef RCC_GetSYSCLKSource ( void );
Nvoid RCC_HCLKConfig ( RCC_HCLK_TypeDef RCC_HCLKCLKSource );
Nvoid RCC_APB0Config ( RCC_PCLK_TypeDef RCC_APB0CLKSource );
Nvoid RCC_APB1Config ( RCC_PCLK_TypeDef RCC_APB1CLKSource );
Nvoid RCC_APB2Config ( RCC_PCLK_TypeDef RCC_APB2CLKSource );
Nvoid RCC_GetClocksFreq ( RCC_ClocksTypeDef* RCC_Clocks );
Nvoid RCC_WaitConfig ( RCC_Wait_TypeDef RCC_Wait );
N/* Peripheral clocks configuration functions **********************************/
N#if defined (SC32f11xx)|| defined(SC32f12xx)
X#if 0L|| 0L
Svoid RCC_PWM0CLKConfig ( RCC_PWM0CLKSource_TypeDef RCC_PWM0CLKSource );
N#endif
N#if defined (SC32f11xx)|| defined(SC32f12xx)|| defined(SC32f10xx)
X#if 0L|| 0L|| 1L
Nvoid RCC_LCDLEDCLKConfig ( RCC_LCDLEDCLKSource_TypeDef RCC_LCDLEDCLKSource );
N#endif
Nvoid RCC_BTMCLKConfig ( RCC_BTMCLKSource_TypeDef RCC_BTMCLKSource );
N
Nvoid RCC_AHBPeriphClockCmd ( uint32_t RCC_AHBPeriph, FunctionalState NewState );
Nvoid RCC_APB0PeriphClockCmd ( uint32_t RCC_APB0Periph, FunctionalState NewState );
Nvoid RCC_APB1PeriphClockCmd ( uint32_t RCC_APB1Periph, FunctionalState NewState );
Nvoid RCC_APB2PeriphClockCmd ( uint32_t RCC_APB2Periph, FunctionalState NewState );
N
Nvoid RCC_AHBPeriphResetCmd ( uint32_t RCC_AHBPeriph, FunctionalState NewState );
Nvoid RCC_APB0PeriphResetCmd ( uint32_t RCC_APB0Periph, FunctionalState NewState );
Nvoid RCC_APB1PeriphResetCmd ( uint32_t RCC_APB1Periph, FunctionalState NewState );
Nvoid RCC_APB2PeriphResetCmd ( uint32_t RCC_APB2Periph, FunctionalState NewState );
N
N/* Systick Timer configuration functions **********************************/
Nvoid RCC_SystickCLKConfig ( RCC_SysTickSource_TypeDef RCC_SYSTICKSource );
Nvoid RCC_SystickSetCounter ( uint32_t Counter );
Nvoid RCC_SystickCmd ( FunctionalState NewState );
NFlagStatus RCC_SystickGetFlagStatus ( void );
N
N/* Interrupts and flags management functions **********************************/
Nvoid RCC_ITConfig ( FunctionalState NewState );
NFlagStatus RCC_GetFlagStatus ( uint32_t RCC_FLAG );
Nvoid RCC_EnableCSS ( void );
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __sc32f1xxx_RCC_H */
N
N/**
N* @}
N*/
N
N/**
N* @}
N*/
N
N/************************ (C) COPYRIGHT SOC Microelectronics *****END OF FILE****/
L 29 "..\FWLib\SC32F1XXX_Lib\inc\sc32_conf.h" 2
N#include "sc32f1xxx_gpio.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx_gpio.h" 1
N/**
N ******************************************************************************
N * @file    sc32f1xxx_gpio.h
N * @author  SOC AE Team
N * @version V1.6
N * @date     04-09-2024
N * @brief   Header file of GPIO module.
N *
N ******************************************************************************
N * @attention
N *
N *1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only
N *intended for use with SinOne products. No other uses are authorized. This
N *software is owned by SinOne Microelectronics Co.,Ltd. and is protected under
N *all applicable laws, including copyright laws.
N *2.The software which is for guidance only aims at providing customers with
N *coding information regarding their products in order for them to save time.
N *As a result, SinOne shall not be held liable for any direct, indirect or
N *consequential damages with respect to any claims arising from the content of
N *such software and/or the use made by customers of the coding information
N *contained herein in connection with their products.
N *
N *  COPYRIGHT 2024 SinOne Microelectronics
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __sc32f1xxx_GPIO_H
N#define __sc32f1xxx_GPIO_H
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "sc32f1xxx.h"
N
N/** @addtogroup sc32f1xxx_StdPeriph_Driver
N * @{
N */
N
N/** @addtogroup GPIO
N * @{
N */
N
N/** @defgroup GPIO_Enumerations GPIO Enumerations
N * @{
N */
N
N/** @brief GPIO_Mode GPIO Mode
N * @{
N */
Ntypedef enum
N{
N    GPIO_Mode_IN_HI = 0x00,  /*!< GPIO High-resistance Input Mode   */
N    GPIO_Mode_IN_PU = 0x01,  /*!< GPIO Pull-up Input Mode  */
N    GPIO_Mode_OUT_PP = 0x02  /*!< GPIO Strong push-pull Output Mode   */
N} GPIO_Mode_TypeDef;
N
N#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_Mode_IN_HI) ||\
N														((MODE) == GPIO_Mode_IN_PU) ||\
N                            ((MODE) == GPIO_Mode_OUT_PP))
X#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_Mode_IN_HI) ||														((MODE) == GPIO_Mode_IN_PU) ||                            ((MODE) == GPIO_Mode_OUT_PP))
N/**
N * @}
N */
N
N/** @brief GPIO_DriveLevel GPIO DriveLevel
N * @{
N */
Ntypedef enum
N{
N    GPIO_DriveLevel_0 = 0x00, /*!< I/O output Drive: Level 0(Max) */
N    GPIO_DriveLevel_1 = 0x01, /*!< I/O output Drive: Level 1 */
N    GPIO_DriveLevel_2 = 0x02, /*!< I/O output Drive: Level 2 */
N    GPIO_DriveLevel_3 = 0x03  /*!< I/O output Drive: Level 3 */
N} GPIO_DriveLevel_TypeDef;
N
N#define IS_GPIO_DriveLevel(LEVEL)	(((LEVEL) == GPIO_DriveLevel_0) ||\
N																	((LEVEL) == GPIO_DriveLevel_1) ||\
N																	((LEVEL) == GPIO_DriveLevel_2) ||\
N																	((LEVEL) == GPIO_DriveLevel_3))
X#define IS_GPIO_DriveLevel(LEVEL)	(((LEVEL) == GPIO_DriveLevel_0) ||																	((LEVEL) == GPIO_DriveLevel_1) ||																	((LEVEL) == GPIO_DriveLevel_2) ||																	((LEVEL) == GPIO_DriveLevel_3))
N
N/**
N * @}
N */
N
N/** @brief   BitAction
N * @{
N */
Ntypedef enum
N{
N    Bit_RESET = 0,
N    Bit_SET
N} BitAction;
N
N#define IS_GPIO_BITACTION(STATE) (((STATE) == Bit_RESET) || ((STATE) == Bit_SET))
N
N/**
N * @}
N */
N#if defined(SC32f10xx) || defined(SC32f12xx)|| defined(SC32f15xx)
X#if 1L || 0L|| 0L
N#define IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) || \
N                                    ((PERIPH) == GPIOB) || \
N                                    ((PERIPH) == GPIOC))
X#define IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) ||                                     ((PERIPH) == GPIOB) ||                                     ((PERIPH) == GPIOC))
N#elif defined(SC31f11xx)
S#define IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) || \
S                                    ((PERIPH) == GPIOB) || \
S                                    ((PERIPH) == GPIOC) || \
S                                    ((PERIPH) == GPIOD))
X#define IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) ||                                     ((PERIPH) == GPIOB) ||                                     ((PERIPH) == GPIOC) ||                                     ((PERIPH) == GPIOD))
N#endif
N/** @brief GPIO_Pin GPIO Pins enumeration
N * @{
N */
Ntypedef enum
N{
N    GPIO_Pin_0 = ( ( uint16_t ) 0x0001 ), /*!< Pin 0 selected    */
N    GPIO_Pin_1 = ( ( uint16_t ) 0x0002 ), /*!< Pin 1 selected    */
N    GPIO_Pin_2 = ( ( uint16_t ) 0x0004 ), /*!< Pin 2 selected    */
N    GPIO_Pin_3 = ( ( uint16_t ) 0x0008 ), /*!< Pin 3 selected    */
N    GPIO_Pin_4 = ( ( uint16_t ) 0x0010 ), /*!< Pin 4 selected    */
N    GPIO_Pin_5 = ( ( uint16_t ) 0x0020 ), /*!< Pin 5 selected    */
N    GPIO_Pin_6 = ( ( uint16_t ) 0x0040 ), /*!< Pin 6 selected    */
N    GPIO_Pin_7 = ( ( uint16_t ) 0x0080 ), /*!< Pin 7 selected    */
N    GPIO_Pin_8 = ( ( uint16_t ) 0x0100 ), /*!< Pin 8 selected    */
N    GPIO_Pin_9 = ( ( uint16_t ) 0x0200 ), /*!< Pin 9 selected    */
N    GPIO_Pin_10 = ( ( uint16_t ) 0x0400 ), /*!< Pin 10 selected    */
N    GPIO_Pin_11 = ( ( uint16_t ) 0x0800 ), /*!< Pin 11 selected    */
N    GPIO_Pin_12 = ( ( uint16_t ) 0x1000 ), /*!< Pin 12 selected    */
N    GPIO_Pin_13 = ( ( uint16_t ) 0x2000 ), /*!< Pin 13 selected    */
N    GPIO_Pin_14 = ( ( uint16_t ) 0x4000 ), /*!< Pin 14 selected    */
N    GPIO_Pin_15 = ( ( uint16_t ) 0x8000 ), /*!< Pin 15 selected    */
N    GPIO_PIN_LNIB = ( ( uint16_t ) 0x00FF ), /*!< Pin Low 8 Bits selected			*/
N    GPIO_PIN_HNIB = ( ( uint16_t ) 0xFF00 ), /*!< Pin High 8 Bits selected		*/
N    GPIO_PIN_All = ( ( uint16_t ) 0xFFFF ), /* All pins selected */
N} GPIO_Pin_TypeDef;
N
N
N
N#define GPIO_PIN_MASK 0x0000FFFFU /* PIN mask for assert test */
N
N#define IS_GPIO_PIN(PIN) ((((PIN)&GPIO_PIN_MASK) != 0x00U) && (((PIN) & ~GPIO_PIN_MASK) == 0x00U))
N
N#define IS_GET_GPIO_PIN(PIN) (((PIN) == GPIO_Pin_0) ||  \
N                              ((PIN) == GPIO_Pin_1) ||  \
N                              ((PIN) == GPIO_Pin_2) ||  \
N                              ((PIN) == GPIO_Pin_3) ||  \
N                              ((PIN) == GPIO_Pin_4) ||  \
N                              ((PIN) == GPIO_Pin_5) ||  \
N                              ((PIN) == GPIO_Pin_6) ||  \
N                              ((PIN) == GPIO_Pin_7) ||  \
N                              ((PIN) == GPIO_Pin_8) ||  \
N                              ((PIN) == GPIO_Pin_9) ||  \
N                              ((PIN) == GPIO_Pin_10) || \
N                              ((PIN) == GPIO_Pin_11) || \
N                              ((PIN) == GPIO_Pin_12) || \
N                              ((PIN) == GPIO_Pin_13) || \
N                              ((PIN) == GPIO_Pin_14) || \
N                              ((PIN) == GPIO_Pin_15))
X#define IS_GET_GPIO_PIN(PIN) (((PIN) == GPIO_Pin_0) ||                                ((PIN) == GPIO_Pin_1) ||                                ((PIN) == GPIO_Pin_2) ||                                ((PIN) == GPIO_Pin_3) ||                                ((PIN) == GPIO_Pin_4) ||                                ((PIN) == GPIO_Pin_5) ||                                ((PIN) == GPIO_Pin_6) ||                                ((PIN) == GPIO_Pin_7) ||                                ((PIN) == GPIO_Pin_8) ||                                ((PIN) == GPIO_Pin_9) ||                                ((PIN) == GPIO_Pin_10) ||                               ((PIN) == GPIO_Pin_11) ||                               ((PIN) == GPIO_Pin_12) ||                               ((PIN) == GPIO_Pin_13) ||                               ((PIN) == GPIO_Pin_14) ||                               ((PIN) == GPIO_Pin_15))
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N/* End of Enumerations --------------------------------------------------*/
N
N/** @defgroup GPIO_Struct GPIO Struct
N * @{
N */
N
N/** @brief GPIO_InitTypeDef  GPIO structure definition
N * @{
N */
Ntypedef struct
N{
N    uint16_t GPIO_Pin;          /*!< Specifies the GPIO pins to be configured.
N                                     This parameter can be any value of @ref GPIO_Pin_TypeDef */
N    uint16_t GPIO_Mode; /*!< Specifies the operating mode for the selected pins.
N                                     This parameter can be a value of @ref GPIO_Mode_TypeDef   */
N    uint16_t GPIO_DriveLevel; /*!< Specifies the operating Drive Level for the selected pins.
N                                     This parameter can be a value of @ref GPIO_DriveLevel_TypeDef   */
N} GPIO_InitTypeDef;
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N/* End of Struct --------------------------------------------------*/
N
N/** @addtogroup GPIO_Exported_Functions
N * @{
N */
N
N/* Initialization and de-initialization functions *****************************/
Nvoid GPIO_DeInit ( GPIO_TypeDef* GPIOx );
Nvoid GPIO_Init ( GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct );
Nvoid GPIO_SetDriveLevel ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_DriveLevel_TypeDef GPIO_DriveLevel );
N
N/* IO operation functions *****************************************************/
Nuint16_t GPIO_ReadData ( GPIO_TypeDef* GPIOx );
NBitAction GPIO_ReadDataBit ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin );
Nvoid GPIO_SetBits ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin );
Nvoid GPIO_ResetBits ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin );
Nvoid GPIO_Write ( GPIO_TypeDef* GPIOx, uint16_t PortVal );
Nvoid GPIO_WriteBit ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal );
Nvoid GPIO_TogglePins ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin );
N
N/**
N * @}
N */
N/* End of functions --------------------------------------------------*/
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* _SC32F1XXX_GPIO_H */
N
N
L 30 "..\FWLib\SC32F1XXX_Lib\inc\sc32_conf.h" 2
N#include "sc32f1xxx_iap.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx_iap.h" 1
N/**
N ******************************************************************************
N * @file    sc32f1xxx_iap.h
N * @author  SOC AE Team
N * @version V1.6
N * @date     04-09-2024
N * @brief   Header file of IAP module.
N ******************************************************************************
N * @attention
N *
N *1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only
N *intended for use with SinOne products. No other uses are authorized. This
N *software is owned by SinOne Microelectronics Co.,Ltd. and is protected under
N *all applicable laws, including copyright laws.
N *2.The software which is for guidance only aims at providing customers with
N *coding information regarding their products in order for them to save time.
N *As a result, SinOne shall not be held liable for any direct, indirect or
N *consequential damages with respect to any claims arising from the content of
N *such software and/or the use made by customers of the coding information
N *contained herein in connection with their products.
N *
N *  COPYRIGHT 2024 SinOne Microelectronics
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __sc32f1xxx_IAP_H
N#define __sc32f1xxx_IAP_H
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "sc32f1xxx.h"
N#include "sc32.h"
N#include "sc32f1xxx_rcc.h"
N
N/** @addtogroup sc32f1xxx_StdPeriph_Driver
N * @{
N */
N
N/** @addtogroup IAP
N * @{
N */
N
N
N
N/** @defgroup IAP_Enumerations IAP Enumerations
N * @{
N */
N
N/** @brief IAP_BTLD IAP Reset Startup area
N * @{
N */
Ntypedef enum
N{
N    IAP_BTLD_APPROM = ( uint8_t ) 0x00 << IAP_CON_BTLD_Pos,
X    IAP_BTLD_APPROM = ( uint8_t ) 0x00 << (9U),
N    IAP_BTLD_LDROM  = ( uint8_t ) 0x01 << IAP_CON_BTLD_Pos,
X    IAP_BTLD_LDROM  = ( uint8_t ) 0x01 << (9U),
N    IAP_BTLD_SRAM   = ( uint8_t ) 0x02 << IAP_CON_BTLD_Pos,
X    IAP_BTLD_SRAM   = ( uint8_t ) 0x02 << (9U),
N} IAP_BTLD_TypeDef;
N
N#define IS_IAP_BTLD(BTLD) (((BTLD) == IAP_BTLD_APPROM) || \
N                           ((BTLD) == IAP_BTLD_LDROM)  || \
N                           ((BTLD) == IAP_BTLD_SRAM))
X#define IS_IAP_BTLD(BTLD) (((BTLD) == IAP_BTLD_APPROM) ||                            ((BTLD) == IAP_BTLD_LDROM)  ||                            ((BTLD) == IAP_BTLD_SRAM))
N/**
N * @}
N */
N/** @defgroup IAP_Keys
N  * @{
N  */
N///IAP_KEY1 value
N#define IAP_KEY1               ((uint32_t)0x12345678)
N///IAP_KEY2 value
N#define IAP_KEY2               ((uint32_t)0xA05F05FA)
N/**
N  * @}
N  */
N/**
N * @}
N */
N/* End of enumerations -----------------------------------------------------*/
N
N
N#define IS_IAP_SECTOR(SECTOR) ((SECTOR) <= 0X000001FF)
N
N#define IS_IAP_ADDRESS(ADDRESS) (((ADDRESS) >= 0x08000000) && ((ADDRESS) <= 0x0803FFFF))
N
N/**
N * @}
N */
N/* End of constants -----------------------------------------------------*/
N
N/** @addtogroup IAP_Functions IAP Functions
N * @{
N */
N
N/* FLASH Memory Programming functions *****************************************/
NboolType IAP_Unlock ( void );
Nvoid IAP_Lock ( void );
Nvoid IAP_WriteCmd ( FunctionalState NewState );
Nvoid IAP_EraseSector ( uint32_t IAP_Sector );
N#if defined(SC32f11xx) ||  defined(SC32f12xx)
X#if 0L ||  0L
Svoid IAP_EEPROMEraseSector ( uint32_t IAP_Sector );
N#endif
NboolType IAP_ProgramWord ( uint32_t Address, uint32_t Data );
N#if defined(SC32f10xx) || defined(SC32f11xx)
X#if 1L || 0L
NboolType IAP_ProgramHalfWord ( uint32_t Address, uint16_t Data );
NboolType IAP_ProgramByte ( uint32_t Address, uint8_t Data );
N#endif
Nuint32_t IAP_ReadWord ( uint32_t Address );
Nuint16_t IAP_ReadHalfWord ( uint32_t Address );
Nuint8_t IAP_ReadByte ( uint32_t Address );
Nuint8_t IAP_ProgramWordArray ( uint32_t Address, uint32_t* ByteArray, uint16_t ArraySize );
N#if defined(SC32f10xx) || defined(SC32f11xx)
X#if 1L || 0L
Nuint8_t IAP_ProgramHalfWordArray ( uint32_t Address, uint16_t* ByteArray, uint16_t ArraySize );
Nuint8_t IAP_ProgramByteArray ( uint32_t Address, uint8_t* ByteArray, uint16_t ArraySize );
N#endif
Nuint8_t IAP_ReadWordArray ( uint32_t Address, uint32_t* ByteArray, uint16_t ArraySize );
Nuint8_t IAP_ReadHalfWordArray ( uint32_t Address, uint16_t* ByteArray, uint16_t ArraySize );
Nuint8_t IAP_ReadByteArray ( uint32_t Address, uint8_t* ByteArray, uint16_t ArraySize );
N
N/* FLASH Reset functions *****************************************/
Nvoid IAP_SoftwareReset ( IAP_BTLD_TypeDef IAP_BTLDType );
N#if defined(SC32f15xx)
X#if 0L
S/* Automatic continuous burning  functions *****************************************/
Svoid IAP_DMAENCmd(FunctionalState NewState);
Svoid IAP_CONTBurnlength(uint8_t Burnlength);
N#endif
N/**
N * @}
N */
N/* End of functions --------------------------------------------------*/
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N/************************ (C) COPYRIGHT SOC Microelectronics *****END OF FILE****/
L 31 "..\FWLib\SC32F1XXX_Lib\inc\sc32_conf.h" 2
N#include "sc32f1xxx_adc.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx_adc.h" 1
N/*
N ******************************************************************************
N * @file    sc32f1xxx_ADC.h
N * @author  SOC AE Team
N * @version V1.6
N * @date     04-09-2024
N * @brief   Header file of ADC module.
N ******************************************************************************
N * @attention
N *
N *1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only
N *intended for use with SinOne products. No other uses are authorized. This
N *software is owned by SinOne Microelectronics Co.,Ltd. and is protected under
N *all applicable laws, including copyright laws.
N *2.The software which is for guidance only aims at providing customers with
N *coding information regarding their products in order for them to save time.
N *As a result, SinOne shall not be held liable for any direct, indirect or
N *consequential damages with respect to any claims arising from the content of
N *such software and/or the use made by customers of the coding information
N *contained herein in connection with their products.
N *
N *  COPYRIGHT 2024 SinOne Microelectronics
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __sc32f1xxx_ADC_H
N#define __sc32f1xxx_ADC_H
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "sc32_conf.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32_conf.h" 1
N/**
N ******************************************************************************
N * @file    sc32_conf.h
N * @author  SOC AE Team
N * @version V1.6
N * @date    04-09-2024
N * @brief   
N *
N *******************************************************************************
N * @attention
N *
N *1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only 
N *intended for use with SinOne products. No other uses are authorized. This 
N *software is owned by SinOne Microelectronics Co.,Ltd. and is protected under 
N *all applicable laws, including copyright laws. 
N *2.The software which is for guidance only aims at providing customers with 
N *coding information regarding their products in order for them to save time. 
N *As a result, SinOne shall not be held liable for any direct, indirect or 
N *consequential damages with respect to any claims arising from the content of 
N *such software and/or the use made by customers of the coding information 
N *contained herein in connection with their products.
N *
N *  COPYRIGHT 2024 SinOne Microelectronics
N */
N#ifndef _sc32_CONF_H_
S#define _sc32_CONF_H_
S#include "sc32f1xxx.h"
S#include "sc32f1xxx_rcc.h"
S#include "sc32f1xxx_gpio.h"
S#include "sc32f1xxx_iap.h"
S#include "sc32f1xxx_adc.h"
S#include "sc32f1xxx_cmp.h"
S#include "sc32f1xxx_option.h"
S#include "sc32f1xxx_int.h"
S#include "sc32f1xxx_uart.h"
S#include "sc32f1xxx_spi.h"
S#include "sc32f1xxx_twi.h"
S#include "sc32f1xxx_wdt.h"
S#include "sc32f1xxx_btm.h"
S#include "sc32f1xxx_crc.h"
S#if !defined(SC32f15xx)
S#include "sc32f1xxx_pwm.h"
S#include "sc32f1xxx_ledpwm.h"
S#include "sc32f1xxx_lcd.h"
S#include "sc32f1xxx_led.h"
S#endif
S#include "sc32f1xxx_tim.h"
S#include "sc32f1xxx_dma.h"
S#include "sc32f1xxx_pwr.h"
S#if defined(SC32f11xx)
S#include "sc32f1xxx_pga.h"
S#include "sc32f1xxx_can.h"	
S#endif
S#if defined(SC32f12xx)
S#include "sc32f1xxx_op.h"	
S#endif
S#if defined(SC32f15xx)
S#include "sc32f1xxx_dac.h"	
S#include "sc32f1xxx_can.h"
S#include "sc32f1xxx_temper.h"
S#include "sc32f1xxx_spi1_twi1.h"
S#include "sc32f1xxx_op.h"
S#include "sc32f1xxx_qep.h"
S#include "sc32f1xxx_vref.h"
S#endif
N#endif
N
L 36 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx_adc.h" 2
N#include "sc32.h"
N#include "sc32f1xxx_rcc.h"
N
N/** @addtogroup sc32f1xxx_StdPeriph_Driver
N * @{
N */
N
N/** @addtogroup ADC
N * @{
N */
N
N/* Exported enumerations ------------------------------------------------------------*/
N/** @defgroup ADC_Exported_Enumerations ADC Exported Enumerations
N * @{
N */
N
N/** @brief ADC_ConvMode ADC Conversion Mode
N * @{
N */
Ntypedef enum
N{
N    ADC_ConvMode_Single        = ( uint16_t ) ( 0x00 << ADC_CON_CONT_Pos ), /*!<Single conversion mode */
X    ADC_ConvMode_Single        = ( uint16_t ) ( 0x00 << (11U) ),  
N	#if defined(SC32f10xx)||defined(SC32f11xx)||defined(SC32f12xx)
X	#if 1L||0L||0L
N    ADC_ConvMode_Continuous    = ( uint16_t ) ( 0x01 << ADC_CON_CONT_Pos ), /*!<Continuous conversion mode */
X    ADC_ConvMode_Continuous    = ( uint16_t ) ( 0x01 << (11U) ),  
N	#elif defined(SC32f15xx)
S	ADC_ConvMode_Sequence    = ( uint16_t ) ( 0x01 << ADC_CON_CONT_Pos ), /*!<Continuous sequence mode */
N	#endif
N} ADC_ConvMode_TypeDef;
N
N#define IS_ADC_CONVMODE(MODE) (((MODE) == ADC_ConvMode_Single) ||  \
N															 ((MODE) == ADC_ConvMode_Continuous))
X#define IS_ADC_CONVMODE(MODE) (((MODE) == ADC_ConvMode_Single) ||  															 ((MODE) == ADC_ConvMode_Continuous))
N/**
N * @}
N */
N
N/** @brief ADC_Prescaler ADC Prescaler
N * @{
N */
Ntypedef enum
N{
N#if defined(SC32f10xx)||defined(SC32f11xx)||defined(SC32f12xx)
X#if 1L||0L||0L
N    ADC_Prescaler_3CLOCK  = ( uint32_t ) ( 0x04 << ADC_CON_LOWSP_Pos ), /*!<The sampling time is 3 APB2 clocks */
X    ADC_Prescaler_3CLOCK  = ( uint32_t ) ( 0x04 << (16U) ),  
N    ADC_Prescaler_6CLOCK  = ( uint32_t ) ( 0x05 << ADC_CON_LOWSP_Pos ), /*!<The sampling time is 6 APB2 clocks */
X    ADC_Prescaler_6CLOCK  = ( uint32_t ) ( 0x05 << (16U) ),  
N    ADC_Prescaler_16CLOCK = ( uint32_t ) ( 0x06 << ADC_CON_LOWSP_Pos ), /*!<The sampling time is 16 APB2 clocks */
X    ADC_Prescaler_16CLOCK = ( uint32_t ) ( 0x06 << (16U) ),  
N    ADC_Prescaler_32CLOCK = ( uint32_t ) ( 0x07 << ADC_CON_LOWSP_Pos ), /*!<The sampling time is 32 APB2 clocks */
X    ADC_Prescaler_32CLOCK = ( uint32_t ) ( 0x07 << (16U) ),  
N#elif defined(SC32f15xx)
S    ADC_Prescaler_3CLOCK   = (uint32_t)(0x00 << ADC_CON_LOWSP_Pos),  /* The sampling time is 3   APB2 clocks */
S    ADC_Prescaler_6CLOCK   = (uint32_t)(0x01 << ADC_CON_LOWSP_Pos),  /* The sampling time is 6   APB2 clocks */
S    ADC_Prescaler_9CLOCK   = (uint32_t)(0x02 << ADC_CON_LOWSP_Pos),  /* The sampling time is 9   APB2 clocks */
S    ADC_Prescaler_15CLOCK  = (uint32_t)(0x03 << ADC_CON_LOWSP_Pos),  /* The sampling time is 15  APB2 clocks */
S    ADC_Prescaler_30CLOCK  = (uint32_t)(0x04 << ADC_CON_LOWSP_Pos),  /* The sampling time is 30  APB2 clocks */
S    ADC_Prescaler_60CLOCK  = (uint32_t)(0x05 << ADC_CON_LOWSP_Pos),  /* The sampling time is 60  APB2 clocks */
S    ADC_Prescaler_120CLOCK = (uint32_t)(0x06 << ADC_CON_LOWSP_Pos),  /* The sampling time is 120 APB2 clocks */
S    ADC_Prescaler_480CLOCK = (uint32_t)(0x07 << ADC_CON_LOWSP_Pos),  /* The sampling time is 480 APB2 clocks */	
N#endif
N} ADC_Prescaler_TypeDef;
N#if defined(SC32f10xx)||defined(SC32f11xx)||defined(SC32f12xx)
X#if 1L||0L||0L
N#define IS_ADC_PRESCALER(PRESCALER) (((PRESCALER) == ADC_Prescaler_3CLOCK) ||  \
N																		 ((PRESCALER) == ADC_Prescaler_6CLOCK) ||  \
N																		 ((PRESCALER) == ADC_Prescaler_16CLOCK) || \
N																		 ((PRESCALER) == ADC_Prescaler_32CLOCK))
X#define IS_ADC_PRESCALER(PRESCALER) (((PRESCALER) == ADC_Prescaler_3CLOCK) ||  																		 ((PRESCALER) == ADC_Prescaler_6CLOCK) ||  																		 ((PRESCALER) == ADC_Prescaler_16CLOCK) || 																		 ((PRESCALER) == ADC_Prescaler_32CLOCK))
N#elif defined(SC32f15xx)
S#define IS_ADC_PRESCALER(PRESCALER) (((PRESCALER) == ADC_Prescaler_3CLOCK)   || \
S                                     ((PRESCALER) == ADC_Prescaler_6CLOCK)   || \
S                                     ((PRESCALER) == ADC_Prescaler_9CLOCK)   || \
S                                     ((PRESCALER) == ADC_Prescaler_15CLOCK)  || \
S                                     ((PRESCALER) == ADC_Prescaler_30CLOCK)  || \
S                                     ((PRESCALER) == ADC_Prescaler_60CLOCK)  || \
S                                     ((PRESCALER) == ADC_Prescaler_120CLOCK) || \
S                                     ((PRESCALER) == ADC_Prescaler_480CLOCK))
X#define IS_ADC_PRESCALER(PRESCALER) (((PRESCALER) == ADC_Prescaler_3CLOCK)   ||                                      ((PRESCALER) == ADC_Prescaler_6CLOCK)   ||                                      ((PRESCALER) == ADC_Prescaler_9CLOCK)   ||                                      ((PRESCALER) == ADC_Prescaler_15CLOCK)  ||                                      ((PRESCALER) == ADC_Prescaler_30CLOCK)  ||                                      ((PRESCALER) == ADC_Prescaler_60CLOCK)  ||                                      ((PRESCALER) == ADC_Prescaler_120CLOCK) ||                                      ((PRESCALER) == ADC_Prescaler_480CLOCK))
N#endif
N/**
N * @}
N */
N
N/** @brief ADC_ChannelTypedef ADC input channel
N * @{
N */
N
Ntypedef enum
N{
N    ADC_Channel_0      = ( uint16_t ) 0x00,		 /*!< ADC input channel 0 */
N    ADC_Channel_1      = ( uint16_t ) 0x01,		 /*!< ADC input channel 1 */
N    ADC_Channel_2      = ( uint16_t ) 0x02,		 /*!< ADC input channel 2 */
N    ADC_Channel_3      = ( uint16_t ) 0x03,		 /*!< ADC input channel 3 */
N    ADC_Channel_4      = ( uint16_t ) 0x04,		 /*!< ADC input channel 4 */
N    ADC_Channel_5      = ( uint16_t ) 0x05,	 	 /*!< ADC input channel 5 */
N    ADC_Channel_6      = ( uint16_t ) 0x06,		 /*!< ADC input channel 6 */
N    ADC_Channel_7      = ( uint16_t ) 0x07,		 /*!< ADC input channel 7 */
N    ADC_Channel_8      = ( uint16_t ) 0x08,		 /*!< ADC input channel 8 */
N    ADC_Channel_9      = ( uint16_t ) 0x09,		 /*!< ADC input channel 9 */
N    ADC_Channel_10     = ( uint16_t ) 0x0A,		 /*!< ADC input channel 10 */
N    ADC_Channel_11     = ( uint16_t ) 0x0B,		 /*!< ADC input channel 11 */
N    ADC_Channel_12     = ( uint16_t ) 0x0C,		 /*!< ADC input channel 12 */
N    ADC_Channel_13     = ( uint16_t ) 0x0D,		 /*!< ADC input channel 13 */
N    ADC_Channel_14     = ( uint16_t ) 0x0E,		 /*!< ADC input channel 14 */
N    ADC_Channel_15     = ( uint16_t ) 0x0F,		 /*!< ADC input channel 15 */
N    ADC_Channel_VDD_D4 = ( uint16_t ) 0x1F,		 /*!< ADC_CHANNEL VDD Divide 4 */
N#if defined(SC32f10xx)
X#if 1L
N    ADC_Channel_16     = ( uint16_t ) 0x10,		 /*!< ADC input channel 16 */
N#elif defined(SC32f11xx)
S    ADC_Channel_16     = ( uint16_t ) 0x10,		 /*!< ADC input channel 16 */
S    ADC_Channel_17     = ( uint16_t ) 0x11,		 /*!< ADC input channel 17 */
S    ADC_Channel_PGA    = ( uint16_t ) 0x1E,		 /*!< ADC_CHANNEL PGA */
S#elif defined(SC32f12xx)
S    ADC_Channel_OP    = ( uint16_t ) 0x1E,		 /*!< ADC_CHANNEL OP */
S#elif defined(SC32f15xx)
S    ADC_Channel_TEMP   = (uint16_t)0x11,		 /*!< ADC input channel TEMP */
N#endif
N} ADC_ChannelTypedef;
N
N
N#if defined(SC32f10xx)
X#if 1L
N#define IS_ADC_CHANNEL(CHANNEL) ((CHANNEL) <= ADC_Channel_16 ||\
N                                 (CHANNEL) == ADC_Channel_VDD_D4)
X#define IS_ADC_CHANNEL(CHANNEL) ((CHANNEL) <= ADC_Channel_16 ||                                 (CHANNEL) == ADC_Channel_VDD_D4)
N#elif defined(SC32f11xx)
S#define IS_ADC_CHANNEL(CHANNEL) ((CHANNEL) <= ADC_Channel_17  ||\
S                                 (CHANNEL) == ADC_Channel_PGA ||\
S                                 (CHANNEL) == ADC_Channel_VDD_D4)
X#define IS_ADC_CHANNEL(CHANNEL) ((CHANNEL) <= ADC_Channel_17  ||                                 (CHANNEL) == ADC_Channel_PGA ||                                 (CHANNEL) == ADC_Channel_VDD_D4)
S#elif defined(SC32f12xx)
S#define IS_ADC_CHANNEL(CHANNEL) ((CHANNEL) <= ADC_Channel_15  ||\
S                                 (CHANNEL) == ADC_Channel_OP ||\
S                                 (CHANNEL) == ADC_Channel_VDD_D4)
X#define IS_ADC_CHANNEL(CHANNEL) ((CHANNEL) <= ADC_Channel_15  ||                                 (CHANNEL) == ADC_Channel_OP ||                                 (CHANNEL) == ADC_Channel_VDD_D4)
S#elif defined(SC32f15xx)
S#define IS_ADC_CHANNEL(CHANNEL) ((CHANNEL) <= ADC_Channel_15  ||\
S                                 (CHANNEL) == ADC_Channel_TEMP ||\
S                                 (CHANNEL) == ADC_Channel_VDD_D4)
X#define IS_ADC_CHANNEL(CHANNEL) ((CHANNEL) <= ADC_Channel_15  ||                                 (CHANNEL) == ADC_Channel_TEMP ||                                 (CHANNEL) == ADC_Channel_VDD_D4)
N#endif
N/**
N * @}
N */
N#if defined(SC32f15xx)
X#if 0L
S/** @defgroup ADC_ChannelATypedef ADC input channel
S * @{
S */
Stypedef enum
S{
S    ADC_ChannelA_0      = (uint16_t)0x00,		 /*!< ADC input channel 0 */ 
S    ADC_ChannelA_2      = (uint16_t)0x02,		 /*!< ADC input channel 2 */
S    ADC_ChannelA_4      = (uint16_t)0x04,		 /*!< ADC input channel 4 */ 
S    ADC_ChannelA_6      = (uint16_t)0x06,		 /*!< ADC input channel 6 */
S    ADC_ChannelA_8      = (uint16_t)0x08,		 /*!< ADC input channel 8 */
S    ADC_ChannelA_10     = (uint16_t)0x0A,		 /*!< ADC input channel 10 */
S    ADC_ChannelA_12     = (uint16_t)0x0C,		 /*!< ADC input channel 12 */
S    ADC_ChannelA_14     = (uint16_t)0x0E,		 /*!< ADC input channel 14 */
S    ADC_ChannelA_VDD_D4 = (uint16_t)0x10,		 /*!< ADC_CHANNEL VDD Divide 4 */
S} ADC_ChannelATypedef;
S
S#define IS_ADC_ChannelA(ChannelA) ((ChannelA) != 0)
S/** @defgroup ADC_ChannelBTypedef ADC input channel
S * @{
S */
Stypedef enum
S{
S   
S    ADC_ChannelB_1      = (uint16_t)0x01,		 /*!< ADC input channel 1 */   
S    ADC_ChannelB_3      = (uint16_t)0x03,		 /*!< ADC input channel 3 */
S    ADC_ChannelB_5      = (uint16_t)0x05,		 /*!< ADC input channel 5 */
S    ADC_ChannelB_7      = (uint16_t)0x07,		 /*!< ADC input channel 7 */  
S    ADC_ChannelB_9      = (uint16_t)0x09,		 /*!< ADC input channel 9 */ 
S    ADC_ChannelB_11     = (uint16_t)0x0B,		 /*!< ADC input channel 11 */ 
S    ADC_ChannelB_13     = (uint16_t)0x0D,		 /*!< ADC input channel 13 */ 
S    ADC_ChannelB_15     = (uint16_t)0x0F,		 /*!< ADC input channel 15 */ 
S    ADC_ChannelB_TEMP   = (uint16_t)0x11,		 /*!< ADC input channel TEMP */
S} ADC_ChannelBTypedef;
S
S#define IS_ADC_ChannelB(ChannelB) ((ChannelB)!= 0)
S/** @defgroup ADC_Thresholds_Channel ADC Thresholds Channel 
S * @{
S */
Stypedef enum
S{
S    ADC_Thresholds_Channel_Less = (uint32_t)0x00000000, /*!< ADC port Less */
S    ADC_Thresholds_Channel_0   = (uint32_t)0x00000001,  /*!< ADC port 0  */
S    ADC_Thresholds_Channel_1   = (uint32_t)0x00000002,  /*!< ADC port 1  */
S    ADC_Thresholds_Channel_2   = (uint32_t)0x00000004,  /*!< ADC port 2  */
S    ADC_Thresholds_Channel_3   = (uint32_t)0x00000008,  /*!< ADC port 3  */
S    ADC_Thresholds_Channel_4   = (uint32_t)0x00000010,  /*!< ADC port 4  */
S    ADC_Thresholds_Channel_5   = (uint32_t)0x00000020,  /*!< ADC port 5  */
S    ADC_Thresholds_Channel_6   = (uint32_t)0x00000040,  /*!< ADC port 6  */
S    ADC_Thresholds_Channel_7   = (uint32_t)0x00000080,  /*!< ADC port 7  */
S    ADC_Thresholds_Channel_8   = (uint32_t)0x00000100,  /*!< ADC port 8  */
S    ADC_Thresholds_Channel_9   = (uint32_t)0x00000200,  /*!< ADC port 9  */
S    ADC_Thresholds_Channel_10  = (uint32_t)0x00000400,  /*!< ADC port 10 */
S    ADC_Thresholds_Channel_11  = (uint32_t)0x00000800,  /*!< ADC port 11 */
S    ADC_Thresholds_Channel_12  = (uint32_t)0x00001000,  /*!< ADC port 12 */
S    ADC_Thresholds_Channel_13  = (uint32_t)0x00002000,  /*!< ADC port 13 */
S    ADC_Thresholds_Channel_14  = (uint32_t)0x00004000,  /*!< ADC port 14 */
S    ADC_Thresholds_Channel_15  = (uint32_t)0x00008000,  /*!< ADC port 15 */
S    ADC_Thresholds_Channel_All = (uint32_t)0x0000FFFF,  /*!< ADC port All */
S} ADC_Thresholds_Channel_Typedef;
S
S#define IS_ADC_Thresholds_Channel(Channel) ((Channel | ADC_Thresholds_Channel_All) != 0)
S/** @defgroup ADC_SQGroup ADC SQGroup
S * @{
S */
Stypedef enum
S{
S    ADC_SQGroup_0    = (uint32_t)0x0000,   /*!< ADC sequence group 0 */
S} ADC_SQGroup_Typedef;
S
S#define IS_ADC_SQGROUP(GROUP) ((GROUP) != 0)
S/**
S * @}
S */
S
S/** @defgroup ADC_SQRank ADC SQRank
S * @{
S */
Stypedef enum
S{
S    ADC_SQRank_0    = (uint32_t)0x0000,   /*!< ADC sequence Channel 0 */
S    ADC_SQRank_1    = (uint32_t)0x0001,   /*!< ADC sequence Channel 1 */
S    ADC_SQRank_2    = (uint32_t)0x0002,   /*!< ADC sequence Channel 2 */
S    ADC_SQRank_3    = (uint32_t)0x0003,   /*!< ADC sequence Channel 3 */
S    ADC_SQRank_4    = (uint32_t)0x0004,   /*!< ADC sequence Channel 4 */
S    ADC_SQRank_5    = (uint32_t)0x0005,   /*!< ADC sequence Channel 5 */
S    ADC_SQRank_6    = (uint32_t)0x0006,   /*!< ADC sequence Channel 6 */
S    ADC_SQRank_7    = (uint32_t)0x0007,   /*!< ADC sequence Channel 7 */
S    ADC_SQRank_8    = (uint32_t)0x0008,   /*!< ADC sequence Channel 8 */
S    ADC_SQRank_9    = (uint32_t)0x0009,   /*!< ADC sequence Channel 9 */
S    ADC_SQRank_10   = (uint32_t)0x000A,   /*!< ADC sequence Channel 10 */
S    ADC_SQRank_11   = (uint32_t)0x000B,   /*!< ADC sequence Channel 11 */
S    ADC_SQRank_12   = (uint32_t)0x000C,   /*!< ADC sequence Channel 12 */
S    ADC_SQRank_13   = (uint32_t)0x000D,   /*!< ADC sequence Channel 13 */
S    ADC_SQRank_14   = (uint32_t)0x000E,   /*!< ADC sequence Channel 14 */
S    ADC_SQRank_15   = (uint32_t)0x000F,   /*!< ADC sequence Channel 15 */
S} ADC_SQRank_Typedef;
S
S#define IS_ADC_SQRANK(RANK) ((RANK) != 0)
S/**
S * @}
S */
N#endif
N/** @brief ADC_EAIN ADC Enable Input
N * @{
N */
N
Ntypedef enum
N{
N    ADC_EAIN_Less = ( uint32_t ) 0x00000000,	/*!< ADC port Less */
N    ADC_EAIN_0   = ( uint32_t ) 0x00000001,	/*!< ADC port 0 */
N    ADC_EAIN_1   = ( uint32_t ) 0x00000002,	/*!< ADC port 1 */
N    ADC_EAIN_2   = ( uint32_t ) 0x00000004,	/*!< ADC port 2 */
N    ADC_EAIN_3   = ( uint32_t ) 0x00000008,	/*!< ADC port 3 */
N    ADC_EAIN_4   = ( uint32_t ) 0x00000010,	/*!< ADC port 4 */
N    ADC_EAIN_5   = ( uint32_t ) 0x00000020,	/*!< ADC port 5 */
N    ADC_EAIN_6   = ( uint32_t ) 0x00000040,	/*!< ADC port 6 */
N    ADC_EAIN_7   = ( uint32_t ) 0x00000080,	/*!< ADC port 7 */
N    ADC_EAIN_8   = ( uint32_t ) 0x00000100,	/*!< ADC port 8 */
N    ADC_EAIN_9   = ( uint32_t ) 0x00000200,	/*!< ADC port 9 */
N    ADC_EAIN_10   = ( uint32_t ) 0x0000400,	/*!< ADC port 10 */
N    ADC_EAIN_11   = ( uint32_t ) 0x0000800,	/*!< ADC port 11 */
N    ADC_EAIN_12  = ( uint32_t ) 0x00001000, /*!< ADC port 12 */
N    ADC_EAIN_13  = ( uint32_t ) 0x00002000, /*!< ADC port 13 */
N    ADC_EAIN_14  = ( uint32_t ) 0x00004000, /*!< ADC port 14 */
N    ADC_EAIN_15  = ( uint32_t ) 0x00008000, /*!< ADC port 15 */
N#if defined(SC32f10xx)
X#if 1L
N    ADC_EAIN_16  = ( uint32_t ) 0x00010000, /*!< ADC port 16 */
N    ADC_EAIN_All = ( uint32_t ) 0x0001FFFF, /*!< ADC port All */
N#elif defined(SC32f11xx)
S    ADC_EAIN_16  = ( uint32_t ) 0x00010000, /*!< ADC port 16 */
S    ADC_EAIN_17  = ( uint32_t ) 0x00020000, /*!< ADC port 17 */
S    ADC_EAIN_All = ( uint32_t ) 0x0003FFFF, /*!< ADC port All */
S#elif defined(SC32f12xx) ||defined(SC32f15xx)
S    ADC_EAIN_All = ( uint32_t ) 0x0000FFFF, /*!< ADC port All */
N#endif
N} ADC_EAIN_Typedef;
N
N
N
N#define IS_ADC_EAIN(EAIN) ((EAIN | ADC_EAIN_All) != 0 || EAIN == ADC_EAIN_Less)
N/**
N * @}
N */
N
N/** @brief ADC_VREF ADC Reference Voltage
N * @{
N */
Ntypedef enum
N{
N#if defined(SC32f10xx)||defined(SC32f11xx)||defined(SC32f12xx)
X#if 1L||0L||0L
N    ADC_VREF_VDD    = ( uint32_t ) ( 0x00 << ADC_CON_VREFS_Pos ),	 /*!< ADC reference voltage is VDD    */
X    ADC_VREF_VDD    = ( uint32_t ) ( 0x00 << (20U) ),	  
N    ADC_VREF_2_048V = ( uint32_t ) ( 0x01 << ADC_CON_VREFS_Pos ),	 /*!< ADC reference voltage is 2.048V */
X    ADC_VREF_2_048V = ( uint32_t ) ( 0x01 << (20U) ),	  
N    ADC_VREF_1_024V = ( uint32_t ) ( 0x02 << ADC_CON_VREFS_Pos ),	 /*!< ADC reference voltage is 1.024V */
X    ADC_VREF_1_024V = ( uint32_t ) ( 0x02 << (20U) ),	  
N    ADC_VREF_2_4V   = ( uint32_t ) ( 0x03 << ADC_CON_VREFS_Pos )	 /*!< ADC reference voltage is 2.4V   */
X    ADC_VREF_2_4V   = ( uint32_t ) ( 0x03 << (20U) )	  
N#elif defined(SC32f15xx)
S    ADC_RefSource_VDD  = (uint32_t)(0x00 << ADC_CON_REFSEL_Pos),	  /*!< ADC reference voltage is VDD    */
S    ADC_RefSource_VREF = (uint32_t)(0x01 << ADC_CON_REFSEL_Pos),	  /*!< ADC reference voltage is Vref */
N#endif
N} ADC_VREF_TypeDef;
N#if defined(SC32f10xx)||defined(SC32f11xx)||defined(SC32f12xx)
X#if 1L||0L||0L
N#define IS_ADC_VREF(VREF) (((VREF) == ADC_VREF_VDD)    || \
N													 ((VREF) == ADC_VREF_2_048V) || \
N													 ((VREF) == ADC_VREF_1_024V) || \
N													 ((VREF) == ADC_VREF_2_4V))
X#define IS_ADC_VREF(VREF) (((VREF) == ADC_VREF_VDD)    || 													 ((VREF) == ADC_VREF_2_048V) || 													 ((VREF) == ADC_VREF_1_024V) || 													 ((VREF) == ADC_VREF_2_4V))
N#elif defined(SC32f15xx)
S#define IS_ADC_VREF(VREF) (((VREF) == ADC_RefSource_VDD)    || \
S                           ((VREF) == ADC_RefSource_VREF))
X#define IS_ADC_VREF(VREF) (((VREF) == ADC_RefSource_VDD)    ||                            ((VREF) == ADC_RefSource_VREF))
N#endif
N/**
N * @}
N */
N
N/** @brief ADC_IT ADC Interrupt
N * @{
N */
Ntypedef enum
N{
N#if defined(SC32f10xx)||defined(SC32f11xx)||defined(SC32f12xx)
X#if 1L||0L||0L
N    ADC_IT_ADCIF = ( uint16_t ) ADC_CON_INTEN,	/*!< ADC Interrupt: ADC  Interrupt */
X    ADC_IT_ADCIF = ( uint16_t ) (0x1UL << (8U)),	 
N#elif defined(SC32f15xx)	
S    ADC_IT_INTEN    = (uint8_t)ADC_IDE_INTEN,	    /*!< ADC interrupt request Flag */
S    ADC_IT_EOCIE    = (uint8_t)ADC_IDE_EOCIE,	/*!< ADC sequence 0 sampling + conversion complete interrupt Flag */
S    ADC_IT_EOSIE0   = (uint8_t)ADC_IDE_EOSIE0,	/*!< ADC sequence 0 sampling + conversion complete interrupt Flag */
S    ADC_IT_UPTHIE   = (uint8_t)ADC_IDE_UPTHIE,	/*!< ADC upper threshold overflow Flag */
S    ADC_IT_LOWTHIE  = (uint8_t)ADC_IDE_LOWTHIE,	/*!< ADC lower threshold overflow Flag */
N#endif	
N} ADC_IT_TypeDef;
N
N#define IS_ADC_IT(IT) ((((IT) & (uint16_t)0xFEFF) == 0x00) && ((IT) != (uint16_t)0x0000))
N/**
N * @}
N */
N
N/** @brief ADC_FLAG ADC Flag
N * @{
N */
Ntypedef enum
N{
N#if defined(SC32f10xx)||defined(SC32f11xx)||defined(SC32f12xx)
X#if 1L||0L||0L
N    ADC_Flag_ADCIF = ( uint8_t ) ADC_STS_EOC,	/*!< ADC Flag:ADC  Flag */
X    ADC_Flag_ADCIF = ( uint8_t ) (0x01UL << (0U)),	 
N#elif defined(SC32f15xx)
S    ADC_Flag_ADCIF    = (uint8_t)ADC_STS_EOCIF,   /*!< ADC interrupt request Flag */
S    ADC_Flag_EOSIF0   = (uint8_t)ADC_STS_EOSIF0,	/*!< ADC sequence 0 sampling + conversion complete interrupt Flag */
S    ADC_Flag_BUSY     = (uint8_t)ADC_STS_BUSY,    /*!< ADC busy Flag */
S    ADC_Flag_UPTHIF   = (uint8_t)ADC_STS_UPTHIF,	/*!< ADC upper threshold overflow Flag */
S    ADC_Flag_LOWTHIF  = (uint8_t)ADC_STS_LOWTHIF,	/*!< ADC lower threshold overflow Flag */
S	  
N#endif	
N	ADC_Flag_OVERRUN =  (int)0x80000000UL,/*!< ADC overflow Flag */
N} ADC_FLAG_TypeDef;
N#if defined(SC32f10xx)||defined(SC32f11xx)||defined(SC32f12xx)
X#if 1L||0L||0L
N#define IS_ADC_FLAG(FLAG) ((((FLAG) & (uint16_t)0xFFFE) == 0x00) && ((FLAG) != (uint16_t)0x0000))
N#define IS_GET_ADC_FLAG(FLAG) ((FLAG) == ADC_Flag_ADCIF)
N#elif defined(SC32f15xx)
S#define IS_ADC_FLAG(FLAG) ((((FLAG) & (uint32_t)0x7FFE) == 0x00) && ((FLAG) != (uint32_t)0x0000))
S
N#endif
N/**
N * @}
N */
N
N/**
N * @}
N */
N/* End of enumerations -----------------------------------------------------*/
N
N
N#define IS_ADC_ALL_PERIPH(PERIPH) ((PERIPH) == ADC)
N
N/**
N * @}
N */
N/* End of constants -----------------------------------------------------*/
N
N/** @defgroup ADC_Exported_Struct ADC Exported Struct
N * @{
N */
N
N/** @brief ADC Time base Configuration Structure definition
N * @{
N */
Ntypedef struct
N{
N    uint32_t ADC_Prescaler; /*!<  Specifies sampling time of ADC.
N																  This parameter can be a value of @ref ADC_Prescaler_TypeDef */
N
N    uint32_t ADC_EAIN; /*!< Specifies Input channel of ADC.
N																	This parameter can be a value of @ref ADC_EAIN_Typedef */
N
N    uint32_t ADC_VREF; /*!<  Specifies reference voltage of ADC.
N																	This parameter can be a value of @ref ADC_VREF_TypeDef */
N
N    uint16_t ADC_ConvMode; /*!< Specifies ADC work conversion mode.
N																	This parameter can be a value of @ref ADC_ConvMode_TypeDef */
N} ADC_InitTypeDef;
N/**
N * @}
N */
N
N/**
N * @}
N */
N/* End of struct -----------------------------------------------------*/
N
N/** @addtogroup ADC_Exported_Functions ADC Exported Functions
N * @{
N */
N
N/* ADC Base functions ********************************************************/
Nvoid ADC_DeInit ( ADC_TypeDef* ADCx );
Nvoid ADC_Init ( ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_Base_InitStruct );
Nvoid ADC_StructInit ( ADC_InitTypeDef* ADC_InitStruct );
Nvoid ADC_Cmd ( ADC_TypeDef *ADCx, FunctionalState NewState );
Nvoid ADC_ConvModeConfig ( ADC_TypeDef* ADCx, ADC_ConvMode_TypeDef ADC_ConvMode );
Nvoid ADC_SetChannel ( ADC_TypeDef* ADCx, ADC_ChannelTypedef ADC_Channel );
NADC_ChannelTypedef ADC_GetChannel ( ADC_TypeDef* ADCx );
N
N/* ADC Conversion management functions ********************************************************/
Nuint16_t ADC_GetConversionValue ( ADC_TypeDef* ADCx );
Nvoid ADC_SoftwareStartConv ( ADC_TypeDef* ADCx );
N
N/* Interrupts and flags  ***********************************************/
Nvoid ADC_ITConfig ( ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState );
NFlagStatus ADC_GetFlagStatus ( ADC_TypeDef* ADCx, uint32_t ADC_FLAG );
Nvoid ADC_ClearFlag ( ADC_TypeDef* ADCx, uint32_t ADC_FLAG );
Nvoid ADC_DMACmd ( ADC_TypeDef *ADCx, FunctionalState NewState );
N#if defined(SC32f15xx)
X#if 0L
Svoid ADC_SequenceChannelConfig(ADC_TypeDef* ADCx,ADC_SQRank_Typedef ADC_SQRank,ADC_ChannelTypedef ADC_Channel);
Svoid ADC_SequenceGroupConfig(ADC_TypeDef* ADCx,uint8_t SQStr,uint8_t SQCnt);
Svoid ADC_SetThresholds(ADC_TypeDef* ADCx, uint16_t HighThreshold,uint16_t LowThreshold);
Svoid ADC_ThresholdsChannelConfig(ADC_TypeDef* ADCx, uint32_t ADC_Thresholds_Channel, FunctionalState NewState);
N#endif
N
N/**
N * @}
N */
N/* End of exported functions --------------------------------------------------*/
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 32 "..\FWLib\SC32F1XXX_Lib\inc\sc32_conf.h" 2
N#include "sc32f1xxx_cmp.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx_cmp.h" 1
N/**
N ******************************************************************************
N * @file    sc32f1xxx_cmp.h
N * @author  SOC AE Team
N * @version V1.6
N * @date     04-09-2024
N * @brief   Header file of CMP module.
N ******************************************************************************
N * @attention
N *
N *1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only
N *intended for use with SinOne products. No other uses are authorized. This
N *software is owned by SinOne Microelectronics Co.,Ltd. and is protected under
N *all applicable laws, including copyright laws.
N *2.The software which is for guidance only aims at providing customers with
N *coding information regarding their products in order for them to save time.
N *As a result, SinOne shall not be held liable for any direct, indirect or
N *consequential damages with respect to any claims arising from the content of
N *such software and/or the use made by customers of the coding information
N *contained herein in connection with their products.
N *
N *  COPYRIGHT 2024 SinOne Microelectronics
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __sc32f1xxx_CMP_H
N#define __sc32f1xxx_CMP_H
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "sc32f1xxx.h"
N#include "sc32.h"
N#include "sc32f1xxx_rcc.h"
N
N/** @addtogroup sc32f1xxx_StdPeriph_Driver
N * @{
N */
N
N/** @addtogroup CMP
N * @{
N */
N
N/* Exported enumerations ------------------------------------------------------------*/
N/** @defgroup CMP_Enumerations CMP Enumerations
N * @{
N */
N
N/** @brief CMP_Positive CMP Positive
N * @{
N */
N#if defined(SC32f10xx)
X#if 1L
Ntypedef enum
N{
N    CMP_Positive_CMP0 = ( uint16_t ) ( 0x00U << CMP_CFG_CMPIS_Pos ), /*!< Select CMP0 as the CMP input port    */
X    CMP_Positive_CMP0 = ( uint16_t ) ( 0x00U << (0U) ),  
N    CMP_Positive_CMP1 = ( uint16_t ) ( 0x01U << CMP_CFG_CMPIS_Pos ), /*!< Select CMP1 as the CMP input port  */
X    CMP_Positive_CMP1 = ( uint16_t ) ( 0x01U << (0U) ),  
N    CMP_Positive_CMP2 = ( uint16_t ) ( 0x02U << CMP_CFG_CMPIS_Pos ), /*!< Select CMP2 as the CMP input port   */
X    CMP_Positive_CMP2 = ( uint16_t ) ( 0x02U << (0U) ),  
N    CMP_Positive_CMP3 = ( uint16_t ) ( 0x03U << CMP_CFG_CMPIS_Pos ), /*!< Select CMP3 as the CMP input port   */
X    CMP_Positive_CMP3 = ( uint16_t ) ( 0x03U << (0U) ),  
N    CMP_Positive_1_5V = ( uint16_t ) ( 0x01U << CMP_CFG_CMPP_Pos ), /*!< Select CMPP as the CMP input port,CMPP is 1.5V reference voltage     */
X    CMP_Positive_1_5V = ( uint16_t ) ( 0x01U << (4U) ),  
N} CMP_Positive_TypeDef;
N
N#define IS_CMP_Positive(POSITIVE) (((POSITIVE) == CMP_Positive_CMP0) || \
N                                   ((POSITIVE) == CMP_Positive_CMP1) || \
N                                   ((POSITIVE) == CMP_Positive_CMP2) || \
N                                   ((POSITIVE) == CMP_Positive_CMP3) || \
N                                   ((POSITIVE) == CMP_Positive_1_5V))
X#define IS_CMP_Positive(POSITIVE) (((POSITIVE) == CMP_Positive_CMP0) ||                                    ((POSITIVE) == CMP_Positive_CMP1) ||                                    ((POSITIVE) == CMP_Positive_CMP2) ||                                    ((POSITIVE) == CMP_Positive_CMP3) ||                                    ((POSITIVE) == CMP_Positive_1_5V))
N#elif defined(SC32f11xx)
Stypedef enum
S{
S    CMP_Positive_CMP0 = ( uint16_t ) ( 0x00U << CMP_CFG_CMPIS_Pos ), /*!< Select CMP0 as the CMP input port    */
S    CMP_Positive_CMP1 = ( uint16_t ) ( 0x01U << CMP_CFG_CMPIS_Pos ), /*!< Select CMP1 as the CMP input port    */
S    CMP_Positive_1_5V = ( uint16_t ) ( 0x01U << CMP_CFG_CMPP_Pos ), /*!< Select CMPP as the CMP input port,CMPP is 1.5V reference voltage     */
S    CMP_Positive_PGA  = ( uint16_t ) ( 0x07U << CMP_CFG_CMPIS_Pos ), /*!< Select OP as the CMP input port       */
S} CMP_Positive_TypeDef;
S
S#define IS_CMP_Positive(POSITIVE) (((POSITIVE) == CMP_Positive_CMP0) || \
S                                   ((POSITIVE) == CMP_Positive_CMP1) || \
S                                   ((POSITIVE) == CMP_Positive_1_5V) || \
S																	 ((POSITIVE) == CMP_Positive_PGA))
X#define IS_CMP_Positive(POSITIVE) (((POSITIVE) == CMP_Positive_CMP0) ||                                    ((POSITIVE) == CMP_Positive_CMP1) ||                                    ((POSITIVE) == CMP_Positive_1_5V) || 																	 ((POSITIVE) == CMP_Positive_PGA))
S
S#elif defined(SC32f12xx)
Stypedef enum
S{
S    CMP_Positive_CMP0 = ( uint16_t ) ( 0x00U << CMP_CFG_CMPIS_Pos ), /*!< Select CMP0 as the CMP input port    */
S    CMP_Positive_CMP1 = ( uint16_t ) ( 0x01U << CMP_CFG_CMPIS_Pos ), /*!< Select CMP1 as the CMP input port    */
S    CMP_Positive_CMP2 = ( uint16_t ) ( 0x02U << CMP_CFG_CMPIS_Pos ), /*!< Select CMP2 as the CMP input port    */
S    CMP_Positive_CMP3 = ( uint16_t ) ( 0x03U << CMP_CFG_CMPIS_Pos ), /*!< Select CMP3 as the CMP input port    */
S    CMP_Positive_1_6V = ( uint16_t ) ( 0x01U << CMP_CFG_CMPP_Pos ), /*!< Select CMPP as the CMP input port,CMPP is 1.5V reference voltage     */
S    CMP_Positive_OP  = ( uint16_t ) ( 0x07U << CMP_CFG_CMPIS_Pos ), /*!< Select OP as the CMP input port       */
S} CMP_Positive_TypeDef;
S
S#define IS_CMP_Positive(POSITIVE) (((POSITIVE) == CMP_Positive_CMP0) || \
S                                   ((POSITIVE) == CMP_Positive_CMP1) || \
S                                   ((POSITIVE) == CMP_Positive_CMP2) || \
S                                   ((POSITIVE) == CMP_Positive_CMP3) || \
S                                   ((POSITIVE) == CMP_Positive_1_5V) || \
S																	 ((POSITIVE) == CMP_Positive_OP))
X#define IS_CMP_Positive(POSITIVE) (((POSITIVE) == CMP_Positive_CMP0) ||                                    ((POSITIVE) == CMP_Positive_CMP1) ||                                    ((POSITIVE) == CMP_Positive_CMP2) ||                                    ((POSITIVE) == CMP_Positive_CMP3) ||                                    ((POSITIVE) == CMP_Positive_1_5V) || 																	 ((POSITIVE) == CMP_Positive_OP))
S#elif defined(SC32f15xx)
Stypedef enum
S{
S  CMP0_Positive_CMP0P = (uint16_t)(0x00U<<CMPX_CFG_CMPPS_Pos),    /*!< CMP0 Select CMP0P as the CMP Positive port    */
S  CMP0_Positive_OP1O = (uint16_t)(0x01U << CMPX_CFG_CMPPS_Pos),    /*!< CMP0 Select OP1O as the CMP Positive port  */
S  CMP0_Positive_OP2O = (uint16_t)(0x02U << CMPX_CFG_CMPPS_Pos),    /*!< CMP0 Select OP2O as the CMP Positive port   */
S  CMP3_Positive_CMP3P = (uint16_t)(0x00U << CMP_CFG_CMPPS_Pos),    /*!< CMP3 Select CMP3P as the CMP input port    */
S  CMP3_Positive_OP1O = (uint16_t)(0x01U << CMP_CFG_CMPPS_Pos),    /*!< CMP3 Select OP1O as the CMP input port  */
S  CMP3_Positive_OP2O = (uint16_t)(0x02U << CMP_CFG_CMPPS_Pos),    /*!< CMP3 Select OP2O as the CMP input port   */
S} CMP_Positive_TypeDef;
S
S#define IS_CMP_Positive(POSITIVE) (((POSITIVE) == CMP0_Positive_CMP0P) || \
S																	((POSITIVE) == CMP0_Positive_OP1O) || \
S																	((POSITIVE) == CMP0_Positive_OP2O) || \
S                                  ((POSITIVE) == CMP3_Positive_CMP3P) || \
S                                  ((POSITIVE) == CMP3_Positive_OP1O)  || \
S                                  ((POSITIVE) == CMP3_Positive_OP2O))
X#define IS_CMP_Positive(POSITIVE) (((POSITIVE) == CMP0_Positive_CMP0P) || 																	((POSITIVE) == CMP0_Positive_OP1O) || 																	((POSITIVE) == CMP0_Positive_OP2O) ||                                   ((POSITIVE) == CMP3_Positive_CMP3P) ||                                   ((POSITIVE) == CMP3_Positive_OP1O)  ||                                   ((POSITIVE) == CMP3_Positive_OP2O))
N#endif
N
N/**
N * @}
N */
N#if defined(SC32f15xx)
X#if 0L
Stypedef enum
S{
S    CMP0_1_2NegativeSelect_CMPxN 	= (uint16_t)(0x00U << CMPX_CFG_CMPNS_Pos),  /*!<  Select CMPxN as the CMP0_1_2 Negative port   */
S    CMP0_1_2NegativeSelect_DAC 	    = (uint16_t)(0x01U << CMPX_CFG_CMPNS_Pos),    /*!< Select DAC as the CMP0_1_2 Negative port   */
S    CMP0_1_2NegativeSelect_BEMF_MID = (uint16_t)(0x02U << CMPX_CFG_CMPNS_Pos), /*!< Select BEMF_MID as the CMP0_1_2 Negative port   */
S    CMP3_NegativeSelect_CMPxN       = (uint16_t)(0x00U << CMP_CFG_CMPNS_Pos),  /*!< Select CMPN as the CMP3 Negative input port    */
S    CMP3_NegativeSelect_DAC 	    = (uint16_t)(0x01U << CMP_CFG_CMPNS_Pos),  /*!< Select DAC as the CMP3 Negative input port    */
S    CMP3_NegativeSelect_CMPRF       = (uint16_t)(0x02U << CMP_CFG_CMPNS_Pos),  /*!< Select CMPRF as the CMP3 Negative input port    */
S} CMP_NegativeSelect_TypeDef ;
S
S#define IS_CMP_NegativeSelect(NegativeSelect) (((NegativeSelect) == CMP0_1_2NegativeSelect_CMPxN) || \
S																	((NegativeSelect) == CMP0_1_2_NegativeSelect_DAC) || \
S																	((NegativeSelect) == CMP0_1_2_NegativeSelect_BEMF_MID) || \
S                                  ((NegativeSelect) == CMP3_NegativeSelect_CMPxN)|| \
S                                  ((NegativeSelect) == CMP3_NegativeSelect_DAC) || \
S                                  ((NegativeSelect) == CMP3_NegativeSelect_CMPRF))
X#define IS_CMP_NegativeSelect(NegativeSelect) (((NegativeSelect) == CMP0_1_2NegativeSelect_CMPxN) || 																	((NegativeSelect) == CMP0_1_2_NegativeSelect_DAC) || 																	((NegativeSelect) == CMP0_1_2_NegativeSelect_BEMF_MID) ||                                   ((NegativeSelect) == CMP3_NegativeSelect_CMPxN)||                                   ((NegativeSelect) == CMP3_NegativeSelect_DAC) ||                                   ((NegativeSelect) == CMP3_NegativeSelect_CMPRF))
S/** @defgroup CMP_VREF CMP Reference Voltage
S * @{
S */
Stypedef enum
S{
S    CMP0_1_2RefSource_VDD  = (uint32_t)(0x00 << CMP_CON_REFSEL_Pos),	  /*!< CMP0_1_2 reference voltage is VDD    */
S    CMP0_1_2RefSource_VREF = (uint32_t)(0x01 << CMP_CON_REFSEL_Pos),	  /*!< CMP0_1_2 reference voltage is Vref */
S    CMP3_RefSource_VDD  = (uint32_t)(0x00 << CMP_CON_REFSEL_Pos),	  /*!< CMP3 reference voltage is VDD    */
S    CMP3_RefSource_VREF = (uint32_t)(0x01 << CMP_CON_REFSEL_Pos),	  /*!< CMP3 reference voltage is Vref */
S} CMP_VREF_TypeDef;
S
S#define IS_CMP_VREF(VREF) (((VREF) == CMP0_1_2RefSource_VDD)    || \
S                           ((VREF) == CMP0_1_2RefSource_VREF) || \
S                           ((VREF) == CMP3_RefSource_VDD)    || \
S                           ((VREF) == CMP3_RefSource_VREF))
X#define IS_CMP_VREF(VREF) (((VREF) == CMP0_1_2RefSource_VDD)    ||                            ((VREF) == CMP0_1_2RefSource_VREF) ||                            ((VREF) == CMP3_RefSource_VDD)    ||                            ((VREF) == CMP3_RefSource_VREF))
S
N#endif
N/** @brief CMP_Negative CMP Negative
N * @{
N */
N #if defined(SC32f10xx)||defined(SC32f11xx)||defined(SC32f12xx)
X #if 1L||0L||0L
Ntypedef enum
N{
N
N    CMP_Negative_CMPR    	= ( uint16_t ) ( 0x00U << CMP_CFG_CMPRF_Pos ), /*!< The comparison voltage of CMP is CMPR  */
X    CMP_Negative_CMPR    	= ( uint16_t ) ( 0x00U << (8U) ),  
N    CMP_Negative_1D16VDD 	= ( uint16_t ) ( 0x01U << CMP_CFG_CMPRF_Pos ), /*!< The comparison voltage of CMP is 1/16VDD   */
X    CMP_Negative_1D16VDD 	= ( uint16_t ) ( 0x01U << (8U) ),  
N    CMP_Negative_2D16VDD 	= ( uint16_t ) ( 0x02U << CMP_CFG_CMPRF_Pos ), /*!< The comparison voltage of CMP is 2/16VDD   */
X    CMP_Negative_2D16VDD 	= ( uint16_t ) ( 0x02U << (8U) ),  
N    CMP_Negative_3D16VDD 	= ( uint16_t ) ( 0x03U << CMP_CFG_CMPRF_Pos ), /*!< The comparison voltage of CMP is 3/16VDD   */
X    CMP_Negative_3D16VDD 	= ( uint16_t ) ( 0x03U << (8U) ),  
N    CMP_Negative_4D16VDD 	= ( uint16_t ) ( 0x04U << CMP_CFG_CMPRF_Pos ), /*!< The comparison voltage of CMP is 4/16VDD   */
X    CMP_Negative_4D16VDD 	= ( uint16_t ) ( 0x04U << (8U) ),  
N    CMP_Negative_5D16VDD 	= ( uint16_t ) ( 0x05U << CMP_CFG_CMPRF_Pos ), /*!< The comparison voltage of CMP is 5/16VDD   */
X    CMP_Negative_5D16VDD 	= ( uint16_t ) ( 0x05U << (8U) ),  
N    CMP_Negative_6D16VDD 	= ( uint16_t ) ( 0x06U << CMP_CFG_CMPRF_Pos ), /*!< The comparison voltage of CMP is 6/16VDD   */
X    CMP_Negative_6D16VDD 	= ( uint16_t ) ( 0x06U << (8U) ),  
N    CMP_Negative_7D16VDD 	= ( uint16_t ) ( 0x07U << CMP_CFG_CMPRF_Pos ), /*!< The comparison voltage of CMP is 7/16VDD   */
X    CMP_Negative_7D16VDD 	= ( uint16_t ) ( 0x07U << (8U) ),  
N    CMP_Negative_8D16VDD 	= ( uint16_t ) ( 0x08U << CMP_CFG_CMPRF_Pos ), /*!< The comparison voltage of CMP is 8/16VDD   */
X    CMP_Negative_8D16VDD 	= ( uint16_t ) ( 0x08U << (8U) ),  
N    CMP_Negative_9D16VDD 	= ( uint16_t ) ( 0x09U << CMP_CFG_CMPRF_Pos ), /*!< The comparison voltage of CMP is 9/16VDD   */
X    CMP_Negative_9D16VDD 	= ( uint16_t ) ( 0x09U << (8U) ),  
N    CMP_Negative_10D16VDD = ( uint16_t ) ( 0x0AU << CMP_CFG_CMPRF_Pos ), /*!< The comparison voltage of CMP is 10/16VDD   */
X    CMP_Negative_10D16VDD = ( uint16_t ) ( 0x0AU << (8U) ),  
N    CMP_Negative_11D16VDD = ( uint16_t ) ( 0x0BU << CMP_CFG_CMPRF_Pos ), /*!< The comparison voltage of CMP is 11/16VDD   */
X    CMP_Negative_11D16VDD = ( uint16_t ) ( 0x0BU << (8U) ),  
N    CMP_Negative_12D16VDD = ( uint16_t ) ( 0x0CU << CMP_CFG_CMPRF_Pos ), /*!< The comparison voltage of CMP is 12/16VDD   */
X    CMP_Negative_12D16VDD = ( uint16_t ) ( 0x0CU << (8U) ),  
N    CMP_Negative_13D16VDD = ( uint16_t ) ( 0x0DU << CMP_CFG_CMPRF_Pos ), /*!< The comparison voltage of CMP is 13/16VDD   */
X    CMP_Negative_13D16VDD = ( uint16_t ) ( 0x0DU << (8U) ),  
N    CMP_Negative_14D16VDD = ( uint16_t ) ( 0x0EU << CMP_CFG_CMPRF_Pos ), /*!< The comparison voltage of CMP is 14/16VDD   */
X    CMP_Negative_14D16VDD = ( uint16_t ) ( 0x0EU << (8U) ),  
N    CMP_Negative_15D16VDD = ( uint16_t ) ( 0x0FU << CMP_CFG_CMPRF_Pos ), /*!< The comparison voltage of CMP is 15/16VDD   */
X    CMP_Negative_15D16VDD = ( uint16_t ) ( 0x0FU << (8U) ),  
N} CMP_Negative_TypeDef;
N
N#define IS_CMP_Negative(NEGATIVE) (((NEGATIVE) == CMP_Negative_CMPR) || \
N                                   ((NEGATIVE) == CMP_Negative_1D16VDD) || \
N                                   ((NEGATIVE) == CMP_Negative_2D16VDD) || \
N                                   ((NEGATIVE) == CMP_Negative_3D16VDD) || \
N                                   ((NEGATIVE) == CMP_Negative_4D16VDD) || \
N                                   ((NEGATIVE) == CMP_Negative_5D16VDD) || \
N                                   ((NEGATIVE) == CMP_Negative_6D16VDD) || \
N                                   ((NEGATIVE) == CMP_Negative_7D16VDD) || \
N                                   ((NEGATIVE) == CMP_Negative_8D16VDD) || \
N                                   ((NEGATIVE) == CMP_Negative_9D16VDD) || \
N                                   ((NEGATIVE) == CMP_Negative_10D16VDD) || \
N                                   ((NEGATIVE) == CMP_Negative_11D16VDD) || \
N                                   ((NEGATIVE) == CMP_Negative_12D16VDD) || \
N                                   ((NEGATIVE) == CMP_Negative_13D16VDD) || \
N                                   ((NEGATIVE) == CMP_Negative_14D16VDD) || \
N                                   ((NEGATIVE) == CMP_Negative_15D16VDD))
X#define IS_CMP_Negative(NEGATIVE) (((NEGATIVE) == CMP_Negative_CMPR) ||                                    ((NEGATIVE) == CMP_Negative_1D16VDD) ||                                    ((NEGATIVE) == CMP_Negative_2D16VDD) ||                                    ((NEGATIVE) == CMP_Negative_3D16VDD) ||                                    ((NEGATIVE) == CMP_Negative_4D16VDD) ||                                    ((NEGATIVE) == CMP_Negative_5D16VDD) ||                                    ((NEGATIVE) == CMP_Negative_6D16VDD) ||                                    ((NEGATIVE) == CMP_Negative_7D16VDD) ||                                    ((NEGATIVE) == CMP_Negative_8D16VDD) ||                                    ((NEGATIVE) == CMP_Negative_9D16VDD) ||                                    ((NEGATIVE) == CMP_Negative_10D16VDD) ||                                    ((NEGATIVE) == CMP_Negative_11D16VDD) ||                                    ((NEGATIVE) == CMP_Negative_12D16VDD) ||                                    ((NEGATIVE) == CMP_Negative_13D16VDD) ||                                    ((NEGATIVE) == CMP_Negative_14D16VDD) ||                                    ((NEGATIVE) == CMP_Negative_15D16VDD))
N/** @brief CMP_TriggerMode CMP TriggerMode
N * @{
N */
Ntypedef enum
N{
N    CMP_TriggerMode_Disable   = ( uint16_t ) ( 0x00U << CMP_CFG_CMPIM_Pos ), /*!< The trigger mode is disable  */
X    CMP_TriggerMode_Disable   = ( uint16_t ) ( 0x00U << (5U) ),  
N    CMP_TriggerMode_RISE      = ( uint16_t ) ( 0x01U << CMP_CFG_CMPIM_Pos ), /*!< The trigger mode of simulated comparator is rising edge  */
X    CMP_TriggerMode_RISE      = ( uint16_t ) ( 0x01U << (5U) ),  
N    CMP_TriggerMode_FALL      = ( uint16_t ) ( 0x02U << CMP_CFG_CMPIM_Pos ), /*!< The trigger mode of simulated comparator is falling edge  */
X    CMP_TriggerMode_FALL      = ( uint16_t ) ( 0x02U << (5U) ),  
N    CMP_TriggerMode_RISE_FALL = ( uint16_t ) ( 0x03U << CMP_CFG_CMPIM_Pos ), /*!< The trigger mode of the simulated comparator is rising edge and falling edge  */
X    CMP_TriggerMode_RISE_FALL = ( uint16_t ) ( 0x03U << (5U) ),  
N} CMP_TriggerMode_TypeDef;
N
N#define IS_CMP_TRIGGER(TRIGGER) (((TRIGGER) == CMP_TriggerMode_Disable) || \
N                                 ((TRIGGER) == CMP_TriggerMode_RISE) || \
N                                 ((TRIGGER) == CMP_TriggerMode_FALL) || \
N                                 ((TRIGGER) == CMP_TriggerMode_RISE_FALL))
X#define IS_CMP_TRIGGER(TRIGGER) (((TRIGGER) == CMP_TriggerMode_Disable) ||                                  ((TRIGGER) == CMP_TriggerMode_RISE) ||                                  ((TRIGGER) == CMP_TriggerMode_FALL) ||                                  ((TRIGGER) == CMP_TriggerMode_RISE_FALL))
N/** @brief CMP_CMPSTA CMP CMPSTA
N * @{
N */
Ntypedef enum
N{
N    CMP_CMPSTA_Low		= ( uint32_t ) ( 0x00 << CMP_STS_CMPSTA_Pos ), /*!< CMP Flag: The non-inverting input is at a lower voltage than the inverting input */
X    CMP_CMPSTA_Low		= ( uint32_t ) ( 0x00 << (1U) ),  
N    CMP_CMPSTA_High		= ( uint32_t ) ( 0x01 << CMP_STS_CMPSTA_Pos ), /*!< CMP Flag: The non-inverting input is at a higher voltage than the inverting input */
X    CMP_CMPSTA_High		= ( uint32_t ) ( 0x01 << (1U) ),  
N} CMP_CMPSTA_TypeDef;
N
N#define IS_CMP_CMPSTA(STA) (((STA) == CMP_TriggerMode_Disable) || \
N                           ((STA) == CMP_TriggerMode_RISE_FALL))
X#define IS_CMP_CMPSTA(STA) (((STA) == CMP_TriggerMode_Disable) ||                            ((STA) == CMP_TriggerMode_RISE_FALL))
N/**
N * @}
N */
N
N/** @brief CMP_FLAG CMP Flag
N * @{
N */
Ntypedef enum
N{
N    CMP_FLAG_IF		= ( uint32_t ) CMP_STS_CMPIF, /*!< CMP Flag: Interrupt flag */
X    CMP_FLAG_IF		= ( uint32_t ) (0x1L << (0U)),  
N} CMP_FLAG_TypeDef;
N
N#define IS_CMP_FLAG(FLAG) ((FLAG) == CMP_FLAG_IF)
N#elif defined(SC32f15xx)
Stypedef enum
S{
S    CMP3_Negative_1D16CMP_VREF   = (uint16_t)(0x01U << CMP_CFG_CMPRF_Pos),  /*!< The comparison voltage of CMP is 1/16VDD   */
S    CMP3_Negative_2D16CMP_VREF   = (uint16_t)(0x02U << CMP_CFG_CMPRF_Pos),  /*!< The comparison voltage of CMP is 2/16VDD   */
S    CMP3_Negative_3D16CMP_VREF   = (uint16_t)(0x03U << CMP_CFG_CMPRF_Pos),  /*!< The comparison voltage of CMP is 3/16VDD   */
S    CMP3_Negative_4D16CMP_VREF   = (uint16_t)(0x04U << CMP_CFG_CMPRF_Pos),  /*!< The comparison voltage of CMP is 4/16VDD   */
S    CMP3_Negative_5D16CMP_VREF   = (uint16_t)(0x05U << CMP_CFG_CMPRF_Pos),  /*!< The comparison voltage of CMP is 5/16VDD   */
S    CMP3_Negative_6D16CMP_VREF   = (uint16_t)(0x06U << CMP_CFG_CMPRF_Pos),  /*!< The comparison voltage of CMP is 6/16VDD   */
S    CMP3_Negative_7D16CMP_VREF   = (uint16_t)(0x07U << CMP_CFG_CMPRF_Pos),  /*!< The comparison voltage of CMP is 7/16VDD   */
S    CMP3_Negative_8D16CMP_VREF   = (uint16_t)(0x08U << CMP_CFG_CMPRF_Pos),  /*!< The comparison voltage of CMP is 8/16VDD   */
S    CMP3_Negative_9D16CMP_VREF   = (uint16_t)(0x09U << CMP_CFG_CMPRF_Pos),  /*!< The comparison voltage of CMP is 9/16VDD   */
S    CMP3_Negative_10D16CMP_VREF  = (uint16_t)(0x0AU << CMP_CFG_CMPRF_Pos),  /*!< The comparison voltage of CMP is 10/16VDD   */
S    CMP3_Negative_11D16CMP_VREF  = (uint16_t)(0x0BU << CMP_CFG_CMPRF_Pos),  /*!< The comparison voltage of CMP is 11/16VDD   */
S    CMP3_Negative_12D16CMP_VREF  = (uint16_t)(0x0CU << CMP_CFG_CMPRF_Pos),  /*!< The comparison voltage of CMP is 12/16VDD   */
S    CMP3_Negative_13D16CMP_VREF  = (uint16_t)(0x0DU << CMP_CFG_CMPRF_Pos),  /*!< The comparison voltage of CMP is 13/16VDD   */
S    CMP3_Negative_14D16CMP_VREF  = (uint16_t)(0x0EU << CMP_CFG_CMPRF_Pos),  /*!< The comparison voltage of CMP is 14/16VDD   */
S    CMP3_Negative_15D16CMP_VREF  = (uint16_t)(0x0FU << CMP_CFG_CMPRF_Pos),  /*!< The comparison voltage of CMP is 15/16VDD   */
S} CMP_Negative_TypeDef;
S
S#define IS_CMP_Negative(Negative) (((Negative) == CMP3_Negative_1D16CMP_VREF) || \
S															((Negative) == CMP3_Negative_2D16CMP_VREF) || \
S															((Negative) == CMP3_Negative_3D16CMP_VREF) || \
S															((Negative) == CMP3_Negative_4D16CMP_VREF) || \
S															((Negative) == CMP3_Negative_5D16CMP_VREF) || \
S															((Negative) == CMP3_Negative_6D16CMP_VREF) || \
S															((Negative) == CMP3_Negative_7D16CMP_VREF) || \
S															((Negative) == CMP3_Negative_8D16CMP_VREF) || \
S															((Negative) == CMP3_Negative_9D16CMP_VREF) || \
S															((Negative) == CMP3_Negative_10D16CMP_VREF) || \
S															((Negative) == CMP3_Negative_11D16CMP_VREF) || \
S															((Negative) == CMP3_Negative_12D16CMP_VREF) || \
S															((Negative) == CMP3_Negative_13D16CMP_VREF) || \
S															((Negative) == CMP3_Negative_14D16CMP_VREF) || \
S															((Negative) == CMP3_Negative_15D16CMP_VREF))
X#define IS_CMP_Negative(Negative) (((Negative) == CMP3_Negative_1D16CMP_VREF) || 															((Negative) == CMP3_Negative_2D16CMP_VREF) || 															((Negative) == CMP3_Negative_3D16CMP_VREF) || 															((Negative) == CMP3_Negative_4D16CMP_VREF) || 															((Negative) == CMP3_Negative_5D16CMP_VREF) || 															((Negative) == CMP3_Negative_6D16CMP_VREF) || 															((Negative) == CMP3_Negative_7D16CMP_VREF) || 															((Negative) == CMP3_Negative_8D16CMP_VREF) || 															((Negative) == CMP3_Negative_9D16CMP_VREF) || 															((Negative) == CMP3_Negative_10D16CMP_VREF) || 															((Negative) == CMP3_Negative_11D16CMP_VREF) || 															((Negative) == CMP3_Negative_12D16CMP_VREF) || 															((Negative) == CMP3_Negative_13D16CMP_VREF) || 															((Negative) == CMP3_Negative_14D16CMP_VREF) || 															((Negative) == CMP3_Negative_15D16CMP_VREF))
S/** @defgroup CMP_TriggerMode_TypeDef CMP TriggerMode
S * @{
S */
Stypedef enum
S{
S	  CMP0_1_2TriggerMode_Disable   = (uint16_t)(0x00U << CMPX_CFG_CMPIM_Pos),    /*!< CMP0_1_2 the trigger mode is disable  */
S    CMP0_1_2TriggerMode_RISE      = (uint16_t)(0x01U << CMPX_CFG_CMPIM_Pos),    /*!< CMP0_1_2 The trigger mode of the simulated comparator is rising edge  */
S    CMP0_1_2TriggerMode_FALL      = (uint16_t)(0x02U << CMPX_CFG_CMPIM_Pos),    /*!< CMP0_1_2 The trigger mode of simulated comparator is falling edge   */
S    CMP0_1_2TriggerMode_RISE_FALL = (uint16_t)(0x03U << CMPX_CFG_CMPIM_Pos),    /*!< CMP0_1_2 The trigger mode of the simulated comparator is rising edge and falling edge  */
S    CMP3_TriggerMode_Disable   = (uint16_t)(0x00U << CMP_CFG_CMPIM_Pos),    /*!< CMP3 the trigger mode is disable  */
S    CMP3_TriggerMode_RISE      = (uint16_t)(0x01U << CMP_CFG_CMPIM_Pos),    /*!< CMP3 The trigger mode of the simulated comparator is rising edge  */
S    CMP3_TriggerMode_FALL      = (uint16_t)(0x02U << CMP_CFG_CMPIM_Pos),    /*!< CMP3 The trigger mode of simulated comparator is falling edge   */
S    CMP3_TriggerMode_RISE_FALL = (uint16_t)(0x03U << CMP_CFG_CMPIM_Pos),    /*!< CMP3 The trigger mode of the simulated comparator is rising edge and falling edge  */
S} CMP_TriggerMode_TypeDef;
S
S#define IS_CMP_TRIGGER(TRIGGER) (((TRIGGER) == CMP0_1_2TriggerMode_Disable) || \
S                                 ((TRIGGER) == CMP0_1_2TriggerMode_RISE) || \
S                                 ((TRIGGER) == CMP0_1_2TriggerMode_FALL) || \
S                                 ((TRIGGER) == CMP0_1_2TriggerMode_RISE_FALL)|| \
S                                 ((TRIGGER) == CMP3_TriggerMode_Disable) || \
S                                 ((TRIGGER) == CMP3_TriggerMode_RISE) || \
S                                 ((TRIGGER) == CMP3_TriggerMode_FALL) || \
S                                 ((TRIGGER) == CMP3_TriggerMode_RISE_FALL))
X#define IS_CMP_TRIGGER(TRIGGER) (((TRIGGER) == CMP0_1_2TriggerMode_Disable) ||                                  ((TRIGGER) == CMP0_1_2TriggerMode_RISE) ||                                  ((TRIGGER) == CMP0_1_2TriggerMode_FALL) ||                                  ((TRIGGER) == CMP0_1_2TriggerMode_RISE_FALL)||                                  ((TRIGGER) == CMP3_TriggerMode_Disable) ||                                  ((TRIGGER) == CMP3_TriggerMode_RISE) ||                                  ((TRIGGER) == CMP3_TriggerMode_FALL) ||                                  ((TRIGGER) == CMP3_TriggerMode_RISE_FALL))
S/** @defgroup CMP_HYS_TypeDef CMP HYS
S * @{
S */
Stypedef enum
S{
S    CMP_HYS_0mV		  = (uint32_t)(0x00 << CMP_CON_HYS_Pos), /*!< CMP_HYS_0mV: Hysteresis voltage selection CMP0_1_2HYS_0mV */
S    CMP_HYS_5mV		  = (uint32_t)(0x01 << CMP_CON_HYS_Pos), /*!<  CMP_HYS_5mV: Hysteresis voltage selection CMP0_1_2HYS_5mV */
S    CMP_HYS_10mV		  = (uint32_t)(0x02 << CMP_CON_HYS_Pos), /*!<  CMP_HYS_10mV: Hysteresis voltage selection CMP0_1_2HYS_10mV */
S    CMP_HYS_20mV		  = (uint32_t)(0x03 << CMP_CON_HYS_Pos), /*!<  CMP_HYS_20mV: Hysteresis voltage selection CMP0_1_2HYS_20mV */
S} CMP_HYS_TypeDef;
S
S#define IS_CMP_HYS(HYS) (((HYS) == CMP0_1_2HYS_0mV) || \
S                        ((HYS) == CMP0_1_2HYS_5mV)|| \
S                        ((HYS) == CMP0_1_2HYS_10mV)|| \
S                        ((HYS) == CMP0_1_2HYS_20mV)|| \
S                        ((HYS) == CMP3_HYS_0mV) || \
S                        ((HYS) == CMP3_HYS_5mV)|| \
S                        ((HYS) == CMP3_HYS_10mV)|| \
S                        ((HYS) == CMP3_HYS_20mV))
X#define IS_CMP_HYS(HYS) (((HYS) == CMP0_1_2HYS_0mV) ||                         ((HYS) == CMP0_1_2HYS_5mV)||                         ((HYS) == CMP0_1_2HYS_10mV)||                         ((HYS) == CMP0_1_2HYS_20mV)||                         ((HYS) == CMP3_HYS_0mV) ||                         ((HYS) == CMP3_HYS_5mV)||                         ((HYS) == CMP3_HYS_10mV)||                         ((HYS) == CMP3_HYS_20mV))
S/**
S * @}
S */
S/** @defgroup CMP_IT CMP Interrupt
S * @{
S */
Stypedef enum
S{
S    CMP0_1_2IT_INT    = (uint8_t) CMP_IDE_INTEN,      /*!< CMP0_1_2 Interrupt: CMP0_1_2 Interrupt */
S    CMP0_1_2IT_CMP0   = (uint8_t)CMP_IDE_CMP0IE,   /*!< CMP0 Interrupt: CMP0 Interrupt */
S    CMP0_1_2IT_CMP1   = (uint8_t)CMP_IDE_CMP1IE,   /*!< CMP1 Interrupt: CMP1  Interrupt */
S    CMP0_1_2IT_CMP2   = (uint8_t)CMP_IDE_CMP2IE,   /*!< CMP2 Interrupt: CMP2 Interrupt */
S    CMP3_IT_INT    = (uint8_t)CMP_IDE_INTEN,        /*!< CMP3 Interrupt: CMP3 Interrupt */
S} CMP_IT_TypeDef;
S
S#define IS_CMP_IT(IT) (((IT) == CMP0_1_2IT_INT) || \
S                       ((IT) == CMP0_1_2IT_CMP0) || \
S                       ((IT) == CMP0_1_2IT_CMP1) || \
S                       ((IT) == CMP0_1_2IT_CMP2) || \
S                       ((IT) == CMP3_IT_INT))
X#define IS_CMP_IT(IT) (((IT) == CMP0_1_2IT_INT) ||                        ((IT) == CMP0_1_2IT_CMP0) ||                        ((IT) == CMP0_1_2IT_CMP1) ||                        ((IT) == CMP0_1_2IT_CMP2) ||                        ((IT) == CMP3_IT_INT))
S/**
S * @}
S */
S
S/** @defgroup CMP_FLAG CMP Flag
S * @{
S */
Stypedef enum
S{
S    CMP_FLAG_CMP0    = (uint8_t)CMP_STS_CMP0IF,     /*!< CMP0 Flag: CMP0 flag */
S    CMP_FLAG_CMP1    = (uint8_t)CMP_STS_CMP1IF,     /*!< CMP1 Flag: CMP1 flag */
S    CMP_FLAG_CMP2    = (uint8_t)CMP_STS_CMP2IF,     /*!< CMP2 Flag: CMP2 flag */
S    CMP_FLAG_CMP3    = (uint8_t)CMP_STS_CMP3IF,     /*!< CMP  Flag: Interrupt flag */
S
S} CMP_FLAG_TypeDef;
S
S#define IS_CMP_FLAG(FLAG) (((FLAG) == CMP_FLAG_CMP0) ||\
S                            ((FLAG) == CMP_FLAG_CMP1)||\
S                            ((FLAG) == CMP_FLAG_CMP2)||\
S                            ((FLAG) == CMP_FLAG_CMP3))
X#define IS_CMP_FLAG(FLAG) (((FLAG) == CMP_FLAG_CMP0) ||                            ((FLAG) == CMP_FLAG_CMP1)||                            ((FLAG) == CMP_FLAG_CMP2)||                            ((FLAG) == CMP_FLAG_CMP3))
S/** @defgroup CMP_CMPSTA CMP CMPSTA
S * @{
S */
Stypedef enum
S{
S  CMP_CMP0STA_Low		= (uint32_t)(0x00 << CMP_STS_CMP0STA_Pos), /*!<  The non-inverting input is at a lower voltage than the inverting input */
S  CMP_CMP0STA_High		= (uint32_t)(0x01 << CMP_STS_CMP0STA_Pos), /*!<The non-inverting input is at a higher voltage than the inverting input */
S  CMP_CMP1STA_Low		= (uint32_t)(0x00 << CMP_STS_CMP1STA_Pos), /*!<The non-inverting input is at a lower voltage than the inverting input */
S  CMP_CMP1STA_High		= (uint32_t)(0x01 << CMP_STS_CMP1STA_Pos), /*!<The non-inverting input is at a higher voltage than the inverting input */
S  CMP_CMP2STA_Low		= (uint32_t)(0x00 << CMP_STS_CMP2STA_Pos), /*!< The non-inverting input is at a lower voltage than the inverting input */
S  CMP_CMP2STA_High		= (uint32_t)(0x01 << CMP_STS_CMP2STA_Pos), /*!<The non-inverting input is at a higher voltage than the inverting input */
S  CMP_CMP3STA_Low		= (uint32_t)(0x00 << CMP_STS_CMP3STA_Pos), /*!< CMP3 positive terminal voltage is less than the negative terminal voltage */
S  CMP_CMP3STA_High		= (uint32_t)(0x01 << CMP_STS_CMP3STA_Pos), /*!<  The positive terminal voltage of CMP3 is greater than the negative terminal voltage */
S} CMP_CMPSTA_TypeDef;
S
S#define IS_CMP_CMPSTA(STA) (((STA) == CMP_CMP0STA_Low) || \
S                           ((STA) == CMP_CMP0STA_High) || \
S                           ((STA) == CMP_CMP1STA_Low) || \
S                           ((STA) == CMP_CMP1STA_High)|| \
S                           ((STA) == CMP_CMP2STA_Low) || \
S                           ((STA) == CMP_CMP2STA_High)|| \
S                           ((STA) == CMP_CMP3STA_Low) || \
S                           ((STA) == CMP_CMP3STA_High))
X#define IS_CMP_CMPSTA(STA) (((STA) == CMP_CMP0STA_Low) ||                            ((STA) == CMP_CMP0STA_High) ||                            ((STA) == CMP_CMP1STA_Low) ||                            ((STA) == CMP_CMP1STA_High)||                            ((STA) == CMP_CMP2STA_Low) ||                            ((STA) == CMP_CMP2STA_High)||                            ((STA) == CMP_CMP3STA_Low) ||                            ((STA) == CMP_CMP3STA_High))
N#endif
N/**
N * @}
N */
N
N
N
N/**
N * @}
N */
N
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N/* End of enumerations -----------------------------------------------------*/
N
N
N#if defined(SC32f10xx)||defined(SC32f11xx)||defined(SC32f12xx)
X#if 1L||0L||0L
N#define IS_CMP_ALL_PERIPH(PERIPH) ((PERIPH) == CMP)
N#elif defined(SC32f15xx)
S#define IS_CMP_ALL_PERIPH(PERIPH) (((PERIPH) == CMP_0) ||\
S                                   ((PERIPH) == CMP_1) ||\
S                                   ((PERIPH) == CMP_2) ||\
S                                   ((PERIPH) == CMP3))
X#define IS_CMP_ALL_PERIPH(PERIPH) (((PERIPH) == CMP_0) ||                                   ((PERIPH) == CMP_1) ||                                   ((PERIPH) == CMP_2) ||                                   ((PERIPH) == CMP3))
N#endif																	 
N/**
N * @}
N */
N/* End of constants -----------------------------------------------------*/
N
N/** @defgroup CMP_Exported_Struct CMP Exported Struct
N * @{
N */
N
N/** @brief CMP Time base Configuration Structure definition
N * @{
N */
N #if defined(SC32f10xx)||defined(SC32f11xx)||defined(SC32f12xx)
X #if 1L||0L||0L
Ntypedef struct
N{
N    uint16_t CMP_Negative;   /*!< This member configures CMP NEGATIVE.
N                                              This parameter can be a value of @ref CMP_Negative_TypeDef. */
N
N    uint16_t CMP_Positive; /*!< This member configures CMP POSITIVE.
N                                              This parameter can be a value of @ref CMP_Positive_TypeDef. */
N
N    uint16_t CMP_TriggerMode; /*!< This member configures CMPTRIGGER.
N                                              This parameter can be a value of @ref CMP_TriggerMode_TypeDef. */
N
N} CMP_InitTypeDef;
N#elif defined(SC32f15xx)
S/** @defgroup CMP  base Configuration Structure definition
S * @{
S */
Stypedef struct
S{
S    uint16_t CMP_Negative;   /*!< This member configures CMP NEGATIVE.
S                                              This parameter can be a value of @ref CMP_Negative_TypeDef. */
S
S    uint16_t CMP_Positive; /*!< This member configures CMP POSITIVE.
S                                              This parameter can be a value of @ref CMP_Positive_TypeDef. */
S
S    uint16_t CMP_VREF; /*!< This member configures CMP VREF.
S                                              This parameter can be a value of @ref CMP_VREF_TypeDef. */
S
S    uint16_t CMP_CMPRF; /*!< This member configures CMP CMPRF.
S                                              This parameter can be a value of @ref CMP_CMPRF_TypeDef. */
S
S    uint16_t CMP_TriggerMode; /*!< This member configures TriggerMode.
S                                              This parameter can be a value of @ref CMP_TriggerMode_TypeDef. */
S
S    uint16_t CMP_HYS; /*!< This member configures CMP HYS.
S                                              This parameter can be a value of @ref CMP_HYS_TypeDef. */
S} CMP_InitTypeDef;
N#endif
N/**
N * @}
N */
N
N/**
N * @}
N */
N/* End of enumerations -----------------------------------------------------*/
N
N/** @addtogroup CMP_Functions CMP Functions
N * @{
N */
N/* CMP Base functions ********************************************************/
Nvoid CMP_DeInit ( CMP_TypeDef* CMPx );
Nvoid CMP_Init ( CMP_TypeDef* CMPx, CMP_InitTypeDef* CMP_InitStruct );
Nvoid CMP_StructInit ( CMP_InitTypeDef* CMP_InitStruct );
Nvoid CMP_Cmd ( CMP_TypeDef* CMPx, FunctionalState NewState );
Nvoid CMP_SetNegativeChannel ( CMP_TypeDef* CMPx, CMP_Negative_TypeDef CMP_Negative_Channel );
NCMP_Negative_TypeDef CMP_GetNegativeChannel ( CMP_TypeDef* CMPx );
Nvoid CMP_SetPositiveChannel ( CMP_TypeDef* CMPx, CMP_Positive_TypeDef CMP_Positive_Channel );
NCMP_Positive_TypeDef CMP_GetPositiveChannel ( CMP_TypeDef* CMPx );
N/* Interrupts and flags management functions  **********************************************/
NCMP_CMPSTA_TypeDef CMP_GetCMPSTA ( CMP_TypeDef* CMPx );
NFlagStatus CMP_GetFlagStatus ( CMP_TypeDef* CMPx, CMP_FLAG_TypeDef CMP_FLAG );
Nvoid CMP_ClearFlag ( CMP_TypeDef* CMPx, CMP_FLAG_TypeDef CMP_FLAG );
N#if  defined(SC32f15xx)
X#if  0L
Svoid CMP_NegativeSelection(CMP_TypeDef* CMPx, CMP_NegativeSelect_TypeDef NegativeSelect);
SCMP_NegativeSelect_TypeDef CMP_GetNegativeSelection(CMP_TypeDef* CMPx);
Svoid CMP_ITConfig(CMP_TypeDef* CMPx, uint16_t CMP_IT, FunctionalState NewState);
N#endif
N/**
N * @}
N */
N/* End of functions --------------------------------------------------*/
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 33 "..\FWLib\SC32F1XXX_Lib\inc\sc32_conf.h" 2
N#include "sc32f1xxx_option.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx_option.h" 1
N/**
N ******************************************************************************
N * @file    sc32f1xxx_option.h
N * @author  SOC AE Team
N * @version V1.6
N * @date     04-09-2024
N * @brief   Header file of OPTION module.
N ******************************************************************************
N * @attention
N *
N *1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only
N *intended for use with SinOne products. No other uses are authorized. This
N *software is owned by SinOne Microelectronics Co.,Ltd. and is protected under
N *all applicable laws, including copyright laws.
N *2.The software which is for guidance only aims at providing customers with
N *coding information regarding their products in order for them to save time.
N *As a result, SinOne shall not be held liable for any direct, indirect or
N *consequential damages with respect to any claims arising from the content of
N *such software and/or the use made by customers of the coding information
N *contained herein in connection with their products.
N *
N *  COPYRIGHT 2024 SinOne Microelectronics
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __sc32f1xxx_OPTION_H
N#define __sc32f1xxx_OPTION_H
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "sc32f1xxx.h"
N#include "SC32.h"
N
N/** @addtogroup sc32f1xxx_StdPeriph_Driver
N * @{
N */
N
N/** @addtogroup OPTION
N * @{
N */
N
N/** @defgroup OPTION_Enumerations OPTION Enumerations
N * @{
N */
N
N/** @brief OPTION_LVR  LVR stalls
N * @{
N */
N
Ntypedef enum
N{
N    OPTION_LVR_DISABLE = ( uint8_t ) 0x04, /*!< LVR Reset: disable */
N    OPTION_LVR_1_9V    = ( uint8_t ) 0x00, /*!< LVR Reset: 1.9V */
N    OPTION_LVR_2_9V    = ( uint8_t ) 0x01, /*!< LVR Reset: 2.9V */
N    OPTION_LVR_3_7V    = ( uint8_t ) 0x02, /*!< LVR Reset: 3.7V */
N    OPTION_LVR_4_3V    = ( uint8_t ) 0x03, /*!< LVR Reset: 4.3V */
N} OPTION_LVR_TypeDef;
N
N#define IS_OPTION_LVR(LVR) (((LVR) == OPTION_LVR_DISABLE) ||  \
N                            ((LVR) == OPTION_LVR_1_9V) ||  \
N                            ((LVR) == OPTION_LVR_2_9V) ||  \
N                            ((LVR) == OPTION_LVR_3_7V) ||  \
N                            ((LVR) == OPTION_LVR_4_3V))
X#define IS_OPTION_LVR(LVR) (((LVR) == OPTION_LVR_DISABLE) ||                              ((LVR) == OPTION_LVR_1_9V) ||                              ((LVR) == OPTION_LVR_2_9V) ||                              ((LVR) == OPTION_LVR_3_7V) ||                              ((LVR) == OPTION_LVR_4_3V))
N
N/**
N * @}
N */
N/* End of enumerations -----------------------------------------------------*/
N
N/** @addtogroup OPTION_Functions OPTION Functions
N * @{
N */
N
N/* option configuration ********************************************************/
Nvoid OPTION_WDTCmd ( FunctionalState NewState );
Nvoid OPTION_LVRConfig (OPTION_LVR_TypeDef OPTION_LVR );
Nvoid OPTION_JTAGCmd ( FunctionalState NewState );
Nvoid OPTION_IAPPORA ( uint16_t IAPPROAST, uint16_t IAPPROAED );
Nvoid OPTION_IAPPORB ( uint16_t IAPPROBST, uint16_t IAPPROBED );
N/**
N * @}
N */
N
N/* End of exported functions --------------------------------------------------*/
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 34 "..\FWLib\SC32F1XXX_Lib\inc\sc32_conf.h" 2
N#include "sc32f1xxx_int.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx_int.h" 1
N/**
N ******************************************************************************
N * @file    sc32f1xxx_int.h
N * @author  SOC AE Team
N * @version V1.6
N * @date     04-09-2024
N * @brief   Header file of INT module.
N ******************************************************************************
N * @attention
N *
N *1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only
N *intended for use with SinOne products. No other uses are authorized. This
N *software is owned by SinOne Microelectronics Co.,Ltd. and is protected under
N *all applicable laws, including copyright laws.
N *2.The software which is for guidance only aims at providing customers with
N *coding information regarding their products in order for them to save time.
N *As a result, SinOne shall not be held liable for any direct, indirect or
N *consequential damages with respect to any claims arising from the content of
N *such software and/or the use made by customers of the coding information
N *contained herein in connection with their products.
N *
N *  COPYRIGHT 2024 SinOne Microelectronics
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __sc32f1xxx_INT_H
N#define __sc32f1xxx_INT_H
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "sc32f1xxx.h"
N#include "sc32.h"
N#include "sc32f1xxx_rcc.h"
N
N/** @addtogroup sc32f1xxx_StdPeriph_Driver
N * @{
N */
N
N/** @brief INT_Channel INT Int Select
N * @{
N */
Ntypedef enum
N{
N    INT_Channel_0  = 0x00000001U,   /*!< Int Select: Px0    */
N    INT_Channel_1  = 0x00000002U,   /*!< Int Select: Px1    */
N    INT_Channel_2  = 0x00000004U,   /*!< Int Select: Px2    */
N    INT_Channel_3  = 0x00000008U,   /*!< Int Select: Px3    */
N    INT_Channel_4  = 0x00000010U,   /*!< Int Select: Px4    */
N    INT_Channel_5  = 0x00000020U,   /*!< Int Select: Px5    */
N    INT_Channel_6  = 0x00000040U,   /*!< Int Select: Px6    */
N    INT_Channel_7  = 0x00000080U,   /*!< Int Select: Px7    */
N    INT_Channel_8  = 0x00000100U,   /*!< Int Select: Px8    */
N    INT_Channel_9  = 0x00000200U,   /*!< Int Select: Px9    */
N    INT_Channel_10 = 0x00000400U,   /*!< Int Select: Px10    */
N    INT_Channel_11 = 0x00000800U,   /*!< Int Select: Px11    */
N    INT_Channel_12 = 0x00001000U,   /*!< Int Select: Px12    */
N    INT_Channel_13 = 0x00002000U,   /*!< Int Select: Px13    */
N    INT_Channel_14 = 0x00004000U,   /*!< Int Select: Px14    */
N    INT_Channel_15 = 0x00008000U,   /*!< Int Select: Px15    */
N} INT_Channel_Typedef;
N
N#define IS_INT_CHANNEL(CHANNEL) (((CHANNEL) == INT_Channel_0) || \
N                                  ((CHANNEL) == INT_Channel_1) || \
N                                  ((CHANNEL) == INT_Channel_2) || \
N                                  ((CHANNEL) == INT_Channel_3) || \
N                                  ((CHANNEL) == INT_Channel_4) || \
N                                  ((CHANNEL) == INT_Channel_5) || \
N                                  ((CHANNEL) == INT_Channel_6) || \
N                                  ((CHANNEL) == INT_Channel_7) || \
N                                  ((CHANNEL) == INT_Channel_8) || \
N                                  ((CHANNEL) == INT_Channel_9) || \
N                                  ((CHANNEL) == INT_Channel_10) || \
N                                  ((CHANNEL) == INT_Channel_11) || \
N                                  ((CHANNEL) == INT_Channel_12) || \
N                                  ((CHANNEL) == INT_Channel_13) || \
N                                  ((CHANNEL) == INT_Channel_14) || \
N                                  ((CHANNEL) == INT_Channel_15))
X#define IS_INT_CHANNEL(CHANNEL) (((CHANNEL) == INT_Channel_0) ||                                   ((CHANNEL) == INT_Channel_1) ||                                   ((CHANNEL) == INT_Channel_2) ||                                   ((CHANNEL) == INT_Channel_3) ||                                   ((CHANNEL) == INT_Channel_4) ||                                   ((CHANNEL) == INT_Channel_5) ||                                   ((CHANNEL) == INT_Channel_6) ||                                   ((CHANNEL) == INT_Channel_7) ||                                   ((CHANNEL) == INT_Channel_8) ||                                   ((CHANNEL) == INT_Channel_9) ||                                   ((CHANNEL) == INT_Channel_10) ||                                   ((CHANNEL) == INT_Channel_11) ||                                   ((CHANNEL) == INT_Channel_12) ||                                   ((CHANNEL) == INT_Channel_13) ||                                   ((CHANNEL) == INT_Channel_14) ||                                   ((CHANNEL) == INT_Channel_15))
N/**
N * @}
N */
N
N#define IS_INT_MODE(MODE) (((MODE) == INT_Mode_Interrupt) || ((MODE) == INT_Mode_Event))
N
N#if defined(SC32f10xx) || defined(SC32f12xx) || defined(SC32f15xx)
X#if 1L || 0L || 0L
N/** @brief INT_INTSEL INT INTSEL
N * @{
N */
Ntypedef enum
N{
N    INT_INTSEL_PA = 0x00000000U,   /*!< Int Select: PA    */
N    INT_INTSEL_PB = 0x00000001U,   /*!< Int Select: PB    */
N    INT_INTSEL_PC = 0x00000002U,   /*!< Int Select: PC    */
N} INT_INTSEL_Typedef;
N
N#define IS_INT_INTSEL(INTSEL) (((INTSEL) == INT_INTSEL_PA) || \
N                               ((INTSEL) == INT_INTSEL_PB) || \
N                               ((INTSEL) == INT_INTSEL_PC))
X#define IS_INT_INTSEL(INTSEL) (((INTSEL) == INT_INTSEL_PA) ||                                ((INTSEL) == INT_INTSEL_PB) ||                                ((INTSEL) == INT_INTSEL_PC))
N#elif  defined(SC32f11xx)
Stypedef enum
S{
S    INT_INTSEL_PA = 0x00000000U,   /*!< Int Select: PA    */
S    INT_INTSEL_PB = 0x00000001U,   /*!< Int Select: PB    */
S    INT_INTSEL_PC = 0x00000002U,   /*!< Int Select: PC    */
S    INT_INTSEL_PD = 0x00000003U,   /*!< Int Select: PD    */
S} INT_INTSEL_Typedef;
S
S#define IS_INT_INTSEL(INTSEL) (((INTSEL) == INT_INTSEL_PA) || \
S                               ((INTSEL) == INT_INTSEL_PB) || \
S                               ((INTSEL) == INT_INTSEL_PC) || \
S                               ((INTSEL) == INT_INTSEL_PD))
X#define IS_INT_INTSEL(INTSEL) (((INTSEL) == INT_INTSEL_PA) ||                                ((INTSEL) == INT_INTSEL_PB) ||                                ((INTSEL) == INT_INTSEL_PC) ||                                ((INTSEL) == INT_INTSEL_PD))
N#endif
N/**
N * @}
N */
N
N/** @brief INT_Trigger INT Trigger
N * @{
N */
Ntypedef enum
N{
N    INT_Trigger_Null           = ( uint16_t ) 0x00,		/*!< INT Interrupt: Null */
N    INT_Trigger_Rising         = ( uint16_t ) 0x01, /*!< INT Interrupt: Rising edge capture */
N    INT_Trigger_Falling        = ( uint16_t ) 0x02, /*!< INT Interrupt: Falling edge capture */
N    INT_Trigger_Rising_Falling = ( uint16_t ) 0x03,		/*!< INT Interrupt: Rising and Falling edge capture */
N} INT_Trigger_TypeDef;
N
N#define IS_INT_TRIGGER(TRIGGER)	(((TRIGGER) == INT_Trigger_Null) || \
N																 ((TRIGGER) == INT_Trigger_Rising) || \
N																 ((TRIGGER) == INT_Trigger_Rising) || \
N																 ((TRIGGER) == INT_Trigger_Rising_Falling))
X#define IS_INT_TRIGGER(TRIGGER)	(((TRIGGER) == INT_Trigger_Null) || 																 ((TRIGGER) == INT_Trigger_Rising) || 																 ((TRIGGER) == INT_Trigger_Rising) || 																 ((TRIGGER) == INT_Trigger_Rising_Falling))
N/**
N * @}
N */
N
N/** @brief INT_IT INT Interrupt
N * @{
N */
Ntypedef enum
N{
N    INT_IT_Rising         = ( uint16_t ) 0x01, /*!< INT Interrupt: Rising edge capture */
N    INT_IT_Falling        = ( uint16_t ) 0x02, /*!< INT Interrupt: Falling edge capture */
N} INT_IT_TypeDef;
N
N#define IS_INT_IT(IT)	(((IT) == INT_IT_Null) || \
N											 ((IT) == INT_IT_Rising) || \
N											 ((IT) == INT_IT_Rising) || \
N											 ((IT) == INT_IT_Rising_Falling))
X#define IS_INT_IT(IT)	(((IT) == INT_IT_Null) || 											 ((IT) == INT_IT_Rising) || 											 ((IT) == INT_IT_Rising) || 											 ((IT) == INT_IT_Rising_Falling))
N/**
N * @}
N */
N
N/** @brief INT_Flag INT Flag
N * @{
N */
Ntypedef enum
N{
N    INT_Flag_Rising = ( uint16_t ) 0x01, /*!< INT Flag: INT overflow */
N    INT_Flag_Falling = ( uint16_t ) 0x02, /*!< INT Flag: Immediate mode */
N} INT_Flag_TypeDef;
N
N#define IS_INT_FLAG(FLAG) (((FLAG) == INT_Flag_Rising) ||  \
N                           ((FLAG) == INT_Flag_Falling))
X#define IS_INT_FLAG(FLAG) (((FLAG) == INT_Flag_Rising) ||                             ((FLAG) == INT_Flag_Falling))
N/**
N * @}
N */
N
N/**
N * @}
N */
N/* End of enumerations -----------------------------------------------------*/
N
N/** @brief INT_InitTypeDef
N * @{
N */
N
N
N
Ntypedef struct
N{
N    uint16_t INT_Channel; /*!<  Specifies the INT channel.
N																					This parameter can be a value of @ref INT_ClockDivision */
N
N    uint16_t INT_Trigger; /*!< Specifies the external interrupt triggering mode.
N                                         This parameter can be a value of @ref INT_Trigger_TypeDef */
N
N    uint16_t INT_INTSEL;	/*!< Specifies the external interrupt port.
N                                         This parameter can be a value of @ref INT_INTSEL_Typedef */
N
N} INT_InitTypeDef;
N/**
N * @}
N */
N
N/**
N * @}
N */
N/* End of Struct --------------------------------------------------*/
N
N/** @addtogroup INT_Functions INT Functions
N * @{
N */
N
N/* Initialization and Configuration functions********************************************************/
Nvoid INT_DeInit ( void );
Nvoid INT_Init ( INT_InitTypeDef* INT_InitStruct );
Nvoid INT_TriggerMode ( INT_Channel_Typedef INT_Channel, INT_Trigger_TypeDef Trigger_Mode );
N
N/* Interrupts and flags management functions ***********************************************/
Nvoid INT_ITConfig ( uint16_t INT_Channel, uint16_t INT_IT, FunctionalState NewState );
NFlagStatus INT_GetFlagStatus ( INT_Channel_Typedef INT_Channel, INT_Flag_TypeDef INT_Flag );
Nvoid INT_ClearFlag ( uint32_t INT_Channel );
N
N/**
N * @}
N */
N/* End of functions --------------------------------------------------*/
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 35 "..\FWLib\SC32F1XXX_Lib\inc\sc32_conf.h" 2
N#include "sc32f1xxx_uart.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx_uart.h" 1
N/**
N ******************************************************************************
N * @file    SC32f10xx_uart.h
N * @author  SOC AE Team
N * @version V1.6
N * @date    04-09-2024
N * @brief   Header file of UART module.
N ******************************************************************************
N * @attention
N *
N *1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only
N *intended for use with SinOne products. No other uses are authorized. This
N *software is owned by SinOne Microelectronics Co.,Ltd. and is protected under
N *all applicable laws, including copyright laws.
N *2.The software which is for guidance only aims at providing customers with
N *coding information regarding their products in order for them to save time.
N *As a result, SinOne shall not be held liable for any direct, indirect or
N *consequential damages with respect to any claims arising from the content of
N *such software and/or the use made by customers of the coding information
N *contained herein in connection with their products.
N *
N *  COPYRIGHT 2024 SinOne Microelectronics
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __sc32f1xxx_UART_H
N#define __sc32f1xxx_UART_H
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "sc32f1xxx.h"
N#include "sc32.h"
N#include "sc32f1xxx_rcc.h"
N#include "stdio.h"
L 1 "D:\keil\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060044
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 39 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx_uart.h" 2
N/** @addtogroup SC32f10xx_StdPeriph_Driver
N * @{
N */
N
N/** @addtogroup UART
N * @{
N */
N
N/* Exported enumerations ------------------------------------------------------------*/
N/** @defgroup UART_Exported_Enumerations UART Exported Enumerations
N * @{
N */
N
N/** @brief UART_Prescaler UART Prescaler
N * @{
N */
Ntypedef enum
N{
N    UART_PRESCALER_12 = 0x00U << UART_CON_PERSCALER_Pos, /*!< Clock division: Fapb/12    */
X    UART_PRESCALER_12 = 0x00U << (4U),  
N    UART_PRESCALER_4 = 0x01U << UART_CON_PERSCALER_Pos,  /*!< Clock division: Fapb/4   */
X    UART_PRESCALER_4 = 0x01U << (4U),   
N} UART_Prescaler_TypeDef;
N
N#define IS_UART_PRESCALER(PRESCALER) (((PRESCALER) == UART_PRESCALER_12) || \
N                                      ((PRESCALER) == UART_PRESCALER_4))
X#define IS_UART_PRESCALER(PRESCALER) (((PRESCALER) == UART_PRESCALER_12) ||                                       ((PRESCALER) == UART_PRESCALER_4))
N/**
N * @}
N */
N
N/** @brief UART_Mode UART Mode
N * @{
N */
Ntypedef enum
N{
N    UART_Mode_8B = ( uint32_t ) ( 0X00U << UART_CON_SM01_Pos ), /*!< UART Mode:8-bit half duplex    */
X    UART_Mode_8B = ( uint32_t ) ( 0X00U << (0U) ),  
N    UART_Mode_10B = ( uint32_t ) ( 0X01U << UART_CON_SM01_Pos ), /*!< UART Mode:10-bit full duplex    */
X    UART_Mode_10B = ( uint32_t ) ( 0X01U << (0U) ),  
N    UART_Mode_11B = ( uint32_t ) ( 0X03U << UART_CON_SM01_Pos ), /*!< UART Mode:11-bit full duplex    */
X    UART_Mode_11B = ( uint32_t ) ( 0X03U << (0U) ),  
N} UART_Mode_Typedef;
N
N#define IS_UART_Mode(MODE) (((MODE) == UART_Mode_8B) ||  \
N                            ((MODE) == UART_Mode_10B) || \
N                            ((MODE) == UART_Mode_11B))
X#define IS_UART_Mode(MODE) (((MODE) == UART_Mode_8B) ||                              ((MODE) == UART_Mode_10B) ||                             ((MODE) == UART_Mode_11B))
N/**
N * @}
N */
N
N/** @brief UART_PinRemap TIM Pin Remap
N * @{
N */
Ntypedef enum
N{
N    UART_PinRemap_Default = ( uint32_t ) 0x00 << UART_CON_SPOS_Pos, /*!< TIM Pin Remap: Disable */
X    UART_PinRemap_Default = ( uint32_t ) 0x00 << (14U),  
N    UART_PinRemap_A       = ( uint32_t ) ( 0x01 << UART_CON_SPOS_Pos ), /*!< TIM Pin Remap: Remap mode A */
X    UART_PinRemap_A       = ( uint32_t ) ( 0x01 << (14U) ),  
N} UART_PinRemap_TypeDef;
N
N#define IS_UART_PINREMAP(PINREMAP) (((PINREMAP) == UART_PinRemap_Default) ||  \
N																    ((PINREMAP) == UART_PinRemap_Enable))
X#define IS_UART_PINREMAP(PINREMAP) (((PINREMAP) == UART_PinRemap_Default) ||  																    ((PINREMAP) == UART_PinRemap_Enable))
N/**
N * @}
N */
N
N/** @brief UART_Interrupt UART Interrupt
N * @{
N */
Ntypedef enum
N{
N    UART_IT_EN = ( uint8_t ) UART_IDE_INTEN, /*!< UART Interrupt: UART Interrupt */
X    UART_IT_EN = ( uint8_t ) (0x1L << (0U)),  
N    UART_IT_TX = ( uint8_t ) UART_IDE_TXIE, /*!< UART Interrupt: Transmit Interrupt */
X    UART_IT_TX = ( uint8_t ) (0x1L << (2U)),  
N    UART_IT_RX = ( uint8_t ) UART_IDE_RXIE, /*!< UART Interrupt: Receive Interrupt */
X    UART_IT_RX = ( uint8_t ) (0x1L << (1U)),  
N    UART_IT_WK = ( uint8_t ) UART_IDE_WKIE, /*!< UART Interrupt: Wake up Interrupt */
X    UART_IT_WK = ( uint8_t ) (0x1L << (4U)),  
N#if defined(SC32f11xx) ||  defined(SC32f12xx) || defined(SC32f15xx)
X#if 0L ||  0L || 0L
S    UART_IT_BK = ( uint16_t ) UART_IDE_BKIE, /*!< UART Interrupt: Break Interrupt */
S    UART_IT_SL = ( uint16_t ) UART_IDE_SLVHEIE, /*!< UART Interrupt: SLVHEIE Interrupt */
S    UART_IT_SY = ( uint16_t ) UART_IDE_SYNCIE, /*!< UART Interrupt: SVNCIE Interrupt */
N#endif
N} UART_IT_TypeDef;
N
N#define IS_UART_IT(IT) ((((IT) & (uint16_t)0xF4E0) == 0x0000) && ((IT) != 0x0000))
N/**
N * @}
N */
N
N/** @brief UART_Flag UART Flag
N * @{
N */
Ntypedef enum
N{
N    UART_Flag_RX = ( uint8_t ) UART_STS_RXIF, /*!< UART Flag: Receive flag */
X    UART_Flag_RX = ( uint8_t ) (0x1L << (0U)),  
N    UART_Flag_TX = ( uint8_t ) UART_STS_TXIF, /*!< UART Flag: Transmit flag */
X    UART_Flag_TX = ( uint8_t ) (0x1L << (1U)),  
N#if defined(SC32f11xx) || defined(SC32f12xx) || defined(SC32f15xx)
X#if 0L || 0L || 0L
S    UART_Flag_BK = ( uint16_t ) UART_STS_BKIF, /*!< UART Flag: Break flag */
S    UART_Flag_SY = ( uint16_t ) UART_STS_SYNCIF, /*!< UART Flag: SYNCIE flag */
S	  UART_Flag_SLVYN = (uint16_t)UART_STS_SLVSYNIF,/*!< UART Flag: SLVYN flag */
S		UART_Flag_SLVHE = (uint16_t)UART_STS_SLVHEIF,/*!< UART Flag: SLVHE flag */
N#endif
N} UART_FLAG_TypeDef;
N
N#define IS_UART_FLAG(FLAG) ((((FLAG) & (uint16_t)0xE4) == 0x00) && ((FLAG) != 0x00))
N
N#define IS_GET_UART_FLAG(FLAG) (((FLAG) == UART_Flag_RX) || \
N                                ((FLAG) == UART_Flag_TX) || \
N                                ((FLAG) == UART_Flag_BK) || \
N                                 ((FLAG) == UART_Flag_SLVYN) || \
N                                 ((FLAG) == UART_Flag_SLVHE) || \
N                                ((FLAG) == UART_Flag_SY))
X#define IS_GET_UART_FLAG(FLAG) (((FLAG) == UART_Flag_RX) ||                                 ((FLAG) == UART_Flag_TX) ||                                 ((FLAG) == UART_Flag_BK) ||                                  ((FLAG) == UART_Flag_SLVYN) ||                                  ((FLAG) == UART_Flag_SLVHE) ||                                 ((FLAG) == UART_Flag_SY))
N/**
N * @}
N */
N
N/** @brief UART_DMARequest UART DMA Request
N * @{
N */
Ntypedef enum
N{
N    UART_DMAReq_RX = ( uint8_t ) UART_IDE_RXDMAEN, /*!< UART DMA Request: Receive */
X    UART_DMAReq_RX = ( uint8_t ) (0x1L << (6U)),  
N    UART_DMAReq_TX = ( uint8_t ) UART_IDE_TXDMAEN, /*!< UART DMA Request: Transmit */
X    UART_DMAReq_TX = ( uint8_t ) (0x1L << (7U)),  
N} UART_DMAReq_TypeDef;
N
N#define IS_UART_DMAREQ(DMAREQ) ((((DMAREQ) & (uint8_t)0x3F) == 0x00) && ((DMAREQ) != 0x00))
N/**
N * @}
N */
N/** @brief UART_LINMODE UART LIN MODE
N * @{
N */
N#if defined(SC32f11xx) ||  defined(SC32f12xx)||defined(SC32f15xx)
X#if 0L ||  0L||0L
Stypedef enum
S{
S    UART_MASTER = ( uint32_t ) ( 0x00 << UART_CON_SLVEN_Pos | ( 0x01 << UART_CON_FUNCSEL_Pos ) ), /*!< UART_LINMODE: UART_MASTER */
S    UART_SLAVER = ( uint32_t ) ( 0x01 << UART_CON_SLVEN_Pos | ( 0x01 << UART_CON_FUNCSEL_Pos ) ), /*!< UART_LINMODE: UART_SLAVER*/
S} UART_LINMODE_TypeDef;
S
S#define IS_UART_LINMODE(LINMODE) (((LINMODE) == UART_MASTER) ||  \
S																    ((LINMODE) == UART_SLAVER))
X#define IS_UART_LINMODE(LINMODE) (((LINMODE) == UART_MASTER) ||  																    ((LINMODE) == UART_SLAVER))
S/**
S * @}
S */
S/** @brief UART_BKSIZE UART BKSIZE
S * @{
S */
Stypedef enum
S{
S    UART_BKSIZE_10 = ( uint32_t ) 0x00 << UART_CON_BKSIZE_Pos, /*!< UART_BKSIZE: UART_BKSIZE_10 */
S    UART_BKSIZE_13 = ( uint32_t ) ( 0x01 << UART_CON_BKSIZE_Pos ), /*!< UART_BKSIZE:UART_BKSIZE_13 */
S} UART_BKSIZE_TypeDef;
S
S#define IS_UART_BKSIZE(BKSIZE) (((BKSIZE) == UART_BKSIZE_10) ||  \
S																    ((BKSIZE) == UART_BKSIZE_13))
X#define IS_UART_BKSIZE(BKSIZE) (((BKSIZE) == UART_BKSIZE_10) ||  																    ((BKSIZE) == UART_BKSIZE_13))
S
S/** @brief UART_LBDL UART LBDL
S * @{
S */
Stypedef enum
S{
S    UART_LBDL_10 = ( uint32_t ) 0x00 << UART_CON_LBDL_Pos, /*!< UART_LBDL: UART_LBDL_10 */
S    UART_LBDL_11 = ( uint32_t ) ( 0x01 << UART_CON_LBDL_Pos ), /*!< UART_LBDL:UART_LBDL_11 */
S} UART_LBDL_TypeDef;
S
S#define IS_UART_LBDL(LBDL) (((LBDL) == UART_LBDL_10) ||  \
S																    ((LBDL) == UART_LBDL_11))
X#define IS_UART_LBDL(LBDL) (((LBDL) == UART_LBDL_10) ||  																    ((LBDL) == UART_LBDL_11))
N#endif
N/* End of enumerations -----------------------------------------------------*/
N
N/** @brief UART_Constants UART Constants
N  * @{
N  */
N#if defined(SC32f10xx)
X#if 1L
N#define IS_UART_ALL_PERIPH(PERIPH) (((PERIPH) == UART0) || \
N                                    ((PERIPH) == UART1) || \
N                                    ((PERIPH) == UART2) || \
N                                    ((PERIPH) == UART3))
X#define IS_UART_ALL_PERIPH(PERIPH) (((PERIPH) == UART0) ||                                     ((PERIPH) == UART1) ||                                     ((PERIPH) == UART2) ||                                     ((PERIPH) == UART3))
N#endif
N#if  defined(SC32f11xx) || defined(SC32f12xx)
X#if  0L || 0L
S#define IS_UART_ALL_PERIPH(PERIPH) (((PERIPH) == UART0) || \
S                                    ((PERIPH) == UART1) || \
S                                    ((PERIPH) == UART2) || \
S                                    ((PERIPH) == UART3) || \
S																		((PERIPH) == UART4) || \
S                                    ((PERIPH) == UART5))
X#define IS_UART_ALL_PERIPH(PERIPH) (((PERIPH) == UART0) ||                                     ((PERIPH) == UART1) ||                                     ((PERIPH) == UART2) ||                                     ((PERIPH) == UART3) || 																		((PERIPH) == UART4) ||                                     ((PERIPH) == UART5))
N#endif
N#if defined(SC32f15xx)
X#if 0L
S#define IS_UART_ALL_PERIPH(PERIPH) (((PERIPH) == UART0) || \
S                                    ((PERIPH) == UART1) || \
S                                    ((PERIPH) == UART2))
X#define IS_UART_ALL_PERIPH(PERIPH) (((PERIPH) == UART0) ||                                     ((PERIPH) == UART1) ||                                     ((PERIPH) == UART2))
N#endif
N#define IS_UART_DMA_PERIPH(PERIPH) (((PERIPH) == UART0) || \
N                                   ((PERIPH) == UART1))
X#define IS_UART_DMA_PERIPH(PERIPH) (((PERIPH) == UART0) ||                                    ((PERIPH) == UART1))
N#if defined(SC32f10xx)
X#if 1L
N#define IS_UART_REMAP_PERIPH(PERIPH) ((PERIPH) == UART2)
N#endif
N#if  defined(SC32f11xx) ||  defined(SC32f12xx)
X#if  0L ||  0L
S#define IS_UART_REMAP_PERIPH(PERIPH) ((PERIPH) == UART2 ) ||\
S                                      ((PERIPH) == UART1) ||\
S																			((PERIPH) == UART5))
X#define IS_UART_REMAP_PERIPH(PERIPH) ((PERIPH) == UART2 ) ||                                      ((PERIPH) == UART1) ||																			((PERIPH) == UART5))
N#endif
N#if  defined(SC32f15xx)
X#if  0L
S#define IS_UART_REMAP_PERIPH(PERIPH) ((PERIPH) == UART0 ) ||\
S                                      ((PERIPH) == UART1) ||\
S																			((PERIPH) == UART2))
X#define IS_UART_REMAP_PERIPH(PERIPH) ((PERIPH) == UART0 ) ||                                      ((PERIPH) == UART1) ||																			((PERIPH) == UART2))
N#endif
N/**
N * @}
N */
N/* End of constants -----------------------------------------------------*/
N
N
N/** @defgroup UART_Exported_Struct UART Exported Struct
N * @{
N */
N
N/** @brief UART Time base Configuration Structure definition
N * @{
N */
Ntypedef struct
N{
N    uint32_t UART_ClockFrequency; /*!<  Specifies the clock division.
N																				This parameter can be a value of @ref UART_ClockDivision */
N
N    uint32_t UART_BaudRate; /*!< This member configures the UART communication baud rate.
N											When UART_Mode is mode 0 This parameter can be a value of @ref UART_Prescaler_TypeDef. */
N
N    uint32_t UART_Mode; /*!< Specifies the counter dierction.
N																						This parameter can be a value of @ref UART_Mode_Typedef */
N} UART_InitTypeDef;
N/**
N * @}
N */
N#if    defined(SC32f11xx) ||defined(SC32f12xx)||defined(SC32f15xx)
X#if    0L ||0L||0L
S#define BIT(A,B)       ((A >> B) & 0x01)
N#endif
N#ifdef PrintfEable
S#define AvoidSemiHostEable 1
N#else
N#define AvoidSemiHostEable 0
N#endif
N
N/**
N * @}
N */
N/* End of exported enumerations -----------------------------------------------------*/
N
N/** @addtogroup UART_Functions UART Functions
N * @{
N */
N
N/* UART Base functions ********************************************************/
Nvoid UART_DeInit ( UART_TypeDef* UARTx );
Nvoid UART_Init ( UART_TypeDef* UARTx, UART_InitTypeDef* UART_InitStruct );
Nvoid UART_TXCmd ( UART_TypeDef* UARTx, FunctionalState NewState );
Nvoid UART_RXCmd ( UART_TypeDef* UARTx, FunctionalState NewState );
N
N/* Data transfers functions ********************************************************/
Nvoid UART_SendData ( UART_TypeDef* UARTx, uint16_t Data );
Nuint16_t UART_ReceiveData ( UART_TypeDef* UARTx );
N
N/* Pin remap management functions  **********************************************/
Nvoid UART_PinRemapConfig ( UART_TypeDef* UARTx, UART_PinRemap_TypeDef UART_Remap );
N
N/* Interrupts, DMA and flags management functions  **********************************************/
Nvoid UART_ITConfig ( UART_TypeDef* UARTx, uint16_t UART_IT, FunctionalState NewState );
NFlagStatus UART_GetFlagStatus ( UART_TypeDef* UARTx, UART_FLAG_TypeDef UART_FLAG );
Nvoid UART_ClearFlag ( UART_TypeDef* UARTx, uint16_t UART_FLAG );
Nvoid UART_DMACmd ( UART_TypeDef* UARTx, uint16_t UART_DMAReq, FunctionalState NewState );
N#if   defined(SC32f11xx) ||defined(SC32f12xx)
X#if   0L ||0L
Svoid UART_LIN_MODE ( UART_TypeDef* UARTx, UART_LINMODE_TypeDef UART_LINMODE );
Svoid UART_LIN_BKSIZE ( UART_TypeDef* UARTx, UART_BKSIZE_TypeDef BKSIZE );
Svoid UART_SendBreak ( void );
Svoid UART_LIN_SLVARENE ( UART_TypeDef* UARTx, FunctionalState NewState );
Svoid UART_LIN_LBDL ( UART_TypeDef* UARTx, UART_LBDL_TypeDef LBDL );
Suint8_t LIN_CalID ( uint8_t id );
Suint8_t LINCalChecksum ( uint8_t id, uint8_t *data, uint8_t len );
N#endif
N#if defined (PrintfEable)
X#if 0L
Svoid Printf_UartInit ( UART_TypeDef* UARTx );
S#if defined (__ARMCC_VERSION)||defined (__ICCARM__)
Sint fputc ( int c, FILE* f );
S#elif defined (__GNUC__)
Sint _write(int fd, char *pbuffer, int size)
S#endif
N#endif
N
N/**
N * @}
N */
N/* End of exported functions --------------------------------------------------*/
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 36 "..\FWLib\SC32F1XXX_Lib\inc\sc32_conf.h" 2
N#include "sc32f1xxx_spi.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx_spi.h" 1
N/**
N ******************************************************************************
N * @file    sc32f1xxx_spi.h
N * @author  SOC AE Team
N * @version V1.6
N * @date     04-09-2024
N * @brief   Header file of SPI module.
N ******************************************************************************
N * @attention
N *
N *1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only
N *intended for use with SinOne products. No other uses are authorized. This
N *software is owned by SinOne Microelectronics Co.,Ltd. and is protected under
N *all applicable laws, including copyright laws.
N *2.The software which is for guidance only aims at providing customers with
N *coding information regarding their products in order for them to save time.
N *As a result, SinOne shall not be held liable for any direct, indirect or
N *consequential damages with respect to any claims arising from the content of
N *such software and/or the use made by customers of the coding information
N *contained herein in connection with their products.
N *
N *  COPYRIGHT 2024 SinOne Microelectronics
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __sc32f1xxx_SPI_H
N#define __sc32f1xxx_SPI_H
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "sc32f1xxx.h"
N#include "sc32.h"
N#include "sc32f1xxx_rcc.h"
N#if !defined(SC32f15xx)
X#if !0L
N/** @addtogroup sc32f1xxx_StdPeriph_Driver
N * @{
N */
N
N/** @addtogroup SPI
N * @{
N */
N
N/** @defgroup SPI_Exported_Enumerations SPI Exported Enumerations
N * @{
N */
N
N/** @brief SPI_Mode SPI Mode
N * @{
N */
Ntypedef enum
N{
N    SPI_Mode_Slave = ( uint16_t ) ( 0X00U << SPI_CON_MSTR_Pos ), /*!< SPI Mode:Slave   */
X    SPI_Mode_Slave = ( uint16_t ) ( 0X00U << (0U) ),  
N    SPI_Mode_Master = ( uint16_t ) ( 0X01U << SPI_CON_MSTR_Pos ), /*!< SPI Mode:Master    */
X    SPI_Mode_Master = ( uint16_t ) ( 0X01U << (0U) ),  
N} SPI_Mode_TypeDef;
N
N#define IS_SPI_Mode(MODE)	(((MODE) == SPI_Mode_Master) ||  \
N													 ((MODE) == SPI_Mode_Slave))
X#define IS_SPI_Mode(MODE)	(((MODE) == SPI_Mode_Master) ||  													 ((MODE) == SPI_Mode_Slave))
N/**
N * @}
N */
N
N/** @brief SPI_DataSize SPI Data Size
N * @{
N */
Ntypedef enum
N{
N    SPI_DataSize_8B  = ( uint16_t ) ( 0X00U << SPI_CON_SPMD_Pos ), /*!< SPI Data Size:Set data frame format to 8bit    */
X    SPI_DataSize_8B  = ( uint16_t ) ( 0X00U << (1U) ),  
N    SPI_DataSize_16B = ( uint16_t ) ( 0X01U << SPI_CON_SPMD_Pos ), /*!< SPI Data Size:Set data frame format to 16bit   */
X    SPI_DataSize_16B = ( uint16_t ) ( 0X01U << (1U) ),  
N} SPI_DataSize_TypeDef;
N
N#define IS_SPI_DATASIZE(SIZE)	(((SIZE) == SPI_DataSize_8B) ||  \
N															 ((SIZE) == SPI_DataSize_16B))
X#define IS_SPI_DATASIZE(SIZE)	(((SIZE) == SPI_DataSize_8B) ||  															 ((SIZE) == SPI_DataSize_16B))
N/**
N * @}
N */
N
N/** @brief SPI_FirstBit SPI First Bit
N * @{
N */
Ntypedef enum
N{
N    SPI_FirstBit_MSB = ( uint16_t ) ( 0X00U << SPI_CON_DORD_Pos ), /*!< SPI First Bit:MSB    */
X    SPI_FirstBit_MSB = ( uint16_t ) ( 0X00U << (2U) ),  
N    SPI_FirstBit_LSB = ( uint16_t ) ( 0X01U << SPI_CON_DORD_Pos ), /*!< SPI First Bit:LSB    */
X    SPI_FirstBit_LSB = ( uint16_t ) ( 0X01U << (2U) ),  
N} SPI_FirstBit_TypeDef;
N
N#define IS_SPI_FIRSTBIT(BIT)	(((BIT) == SPI_FirstBit_MSB) ||  \
N															((BIT) == SPI_FirstBit_LSB))
X#define IS_SPI_FIRSTBIT(BIT)	(((BIT) == SPI_FirstBit_MSB) ||  															((BIT) == SPI_FirstBit_LSB))
N/**
N * @}
N */
N
N/** @brief SPI_CPHA_TypeDef SPI CPHA
N * @{
N */
Ntypedef enum
N{
N    SPI_CPHA_1Edge = ( uint16_t ) ( 0X00U << SPI_CON_CPHA_Pos ), /*!< SPI Clock Phase:The first edge signal is triggered   */
X    SPI_CPHA_1Edge = ( uint16_t ) ( 0X00U << (3U) ),  
N    SPI_CPHA_2Edge = ( uint16_t ) ( 0X01U << SPI_CON_CPHA_Pos ), /*!< SPI Clock Phase:The second edge signal is triggered    */
X    SPI_CPHA_2Edge = ( uint16_t ) ( 0X01U << (3U) ),  
N} SPI_CPHA_TypeDef;
N
N#define IS_SPI_CPHA(CPHA)	(((CPHA) == SPI_CPHA_1Edge) ||  \
N												   ((CPHA) == SPI_CPHA_2Edge))
X#define IS_SPI_CPHA(CPHA)	(((CPHA) == SPI_CPHA_1Edge) ||  												   ((CPHA) == SPI_CPHA_2Edge))
N/**
N * @}
N */
N
N/** @brief SPI_CPOL SPI CPOL
N * @{
N */
Ntypedef enum
N{
N    SPI_CPOL_Low  = ( uint16_t ) ( 0X00U << SPI_CON_CPOL_Pos ), /*!< SPI Clock Polarity:It is low in the idle state  */
X    SPI_CPOL_Low  = ( uint16_t ) ( 0X00U << (4U) ),  
N    SPI_CPOL_High = ( uint16_t ) ( 0X01U << SPI_CON_CPOL_Pos ), /*!< SPI Clock Polarity:It is high in the idle state    */
X    SPI_CPOL_High = ( uint16_t ) ( 0X01U << (4U) ),  
N} SPI_CPOL_TypeDef;
N
N#define IS_SPI_CPOL(CPOL)	(((CPOL) == SPI_CPOL_Low) ||  \
N													 ((CPOL) == SPI_CPOL_High))
X#define IS_SPI_CPOL(CPOL)	(((CPOL) == SPI_CPOL_Low) ||  													 ((CPOL) == SPI_CPOL_High))
N/**
N * @}
N */
N
N/** @brief SPI_Prescaler SPI Prescaler
N * @{
N */
Ntypedef enum
N{
N    SPI_Prescaler_1 = 0x00U << SPI_CON_SPR_Pos,    /*!< Clock division: Fsource/1    */
X    SPI_Prescaler_1 = 0x00U << (8U),     
N    SPI_Prescaler_2 = 0x01U << SPI_CON_SPR_Pos,    /*!< Clock division: Fsource/2    */
X    SPI_Prescaler_2 = 0x01U << (8U),     
N    SPI_Prescaler_4 = 0x02U << SPI_CON_SPR_Pos,    /*!< Clock division: Fsource/4    */
X    SPI_Prescaler_4 = 0x02U << (8U),     
N    SPI_Prescaler_8 = 0x03U << SPI_CON_SPR_Pos,    /*!< Clock division: Fsource/8    */
X    SPI_Prescaler_8 = 0x03U << (8U),     
N    SPI_Prescaler_16 = 0x04U << SPI_CON_SPR_Pos,   /*!< Clock division: Fsource/16    */
X    SPI_Prescaler_16 = 0x04U << (8U),    
N    SPI_Prescaler_32 = 0x05U << SPI_CON_SPR_Pos,   /*!< Clock division: Fsource/32    */
X    SPI_Prescaler_32 = 0x05U << (8U),    
N    SPI_Prescaler_64 = 0x06U << SPI_CON_SPR_Pos,   /*!< Clock division: Fsource/64    */
X    SPI_Prescaler_64 = 0x06U << (8U),    
N    SPI_Prescaler_128 = 0x07U << SPI_CON_SPR_Pos,  /*!< Clock division: Fsource/128    */
X    SPI_Prescaler_128 = 0x07U << (8U),   
N    SPI_Prescaler_256 = 0x08U << SPI_CON_SPR_Pos,  /*!< Clock division: Fsource/256    */
X    SPI_Prescaler_256 = 0x08U << (8U),   
N    SPI_Prescaler_512 = 0x09U << SPI_CON_SPR_Pos,  /*!< Clock division: Fsource/512    */
X    SPI_Prescaler_512 = 0x09U << (8U),   
N    SPI_Prescaler_1024 = 0x0AU << SPI_CON_SPR_Pos, /*!< Clock division: Fsource/1024    */
X    SPI_Prescaler_1024 = 0x0AU << (8U),  
N} SPI_Prescaler_TypeDef;
N
N#define IS_SPI_PRESCALER(PRESCALER) (((PRESCALER) == SPI_Prescaler_1) || \
N                                     ((PRESCALER) == SPI_Prescaler_2) || \
N                                     ((PRESCALER) == SPI_Prescaler_4) || \
N                                     ((PRESCALER) == SPI_Prescaler_8) || \
N                                     ((PRESCALER) == SPI_Prescaler_16) || \
N                                     ((PRESCALER) == SPI_Prescaler_32) || \
N                                     ((PRESCALER) == SPI_Prescaler_64) || \
N                                     ((PRESCALER) == SPI_Prescaler_128) || \
N                                     ((PRESCALER) == SPI_Prescaler_256) || \
N                                     ((PRESCALER) == SPI_Prescaler_512) || \
N                                     ((PRESCALER) == SPI_Prescaler_1024))
X#define IS_SPI_PRESCALER(PRESCALER) (((PRESCALER) == SPI_Prescaler_1) ||                                      ((PRESCALER) == SPI_Prescaler_2) ||                                      ((PRESCALER) == SPI_Prescaler_4) ||                                      ((PRESCALER) == SPI_Prescaler_8) ||                                      ((PRESCALER) == SPI_Prescaler_16) ||                                      ((PRESCALER) == SPI_Prescaler_32) ||                                      ((PRESCALER) == SPI_Prescaler_64) ||                                      ((PRESCALER) == SPI_Prescaler_128) ||                                      ((PRESCALER) == SPI_Prescaler_256) ||                                      ((PRESCALER) == SPI_Prescaler_512) ||                                      ((PRESCALER) == SPI_Prescaler_1024))
N
N/**
N * @}
N */
N
N/** @brief SPI_PinRemap TIM Pin Remap
N * @{
N */
N#if defined(SC32f10xx)
X#if 1L
Ntypedef enum
N{
N    SPI_PinRemap_Default = ( uint32_t ) ( 0x00 << SPI_CON_SPOS_Pos ), /*!< TIM Pin Remap: Disable */
X    SPI_PinRemap_Default = ( uint32_t ) ( 0x00 << (14U) ),  
N    SPI_PinRemap_A       = ( uint32_t ) ( 0x01 << SPI_CON_SPOS_Pos ), /*!< TIM Pin Remap: Remap mode A */
X    SPI_PinRemap_A       = ( uint32_t ) ( 0x01 << (14U) ),  
N    SPI_PinRemap_B       = ( uint32_t ) ( 0x02 << SPI_CON_SPOS_Pos ), /*!< TIM Pin Remap: Remap mode B */
X    SPI_PinRemap_B       = ( uint32_t ) ( 0x02 << (14U) ),  
N} SPI_PinRemap_TypeDef;
N
N#define IS_SPI_LIST1_PINREMAP(REMAP) (((REMAP) == SPI_PinRemap_Default) ||  \
N															      	((REMAP) == SPI_PinRemap_A)  ||  \
N																      ((REMAP) == SPI_PinRemap_B))
X#define IS_SPI_LIST1_PINREMAP(REMAP) (((REMAP) == SPI_PinRemap_Default) ||  															      	((REMAP) == SPI_PinRemap_A)  ||  																      ((REMAP) == SPI_PinRemap_B))
N
N#define IS_SPI_LIST2_PINREMAP(REMAP) (((REMAP) == SPI_PinRemap_Default) ||  \
N															      	((REMAP) == SPI_PinRemap_A))
X#define IS_SPI_LIST2_PINREMAP(REMAP) (((REMAP) == SPI_PinRemap_Default) ||  															      	((REMAP) == SPI_PinRemap_A))
N#elif  defined(SC32f11xx)||defined(SC32f12xx)
Stypedef enum
S{
S    SPI_PinRemap_Default = ( uint32_t ) ( 0x00 << SPI_CON_SPOS_Pos ), /*!< TIM Pin Remap: Disable */
S    SPI_PinRemap_A       = ( uint32_t ) ( 0x01 << SPI_CON_SPOS_Pos ), /*!< TIM Pin Remap: Remap mode A */
S    SPI_PinRemap_B       = ( uint32_t ) ( 0x02 << SPI_CON_SPOS_Pos ), /*!< TIM Pin Remap: Remap mode B */
S    SPI_PinRemap_C       = ( uint32_t ) ( 0x03 << SPI_CON_SPOS_Pos ), /*!< TIM Pin Remap: Remap mode C */
S} SPI_PinRemap_TypeDef;
S
S#define IS_SPI_LIST1_PINREMAP(REMAP) (((REMAP) == SPI_PinRemap_Default) ||  \
S															      	((REMAP) == SPI_PinRemap_A)  ||  \
S																      ((REMAP) == SPI_PinRemap_B)  ||  \
S                                      ((REMAP) == SPI_PinRemap_C))
X#define IS_SPI_LIST1_PINREMAP(REMAP) (((REMAP) == SPI_PinRemap_Default) ||  															      	((REMAP) == SPI_PinRemap_A)  ||  																      ((REMAP) == SPI_PinRemap_B)  ||                                        ((REMAP) == SPI_PinRemap_C))
S
S#define IS_SPI_LIST2_PINREMAP(REMAP) (((REMAP) == SPI_PinRemap_Default) ||  \
S															      	((REMAP) == SPI_PinRemap_A)  ||  \
S																      ((REMAP) == SPI_PinRemap_B)  ||  \
S                                      ((REMAP) == SPI_PinRemap_C))
X#define IS_SPI_LIST2_PINREMAP(REMAP) (((REMAP) == SPI_PinRemap_Default) ||  															      	((REMAP) == SPI_PinRemap_A)  ||  																      ((REMAP) == SPI_PinRemap_B)  ||                                        ((REMAP) == SPI_PinRemap_C))
N#endif
N/**
N * @}
N */
N
N/** @brief SPI_IT SPI Interrupt
N * @{
N */
Ntypedef enum
N{
N    SPI_IT_INTEN = ( uint32_t ) SPI_IDE_INTEN,	/*!< SPI Interrupt: SPI total interruption */
X    SPI_IT_INTEN = ( uint32_t ) (0x1L << (0U)),	 
N    SPI_IT_RXNE  = ( uint32_t ) SPI_IDE_RXNEIE,	/*!< SPI Interrupt: SPI RX buffer not empty Interrupt */
X    SPI_IT_RXNE  = ( uint32_t ) (0x1L << (1U)),	 
N    SPI_IT_TB    = ( uint32_t ) SPI_IDE_TBIE,  		/*!< SPI Interrupt: SPI TX buffer is empty Interrupt */
X    SPI_IT_TB    = ( uint32_t ) (0x1L << (2U)),  		 
N    SPI_IT_RX    = ( uint32_t ) SPI_IDE_RXIE,  		/*!< SPI Interrupt: Receiving FIFO overflow Interrupt */
X    SPI_IT_RX    = ( uint32_t ) (0x1L << (3U)),  		 
N    SPI_IT_RXH   = ( uint32_t ) SPI_IDE_RXHIE,  	/*!< SPI Interrupt: Receive FIFO over half Interrupt */
X    SPI_IT_RXH   = ( uint32_t ) (0x1L << (4U)),  	 
N    SPI_IT_TXH   = ( uint32_t ) SPI_IDE_TXHIE,  	/*!< SPI Interrupt: Transmit FIFO under half Interrupt */
X    SPI_IT_TXH   = ( uint32_t ) (0x1L << (5U)),  	 
N} SPI_IT_TypeDef;
N
N#define IS_SPI_IT(IT) (((IT) == SPI_IT_INTEN) || \
N                       ((IT) == SPI_IT_RXNE) || \
N                       ((IT) == SPI_IT_TB) || \
N                       ((IT) == SPI_IT_RX) || \
N											 ((IT) == SPI_IT_RXH) || \
N                       ((IT) == SPI_IT_TXH)|| \
N                       ((IT) == SPI_IT_TBIE))
X#define IS_SPI_IT(IT) (((IT) == SPI_IT_INTEN) ||                        ((IT) == SPI_IT_RXNE) ||                        ((IT) == SPI_IT_TB) ||                        ((IT) == SPI_IT_RX) || 											 ((IT) == SPI_IT_RXH) ||                        ((IT) == SPI_IT_TXH)||                        ((IT) == SPI_IT_TBIE))
N
N/**
N * @}
N */
N
N/** @brief SPI_FLAG SPI Flag
N * @{
N */
Ntypedef enum
N{
N    SPI_Flag_SPIF   = ( uint32_t ) SPI_STS_SPIF, /*!< SPI Flag: SPI transmit and receive flag */
X    SPI_Flag_SPIF   = ( uint32_t ) (0x1L << (0U)),  
N    SPI_Flag_RINEIF = ( uint32_t ) SPI_STS_RINEIF, /*!< SPI Flag: SPI RX buffer not empty flag */
X    SPI_Flag_RINEIF = ( uint32_t ) (0x1L << (1U)),  
N    SPI_Flag_TXEIF  = ( uint32_t ) SPI_STS_TXEIF, /*!< SPI Flag: TX buffer is empty flag */
X    SPI_Flag_TXEIF  = ( uint32_t ) (0x1L << (2U)),  
N    SPI_Flag_RXFIF  = ( uint32_t ) SPI_STS_RXFIF, /*!< SPI Flag: Receiving FIFO overflow flag */
X    SPI_Flag_RXFIF  = ( uint32_t ) (0x1L << (3U)),  
N    SPI_Flag_RXHIF  = ( uint32_t ) SPI_STS_RXHIF, /*!< SPI Flag: Receive FIFO over half flag */
X    SPI_Flag_RXHIF  = ( uint32_t ) (0x1L << (4U)),  
N    SPI_Flag_TXHIF  = ( uint32_t ) SPI_STS_TXHIF, /*!< SPI Flag: Transmit FIFO under half flag */
X    SPI_Flag_TXHIF  = ( uint32_t ) (0x1L << (5U)),  
N    SPI_Flag_WCOL   = ( uint32_t ) SPI_STS_WCOL, /*!< SPI Flag: Write conflict flag */
X    SPI_Flag_WCOL   = ( uint32_t ) (0x1L << (7U)),  
N
N} SPI_FLAG_TypeDef;
N
N#define IS_SPI_FLAG(FLAG) (((FLAG) == SPI_Flag_SPIF) || \
N                           ((FLAG) == SPI_Flag_RINEIF) || \
N                           ((FLAG) == SPI_Flag_TXEIF) || \
N                           ((FLAG) == SPI_Flag_RXFIF) || \
N                           ((FLAG) == SPI_Flag_RXHIF) || \
N                           ((FLAG) == SPI_Flag_TXHIF) || \
N                           ((FLAG) == SPI_Flag_WCOL))
X#define IS_SPI_FLAG(FLAG) (((FLAG) == SPI_Flag_SPIF) ||                            ((FLAG) == SPI_Flag_RINEIF) ||                            ((FLAG) == SPI_Flag_TXEIF) ||                            ((FLAG) == SPI_Flag_RXFIF) ||                            ((FLAG) == SPI_Flag_RXHIF) ||                            ((FLAG) == SPI_Flag_TXHIF) ||                            ((FLAG) == SPI_Flag_WCOL))
N
N/**
N * @}
N */
N
N/** @brief SPI_DMAReq SPI DMA Request
N * @{
N */
Ntypedef enum
N{
N    SPI_DMAReq_RX = ( uint32_t ) SPI_IDE_RXDMAEN, /*!< SPI DMA Request: Receive */
X    SPI_DMAReq_RX = ( uint32_t ) (0x1L << (6U)),  
N    SPI_DMAReq_TX = ( uint32_t ) SPI_IDE_TXDMAEN, /*!< SPI DMA Request: Transmit */
X    SPI_DMAReq_TX = ( uint32_t ) (0x1L << (7U)),  
N} SPI_DMAReq_TypeDef;
N
N#define IS_SPI_DMAREQ(DMAREQ) (((DMAREQ) == SPI_DMAReq_RX) || \
N                               ((DMAREQ) == SPI_DMAReq_TX))
X#define IS_SPI_DMAREQ(DMAREQ) (((DMAREQ) == SPI_DMAReq_RX) ||                                ((DMAREQ) == SPI_DMAReq_TX))
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/** @brief SPI_Constants SPI Constants
N  * @{
N  */
N#if defined(SC32f10xx)  ||defined(SC32f11xx)
X#if 1L  ||0L
N#define IS_SPI_ALL_PERIPH(PERIPH) (((PERIPH) == SPI0) || \
N                                   ((PERIPH) == SPI1))
X#define IS_SPI_ALL_PERIPH(PERIPH) (((PERIPH) == SPI0) ||                                    ((PERIPH) == SPI1))
N#elif defined(SC32f12xx)
S#define IS_SPI_ALL_PERIPH(PERIPH) (((PERIPH) == SPI0) || \
S                                   ((PERIPH) == SPI1) ||\
S                                   ((PERIPH) == SPI2)  )
X#define IS_SPI_ALL_PERIPH(PERIPH) (((PERIPH) == SPI0) ||                                    ((PERIPH) == SPI1) ||                                   ((PERIPH) == SPI2)  )
N#endif
N#else
S/** @defgroup SPI_Mode SPI Mode
S * @{
S */
Stypedef enum
S{
S  SPI_Mode_Slave = (uint16_t)(0X00U << SPI0_CON_MSTR_Pos), /*!< SPI Mode:Slave   */
S  SPI_Mode_Master = (uint16_t)(0X01U << SPI0_CON_MSTR_Pos),  /*!< SPI Mode:Master    */
S} SPI_Mode_TypeDef;
S
S#define IS_SPI_Mode(MODE)	(((MODE) == SPI_Mode_Master) ||  \
S													 ((MODE) == SPI_Mode_Slave))
X#define IS_SPI_Mode(MODE)	(((MODE) == SPI_Mode_Master) ||  													 ((MODE) == SPI_Mode_Slave))
S/**
S * @}
S */
S
S/** @defgroup SPI_DataSize SPI Data Size
S * @{
S */
Stypedef enum
S{
S  SPI_DataSize_8B  = (uint16_t)(0X00U << SPI0_CON_SPMD_Pos),  /*!< SPI Data Size:Set data frame format to 8bit    */
S  SPI_DataSize_16B = (uint16_t)(0X01U << SPI0_CON_SPMD_Pos),  /*!< SPI Data Size:Set data frame format to 16bit   */
S} SPI_DataSize_TypeDef;
S
S#define IS_SPI_DATASIZE(SIZE)	(((SIZE) == SPI_DataSize_8B) ||  \
S															 ((SIZE) == SPI_DataSize_16B))
X#define IS_SPI_DATASIZE(SIZE)	(((SIZE) == SPI_DataSize_8B) ||  															 ((SIZE) == SPI_DataSize_16B))
S/**
S * @}
S */
S
S/** @defgroup SPI0_FirstBit SPI First Bit
S * @{
S */
Stypedef enum
S{
S  SPI_FirstBit_MSB = (uint16_t)(0X00U << SPI0_CON_DORD_Pos),  /*!< SPI First Bit:MSB    */
S  SPI_FirstBit_LSB = (uint16_t)(0X01U << SPI0_CON_DORD_Pos), /*!< SPI First Bit:LSB    */
S} SPI_FirstBit_TypeDef;
S
S#define IS_SPI_FIRSTBIT(BIT)	(((BIT) == SPI_FirstBit_MSB) ||  \
S															((BIT) == SPI_FirstBit_LSB))
X#define IS_SPI_FIRSTBIT(BIT)	(((BIT) == SPI_FirstBit_MSB) ||  															((BIT) == SPI_FirstBit_LSB))
S/**
S * @}
S */
S
S/** @defgroup SPI_CPHA_TypeDef SPI CPHA
S * @{
S */
Stypedef enum
S{
S  SPI_CPHA_1Edge = (uint16_t)(0X00U << SPI0_CON_CPHA_Pos),  /*!< SPI Clock Phase:The first edge signal is triggered   */
S  SPI_CPHA_2Edge = (uint16_t)(0X01U << SPI0_CON_CPHA_Pos), /*!< SPI Clock Phase:The second edge signal is triggered    */
S} SPI_CPHA_TypeDef;
S
S#define IS_SPI_CPHA(CPHA)	(((CPHA) == SPI_CPHA_1Edge) ||  \
S												   ((CPHA) == SPI_CPHA_2Edge))
X#define IS_SPI_CPHA(CPHA)	(((CPHA) == SPI_CPHA_1Edge) ||  												   ((CPHA) == SPI_CPHA_2Edge))
S/**
S * @}
S */
S
S/** @defgroup SPI_CPOL SPI CPOL
S * @{
S */
Stypedef enum
S{
S  SPI_CPOL_Low  = (uint16_t)(0X00U << SPI0_CON_CPOL_Pos),  /*!< SPI Clock Polarity:It is low in the idle state  */
S  SPI_CPOL_High = (uint16_t)(0X01U << SPI0_CON_CPOL_Pos), /*!< SPI Clock Polarity:It is high in the idle state    */
S} SPI_CPOL_TypeDef;
S
S#define IS_SPI_CPOL(CPOL)	(((CPOL) == SPI_CPOL_Low) ||  \
S													 ((CPOL) == SPI_CPOL_High))
X#define IS_SPI_CPOL(CPOL)	(((CPOL) == SPI_CPOL_Low) ||  													 ((CPOL) == SPI_CPOL_High))
S/**
S * @}
S */
S
S/** @defgroup SPI_Prescaler SPI Prescaler
S * @{
S */
Stypedef enum
S{
S  SPI_Prescaler_1 = 0x00U << SPI0_CON_SPR_Pos,    /*!< Clock division: Fsource/1    */
S  SPI_Prescaler_2 = 0x01U << SPI0_CON_SPR_Pos,    /*!< Clock division: Fsource/2    */
S  SPI_Prescaler_4 = 0x02U << SPI0_CON_SPR_Pos,    /*!< Clock division: Fsource/4    */
S  SPI_Prescaler_8 = 0x03U << SPI0_CON_SPR_Pos,    /*!< Clock division: Fsource/8    */
S  SPI_Prescaler_16 = 0x04U << SPI0_CON_SPR_Pos,   /*!< Clock division: Fsource/16    */
S  SPI_Prescaler_32 = 0x05U << SPI0_CON_SPR_Pos,   /*!< Clock division: Fsource/32    */
S  SPI_Prescaler_64 = 0x06U << SPI0_CON_SPR_Pos,   /*!< Clock division: Fsource/64    */
S  SPI_Prescaler_128 = 0x07U << SPI0_CON_SPR_Pos,  /*!< Clock division: Fsource/128    */
S  SPI_Prescaler_256 = 0x08U << SPI0_CON_SPR_Pos,  /*!< Clock division: Fsource/256    */
S  SPI_Prescaler_512 = 0x09U << SPI0_CON_SPR_Pos,  /*!< Clock division: Fsource/512    */
S  SPI_Prescaler_1024 = 0x0AU << SPI0_CON_SPR_Pos, /*!< Clock division: Fsource/1024    */
S  
S  SPI_Prescaler_2048 = (uint16_t)(0x0BU << SPI1_TWI1_CON_QTWCK_Pos), /*!< Clock division: Fsource/2048   */
S	SPI_Prescaler_4096 = (uint16_t)(0x0CU << SPI1_TWI1_CON_QTWCK_Pos), /*!< Clock division: Fsource/2048   */
S} SPI_Prescaler_TypeDef;
S
S#define IS_SPI_PRESCALER(PRESCALER) (((PRESCALER) == SPI_Prescaler_1) || \
S                                     ((PRESCALER) == SPI_Prescaler_2) || \
S                                     ((PRESCALER) == SPI_Prescaler_4) || \
S                                     ((PRESCALER) == SPI_Prescaler_8) || \
S                                     ((PRESCALER) == SPI_Prescaler_16) || \
S                                     ((PRESCALER) == SPI_Prescaler_32) || \
S                                     ((PRESCALER) == SPI_Prescaler_64) || \
S                                     ((PRESCALER) == SPI_Prescaler_128) || \
S                                     ((PRESCALER) == SPI_Prescaler_256) || \
S                                     ((PRESCALER) == SPI_Prescaler_512) || \
S                                     ((PRESCALER) == SPI_Prescaler_1024)|| \
S                                     ((PRESCALER) == SPI_Prescaler_2048) || \
S                                     ((PRESCALER) == SPI_Prescaler_4096) )
X#define IS_SPI_PRESCALER(PRESCALER) (((PRESCALER) == SPI_Prescaler_1) ||                                      ((PRESCALER) == SPI_Prescaler_2) ||                                      ((PRESCALER) == SPI_Prescaler_4) ||                                      ((PRESCALER) == SPI_Prescaler_8) ||                                      ((PRESCALER) == SPI_Prescaler_16) ||                                      ((PRESCALER) == SPI_Prescaler_32) ||                                      ((PRESCALER) == SPI_Prescaler_64) ||                                      ((PRESCALER) == SPI_Prescaler_128) ||                                      ((PRESCALER) == SPI_Prescaler_256) ||                                      ((PRESCALER) == SPI_Prescaler_512) ||                                      ((PRESCALER) == SPI_Prescaler_1024)||                                      ((PRESCALER) == SPI_Prescaler_2048) ||                                      ((PRESCALER) == SPI_Prescaler_4096) )
S/**
S * @}
S */
S
S/** @defgroup SPI_PinRemap TIM Pin Remap
S * @{
S */
Stypedef enum
S{
S  SPI_PinRemap_Default = (uint32_t)(0x00 << SPI0_CON_SPOS_Pos),  /*!< SPI0 Pin Remap: Disable */
S  SPI_PinRemap_A       = (uint32_t)(0x01 << SPI0_CON_SPOS_Pos),  /*!< SPI0 Pin Remap: Remap mode A */
S  
S	SPI_PinRemap_B       = (uint32_t)(0x02 << SPI1_TWI1_CON_SPOS_Pos),  /*!< SPI1_TWI1 Pin Remap: Remap mode B */
S  SPI_PinRemap_C       = (uint32_t)(0x03 << SPI1_TWI1_CON_SPOS_Pos),  /*!< SPI1_TWI1 Pin Remap: Remap mode C */
S} SPI_PinRemap_TypeDef;
S
S#define IS_SPI_LIST_PINREMAP(REMAP) (((REMAP) == SPI_PinRemap_Default) ||  \
S															      	((REMAP) == SPI_PinRemap_A)||  \
S                                       ((REMAP) == SPI_PinRemap_B) ||  \
S															      	((REMAP) == SPI_PinRemap_C) )
X#define IS_SPI_LIST_PINREMAP(REMAP) (((REMAP) == SPI_PinRemap_Default) ||  															      	((REMAP) == SPI_PinRemap_A)||                                         ((REMAP) == SPI_PinRemap_B) ||  															      	((REMAP) == SPI_PinRemap_C) )
S
S/**
S * @}
S */
S
S/** @defgroup SPI_IT SPI Interrupt
S * @{
S */
Stypedef enum
S{
S  SPI_IT_INTEN = (uint32_t)SPI0_IDE_INTEN,	/*!< SPI Interrupt: SPI total interruption */
S  SPI_IT_RXNE  = (uint32_t)SPI0_IDE_RXNEIE,	/*!< SPI Interrupt: SPI RX buffer not empty Interrupt */
S  SPI_IT_TB    = (uint32_t)SPI0_IDE_TBIE,  		/*!< SPI Interrupt: SPI TX buffer is empty Interrupt */
S  SPI_IT_RX    = (uint32_t)SPI0_IDE_RXIE,  		/*!< SPI Interrupt: Receiving FIFO overflow Interrupt */
S  SPI_IT_RXH   = (uint32_t)SPI0_IDE_RXHIE,  	/*!< SPI Interrupt: Receive FIFO over half Interrupt */
S  SPI_IT_TXH   = (uint32_t)SPI0_IDE_TXHIE,  	/*!< SPI Interrupt: Transmit FIFO under half Interrupt */
S	SPI_IT_TBIE = (uint8_t)SPI1_IDE_TBIE,/*!< SPI Interrupt: Transmit TBIE under half Interrupt */
S	
S} SPI_IT_TypeDef;
S
S#define IS_SPI_IT(IT) (((IT) == SPI_IT_INTEN) || \
S                       ((IT) == SPI_IT_RXNE) || \
S                       ((IT) == SPI_IT_TB) || \
S                       ((IT) == SPI_IT_RX) || \
S											 ((IT) == SPI_IT_RXH) || \
S                       ((IT) == SPI_IT_TXH)|| \
S                       ((IT) == SPI_IT_TBIE))
X#define IS_SPI_IT(IT) (((IT) == SPI_IT_INTEN) ||                        ((IT) == SPI_IT_RXNE) ||                        ((IT) == SPI_IT_TB) ||                        ((IT) == SPI_IT_RX) || 											 ((IT) == SPI_IT_RXH) ||                        ((IT) == SPI_IT_TXH)||                        ((IT) == SPI_IT_TBIE))
S/**
S * @}
S */
S
S/** @defgroup SPI_FLAG SPI Flag
S * @{
S */
Stypedef enum
S{
S  SPI_Flag_SPIF   = (uint32_t)SPI0_STS_SPIF, /*!< SPI Flag: SPI transmit and receive flag */
S  SPI_Flag_RINEIF = (uint32_t)SPI0_STS_RXNEIF, /*!< SPI Flag: SPI RX buffer not empty flag */
S  SPI_Flag_TXEIF  = (uint32_t)SPI0_STS_TXEIF, /*!< SPI Flag: TX buffer is empty flag */
S  SPI_Flag_RXFIF  = (uint32_t)SPI0_STS_RXFIF, /*!< SPI Flag: Receiving FIFO overflow flag */
S  SPI_Flag_RXHIF  = (uint32_t)SPI0_STS_RXHIF, /*!< SPI Flag: Receive FIFO over half flag */
S  SPI_Flag_TXHIF  = (uint32_t)SPI0_STS_TXHIF, /*!< SPI Flag: Transmit FIFO under half flag */
S  SPI_Flag_WCOL   = (uint32_t)SPI0_STS_WCOL, /*!< SPI Flag: Write conflict flag */
S	SPI_FLAG_QTWIF = (uint8_t)SPI1_TWI1_STS_QTWIF, /*!< SPI1 Flag: Interrupt flag */
S} SPI_FLAG_TypeDef;
S
S#define IS_SPI_FLAG(FLAG) (((FLAG) == SPI_Flag_SPIF) || \
S                           ((FLAG) == SPI_Flag_RINEIF) || \
S                           ((FLAG) == SPI_Flag_TXEIF) || \
S                           ((FLAG) == SPI_Flag_RXFIF) || \
S                           ((FLAG) == SPI_Flag_RXHIF) || \
S                           ((FLAG) == SPI_Flag_TXHIF) || \
S                           ((FLAG) == SPI_Flag_WCOL) || \
S                           ((FLAG) == SPI_FLAG_QTWIF))
X#define IS_SPI_FLAG(FLAG) (((FLAG) == SPI_Flag_SPIF) ||                            ((FLAG) == SPI_Flag_RINEIF) ||                            ((FLAG) == SPI_Flag_TXEIF) ||                            ((FLAG) == SPI_Flag_RXFIF) ||                            ((FLAG) == SPI_Flag_RXHIF) ||                            ((FLAG) == SPI_Flag_TXHIF) ||                            ((FLAG) == SPI_Flag_WCOL) ||                            ((FLAG) == SPI_FLAG_QTWIF))
S/**
S * @}
S */
S
S/** @defgroup SPI_DMAReq SPI DMA Request
S * @{
S */
Stypedef enum
S{
S  SPI_DMAReq_RX = (uint32_t)SPI0_IDE_RXDMAEN, /*!< SPI DMA Request: Receive */
S  SPI_DMAReq_TX = (uint32_t)SPI0_IDE_TXDMAEN, /*!< SPI DMA Request: Transmit */
S} SPI_DMAReq_TypeDef;
S
S#define IS_SPI_DMAREQ(DMAREQ) (((DMAREQ) == SPI_DMAReq_RX) || \
S                               ((DMAREQ) == SPI_DMAReq_TX))
X#define IS_SPI_DMAREQ(DMAREQ) (((DMAREQ) == SPI_DMAReq_RX) ||                                ((DMAREQ) == SPI_DMAReq_TX))
S/**
S * @}
S */
S
S/**
S * @}
S */
S
S/** @defgroup SPI_Constants SPI Constants
S  * @{
S  */
S
S#define IS_SPI_ALL_PERIPH(PERIPH) (((PERIPH) == SPI0))
S
N#endif
N/**
N * @}
N */
N/* End of constants -----------------------------------------------------*/
N
N/** @defgroup SPI_Struct SPI Struct
N * @{
N */
N
N/** @brief SPI Time base Configuration Structure definition
N * @{
N */
Ntypedef struct
N{
N    uint16_t SPI_Mode; /*!< This member configures SPI mode.
N                                              This parameter can be a value of @ref SPI_Mode_TypeDef */
N
N    uint16_t SPI_DataSize; /*!< This member configures SPI data size.
N                                              This parameter can be a value of @ref SPI_DataSize_TypeDef */
N
N
N    uint16_t SPI_CPHA; /*!< This member configures SPI Clock Phase.
N                                              This parameter can be a value of @ref SPI_CPHA_TypeDef */
N
N    uint16_t SPI_CPOL; /*!< This member configures SPI Clock Polarity.
N                                              This parameter can be a value of @ref SPI_CPOL_TypeDef */
N
N    uint32_t SPI_FirstBit; /*!< This member configures SPI first transmitted bit.
N                                              This parameter can be a value of @ref SPI_FirstBit_TypeDef */
N
N
N    uint32_t SPI_Prescaler; /*!< This member configures SPI clock predivision.
N                                              This parameter can be a value of @ref SPI_Prescaler_TypeDef */
N} SPI_InitTypeDef;
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/** @addtogroup SPI_Functions SPI Functions
N * @{
N */
N
N/* SPI Base functions ********************************************************/
Nvoid SPI_DeInit ( SPI_TypeDef* SPIx );
Nvoid SPI_StructInit ( SPI_InitTypeDef* SPI_InitStruct );
Nvoid SPI_Init ( SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct );
Nvoid SPI_Cmd ( SPI_TypeDef* SPIx, FunctionalState NewState );
Nvoid SPI_SetMode ( SPI_TypeDef* SPIx, SPI_Mode_TypeDef SPI_Mode );
Nvoid SPI_DataSizeConfig ( SPI_TypeDef* SPIx, SPI_DataSize_TypeDef SPI_DataSize );
N
N/* Data transfers functions ********************************************************/
Nvoid SPI_SendData ( SPI_TypeDef* SPIx, uint16_t Data );
Nuint16_t SPI_ReceiveData ( SPI_TypeDef* SPIx );
Nvoid SPI_SendDataFIFO ( SPI_TypeDef* SPIx, uint16_t* Data, uint16_t length );
Nvoid SPI_ReceiveDataFIFO ( SPI_TypeDef* SPIx, uint16_t* Data, uint16_t length );
N
N/* Pin remap management functions  **********************************************/
Nvoid SPI_PinRemapConfig ( SPI_TypeDef* SPIx, SPI_PinRemap_TypeDef SPI_PinRemap );
N
N/* Interrupts and flags management functions  **********************************************/
Nvoid SPI_ITConfig ( SPI_TypeDef* SPIx, uint16_t SPI_IT, FunctionalState NewState );
NFlagStatus SPI_GetFlagStatus ( SPI_TypeDef* SPIx, SPI_FLAG_TypeDef SPI_FLAG );
Nvoid SPI_ClearFlag ( SPI_TypeDef* SPIx, uint32_t SPI_FLAG );
Nvoid SPI_DMACmd ( SPI_TypeDef* SPIx, uint16_t SPI_DMAReq, FunctionalState NewState );
N/**
N * @}
N */
N/* End of functions --------------------------------------------------*/
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 37 "..\FWLib\SC32F1XXX_Lib\inc\sc32_conf.h" 2
N#include "sc32f1xxx_twi.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx_twi.h" 1
N/**
N ******************************************************************************
N * @file    sc32f1xxx_twi.h
N * @author  SOC AE Team
N * @version V1.6
N * @date     04-09-2024
N * @brief   Header file of TWI module.
N ******************************************************************************
N * @attention
N *
N *1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only
N *intended for use with SinOne products. No other uses are authorized. This
N *software is owned by SinOne Microelectronics Co.,Ltd. and is protected under
N *all applicable laws, including copyright laws.
N *2.The software which is for guidance only aims at providing customers with
N *coding information regarding their products in order for them to save time.
N *As a result, SinOne shall not be held liable for any direct, indirect or
N *consequential damages with respect to any claims arising from the content of
N *such software and/or the use made by customers of the coding information
N *contained herein in connection with their products.
N *
N *  COPYRIGHT 2024 SinOne Microelectronics
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __sc32f1xxx_TWI_H
N#define __sc32f1xxx_TWI_H
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "sc32f1xxx.h"
N#include "sc32.h"
N#include "sc32f1xxx_rcc.h"
N
N/** @addtogroup sc32f1xxx_StdPeriph_Driver
N * @{
N */
N
N/** @addtogroup TWI
N * @{
N */
N
N/** @defgroup TWI_Enumerations TWI Enumerations
N * @{
N */
N
N/** @brief TWI_Ack TWI Ack State
N * @{
N */
Ntypedef enum
N{
N    TWI_Ack_Disable = ( uint16_t ) ( 0X00U << TWI_CON_AA_Pos ), /*!< TWI Ack:Disable    */
X    TWI_Ack_Disable = ( uint16_t ) ( 0X00U << (1U) ),  
N    TWI_Ack_Enable  = ( uint16_t ) ( 0X01U << TWI_CON_AA_Pos ), /*!< TWI Ack:Enable   */
X    TWI_Ack_Enable  = ( uint16_t ) ( 0X01U << (1U) ),  
N} TWI_Ack_TypeDef;
N
N#define IS_TWI_ACK(STATE)	(((STATE) == TWI_Ack_Disable) ||  \
N												  ((STATE) == TWI_Ack_Enable))
X#define IS_TWI_ACK(STATE)	(((STATE) == TWI_Ack_Disable) ||  												  ((STATE) == TWI_Ack_Enable))
N/**
N * @}
N */
N
N/** @brief TWI_Prescaler TWI Prescaler
N * @{
N */
N#if !defined(SC32f15xx)
X#if !0L
Ntypedef enum
N{
N    TWI_PRESCALER_4096	= ( uint16_t ) ( 0x00U << TWI_CON_TWCK_Pos ), /*!< Clock division: Fsource/4096    */
X    TWI_PRESCALER_4096	= ( uint16_t ) ( 0x00U << (8U) ),  
N    TWI_PRESCALER_2048	= ( uint16_t ) ( 0x01U << TWI_CON_TWCK_Pos ), /*!< Clock division: Fsource/2048    */
X    TWI_PRESCALER_2048	= ( uint16_t ) ( 0x01U << (8U) ),  
N    TWI_PRESCALER_1024	= ( uint16_t ) ( 0x02U << TWI_CON_TWCK_Pos ), /*!< Clock division: Fsource/1024    */
X    TWI_PRESCALER_1024	= ( uint16_t ) ( 0x02U << (8U) ),  
N    TWI_PRESCALER_512		= ( uint16_t ) ( 0x03U << TWI_CON_TWCK_Pos ), /*!< Clock division: Fsource/512    */
X    TWI_PRESCALER_512		= ( uint16_t ) ( 0x03U << (8U) ),  
N    TWI_PRESCALER_256		= ( uint16_t ) ( 0x04U << TWI_CON_TWCK_Pos ), /*!< Clock division: Fsource/256    */
X    TWI_PRESCALER_256		= ( uint16_t ) ( 0x04U << (8U) ),  
N    TWI_PRESCALER_128		= ( uint16_t ) ( 0x05U << TWI_CON_TWCK_Pos ), /*!< Clock division: Fsource/128    */
X    TWI_PRESCALER_128		= ( uint16_t ) ( 0x05U << (8U) ),  
N    TWI_PRESCALER_64		= ( uint16_t ) ( 0x06U << TWI_CON_TWCK_Pos ), /*!< Clock division: Fsource/64    */
X    TWI_PRESCALER_64		= ( uint16_t ) ( 0x06U << (8U) ),  
N    TWI_PRESCALER_32		= ( uint16_t ) ( 0x07U << TWI_CON_TWCK_Pos ), /*!< Clock division: Fsource/32    */
X    TWI_PRESCALER_32		= ( uint16_t ) ( 0x07U << (8U) ),  
N    TWI_PRESCALER_16		= ( uint16_t ) ( 0x08U << TWI_CON_TWCK_Pos ), /*!< Clock division: Fsource/16    */
X    TWI_PRESCALER_16		= ( uint16_t ) ( 0x08U << (8U) ),  
N    TWI_PRESCALER_8			= ( uint16_t ) ( 0x09U << TWI_CON_TWCK_Pos ), /*!< Clock division: Fsource/8    */
X    TWI_PRESCALER_8			= ( uint16_t ) ( 0x09U << (8U) ),  
N    TWI_PRESCALER_4			= ( uint16_t ) ( 0x0AU << TWI_CON_TWCK_Pos ), /*!< Clock division: Fsource/4    */
X    TWI_PRESCALER_4			= ( uint16_t ) ( 0x0AU << (8U) ),  
N} TWI_Prescaler_TypeDef;
N
N#define IS_TWI_PRESCALER(PRESCALER) (((PRESCALER) == TWI_PRESCALER_4) || \
N                                     ((PRESCALER) == TWI_PRESCALER_8) || \
N                                     ((PRESCALER) == TWI_PRESCALER_16) || \
N                                     ((PRESCALER) == TWI_PRESCALER_32) || \
N                                     ((PRESCALER) == TWI_PRESCALER_64) || \
N                                     ((PRESCALER) == TWI_PRESCALER_128) || \
N                                     ((PRESCALER) == TWI_PRESCALER_256) || \
N                                     ((PRESCALER) == TWI_PRESCALER_512) || \
N                                     ((PRESCALER) == TWI_PRESCALER_1024) || \
N                                     ((PRESCALER) == TWI_PRESCALER_2048) || \
N                                     ((PRESCALER) == TWI_PRESCALER_4096))
X#define IS_TWI_PRESCALER(PRESCALER) (((PRESCALER) == TWI_PRESCALER_4) ||                                      ((PRESCALER) == TWI_PRESCALER_8) ||                                      ((PRESCALER) == TWI_PRESCALER_16) ||                                      ((PRESCALER) == TWI_PRESCALER_32) ||                                      ((PRESCALER) == TWI_PRESCALER_64) ||                                      ((PRESCALER) == TWI_PRESCALER_128) ||                                      ((PRESCALER) == TWI_PRESCALER_256) ||                                      ((PRESCALER) == TWI_PRESCALER_512) ||                                      ((PRESCALER) == TWI_PRESCALER_1024) ||                                      ((PRESCALER) == TWI_PRESCALER_2048) ||                                      ((PRESCALER) == TWI_PRESCALER_4096))
N#else
S/** @defgroup TWI_Prescaler TWI Prescaler
S * @{
S */
Stypedef enum
S{
S  TWI0_PRESCALER_4096	= (uint16_t)(0x00U << TWI_CON_TWCK_Pos),    /*!< Clock division: Fsource/4096    */
S  TWI0_PRESCALER_2048	= (uint16_t)(0x01U << TWI_CON_TWCK_Pos),    /*!< Clock division: Fsource/2048    */
S  TWI0_PRESCALER_1024	= (uint16_t)(0x02U << TWI_CON_TWCK_Pos),    /*!< Clock division: Fsource/1024    */
S  TWI0_PRESCALER_512		= (uint16_t)(0x03U << TWI_CON_TWCK_Pos),    /*!< Clock division: Fsource/512    */
S  TWI0_PRESCALER_256		= (uint16_t)(0x04U << TWI_CON_TWCK_Pos),   /*!< Clock division: Fsource/256    */
S  TWI0_PRESCALER_128		= (uint16_t)(0x05U << TWI_CON_TWCK_Pos),   /*!< Clock division: Fsource/128    */
S  TWI0_PRESCALER_64		= (uint16_t)(0x06U << TWI_CON_TWCK_Pos),   /*!< Clock division: Fsource/64    */
S  TWI0_PRESCALER_32		= (uint16_t)(0x07U << TWI_CON_TWCK_Pos),  /*!< Clock division: Fsource/32    */
S  TWI0_PRESCALER_16		= (uint16_t)(0x08U << TWI_CON_TWCK_Pos),  /*!< Clock division: Fsource/16    */
S  TWI0_PRESCALER_8			= (uint16_t)(0x09U << TWI_CON_TWCK_Pos),  /*!< Clock division: Fsource/8    */
S  TWI0_PRESCALER_4			= (uint16_t)(0x0AU << TWI_CON_TWCK_Pos), /*!< Clock division: Fsource/4    */
S	TWI1_Prescaler_1 =  (uint16_t)(0x00U << SPI1_TWI1_CON_QTWCK_Pos),    /*!< Clock division: Fsource/1    */
S  TWI1_Prescaler_2 =  (uint16_t)(0x01U << SPI1_TWI1_CON_QTWCK_Pos),    /*!< Clock division: Fsource/2    */
S  TWI1_Prescaler_4 =  (uint16_t)(0x02U << SPI1_TWI1_CON_QTWCK_Pos),    /*!< Clock division: Fsource/4    */
S  TWI1_Prescaler_8 =  (uint16_t)(0x03U << SPI1_TWI1_CON_QTWCK_Pos),    /*!< Clock division: Fsource/8    */
S  TWI1_Prescaler_16 = (uint16_t)(0x04U << SPI1_TWI1_CON_QTWCK_Pos),   /*!< Clock division: Fsource/16    */
S  TWI1_Prescaler_32 = (uint16_t)(0x05U << SPI1_TWI1_CON_QTWCK_Pos),   /*!< Clock division: Fsource/32    */
S  TWI1_Prescaler_64 = (uint16_t)(0x06U << SPI1_TWI1_CON_QTWCK_Pos),   /*!< Clock division: Fsource/64    */
S  TWI1_Prescaler_128 = (uint16_t)(0x07U << SPI1_TWI1_CON_QTWCK_Pos),  /*!< Clock division: Fsource/128    */
S  TWI1_Prescaler_256 = (uint16_t)(0x08U << SPI1_TWI1_CON_QTWCK_Pos),  /*!< Clock division: Fsource/256    */
S  TWI1_Prescaler_512 = (uint16_t)(0x09U << SPI1_TWI1_CON_QTWCK_Pos),  /*!< Clock division: Fsource/512    */
S  TWI1_Prescaler_1024 = (uint16_t)(0x0AU << SPI1_TWI1_CON_QTWCK_Pos), /*!< Clock division: Fsource/1024    */
S  TWI1_Prescaler_2048 = (uint16_t)(0x0BU << SPI1_TWI1_CON_QTWCK_Pos), /*!< Clock division: Fsource/2048   */
S  TWI1_Prescaler_4096 = (uint16_t)(0x0CU << SPI1_TWI1_CON_QTWCK_Pos), /*!< Clock division: Fsource/2048   */
S} TWI_Prescaler_TypeDef;
S
S#define IS_TWI_PRESCALER(PRESCALER) (((PRESCALER) == TWI0_PRESCALER_4) || \
S                                     ((PRESCALER) == TWI0_PRESCALER_8) || \
S                                     ((PRESCALER) == TWI0_PRESCALER_16) || \
S                                     ((PRESCALER) == TWI0_PRESCALER_32) || \
S                                     ((PRESCALER) == TWI0_PRESCALER_64) || \
S                                     ((PRESCALER) == TWI0_PRESCALER_128) || \
S                                     ((PRESCALER) == TWI0_PRESCALER_256) || \
S                                     ((PRESCALER) == TWI0_PRESCALER_512) || \
S                                     ((PRESCALER) == TWI0_PRESCALER_1024) || \
S                                     ((PRESCALER) == TWI0_PRESCALER_2048) || \
S                                     ((PRESCALER) == TWI0_PRESCALER_4096) || \
S                                     ((PRESCALER) == TWI1_Prescaler_1) || \
S                                     ((PRESCALER) == TWI1_Prescaler_2) || \
S                                     ((PRESCALER) == TWI1_Prescaler_4) || \
S                                     ((PRESCALER) == TWI1_Prescaler_8) || \
S                                     ((PRESCALER) == TWI1_Prescaler_16) || \
S                                     ((PRESCALER) == TWI1_Prescaler_32) || \
S                                     ((PRESCALER) == TWI1_Prescaler_64) || \
S                                     ((PRESCALER) == TWI1_Prescaler_128) || \
S                                     ((PRESCALER) == TWI1_Prescaler_256) || \
S                                     ((PRESCALER) == TWI1_Prescaler_512) || \
S                                     ((PRESCALER) == TWI1_Prescaler_1024)|| \
S                                     ((PRESCALER) == TWI1_Prescaler_2048) || \
S                                     ((PRESCALER) == TWI1_Prescaler_4096))
X#define IS_TWI_PRESCALER(PRESCALER) (((PRESCALER) == TWI0_PRESCALER_4) ||                                      ((PRESCALER) == TWI0_PRESCALER_8) ||                                      ((PRESCALER) == TWI0_PRESCALER_16) ||                                      ((PRESCALER) == TWI0_PRESCALER_32) ||                                      ((PRESCALER) == TWI0_PRESCALER_64) ||                                      ((PRESCALER) == TWI0_PRESCALER_128) ||                                      ((PRESCALER) == TWI0_PRESCALER_256) ||                                      ((PRESCALER) == TWI0_PRESCALER_512) ||                                      ((PRESCALER) == TWI0_PRESCALER_1024) ||                                      ((PRESCALER) == TWI0_PRESCALER_2048) ||                                      ((PRESCALER) == TWI0_PRESCALER_4096) ||                                      ((PRESCALER) == TWI1_Prescaler_1) ||                                      ((PRESCALER) == TWI1_Prescaler_2) ||                                      ((PRESCALER) == TWI1_Prescaler_4) ||                                      ((PRESCALER) == TWI1_Prescaler_8) ||                                      ((PRESCALER) == TWI1_Prescaler_16) ||                                      ((PRESCALER) == TWI1_Prescaler_32) ||                                      ((PRESCALER) == TWI1_Prescaler_64) ||                                      ((PRESCALER) == TWI1_Prescaler_128) ||                                      ((PRESCALER) == TWI1_Prescaler_256) ||                                      ((PRESCALER) == TWI1_Prescaler_512) ||                                      ((PRESCALER) == TWI1_Prescaler_1024)||                                      ((PRESCALER) == TWI1_Prescaler_2048) ||                                      ((PRESCALER) == TWI1_Prescaler_4096))
N#endif
N/**
N * @}
N */
N
N/** @brief TWI_Stretch TWI Stretch State
N * @{
N */
Ntypedef enum
N{
N    TWI_Stretch_Disable	= 0X00U << TWI_CON_STRETCH_Pos,  /*!< TWI Slave Clock Stretch:Disable    */
X    TWI_Stretch_Disable	= 0X00U << (0U),   
N    TWI_Stretch_Enable	= 0X01U << TWI_CON_STRETCH_Pos, /*!< TWI Slave Clock Stretch:Enable   */
X    TWI_Stretch_Enable	= 0X01U << (0U),  
N} TWI_Stretch_TypeDef;
N
N#define IS_TWI_STRETCH(STRETCH)	(((STRETCH) == TWI_Stretch_Enable) ||  \
N																((STRETCH) == TWI_Stretch_Disable))
X#define IS_TWI_STRETCH(STRETCH)	(((STRETCH) == TWI_Stretch_Enable) ||  																((STRETCH) == TWI_Stretch_Disable))
N/**
N * @}
N */
N
N/** @brief TWI_GeneralCall TWI First Bit
N * @{
N */
Ntypedef enum
N{
N    TWI_GeneralCall_Disable = 0X00U << TWI_ADD_GC_Pos,  /*!< TWI General Call State:Disable    */
X    TWI_GeneralCall_Disable = 0X00U << (0U),   
N    TWI_GeneralCall_Enable = 0X01U << TWI_ADD_GC_Pos, /*!< TWI General Call State:Enable    */
X    TWI_GeneralCall_Enable = 0X01U << (0U),  
N} TWI_GeneralCall_TypeDef;
N
N#define IS_TWI_GENERALCALL(GENERALCALL)	(((GENERALCALL) == TWI_GeneralCall_Disable) ||  \
N																				((GENERALCALL) == TWI_GeneralCall_Enable))
X#define IS_TWI_GENERALCALL(GENERALCALL)	(((GENERALCALL) == TWI_GeneralCall_Disable) ||  																				((GENERALCALL) == TWI_GeneralCall_Enable))
N/**
N * @}
N */
N
N/** @brief TWI_Command TWI Command
N * @{
N */
Ntypedef enum
N{
N    TWI_Command_Write = ( uint8_t ) 0X00U, /*!< TWI Command:Write    */
N    TWI_Command_Read  = ( uint8_t ) 0X01U, /*!< TWI Command:Read    */
N} TWI_Command_TypeDef;
N
N#define IS_TWI_COMMAND(COMMAND)	(((COMMAND) == TWI_Command_Write) ||  \
N														    	((COMMAND) == TWI_Command_Read))
X#define IS_TWI_COMMAND(COMMAND)	(((COMMAND) == TWI_Command_Write) ||  														    	((COMMAND) == TWI_Command_Read))
N/**
N * @}
N */
N
N
N/** @brief TWI_PinRemap TIM Pin Remap
N * @{
N */
N#if defined(SC32f10xx) ||defined(SC32f15xx)
X#if 1L ||0L
Ntypedef enum
N{
N    TWI_PinRemap_Default = ( uint32_t ) ( 0x00 << TWI_CON_SPOS_Pos ), /*!< TIM Pin Remap: Disable */
X    TWI_PinRemap_Default = ( uint32_t ) ( 0x00 << (14U) ),  
N    TWI_PinRemap_A       = ( uint32_t ) ( 0x01 << TWI_CON_SPOS_Pos ), /*!< TIM Pin Remap: Remap mode A */
X    TWI_PinRemap_A       = ( uint32_t ) ( 0x01 << (14U) ),  
N    TWI_PinRemap_B       = ( uint32_t ) ( 0x02 << TWI_CON_SPOS_Pos ), /*!< TIM Pin Remap: Remap mode B */
X    TWI_PinRemap_B       = ( uint32_t ) ( 0x02 << (14U) ),  
N    TWI_PinRemap_C       = ( uint32_t ) ( 0x03 << TWI_CON_SPOS_Pos ), /*!< TIM Pin Remap: Remap mode C */
X    TWI_PinRemap_C       = ( uint32_t ) ( 0x03 << (14U) ),  
N} TWI_PinRemap_TypeDef;
N
N#define IS_TWI_LIST1_PINREMAP(REMAP) (((REMAP) == TWI_PinRemap_Default) ||  \
N																      ((REMAP) == TWI_PinRemap_A) ||  \
N																      ((REMAP) == TWI_PinRemap_B) ||  \
N																      ((REMAP) == TWI_PinRemap_C))
X#define IS_TWI_LIST1_PINREMAP(REMAP) (((REMAP) == TWI_PinRemap_Default) ||  																      ((REMAP) == TWI_PinRemap_A) ||  																      ((REMAP) == TWI_PinRemap_B) ||  																      ((REMAP) == TWI_PinRemap_C))
N
N#define IS_TWI_LIST2_PINREMAP(REMAP) (((REMAP) == TWI_PinRemap_Default) ||  \
N																      ((REMAP) == TWI_PinRemap_A) ||\
N																			((REMAP) == TWI_PinRemap_B))
X#define IS_TWI_LIST2_PINREMAP(REMAP) (((REMAP) == TWI_PinRemap_Default) ||  																      ((REMAP) == TWI_PinRemap_A) ||																			((REMAP) == TWI_PinRemap_B))
N#elif defined(SC32f11xx)
Stypedef enum
S{
S    TWI_PinRemap_Default = ( uint32_t ) ( 0x00 << TWI_CON_SPOS_Pos ), /*!< TIM Pin Remap: Disable */
S    TWI_PinRemap_A       = ( uint32_t ) ( 0x01 << TWI_CON_SPOS_Pos ), /*!< TIM Pin Remap: Remap mode A */
S    TWI_PinRemap_B       = ( uint32_t ) ( 0x02 << TWI_CON_SPOS_Pos ), /*!< TIM Pin Remap: Remap mode B */
S    TWI_PinRemap_C       = ( uint32_t ) ( 0x03 << TWI_CON_SPOS_Pos ), /*!< TIM Pin Remap: Remap mode C */
S    TWI_PinRemap_D       = ( uint32_t ) ( 0x04 << TWI_CON_SPOS_Pos ), /*!< TIM Pin Remap: Remap mode D */
S    TWI_PinRemap_E       = ( uint32_t ) ( 0x05 << TWI_CON_SPOS_Pos ), /*!< TIM Pin Remap: Remap mode E */
S    TWI_PinRemap_F       = ( uint32_t ) ( 0x06 << TWI_CON_SPOS_Pos ), /*!< TIM Pin Remap: Remap mode F */
S    TWI_PinRemap_G       = ( uint32_t ) ( 0x07 << TWI_CON_SPOS_Pos ), /*!< TIM Pin Remap: Remap mode G */
S} TWI_PinRemap_TypeDef;
S
S#define IS_TWI_LIST1_PINREMAP(REMAP) (((REMAP) == TWI_PinRemap_Default) ||  \
S																      ((REMAP) == TWI_PinRemap_A) ||  \
S																      ((REMAP) == TWI_PinRemap_B) ||  \
S																      ((REMAP) == TWI_PinRemap_C) ||  \
S                                      ((REMAP) == TWI_PinRemap_D) ||  \
S																      ((REMAP) == TWI_PinRemap_E) ||  \
S																      ((REMAP) == TWI_PinRemap_F) ||  \
S                                      ((REMAP) == TWI_PinRemap_G))
X#define IS_TWI_LIST1_PINREMAP(REMAP) (((REMAP) == TWI_PinRemap_Default) ||  																      ((REMAP) == TWI_PinRemap_A) ||  																      ((REMAP) == TWI_PinRemap_B) ||  																      ((REMAP) == TWI_PinRemap_C) ||                                        ((REMAP) == TWI_PinRemap_D) ||  																      ((REMAP) == TWI_PinRemap_E) ||  																      ((REMAP) == TWI_PinRemap_F) ||                                        ((REMAP) == TWI_PinRemap_G))
S
S#define IS_TWI_LIST2_PINREMAP(REMAP) (((REMAP) == TWI_PinRemap_Default) ||  \
S																      ((REMAP) == TWI_PinRemap_A) ||  \
S																      ((REMAP) == TWI_PinRemap_B) ||  \
S																      ((REMAP) == TWI_PinRemap_C) )
X#define IS_TWI_LIST2_PINREMAP(REMAP) (((REMAP) == TWI_PinRemap_Default) ||  																      ((REMAP) == TWI_PinRemap_A) ||  																      ((REMAP) == TWI_PinRemap_B) ||  																      ((REMAP) == TWI_PinRemap_C) )
S#elif defined(SC32f12xx)
Stypedef enum
S{
S    TWI_PinRemap_Default = ( uint32_t ) ( 0x00 << TWI_CON_SPOS_Pos ), /*!< TIM Pin Remap: Disable */
S    TWI_PinRemap_A       = ( uint32_t ) ( 0x01 << TWI_CON_SPOS_Pos ), /*!< TIM Pin Remap: Remap mode A */
S    TWI_PinRemap_B       = ( uint32_t ) ( 0x02 << TWI_CON_SPOS_Pos ), /*!< TIM Pin Remap: Remap mode B */
S    TWI_PinRemap_C       = ( uint32_t ) ( 0x03 << TWI_CON_SPOS_Pos ), /*!< TIM Pin Remap: Remap mode C */
S    TWI_PinRemap_D       = ( uint32_t ) ( 0x04 << TWI_CON_SPOS_Pos ), /*!< TIM Pin Remap: Remap mode D */
S    TWI_PinRemap_E       = ( uint32_t ) ( 0x05 << TWI_CON_SPOS_Pos ), /*!< TIM Pin Remap: Remap mode E */
S} TWI_PinRemap_TypeDef;
S
S#define IS_TWI_LIST1_PINREMAP(REMAP) (((REMAP) == TWI_PinRemap_Default) ||  \
S																      ((REMAP) == TWI_PinRemap_A) ||  \
S																      ((REMAP) == TWI_PinRemap_B) ||  \
S																      ((REMAP) == TWI_PinRemap_C) ||  \
S                                      ((REMAP) == TWI_PinRemap_D) ||  \
S																      ((REMAP) == TWI_PinRemap_E) )
X#define IS_TWI_LIST1_PINREMAP(REMAP) (((REMAP) == TWI_PinRemap_Default) ||  																      ((REMAP) == TWI_PinRemap_A) ||  																      ((REMAP) == TWI_PinRemap_B) ||  																      ((REMAP) == TWI_PinRemap_C) ||                                        ((REMAP) == TWI_PinRemap_D) ||  																      ((REMAP) == TWI_PinRemap_E) )
S
S#define IS_TWI_LIST2_PINREMAP(REMAP) (((REMAP) == TWI_PinRemap_Default) ||  \
S																      ((REMAP) == TWI_PinRemap_A) ||  \
S																      ((REMAP) == TWI_PinRemap_B) ||  \
S																      ((REMAP) == TWI_PinRemap_C) ||  \
S                                      ((REMAP) == TWI_PinRemap_D) ||  \
S																      ((REMAP) == TWI_PinRemap_E) )
X#define IS_TWI_LIST2_PINREMAP(REMAP) (((REMAP) == TWI_PinRemap_Default) ||  																      ((REMAP) == TWI_PinRemap_A) ||  																      ((REMAP) == TWI_PinRemap_B) ||  																      ((REMAP) == TWI_PinRemap_C) ||                                        ((REMAP) == TWI_PinRemap_D) ||  																      ((REMAP) == TWI_PinRemap_E) )
S
N#endif
N/**
N * @}
N */
N
N/** @brief TWI_StateMachine TWI StateMachine
N * @{
N */
Ntypedef enum
N{
N    TWI_Slave_Idle = 0x00 << TWI_STS_STATE_Pos,
X    TWI_Slave_Idle = 0x00 << (8U),
N    TWI_Slave_ReceivedaAddress = 0x01 << TWI_STS_STATE_Pos,
X    TWI_Slave_ReceivedaAddress = 0x01 << (8U),
N    TWI_Slave_ReceivedaData = 0x02 << TWI_STS_STATE_Pos,
X    TWI_Slave_ReceivedaData = 0x02 << (8U),
N    TWI_Slave_SendData = 0x03 << TWI_STS_STATE_Pos,
X    TWI_Slave_SendData = 0x03 << (8U),
N    TWI_Slave_ReceivedaUACK = 0x04 << TWI_STS_STATE_Pos,
X    TWI_Slave_ReceivedaUACK = 0x04 << (8U),
N    TWI_Slave_DisableACK = 0x05 << TWI_STS_STATE_Pos,
X    TWI_Slave_DisableACK = 0x05 << (8U),
N    TWI_Slave_AddressError = 0x06 << TWI_STS_STATE_Pos,
X    TWI_Slave_AddressError = 0x06 << (8U),
N
N    TWI_Master_Idle = 0x00 << TWI_STS_STATE_Pos,
X    TWI_Master_Idle = 0x00 << (8U),
N    TWI_Master_SendAddress = 0x01 << TWI_STS_STATE_Pos,
X    TWI_Master_SendAddress = 0x01 << (8U),
N    TWI_Master_SendData = 0x02 << TWI_STS_STATE_Pos,
X    TWI_Master_SendData = 0x02 << (8U),
N    TWI_Master_ReceivedaData = 0x03 << TWI_STS_STATE_Pos,
X    TWI_Master_ReceivedaData = 0x03 << (8U),
N    TWI_Master_ReceivedaUACK = 0x04 << TWI_STS_STATE_Pos,
X    TWI_Master_ReceivedaUACK = 0x04 << (8U),
N} TWI_StateMachine_TypeDef;
N
N#define IS_TWI_STATEMACHINE(STATE)	(((STATE) == TWI_Slave_Idle) ||  \
N															((STATE) == TWI_Slave_ReceivedaAddress) ||  \
N                              ((STATE) == TWI_Slave_ReceivedaData) ||  \
N                              ((STATE) == TWI_Slave_SendData) ||  \
N                              ((STATE) == TWI_Slave_ReceivedaUACK) ||  \
N                              ((STATE) == TWI_Slave_DisableACK) ||  \
N                              ((STATE) == TWI_Slave_AddressError)) || \
N                              ((STATE) == TWI_Master_Idle) ||  \
N                              ((STATE) == TWI_Master_SendAddress) ||  \
N                              ((STATE) == TWI_Master_SendData) ||  \
N                              ((STATE) == TWI_Master_ReceivedaData) ||  \
N                              ((STATE) == TWI_Master_ReceivedaUACK))
X#define IS_TWI_STATEMACHINE(STATE)	(((STATE) == TWI_Slave_Idle) ||  															((STATE) == TWI_Slave_ReceivedaAddress) ||                                ((STATE) == TWI_Slave_ReceivedaData) ||                                ((STATE) == TWI_Slave_SendData) ||                                ((STATE) == TWI_Slave_ReceivedaUACK) ||                                ((STATE) == TWI_Slave_DisableACK) ||                                ((STATE) == TWI_Slave_AddressError)) ||                               ((STATE) == TWI_Master_Idle) ||                                ((STATE) == TWI_Master_SendAddress) ||                                ((STATE) == TWI_Master_SendData) ||                                ((STATE) == TWI_Master_ReceivedaData) ||                                ((STATE) == TWI_Master_ReceivedaUACK))
N/**
N * @}
N */
N
N/** @brief TWI_IT TWI Interrupt
N * @{
N */
Ntypedef enum
N{
N    TWI_IT_INT = ( uint32_t ) TWI_IDE_INTEN,	/*!< TWI Interrupt: TWI Interrupt */
X    TWI_IT_INT = ( uint32_t ) (0x1L << (0U)),	 
N} TWI_IT_TypeDef;
N
N#define IS_TWI_IT(IT) ((IT) == TWI_IT_INT)
N/**
N * @}
N */
N
N/** @brief TWI_DMAReq TWI DMA Request
N * @{
N */
Ntypedef enum
N{
N    TWI_DMAReq_RX = ( uint32_t ) TWI_IDE_RXDMAEN, /*!< TWI DMA Request: Receive */
X    TWI_DMAReq_RX = ( uint32_t ) (0x1L << (6U)),  
N    TWI_DMAReq_TX = ( uint32_t ) TWI_IDE_TXDMAEN, /*!< TWI DMA Request: Transmit */
X    TWI_DMAReq_TX = ( uint32_t ) (0x1L << (7U)),  
N} TWI_DMAReq_TypeDef;
N
N#define IS_TWI_DMAREQ(DMAREQ) (((DMAREQ) == TWI_DMAReq_RX) || \
N                               ((DMAREQ) == TWI_DMAReq_TX))
X#define IS_TWI_DMAREQ(DMAREQ) (((DMAREQ) == TWI_DMAReq_RX) ||                                ((DMAREQ) == TWI_DMAReq_TX))
N/**
N * @}
N */
N
N/** @brief TWI_FLAG TWI Flag
N * @{
N */
N#if !defined(SC32f15xx)
X#if !0L
Ntypedef enum
N{
N    TWI_FLAG_TWIF = ( uint32_t ) TWI_STS_TWIF, /*!< TWI Flag: Interrupt flag */
X    TWI_FLAG_TWIF = ( uint32_t ) (0x1L << (0U)),  
N    TWI_FLAG_TXRXnE = ( uint32_t ) TWI_STS_TXERXE, /*!< TWI Flag: Transmit/receive completion flag */
X    TWI_FLAG_TXRXnE = ( uint32_t ) (0x1L << (1U)),  
N    TWI_FLAG_GCA = ( uint32_t ) TWI_STS_GCA, /*!< TWI Flag: Generic Call flags */
X    TWI_FLAG_GCA = ( uint32_t ) (0x1L << (2U)),  
N    TWI_FLAG_MSTR = ( uint32_t ) TWI_STS_MSTR, /*!< TWI Flag: Flag to identify master or slave */
X    TWI_FLAG_MSTR = ( uint32_t ) (0x1L << (3U)),  
N} TWI_FLAG_TypeDef;
N
N#define IS_TWI_FLAG(FLAG) (((FLAG) == TWI_FLAG_TWIF) || \
N                           ((FLAG) == TWI_FLAG_TXRXnE) || \
N                           ((FLAG) == TWI_FLAG_GCA) || \
N                           ((FLAG) == TWI_FLAG_MSTR))
X#define IS_TWI_FLAG(FLAG) (((FLAG) == TWI_FLAG_TWIF) ||                            ((FLAG) == TWI_FLAG_TXRXnE) ||                            ((FLAG) == TWI_FLAG_GCA) ||                            ((FLAG) == TWI_FLAG_MSTR))
N#else
S/** @defgroup TWI_FLAG TWI Flag
S * @{
S */
Stypedef enum
S{
S  TWI_FLAG_TWIF = (uint32_t)TWI_STS_TWIF, /*!< TWI Flag: Interrupt flag */
S  TWI_FLAG_TXRXnE = (uint32_t)TWI_STS_TXERXE, /*!< TWI Flag: Transmit/receive completion flag */
S  TWI_FLAG_GCA = (uint32_t)TWI_STS_GCA, /*!< TWI Flag: Generic Call flags */
S  TWI_FLAG_QTWIF = (uint8_t)SPI1_TWI1_STS_QTWIF, /*!< TWI1 Flag: Interrupt flag */
S 
S} TWI_FLAG_TypeDef;
S
S#define IS_TWI_FLAG(FLAG) (((FLAG) == TWI_FLAG_TWIF) || \
S                           ((FLAG) == TWI_FLAG_TXRXnE) || \
S                           ((FLAG) == TWI_FLAG_GCA)||\
S													  ((FLAG) == TWI_FLAG_QTWIF) )
X#define IS_TWI_FLAG(FLAG) (((FLAG) == TWI_FLAG_TWIF) ||                            ((FLAG) == TWI_FLAG_TXRXnE) ||                            ((FLAG) == TWI_FLAG_GCA)||													  ((FLAG) == TWI_FLAG_QTWIF) )
N#endif
N/**
N * @}
N */
N
N/**
N * @}
N */
N/* End of enumerations -----------------------------------------------------*/
N
N/** @brief TWI_Constants TWI Constants
N  * @{
N  */
N
N#define IS_TWI_ALL_PERIPH(PERIPH) (((PERIPH) == TWI0) || \
N                                   ((PERIPH) == TWI1))
X#define IS_TWI_ALL_PERIPH(PERIPH) (((PERIPH) == TWI0) ||                                    ((PERIPH) == TWI1))
N/**
N * @}
N */
N/* End of constants -----------------------------------------------------*/
N
N/** @defgroup TWI_Struct TWI Struct
N * @{
N */
N
N/** @brief TWI Time base Configuration Structure definition
N * @{
N */
Ntypedef struct
N{
N    uint16_t TWI_Ack; /*!< This member configures TWI Ack.
N                                              This parameter can be a value of @ref TWI_Ack_TypeDef. */
N
N    uint16_t TWI_Prescaler; /*!< This member configures TWI Prescaler.
N                                              This parameter can be a value of @ref TWI_Prescaler_TypeDef. */
N
N    uint16_t TWI_Stretch; /*!< This member configures TWI Stretch.
N                                              This parameter can be a value of @ref TWI_Stretch_TypeDef. */
N
N    uint16_t TWI_GeneralCall; /*!< This member configures TWI General Call.
N                                              This parameter can be a value of @ref TWI_GeneralCall_TypeDef. */
N
N    uint32_t TWI_SlaveAdress; /*!< This member configures TWI SlaveAdress.
N                                              This parameter can be a value of 1 to 127. */
N
N} TWI_InitTypeDef;
N/**
N * @}
N */
N
N/**
N * @}
N */
N/* End of Struct -----------------------------------------------------*/
N
N/** @addtogroup TWI_Functions TWI Functions
N * @{
N */
N
N/* TWI Base functions ********************************************************/
Nvoid TWI_DeInit ( TWI_TypeDef* TWIx );
Nvoid TWI_Init ( TWI_TypeDef* TWIx, TWI_InitTypeDef* TWI_InitStruct );
Nvoid TWI_StructInit ( TWI_InitTypeDef* TWI_InitStruct );
Nvoid TWI_Cmd ( TWI_TypeDef* TWIx, FunctionalState NewState );
Nvoid TWI_AcknowledgeConfig ( TWI_TypeDef* TWIx, FunctionalState NewState );
Nvoid TWI_GeneralCallCmd ( TWI_TypeDef* TWIx, FunctionalState NewState );
Nvoid TWI_StretchClockConfig ( TWI_TypeDef* TWIx, FunctionalState NewState );
Nvoid TWI_SetNbytes ( TWI_TypeDef* TWIx, uint8_t Nbytes );
Nuint8_t TWI_GetNbytes ( TWI_TypeDef* TWIx );
N/* Data transfers functions ********************************************************/
Nvoid TWI_GenerateSTART ( TWI_TypeDef* TWIx, FunctionalState NewState );
Nvoid TWI_GenerateSTOP ( TWI_TypeDef* TWIx, FunctionalState NewState );
Nvoid TWI_Send7bitAddress ( TWI_TypeDef* TWIx, uint8_t Address, TWI_Command_TypeDef TWI_Command );
Nvoid TWI_SendData ( TWI_TypeDef* TWIx, uint8_t Data );
Nuint16_t TWI_ReceiveData ( TWI_TypeDef* TWIx );
N
N/* Pin remap management functions  **********************************************/
Nvoid TWI_PinRemapConfig ( TWI_TypeDef* TWIx, TWI_PinRemap_TypeDef TWI_Remap );
N
N/* Interrupts, DMA and flags management functions  **********************************************/
Nvoid TWI_ITConfig ( TWI_TypeDef* TWIx, uint16_t TWI_IT, FunctionalState NewState );
NFlagStatus TWI_GetFlagStatus ( TWI_TypeDef* TWIx, TWI_FLAG_TypeDef TWI_FLAG );
NTWI_StateMachine_TypeDef TWI_GetStateMachine ( TWI_TypeDef* TWIx );
Nvoid TWI_ClearFlag ( TWI_TypeDef* TWIx, TWI_FLAG_TypeDef TWI_FLAG );
Nvoid TWI_DMACmd ( TWI_TypeDef* TWIx, TWI_DMAReq_TypeDef TWI_DMAReq, FunctionalState NewState );
N
N/**
N * @}
N */
N/* End of functions --------------------------------------------------*/
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 38 "..\FWLib\SC32F1XXX_Lib\inc\sc32_conf.h" 2
N#include "sc32f1xxx_wdt.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx_wdt.h" 1
N/**
N ******************************************************************************
N * @file    sc32f1xxx_WDT.h
N * @author  SOC AE Team
N * @version V1.6
N * @date    04-09-2024
N * @brief   Header file of WDT module.
N ******************************************************************************
N * @attention
N *
N *1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only
N *intended for use with SinOne products. No other uses are authorized. This
N *software is owned by SinOne Microelectronics Co.,Ltd. and is protected under
N *all applicable laws, including copyright laws.
N *2.The software which is for guidance only aims at providing customers with
N *coding information regarding their products in order for them to save time.
N *As a result, SinOne shall not be held liable for any direct, indirect or
N *consequential damages with respect to any claims arising from the content of
N *such software and/or the use made by customers of the coding information
N *contained herein in connection with their products.
N *
N *  COPYRIGHT 2024 SinOne Microelectronics
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __sc32f1xxx_WDT_H
N#define __sc32f1xxx_WDT_H
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "sc32f1xxx.h"
N#include "sc32.h"
N#include "sc32f1xxx_rcc.h"
N
N/** @addtogroup sc32f1xxx_StdPeriph_Driver
N * @{
N */
N
N/** @addtogroup WDT
N * @{
N */
N
N/** @defgroup WDT_Enumerations WDT Enumerations
N * @{
N */
N
N/** @brief WDT_OverTime WDT OverTime
N * @{
N */
Ntypedef enum
N{
N    WDT_OverTime_500MS = ( uint8_t ) 0x00U << WDT_CFG_WDTCKS_Pos, /*!< WDT Interruption: Happens every 500MS    */
X    WDT_OverTime_500MS = ( uint8_t ) 0x00U << (0U),  
N    WDT_OverTime_250MS = ( uint8_t ) 0x01U << WDT_CFG_WDTCKS_Pos, /*!< WDT Interruption: Happens every 250MS   */
X    WDT_OverTime_250MS = ( uint8_t ) 0x01U << (0U),  
N    WDT_OverTime_125MS = ( uint8_t ) 0x02U << WDT_CFG_WDTCKS_Pos, /*!< WDT Interruption: Happens every 125MS    */
X    WDT_OverTime_125MS = ( uint8_t ) 0x02U << (0U),  
N    WDT_OverTime_62_5MS = ( uint8_t ) 0x03U << WDT_CFG_WDTCKS_Pos, /*!< WDT Interruption: Happens every 62.5MS    */
X    WDT_OverTime_62_5MS = ( uint8_t ) 0x03U << (0U),  
N    WDT_OverTime_31_5MS = ( uint8_t ) 0x04U << WDT_CFG_WDTCKS_Pos, /*!< WDT Interruption: Happens every 31.5MS    */
X    WDT_OverTime_31_5MS = ( uint8_t ) 0x04U << (0U),  
N    WDT_OverTime_15_75MS = ( uint8_t ) 0x05U << WDT_CFG_WDTCKS_Pos, /*!< WDT Interruption: Happens every 15.75MS    */
X    WDT_OverTime_15_75MS = ( uint8_t ) 0x05U << (0U),  
N    WDT_OverTime_7_88MS = ( uint8_t ) 0x06U << WDT_CFG_WDTCKS_Pos, /*!< WDT Interruption: Happens every 7.88MS    */
X    WDT_OverTime_7_88MS = ( uint8_t ) 0x06U << (0U),  
N    WDT_OverTime_3_94MS = ( uint8_t ) 0x07U << WDT_CFG_WDTCKS_Pos, /*!< WDT Interruption: Happens every 3.94MS    */
X    WDT_OverTime_3_94MS = ( uint8_t ) 0x07U << (0U),  
N} WDT_OverTime_TypeDef;
N
N#define IS_WDT_OverTime(OVERTIME) (((OVERTIME) == WDT_OverTime_500MS) || \
N                                    ((OVERTIME) == WDT_OverTime_250MS) || \
N                                    ((OVERTIME) == WDT_OverTime_125MS) || \
N                                    ((OVERTIME) == WDT_OverTime_62_5MS) || \
N                                    ((OVERTIME) == WDT_OverTime_31_5MS) || \
N                                    ((OVERTIME) == WDT_OverTime_15_75MS) || \
N                                    ((OVERTIME) == WDT_OverTime_7_88MS) || \
N                                    ((OVERTIME) == WDT_OverTime_3_94MS))
X#define IS_WDT_OverTime(OVERTIME) (((OVERTIME) == WDT_OverTime_500MS) ||                                     ((OVERTIME) == WDT_OverTime_250MS) ||                                     ((OVERTIME) == WDT_OverTime_125MS) ||                                     ((OVERTIME) == WDT_OverTime_62_5MS) ||                                     ((OVERTIME) == WDT_OverTime_31_5MS) ||                                     ((OVERTIME) == WDT_OverTime_15_75MS) ||                                     ((OVERTIME) == WDT_OverTime_7_88MS) ||                                     ((OVERTIME) == WDT_OverTime_3_94MS))
N/**
N * @}
N */
N
N/**
N * @}
N */
N/* End of enumerations -----------------------------------------------------*/
N
N/** @addtogroup WDT_Functions WDT Functions
N * @{
N */
N
N/* WDT Base functions ********************************************************/
Nvoid WDT_DeInit ( void );
Nvoid WDT_SetOverTime ( WDT_OverTime_TypeDef WDT_OverTime );
Nvoid WDT_Cmd ( FunctionalState NewState );
N
N/* WDT SetReload functions  **********************************************/
Nvoid WDT_SetReload ( void );
N
N/**
N * @}
N */
N/* End of functions --------------------------------------------------*/
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 39 "..\FWLib\SC32F1XXX_Lib\inc\sc32_conf.h" 2
N#include "sc32f1xxx_btm.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx_btm.h" 1
N/**
N ******************************************************************************
N * @file    sc32f1xxx_btm.h
N * @author  SOC AE Team
N * @version V1.6
N * @date     04-09-2024
N * @brief   Header file of BTM module.
N ******************************************************************************
N * @attention
N *
N *1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only
N *intended for use with SinOne products. No other uses are authorized. This
N *software is owned by SinOne Microelectronics Co.,Ltd. and is protected under
N *all applicable laws, including copyright laws.
N *2.The software which is for guidance only aims at providing customers with
N *coding information regarding their products in order for them to save time.
N *As a result, SinOne shall not be held liable for any direct, indirect or
N *consequential damages with respect to any claims arising from the content of
N *such software and/or the use made by customers of the coding information
N *contained herein in connection with their products.
N *
N *  COPYRIGHT 2024 SinOne Microelectronics
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __sc32f1xxx_BTM_H
N#define __sc32f1xxx_BTM_H
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "sc32f1xxx.h"
N#include "sc32.h"
N#include "sc32f1xxx_rcc.h"
N
N/** @addtogroup sc32f1xxx_StdPeriph_Driver
N * @{
N */
N
N/** @addtogroup BTM
N * @{
N */
N
N/** @defgroup BTM_Enumerations BTM Enumerations
N * @{
N */
N
N/** @brief BTM_FreqSelect BTM FreqSelect
N * @{
N */
Ntypedef enum
N{
N    BTM_FreqSelect_15_625MS = 0x00U << BTM_CON_BTMFS_Pos,    /*!< BTM Interruption: Happens every 15.625MS    */
X    BTM_FreqSelect_15_625MS = 0x00U << (0U),     
N    BTM_FreqSelect_31_25MS = 0x01U << BTM_CON_BTMFS_Pos,    /*!< BTM Interruption: Happens every 31.25MS   */
X    BTM_FreqSelect_31_25MS = 0x01U << (0U),     
N    BTM_FreqSelect_62_5MS = 0x02U << BTM_CON_BTMFS_Pos,    /*!< BTM Interruption: Happens every 62.5MS    */
X    BTM_FreqSelect_62_5MS = 0x02U << (0U),     
N    BTM_FreqSelect_125MS = 0x03U << BTM_CON_BTMFS_Pos,    /*!< BTM Interruption: Happens every 125MS    */
X    BTM_FreqSelect_125MS = 0x03U << (0U),     
N    BTM_FreqSelect_250MS = 0x04U << BTM_CON_BTMFS_Pos,   /*!< BTM Interruption: Happens every 250MS    */
X    BTM_FreqSelect_250MS = 0x04U << (0U),    
N    BTM_FreqSelect_500MS = 0x05U << BTM_CON_BTMFS_Pos,   /*!< BTM Interruption: Happens every 500MS    */
X    BTM_FreqSelect_500MS = 0x05U << (0U),    
N    BTM_FreqSelect_1S = 0x06U << BTM_CON_BTMFS_Pos,   /*!< BTM Interruption: Happens every 1S    */
X    BTM_FreqSelect_1S = 0x06U << (0U),    
N    BTM_FreqSelect_2S = 0x07U << BTM_CON_BTMFS_Pos,  /*!< BTM Interruption: Happens every 2S    */
X    BTM_FreqSelect_2S = 0x07U << (0U),   
N    BTM_FreqSelect_4S = 0x08U << BTM_CON_BTMFS_Pos,  /*!< BTM Interruption: Happens every 4S    */
X    BTM_FreqSelect_4S = 0x08U << (0U),   
N    BTM_FreqSelect_8S = 0x09U << BTM_CON_BTMFS_Pos,  /*!< BTM Interruption: Happens every 8S    */
X    BTM_FreqSelect_8S = 0x09U << (0U),   
N    BTM_FreqSelect_16S = 0x0AU << BTM_CON_BTMFS_Pos, /*!< BTM Interruption: Happens every 16S    */
X    BTM_FreqSelect_16S = 0x0AU << (0U),  
N    BTM_FreqSelect_32S = 0x0BU << BTM_CON_BTMFS_Pos,       /*!< Happens every 32S    */
X    BTM_FreqSelect_32S = 0x0BU << (0U),        
N} BTM_FreqSelect_TypeDef;
N
N#define IS_BTM_FREQSELECT(SELECT) (((SELECT) == BTM_FreqSelect_15_625MS) || \
N                                   ((SELECT) == BTM_FreqSelect_31_25MS) || \
N                                   ((SELECT) == BTM_FreqSelect_62_5MS) || \
N                                   ((SELECT) == BTM_FreqSelect_125MS) || \
N                                   ((SELECT) == BTM_FreqSelect_250MS) || \
N                                   ((SELECT) == BTM_FreqSelect_500MS) || \
N                                   ((SELECT) == BTM_FreqSelect_1S) || \
N                                   ((SELECT) == BTM_FreqSelect_2S) || \
N                                   ((SELECT) == BTM_FreqSelect_4S) || \
N                                   ((SELECT) == BTM_FreqSelect_8S) || \
N                                   ((SELECT) == BTM_FreqSelect_16S) || \
N                                   ((SELECT) == BTM_FreqSelect_32S))
X#define IS_BTM_FREQSELECT(SELECT) (((SELECT) == BTM_FreqSelect_15_625MS) ||                                    ((SELECT) == BTM_FreqSelect_31_25MS) ||                                    ((SELECT) == BTM_FreqSelect_62_5MS) ||                                    ((SELECT) == BTM_FreqSelect_125MS) ||                                    ((SELECT) == BTM_FreqSelect_250MS) ||                                    ((SELECT) == BTM_FreqSelect_500MS) ||                                    ((SELECT) == BTM_FreqSelect_1S) ||                                    ((SELECT) == BTM_FreqSelect_2S) ||                                    ((SELECT) == BTM_FreqSelect_4S) ||                                    ((SELECT) == BTM_FreqSelect_8S) ||                                    ((SELECT) == BTM_FreqSelect_16S) ||                                    ((SELECT) == BTM_FreqSelect_32S))
N/**
N * @}
N */
N
N/** @brief BTM_IT BTM Interrupt
N * @{
N */
Ntypedef enum
N{
N    BTM_IT_INT = ( uint32_t ) BTM_CON_INTEN,	/*!< BTM Interrupt: BTM Interrupt */
X    BTM_IT_INT = ( uint32_t ) (0x1L << (6U)),	 
N} BTM_IT_TypeDef;
N
N#define IS_BTM_IT(IT) ((((IT) & (uint8_t)0xFE) == 0x00) && ((IT) != (uint8_t)0x00))
N/**
N * @}
N */
N
N/** @brief BTM_FLAG BTM Flag
N * @{
N */
Ntypedef enum
N{
N    BTM_FLAG_IF = ( uint8_t ) BTM_STS_BTMIF, /*!< BTM Flag: Interrupt flag */
X    BTM_FLAG_IF = ( uint8_t ) (0x1L << (0U)),  
N} BTM_FLAG_TypeDef;
N
N#define IS_BTM_FLAG(FLAG) ((((FLAG) & (uint8_t)0xFE) == 0x00) && ((FLAG) != (uint8_t)0x00))
N
N#define IS_GET_BTM_FLAG(FLAG) (((FLAG) == BTM_FLAG_IF))
N/**
N * @}
N */
N
N/**
N * @}
N */
N/* End of BTM Enumerations.	*/
N
N
N#define IS_BTM_ALL_PERIPH(PERIPH) ((PERIPH) == BTM)
N/**
N * @}
N */
N/* End of constants -----------------------------------------------------*/
N
N
N/** @addtogroup BTM_Functions BTM Functions
N * @{
N */
N
N/* BTM Base functions ********************************************************/
Nvoid BTM_DeInit ( BTM_TypeDef* BTMx );
Nvoid BTM_FSConfig ( BTM_TypeDef* BTMx, BTM_FreqSelect_TypeDef BTM_FreqSelect );
Nvoid BTM_Cmd ( BTM_TypeDef* BTMx, FunctionalState NewState );
N
N/* Interrupts and flags management functions  **********************************************/
Nvoid BTM_ITConfig ( BTM_TypeDef* BTMx, uint16_t BTM_IT, FunctionalState NewState );
NFlagStatus BTM_GetFlagStatus ( BTM_TypeDef* BTMx, BTM_FLAG_TypeDef BTM_FLAG );
Nvoid BTM_ClearFlag ( BTM_TypeDef* BTMx, BTM_FLAG_TypeDef BTM_FLAG );
N
N/**
N * @}
N */
N/* End of BTM Functions.	*/
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 40 "..\FWLib\SC32F1XXX_Lib\inc\sc32_conf.h" 2
N#include "sc32f1xxx_crc.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx_crc.h" 1
N/**
N ******************************************************************************
N * @file    sc32f1xxx_CRC.h
N * @author  SOC AE Team
N * @version V1.6
N * @date    04-09-2024
N * @brief   Header file of CRC module.
N ******************************************************************************
N * @attention
N *
N *1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only
N *intended for use with SinOne products. No other uses are authorized. This
N *software is owned by SinOne Microelectronics Co.,Ltd. and is protected under
N *all applicable laws, including copyright laws.
N *2.The software which is for guidance only aims at providing customers with
N *coding information regarding their products in order for them to save time.
N *As a result, SinOne shall not be held liable for any direct, indirect or
N *consequential damages with respect to any claims arising from the content of
N *such software and/or the use made by customers of the coding information
N *contained herein in connection with their products.
N *
N *  COPYRIGHT 2024 SinOne Microelectronics
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __sc32f1xxx_CRC_H
N#define __sc32f1xxx_CRC_H
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "sc32f1xxx.h"
N#include "sc32.h"
N#include "sc32f1xxx_rcc.h"
N
N/** @addtogroup sc32f1xxx_StdPeriph_Driver
N * @{
N */
N
N/** @addtogroup CRC
N * @{
N */
N
N/* Exported enumerations ------------------------------------------------------------*/
N/** @defgroup CRC_Exported_Enumerations CRC Exported Enumerations
N * @{
N */
N
N/** @brief DEFAULT_Polynomial    Indicates whether or not default polynomial is used
N  * @{
N  */
Ntypedef enum
N{
N    DEFAULT_Polynomial_Enable		=	( ( uint8_t ) 0x00U ), /*!< Enable default generating polynomial 0x04C11DB7  */
N    DEFAULT_Polynomial_Disable	=	( ( uint8_t ) 0x01U ), /*!< Disable default generating polynomial 0x04C11DB7 */
N} DEFAULT_Polynomial_TypeDef;
N
N#define IS_DEFAULT_POLYNOMIAL(POSITIVE) (((DEFAULT) == DEFAULT_Polynomial_Enable) || \
N																				((DEFAULT) == DEFAULT_Polynomial_Disable))
X#define IS_DEFAULT_POLYNOMIAL(POSITIVE) (((DEFAULT) == DEFAULT_Polynomial_Enable) || 																				((DEFAULT) == DEFAULT_Polynomial_Disable))
N/**
N  * @}
N  */
N
N/** @brief DEFAULT_InitValue    Indicates whether or not default init value is used
N  * @{
N  */
Ntypedef enum
N{
N    DEFAULT_InitValue_Enable	=	( ( uint8_t ) 0x00U ), /*!< Enable initial CRC default value  */
N    DEFAULT_InitValue_Disable	=	( ( uint8_t ) 0x01U ), /*!< Disable initial CRC default value */
N} DEFAULT_InitValue_TypeDef;
N
N#define IS_DEFAULT_INITVALUE(VALUE) (((VALUE) == DEFAULT_Polynomial_Enable) || \
N																		((VALUE) == DEFAULT_Polynomial_Disable))
X#define IS_DEFAULT_INITVALUE(VALUE) (((VALUE) == DEFAULT_Polynomial_Enable) || 																		((VALUE) == DEFAULT_Polynomial_Disable))
N/**
N  * @}
N  */
N
N/** @brief CRC_POLYSIZE CRC POLY Length
N * @{
N */
Ntypedef enum
N{
N    CRC_POLYSIZE_7B = 0x03U << CRC_CON_POLYSIZE_Pos,    /*!< The Size of the polynomial: 7Bit   */
X    CRC_POLYSIZE_7B = 0x03U << (6U),     
N    CRC_POLYSIZE_8B = 0x02U << CRC_CON_POLYSIZE_Pos,    /*!< The Size of the polynomial: 8Bit   */
X    CRC_POLYSIZE_8B = 0x02U << (6U),     
N    CRC_POLYSIZE_16B = 0x01U << CRC_CON_POLYSIZE_Pos,    /*!< The Size of the polynomial: 16Bit   */
X    CRC_POLYSIZE_16B = 0x01U << (6U),     
N    CRC_POLYSIZE_32B = 0x00U << CRC_CON_POLYSIZE_Pos,   /*!< The Size of the polynomial: 32Bit   */
X    CRC_POLYSIZE_32B = 0x00U << (6U),    
N} CRC_POLYSIZE_TypeDef;
N
N#define IS_CRC_POLYSIZE(POSITIVE) (((POSITIVE) == CRC_POLYSIZE_7B) || \
N                                   ((POSITIVE) == CRC_POLYSIZE_8B) || \
N                                   ((POSITIVE) == CRC_POLYSIZE_16B) || \
N                                   ((POSITIVE) == CRC_POLYSIZE_32B))
X#define IS_CRC_POLYSIZE(POSITIVE) (((POSITIVE) == CRC_POLYSIZE_7B) ||                                    ((POSITIVE) == CRC_POLYSIZE_8B) ||                                    ((POSITIVE) == CRC_POLYSIZE_16B) ||                                    ((POSITIVE) == CRC_POLYSIZE_32B))
N
N/**
N * @}
N */
N
N/** @brief CRC_InputData_Format CRC Input Buffer Format
N * @{
N */
Ntypedef enum
N{
N    CRC_InputData_Format_BYTES			= 0x00000001U, /*!< Input data in byte format      */
N    CRC_InputData_Format_HALFWORDS	= 0x00000002U,  /*!< Input data in half-word format */
N    CRC_InputData_Format_WORDS			= 0x00000003U, /*!< Input data in word format      */
N} CRC_InputData_Format_TypeDef;
N
N#define IS_CRC_INPUTDATA_FORMAT(FORMAT) (((FORMAT) == CRC_InputData_Format_UNDEFINED) || \
N																				((FORMAT) == CRC_InputData_Format_BYTES) || \
N																				((FORMAT) == CRC_InputData_Format_HALFWORDS) || \
N																				((FORMAT) == CRC_InputData_Format_WORDS))
X#define IS_CRC_INPUTDATA_FORMAT(FORMAT) (((FORMAT) == CRC_InputData_Format_UNDEFINED) || 																				((FORMAT) == CRC_InputData_Format_BYTES) || 																				((FORMAT) == CRC_InputData_Format_HALFWORDS) || 																				((FORMAT) == CRC_InputData_Format_WORDS))
N
N/**
N * @}
N */
N
N/* End of enumerations -----------------------------------------------------*/
N
N/** @defgroup CRC_Exported_Struct CRC Exported Struct
N * @{
N */
N
N/** @brief CRC Configuration Structure definition
N * @{
N */
Ntypedef struct
N{
N    uint16_t DefaultPolynomialUse;	/*!< This parameter is a value of @ref DEFAULT_Polynomial_TypeDef and indicates if default polynomial is used.
N																										If set to DEFAULT_POLYNOMIAL_ENABLE, resort to default
N																										X^32 + X^26 + X^23 + X^22 + X^16 + X^12 + X^11 + X^10 +X^8 + X^7 + X^5 +
N																										X^4 + X^2+ X +1.
N																										In that case, there is no need to set GeneratingPolynomial field.
N																										If otherwise set to DEFAULT_POLYNOMIAL_DISABLE, GeneratingPolynomial and
N																										CRCLength fields must be set. */
N
N    uint16_t DefaultInitValueUse;	/*!< This parameter is a value of @ref DEFAULT_InitValue_TypeDef and indicates if default init value is used.
N																									If set to DEFAULT_INIT_VALUE_ENABLE, resort to default
N																									0xFFFFFFFF value. In that case, there is no need to set InitValue field. If
N																									otherwise set to DEFAULT_INIT_VALUE_DISABLE, InitValue field must be set. */
N
N    uint32_t GeneratingPolynomial;      /*!< Set CRC generating polynomial as a 7, 8, 16 or 32-bit long value for a polynomial degree
N                                           respectively equal to 7, 8, 16 or 32. This field is written in normal,
N                                           representation e.g., for a polynomial of degree 7, X^7 + X^6 + X^5 + X^2 + 1
N                                           is written 0x65. No need to specify it if DefaultPolynomialUse is set to
N                                            DEFAULT_POLYNOMIAL_ENABLE.   */
N
N    uint32_t InitValue;  /*!< Init value to initiate CRC computation. No need to specify it if DefaultInitValueUse
N                                           is set to DEFAULT_INIT_VALUE_ENABLE.   */
N
N    uint32_t CRCSize;                 /*!< This parameter is a value of @ref CRC_POLYSIZE_TypeDef and indicates CRC length. */
N
N} CRC_InitTypeDef;
N/**
N * @}
N */
N
N/**
N * @}
N */
N/* End of struct -----------------------------------------------------*/
N
N
N/** @defgroup  CRC_Macros CRC Macros
N  * @{
N  */
N
N
N///   X^32 + X^26 + X^23 + X^22 + X^16 + X^12 + X^11 + X^10 +X^8 + X^7 + X^5 + X^4 + X^2+ X +1
N#define DEFAULT_CRC32_POLY      0x04C11DB7U
N
N
N/** @brief CRC_Default_InitValue    Default CRC computation initialization value
N  * @{
N  */
N///   Initial CRC default value
N#define DEFAULT_CRC_INITVALUE   0xFFFFFFFFU
N/**
N  * @}
N  */
N
N/**
N * @}
N */
N
N/** @addtogroup CRC_Functions CRC Functions
N * @{
N */
N
N/* CRC Base functions ********************************************************/
Nvoid CRC_DeInit ( void );
Nvoid CRC_Init ( CRC_InitTypeDef* CRC_InitStruct );
Nvoid CRC_PolynomialSizeSelect ( CRC_POLYSIZE_TypeDef CRC_PolSize );
Nvoid CRC_SetInitRegister ( uint32_t CRC_InitValue );
Nvoid CRC_SetPolynomial ( uint32_t CRC_Pol );
N
N/* CRC Operate functions ********************************************************/
Nvoid CRC_ResetDR ( void );
Nuint32_t CRC_CalcCRC ( uint32_t CRC_Data );
Nuint32_t CRC_CalcCRC16bits ( uint16_t CRC_Data );
Nuint32_t CRC_CalcCRC8bits ( uint8_t CRC_Data );
Nuint32_t CRC_GetCRC ( void );
Nuint32_t CRC_Accumulate ( CRC_InputData_Format_TypeDef InputDataFormat, uint32_t pBuffer[], uint32_t BufferLength );
Nuint32_t CRC_Calculate ( CRC_InputData_Format_TypeDef InputDataFormat, uint32_t pBuffer[], uint32_t BufferLength );
N/**
N * @}
N */
N/* End of functions --------------------------------------------------*/
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 41 "..\FWLib\SC32F1XXX_Lib\inc\sc32_conf.h" 2
N#if !defined(SC32f15xx)
X#if !0L
N#include "sc32f1xxx_pwm.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx_pwm.h" 1
N/**
N ******************************************************************************
N * @file    SC32f10xx_pwm.h
N * @author  SOC AE Team
N * @version V1.5
N * @date     26-08-2024
N * @brief   Header file of PWM module.
N ******************************************************************************
N * @attention
N *
N *1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only
N *intended for use with SinOne products. No other uses are authorized. This
N *software is owned by SinOne Microelectronics Co.,Ltd. and is protected under
N *all applicable laws, including copyright laws.
N *2.The software which is for guidance only aims at providing customers with
N *coding information regarding their products in order for them to save time.
N *As a result, SinOne shall not be held liable for any direct, indirect or
N *consequential damages with respect to any claims arising from the content of
N *such software and/or the use made by customers of the coding information
N *contained herein in connection with their products.
N *
N *  COPYRIGHT 2024 SinOne Microelectronics
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __sc32f1xxx_PWM_H
N#define __sc32f1xxx_PWM_H
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "sc32f1xxx.h"
N#include "sc32.h"
N#include "sc32f1xxx_rcc.h"
N
N/** @addtogroup SC32f10xx_StdPeriph_Driver
N * @{
N */
N
N/** @addtogroup PWM
N * @{
N */
N
N/** @defgroup PWM_Enumerations PWM Enumerations
N * @{
N */
N
N/** @brief PWM_Prescaler PWM Prescaler
N * @{
N */
Ntypedef enum
N{
N    PWM_PRESCALER_DIV1	 = ( uint16_t ) ( 0x00U << PWM_CON_PWMCLK_Pos ),	/*!< Clock division: Fsource/1    */
X    PWM_PRESCALER_DIV1	 = ( uint16_t ) ( 0x00U << (0U) ),	 
N    PWM_PRESCALER_DIV2	 = ( uint16_t ) ( 0x01U << PWM_CON_PWMCLK_Pos ),	/*!< Clock division: Fsource/2    */
X    PWM_PRESCALER_DIV2	 = ( uint16_t ) ( 0x01U << (0U) ),	 
N    PWM_PRESCALER_DIV4	 = ( uint16_t ) ( 0x02U << PWM_CON_PWMCLK_Pos ),	/*!< Clock division: Fsource/4    */
X    PWM_PRESCALER_DIV4	 = ( uint16_t ) ( 0x02U << (0U) ),	 
N    PWM_PRESCALER_DIV8	 = ( uint16_t ) ( 0x03U << PWM_CON_PWMCLK_Pos ),	/*!< Clock division: Fsource/8    */
X    PWM_PRESCALER_DIV8	 = ( uint16_t ) ( 0x03U << (0U) ),	 
N    PWM_PRESCALER_DIV16	 = ( uint16_t ) ( 0x04U << PWM_CON_PWMCLK_Pos ),	/*!< Clock division: Fsource/16    */
X    PWM_PRESCALER_DIV16	 = ( uint16_t ) ( 0x04U << (0U) ),	 
N    PWM_PRESCALER_DIV32	 = ( uint16_t ) ( 0x05U << PWM_CON_PWMCLK_Pos ),	/*!< Clock division: Fsource/32    */
X    PWM_PRESCALER_DIV32	 = ( uint16_t ) ( 0x05U << (0U) ),	 
N    PWM_PRESCALER_DIV64	 = ( uint16_t ) ( 0x06U << PWM_CON_PWMCLK_Pos ),	/*!< Clock division: Fsource/64    */
X    PWM_PRESCALER_DIV64	 = ( uint16_t ) ( 0x06U << (0U) ),	 
N    PWM_PRESCALER_DIV128 = ( uint16_t ) ( 0x07U << PWM_CON_PWMCLK_Pos ), /*!< Clock division: Fsource/128    */
X    PWM_PRESCALER_DIV128 = ( uint16_t ) ( 0x07U << (0U) ),  
N    PWM_PRESCALER_DIV256 = ( uint16_t ) ( 0x08U << PWM_CON_PWMCLK_Pos ), /*!< Clock division: Fsource/256    */
X    PWM_PRESCALER_DIV256 = ( uint16_t ) ( 0x08U << (0U) ),  
N} PWM_Prescaler_TypeDef;
N
N#define IS_PWM_PRESCALER(PRESCALER) (((PRESCALER) == PWM_PRESCALER_DIV1) ||   \
N																		 ((PRESCALER) == PWM_PRESCALER_DIV2) ||   \
N																		 ((PRESCALER) == PWM_PRESCALER_DIV4) ||   \
N																		 ((PRESCALER) == PWM_PRESCALER_DIV8) ||   \
N																		 ((PRESCALER) == PWM_PRESCALER_DIV16) ||  \
N																		 ((PRESCALER) == PWM_PRESCALER_DIV32) ||  \
N																		 ((PRESCALER) == PWM_PRESCALER_DIV64) ||  \
N																		 ((PRESCALER) == PWM_PRESCALER_DIV128) || \
N																		 ((PRESCALER) == PWM_PRESCALER_DIV256))
X#define IS_PWM_PRESCALER(PRESCALER) (((PRESCALER) == PWM_PRESCALER_DIV1) ||   																		 ((PRESCALER) == PWM_PRESCALER_DIV2) ||   																		 ((PRESCALER) == PWM_PRESCALER_DIV4) ||   																		 ((PRESCALER) == PWM_PRESCALER_DIV8) ||   																		 ((PRESCALER) == PWM_PRESCALER_DIV16) ||  																		 ((PRESCALER) == PWM_PRESCALER_DIV32) ||  																		 ((PRESCALER) == PWM_PRESCALER_DIV64) ||  																		 ((PRESCALER) == PWM_PRESCALER_DIV128) || 																		 ((PRESCALER) == PWM_PRESCALER_DIV256))
N/**
N * @}
N */
N
N/** @brief PWM_AlignedMode PWM AlignedMode
N * @{
N */
Ntypedef enum
N{
N    PWM_AlignmentMode_Edge	 = ( uint16_t ) ( 0x00U << PWM_CON_PWMMD0_Pos ),	 /*!< Edge Alignment mode */
X    PWM_AlignmentMode_Edge	 = ( uint16_t ) ( 0x00U << (6U) ),	  
N    PWM_AlignmentMode_Center = ( uint16_t ) ( 0x01U << PWM_CON_PWMMD0_Pos ), /*!< Center Alignment mode */
X    PWM_AlignmentMode_Center = ( uint16_t ) ( 0x01U << (6U) ),  
N} PWM_AlignedMode_TypeDef;
N
N#define IS_PWM_AlignedMode(MODE) (((MODE) == PWM_AlignmentMode_Edge) || \
N																	((MODE) == PWM_AlignmentMode_Center))
X#define IS_PWM_AlignedMode(MODE) (((MODE) == PWM_AlignmentMode_Edge) || 																	((MODE) == PWM_AlignmentMode_Center))
N/**
N * @}
N */
N
N/** @brief PWM_WordMode PWM WordMode
N * @{
N */
Ntypedef enum
N{
N    PWM_WorkMode_Independent		= ( uint16_t ) ( 0x00U << PWM_CON_PWMMD1_Pos ),	 /*!< Independent working mode */
X    PWM_WorkMode_Independent		= ( uint16_t ) ( 0x00U << (5U) ),	  
N    PWM_WorkMode_Complementary	= ( uint16_t ) ( 0x01U << PWM_CON_PWMMD1_Pos ), /*!< Complementary working mode*/
X    PWM_WorkMode_Complementary	= ( uint16_t ) ( 0x01U << (5U) ),  
N} PWM_WorkMode_TypeDef;
N
N#define IS_PWM_WORKMode(MODE)	(((MODE) == PWM_Mode_Independent) || \
N															((MODE) == PWM_Mode_Complementary))
X#define IS_PWM_WORKMode(MODE)	(((MODE) == PWM_Mode_Independent) || 															((MODE) == PWM_Mode_Complementary))
N/**
N * @}
N */
N
N/** @brief PWM_Channel PWM Channel
N * @{
N */
Ntypedef enum
N{
N    PWMChannel_Less = 0x00000000UL, /*!< No channels are selected */
N    PWM_Channel_0 = ( int32_t ) 0x00000001UL,	/*!< PMW output channel 0 */
N    PWM_Channel_1 = ( int32_t ) 0x00000002UL,	/*!< PMW output channel 1 */
N    PWM_Channel_2 = ( int32_t ) 0x00000004UL,	/*!< PMW output channel 2 */
N    PWM_Channel_3 = ( int32_t ) 0x00000008UL,	/*!< PMW output channel 3 */
N    PWM_Channel_4 = ( int32_t ) 0x00000010UL,	/*!< PMW output channel 4 */
N    PWM_Channel_5 = ( int32_t ) 0x00000020UL,	/*!< PMW output channel 5 */
N    PWM_Channel_6 = ( int32_t ) 0x00000040UL,	/*!< PMW output channel 6 */
N    PWM_Channel_7 = ( int32_t ) 0x00000080UL,	/*!< PMW output channel 7 */
N    PWM_Channel_All = ( int32_t ) 0x000000FFUL, /*!< PMW output channel ALL */
N} PWM_Channel_Typedef;
N
N#define IS_PWM_CHANNEL(CHANNEL) (((CHANNEL) & (uint32_t)0xFFFFFF00) == 0x00)
N/**
N * @}
N */
N
N/** @brief PWM_FDMode PWM FDMode
N * @{
N */
Ntypedef enum
N{
N    PWM_FDMode_Latch		 = ( uint16_t ) ( 0x00U << PWM_FLT_FLTMD_Pos ),	/*!< PWM fault detection mode: Latch mode */
X    PWM_FDMode_Latch		 = ( uint16_t ) ( 0x00U << (5U) ),	 
N    PWM_FDMode_Immediate = ( uint16_t ) ( 0x01U << PWM_FLT_FLTMD_Pos ), /*!< PWM fault detection mode: Immediate mode */
X    PWM_FDMode_Immediate = ( uint16_t ) ( 0x01U << (5U) ),  
N} PWM_FDMode_TypeDef;
N
N#define IS_PWM_FDMODE(MODE) (((MODE) == PWM_FDMode_Latch) || \
N														 ((MODE) == PWM_FDMode_Immediate))
X#define IS_PWM_FDMODE(MODE) (((MODE) == PWM_FDMode_Latch) || 														 ((MODE) == PWM_FDMode_Immediate))
N/**
N * @}
N */
N
N/** @brief PWM_FDVoltage PWM FDVoltage
N * @{
N */
Ntypedef enum
N{
N    PWM_FDVoltage_Low		= ( uint16_t ) ( 0x00U << PWM_FLT_FLTTV_Pos ),	 /*!< PWM fault detection Voltage:Low level */
X    PWM_FDVoltage_Low		= ( uint16_t ) ( 0x00U << (4U) ),	  
N    PWM_FDVoltage_High	= ( uint16_t ) ( 0x01U << PWM_FLT_FLTTV_Pos ), /*!< PWM fault detection Voltage:High level */
X    PWM_FDVoltage_High	= ( uint16_t ) ( 0x01U << (4U) ),  
N} PWM_FDVoltage_TypeDef;
N
N#define IS_PWM_FDVOLTAGE(VOLTAGE) (((VOLTAGE) == PWM_FDVoltage_Low) || \
N																	 ((VOLTAGE) == PWM_FDVoltage_High))
X#define IS_PWM_FDVOLTAGE(VOLTAGE) (((VOLTAGE) == PWM_FDVoltage_Low) || 																	 ((VOLTAGE) == PWM_FDVoltage_High))
N/**
N * @}
N */
N
N/** @brief PWM_FDFilteringTime PWM FDFilteringTime
N * @{
N */
Ntypedef enum
N{
N    PWM_FilteringTime_0us		= ( uint16_t ) ( 0x00U << PWM_FLT_FLTDT_Pos ),	/*!< PWM fault detection input signal filtering time is 0us */
X    PWM_FilteringTime_0us		= ( uint16_t ) ( 0x00U << (0U) ),	 
N    PWM_FilteringTime_1us		= ( uint16_t ) ( 0x01U << PWM_FLT_FLTDT_Pos ),	/*!< PWM fault detection input signal filtering time is 1us */
X    PWM_FilteringTime_1us		= ( uint16_t ) ( 0x01U << (0U) ),	 
N    PWM_FilteringTime_4us		= ( uint16_t ) ( 0x02U << PWM_FLT_FLTDT_Pos ),	/*!< PWM fault detection input signal filtering time is 4us */
X    PWM_FilteringTime_4us		= ( uint16_t ) ( 0x02U << (0U) ),	 
N    PWM_FilteringTime_16us	= ( uint16_t ) ( 0x03U << PWM_FLT_FLTDT_Pos ), /*!< PWM fault detection input signal filtering time is 16us */
X    PWM_FilteringTime_16us	= ( uint16_t ) ( 0x03U << (0U) ),  
N} PWM_FDFilteringTime_TypeDef;
N
N#define IS_PWM_FDFILTERINGTIME(TIME) (((TIME) == PWM_WaveFilteringTime_0us) || \
N																			((TIME) == PWM_WaveFilteringTime_1us) || \
N																			((TIME) == PWM_WaveFilteringTime_4us) || \
N																			((TIME) == PWM_WaveFilteringTime_16us))
X#define IS_PWM_FDFILTERINGTIME(TIME) (((TIME) == PWM_WaveFilteringTime_0us) || 																			((TIME) == PWM_WaveFilteringTime_1us) || 																			((TIME) == PWM_WaveFilteringTime_4us) || 																			((TIME) == PWM_WaveFilteringTime_16us))
N/**
N * @}
N */
N
N/** @brief PWM_IT PWM Interrupt
N * @{
N */
Ntypedef enum
N{
N    PWM_IT_INTEN = ( uint16_t ) PWM_CON_INTEN,	/*!< PWM Interrupt: PWM Interrupt */
X    PWM_IT_INTEN = ( uint16_t ) (0x1L << (8U)),	 
N} PWM_IT_TypeDef;
N
N#define IS_PWM_IT(IT) ((((IT) & (uint16_t)0xFEFF) == 0x00) && ((IT) != (uint16_t)0x0000))
N
N/**
N * @}
N */
N
N/** @brief PWM_Flag PWM Flag
N * @{
N */
Ntypedef enum
N{
N    PWM_Flag_PWMIF  = ( uint8_t ) PWM_STS_PWMIF,	/*!< PWM Interrupt: PWM Interrupt */
X    PWM_Flag_PWMIF  = ( uint8_t ) (0x1L << (0U)),	 
N    PWM_Flag_FLTSTA = ( uint8_t ) PWM_STS_FLTSTA, /*!< PWM Interrupt: Flult Interrupt */
X    PWM_Flag_FLTSTA = ( uint8_t ) (0x1L << (1U)),  
N} PWM_Flag_TypeDef;
N
N#define IS_PWM_FLAG(FLAG) ((((FLAG) & (uint8_t)0xFC) == 0x00) && ((FLAG) != (uint8_t)0x00))
N
N#define IS_GET_PWM_FLAG(FLAG) (((FLAG) == PWM_Flag_PWMIF) || \
N													     ((FLAG) == PWM_Flag_FLTSTA))
X#define IS_GET_PWM_FLAG(FLAG) (((FLAG) == PWM_Flag_PWMIF) || 													     ((FLAG) == PWM_Flag_FLTSTA))
N/**
N * @}
N */
N
N
N/**
N * @}
N */
N/* End of enumerations -----------------------------------------------------*/
N
N/** @brief PWM_Constants PWM Constants
N  * @{
N  */
N#define IS_PWM_ALL_PERIPH(PERIPH) ((PERIPH) == PWM0)
N
N#define IS_PWM_COMPLEMENTARY_PERIPH(PERIPH) ((PERIPH) == PWM0)
N/**
N * @}
N */
N
N/* Exported struct ------------------------------------------------------------*/
N/** @defgroup PWM_Exported_Struct PWM Exported Struct
N * @{
N */
N
N/** @brief PWM Time base Configuration Structure definition
N * @{
N */
Ntypedef struct
N{
N    uint16_t PWM_Prescaler; /*!<  Specifies the predivision.
N																			This parameter can be a value of @ref PWM_Prescaler_TypeDef */
N
N    uint16_t PWM_AlignedMode; /*!< Specifies the aligne mode.
N																			This parameter can be a value of @ref PWM_AlignedMode_TypeDef */
N
N    uint16_t PWM_WorkMode; /*!< Specifies the work mode.
N																					This parameter can be a value of @ref PWM_WorkMode_TypeDef */
N
N    uint16_t PWM_Cycle;   /*!< Specifies the cycle.
N															 */
N
N    uint32_t PWM_OutputChannel; /*!< Specifies the output Channel.
N																			 This parameter can be a value of @ref PWM_CHANNEL_Typedef */
N
N    uint32_t PWM_LowPolarityChannl; /*!< Specifies the invert Channel.
N																				 This parameter can be a value of @ref PWM_CHANNEL_Typedef */
N} PWM_InitTypeDef;
N/**
N * @}
N */
N
N/** @brief PWM_FDInitTypeDef
N * @{
N */
Ntypedef struct
N{
N    uint16_t PWM_FDMode;							 /*!<  Specifies the PWM fault detection mode.
N																										 This parameter can be a value of @ref PWM_FDMode_TypeDef */
N    uint16_t PWM_FDVoltage;				 /*!<  Specifies the PWM fault detection active level.
N																							 This parameter can be a value of @ref PWM_FDVoltage_TypeDef */
N    uint16_t PWM_FDFilteringTime; /*!<  Specifies the PWM fault detection filtering time.
N																			 This parameter can be a value of @ref PWM_FDFilteringTime_TypeDef */
N} PWM_FDInitTypeDef;
N/**
N * @}
N */
N
N/**
N * @}
N */
N/* End of struct -----------------------------------------------------*/
N
N/** @addtogroup PWM_Functions PWM Functions
N * @{
N */
N
N/* PWM Base functions ********************************************************/
Nvoid PWM_DeInit ( PWM_TypeDef* PWMx );
Nvoid PWM_StructInit ( PWM_InitTypeDef* PWM_InitStruct );
Nvoid PWM_Init ( PWM_TypeDef* PWMx, PWM_InitTypeDef* PWM_InitStruct );
Nvoid PWM_Cmd ( PWM_TypeDef* PWMx, FunctionalState NewState );
Nvoid PWM_SetCycle ( PWM_TypeDef* PWMx, uint32_t PWM_Cycle );
Nuint16_t PWM_GetCycle ( PWM_TypeDef* PWMx );
Nvoid PWM_SetPrescaler ( PWM_TypeDef* PWMx, PWM_Prescaler_TypeDef PWM_Prescaler );
NPWM_Prescaler_TypeDef PWM_GetPrescaler ( PWM_TypeDef* PWMx );
Nvoid PWM_SetDuty ( PWM_TypeDef* PWMx, PWM_Channel_Typedef PWM_Channel, uint16_t PWM_Duty );
Nuint16_t PWM_GetDuty ( PWM_TypeDef* PWMx, PWM_Channel_Typedef PWM_Channel );
Nvoid PWM_RisingDeadTimeConfig ( PWM_TypeDef* PWMx, uint8_t PWM_RisingDeadTime );
Nvoid PWM_FallingDeadTimeConfig ( PWM_TypeDef* PWMx, uint8_t PWM_FallingDeadTime );
N
N/* PWM Falut Dectection functions **********************************************/
Nvoid PWM_FDStructInit ( PWM_FDInitTypeDef* PWM_FDInitStruct );
Nvoid PWM_FDInit ( PWM_TypeDef* PWMx, PWM_FDInitTypeDef* PWM_FDInitStruct );
Nvoid PWM_FDCmd ( PWM_TypeDef* PWMx, FunctionalState NewState );
N
N/* Interrupt Handler functions  ***********************************************/
Nvoid PWM_ITConfig ( PWM_TypeDef* PWMx, uint16_t PWM_IT, FunctionalState NewState );
NFlagStatus PWM_GetFlagStatus ( PWM_TypeDef* PWMx, uint16_t PWM_FLAG );
Nvoid PWM_ClearFlag ( PWM_TypeDef* PWMx, uint16_t PWM_FLAG );
N
N/**
N * @}
N */
N/* End of functions --------------------------------------------------*/
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 43 "..\FWLib\SC32F1XXX_Lib\inc\sc32_conf.h" 2
N#include "sc32f1xxx_ledpwm.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx_ledpwm.h" 1
N/**
N ******************************************************************************
N * @file    SC32f10xx_pwm.h
N * @author  SOC AE Team
N * @version V1.5
N * @date    26-08-2024
N * @brief   Header file of LEDPWM module.
N ******************************************************************************
N * @attention
N *
N *1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only
N *intended for use with SinOne products. No other uses are authorized. This
N *software is owned by SinOne Microelectronics Co.,Ltd. and is protected under
N *all applicable laws, including copyright laws.
N *2.The software which is for guidance only aims at providing customers with
N *coding information regarding their products in order for them to save time.
N *As a result, SinOne shall not be held liable for any direct, indirect or
N *consequential damages with respect to any claims arising from the content of
N *such software and/or the use made by customers of the coding information
N *contained herein in connection with their products.
N *
N *  COPYRIGHT 2024 SinOne Microelectronics
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __sc32f1xxx_LEDPWM_H
N#define __sc32f1xxx_LEDPWM_H
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "sc32f1xxx.h"
N#include "sc32.h"
N#include "sc32f1xxx_rcc.h"
N
N/** @addtogroup SC32f10xx_StdPeriph_Driver
N * @{
N */
N
N/** @addtogroup LEDPWM
N * @{
N */
N
N/** @defgroup LEDPWM_Enumerations LEDPWM Enumerations
N * @{
N */
N
N/** @brief LEDPWM_Prescaler LEDPWM Prescaler
N * @{
N */
Ntypedef enum
N{
N    LEDPWM_PRESCALER_DIV1	 = ( uint16_t ) ( 0x00U << LEDPWM_CON_PWMCLK_Pos ),	/*!< Clock division: Fsource/1    */
X    LEDPWM_PRESCALER_DIV1	 = ( uint16_t ) ( 0x00U << (0U) ),	 
N    LEDPWM_PRESCALER_DIV2	 = ( uint16_t ) ( 0x01U << LEDPWM_CON_PWMCLK_Pos ),	/*!< Clock division: Fsource/2    */
X    LEDPWM_PRESCALER_DIV2	 = ( uint16_t ) ( 0x01U << (0U) ),	 
N    LEDPWM_PRESCALER_DIV4	 = ( uint16_t ) ( 0x02U << LEDPWM_CON_PWMCLK_Pos ),	/*!< Clock division: Fsource/4    */
X    LEDPWM_PRESCALER_DIV4	 = ( uint16_t ) ( 0x02U << (0U) ),	 
N    LEDPWM_PRESCALER_DIV8	 = ( uint16_t ) ( 0x03U << LEDPWM_CON_PWMCLK_Pos ),	/*!< Clock division: Fsource/8    */
X    LEDPWM_PRESCALER_DIV8	 = ( uint16_t ) ( 0x03U << (0U) ),	 
N    LEDPWM_PRESCALER_DIV16	 = ( uint16_t ) ( 0x04U << LEDPWM_CON_PWMCLK_Pos ),	/*!< Clock division: Fsource/16    */
X    LEDPWM_PRESCALER_DIV16	 = ( uint16_t ) ( 0x04U << (0U) ),	 
N    LEDPWM_PRESCALER_DIV32	 = ( uint16_t ) ( 0x05U << LEDPWM_CON_PWMCLK_Pos ),	/*!< Clock division: Fsource/32    */
X    LEDPWM_PRESCALER_DIV32	 = ( uint16_t ) ( 0x05U << (0U) ),	 
N    LEDPWM_PRESCALER_DIV64	 = ( uint16_t ) ( 0x06U << LEDPWM_CON_PWMCLK_Pos ),	/*!< Clock division: Fsource/64    */
X    LEDPWM_PRESCALER_DIV64	 = ( uint16_t ) ( 0x06U << (0U) ),	 
N    LEDPWM_PRESCALER_DIV128 = ( uint16_t ) ( 0x07U << LEDPWM_CON_PWMCLK_Pos ), /*!< Clock division: Fsource/128    */
X    LEDPWM_PRESCALER_DIV128 = ( uint16_t ) ( 0x07U << (0U) ),  
N    LEDPWM_PRESCALER_DIV256 = ( uint16_t ) ( 0x08U << LEDPWM_CON_PWMCLK_Pos ), /*!< Clock division: Fsource/256    */
X    LEDPWM_PRESCALER_DIV256 = ( uint16_t ) ( 0x08U << (0U) ),  
N} LEDPWM_Prescaler_TypeDef;
N
N#define IS_LEDPWM_PRESCALER(PRESCALER) (((PRESCALER) == LEDPWM_PRESCALER_DIV1) ||   \
N																		 ((PRESCALER) == LEDPWM_PRESCALER_DIV2) ||   \
N																		 ((PRESCALER) == LEDPWM_PRESCALER_DIV4) ||   \
N																		 ((PRESCALER) == LEDPWM_PRESCALER_DIV8) ||   \
N																		 ((PRESCALER) == LEDPWM_PRESCALER_DIV16) ||  \
N																		 ((PRESCALER) == LEDPWM_PRESCALER_DIV32) ||  \
N																		 ((PRESCALER) == LEDPWM_PRESCALER_DIV64) ||  \
N																		 ((PRESCALER) == LEDPWM_PRESCALER_DIV128) || \
N																		 ((PRESCALER) == LEDPWM_PRESCALER_DIV256))
X#define IS_LEDPWM_PRESCALER(PRESCALER) (((PRESCALER) == LEDPWM_PRESCALER_DIV1) ||   																		 ((PRESCALER) == LEDPWM_PRESCALER_DIV2) ||   																		 ((PRESCALER) == LEDPWM_PRESCALER_DIV4) ||   																		 ((PRESCALER) == LEDPWM_PRESCALER_DIV8) ||   																		 ((PRESCALER) == LEDPWM_PRESCALER_DIV16) ||  																		 ((PRESCALER) == LEDPWM_PRESCALER_DIV32) ||  																		 ((PRESCALER) == LEDPWM_PRESCALER_DIV64) ||  																		 ((PRESCALER) == LEDPWM_PRESCALER_DIV128) || 																		 ((PRESCALER) == LEDPWM_PRESCALER_DIV256))
N/**
N * @}
N */
N
N/** @brief LEDPWM_AlignedMode_TypeDef
N * @{
N */
Ntypedef enum
N{
N    LEDPWM_AlignmentMode_Edge	 = ( uint16_t ) ( 0x00U << LEDPWM_CON_PWMMD0_Pos ),	 /*!< Edge Alignment mode */
X    LEDPWM_AlignmentMode_Edge	 = ( uint16_t ) ( 0x00U << (6U) ),	  
N    LEDPWM_AlignmentMode_Center = ( uint16_t ) ( 0x01U << LEDPWM_CON_PWMMD0_Pos ), /*!< Center Alignment mode */
X    LEDPWM_AlignmentMode_Center = ( uint16_t ) ( 0x01U << (6U) ),  
N} LEDPWM_AlignedMode_TypeDef;
N
N#define IS_LEDPWM_AlignedMode(MODE) (((MODE) == LEDPWM_AlignmentMode_Edge) || \
N																	((MODE) == LEDPWM_AlignmentMode_Center))
X#define IS_LEDPWM_AlignedMode(MODE) (((MODE) == LEDPWM_AlignmentMode_Edge) || 																	((MODE) == LEDPWM_AlignmentMode_Center))
N/**
N * @}
N */
N
N/** @brief LEDPWM_Channel
N * @{
N */
N#if defined(SC32f10xx) ||  defined(SC32f12xx)
X#if 1L ||  0L
Ntypedef enum
N{
N    LEDPWMChannel_Less = 0x00000000UL, /*!< No channels are selected */
N    LEDPWM_Channel_0 = ( int32_t ) 0x00000001UL,	/*!< PMW output channel 0 */
N    LEDPWM_Channel_1 = ( int32_t ) 0x00000002UL,	/*!< PMW output channel 1 */
N    LEDPWM_Channel_2 = ( int32_t ) 0x00000004UL,	/*!< PMW output channel 2 */
N    LEDPWM_Channel_3 = ( int32_t ) 0x00000008UL,	/*!< PMW output channel 3 */
N    LEDPWM_Channel_4 = ( int32_t ) 0x00000010UL,	/*!< PMW output channel 4 */
N    LEDPWM_Channel_5 = ( int32_t ) 0x00000020UL,	/*!< PMW output channel 5 */
N    LEDPWM_Channel_6 = ( int32_t ) 0x00000040UL,	/*!< PMW output channel 6 */
N    LEDPWM_Channel_7 = ( int32_t ) 0x00000080UL,	/*!< PMW output channel 7 */
N    LEDPWM_Channel_8 = ( int32_t ) 0x00000100UL,	/*!< PMW output channel 8 */
N    LEDPWM_Channel_9 = ( int32_t ) 0x00000200UL,	/*!< PMW output channel 9 */
N    LEDPWM_Channel_10 = ( int32_t ) 0x00000400UL,	/*!< PMW output channel 10 */
N    LEDPWM_Channel_11 = ( int32_t ) 0x00000800UL,	/*!< PMW output channel 11 */
N    LEDPWM_Channel_12 = ( int32_t ) 0x00001000UL,	/*!< PMW output channel 12 */
N    LEDPWM_Channel_13 = ( int32_t ) 0x00002000UL,	/*!< PMW output channel 13 */
N    LEDPWM_Channel_14 = ( int32_t ) 0x00004000UL,	/*!< PMW output channel 14 */
N    LEDPWM_Channel_15 = ( int32_t ) 0x00008000UL,	/*!< PMW output channel 15 */
N    LEDPWM_Channel_16 = ( int32_t ) 0x00010000UL,	/*!< PMW output channel 16 */
N    LEDPWM_Channel_17 = ( int32_t ) 0x00020000UL,	/*!< PMW output channel 17 */
N    LEDPWM_Channel_18 = ( int32_t ) 0x00040000UL,	/*!< PMW output channel 18 */
N    LEDPWM_Channel_19 = ( int32_t ) 0x00080000UL,	/*!< PMW output channel 19 */
N    LEDPWM_Channel_20 = ( int32_t ) 0x00100000UL,	/*!< PMW output channel 20 */
N    LEDPWM_Channel_21 = ( int32_t ) 0x00200000UL,	/*!< PMW output channel 21 */
N    LEDPWM_Channel_22 = ( int32_t ) 0x00400000UL,	/*!< PMW output channel 22 */
N    LEDPWM_Channel_23 = ( int32_t ) 0x00800000UL,	/*!< PMW output channel 23 */
N    LEDPWM_Channel_24 = ( int32_t ) 0x01000000UL,	/*!< PMW output channel 24 */
N    LEDPWM_Channel_25 = ( int32_t ) 0x02000000UL,	/*!< PMW output channel 25 */
N    LEDPWM_Channel_26 = ( int32_t ) 0x04000000UL,	/*!< PMW output channel 26 */
N    LEDPWM_Channel_27 = ( int32_t ) 0x08000000UL,	/*!< PMW output channel 27 */
N    LEDPWM_Channel_28 = ( int32_t ) 0x10000000UL,	/*!< PMW output channel 28 */
N    LEDPWM_Channel_29 = ( int32_t ) 0x20000000UL,	/*!< PMW output channel 29 */
N    LEDPWM_Channel_30 = ( int32_t ) 0x40000000UL,	/*!< PMW output channel 30 */
N    LEDPWM_Channel_31 = ( int32_t ) 0x80000000UL,	/*!< PMW output channel 31 */
N    LEDPWM_Channel_All = ( int32_t ) 0xFFFFFFFFUL, /*!< PMW output channel ALL */
N} LEDPWM_Channel_Typedef;
N
N#define IS_LEDPWM_CHANNEL(CHANNEL) (((CHANNEL) & (uint32_t)0xFFFFFF00) == 0x00)
N#elif  defined(SC32f11xx)
Stypedef enum
S{
S    LEDPWMChannel_Less = 0x00000000UL, /*!< No channels are selected */
S    LEDPWM_Channel_0 = ( int32_t ) 0x00000001UL,	/*!< PMW output channel 0 */
S    LEDPWM_Channel_1 = ( int32_t ) 0x00000002UL,	/*!< PMW output channel 1 */
S    LEDPWM_Channel_2 = ( int32_t ) 0x00000004UL,	/*!< PMW output channel 2 */
S    LEDPWM_Channel_3 = ( int32_t ) 0x00000008UL,	/*!< PMW output channel 3 */
S    LEDPWM_Channel_4 = ( int32_t ) 0x00000010UL,	/*!< PMW output channel 4 */
S    LEDPWM_Channel_5 = ( int32_t ) 0x00000020UL,	/*!< PMW output channel 5 */
S    LEDPWM_Channel_6 = ( int32_t ) 0x00000040UL,	/*!< PMW output channel 6 */
S    LEDPWM_Channel_7 = ( int32_t ) 0x00000080UL,	/*!< PMW output channel 7 */
S    LEDPWM_Channel_8 = ( int32_t ) 0x00000100UL,	/*!< PMW output channel 8 */
S    LEDPWM_Channel_9 = ( int32_t ) 0x00000200UL,	/*!< PMW output channel 9 */
S    LEDPWM_Channel_10 = ( int32_t ) 0x00000400UL,	/*!< PMW output channel 10 */
S    LEDPWM_Channel_11 = ( int32_t ) 0x00000800UL,	/*!< PMW output channel 11 */
S    LEDPWM_Channel_12 = ( int32_t ) 0x00001000UL,	/*!< PMW output channel 12 */
S    LEDPWM_Channel_13 = ( int32_t ) 0x00002000UL,	/*!< PMW output channel 13 */
S    LEDPWM_Channel_14 = ( int32_t ) 0x00004000UL,	/*!< PMW output channel 14 */
S    LEDPWM_Channel_15 = ( int32_t ) 0x00008000UL,	/*!< PMW output channel 15 */
S    LEDPWM_Channel_16 = ( int32_t ) 0x00010000UL,	/*!< PMW output channel 16 */
S    LEDPWM_Channel_17 = ( int32_t ) 0x00020000UL,	/*!< PMW output channel 17 */
S    LEDPWM_Channel_18 = ( int32_t ) 0x00040000UL,	/*!< PMW output channel 18 */
S    LEDPWM_Channel_19 = ( int32_t ) 0x00080000UL,	/*!< PMW output channel 19 */
S    LEDPWM_Channel_20 = ( int32_t ) 0x00100000UL,	/*!< PMW output channel 20 */
S    LEDPWM_Channel_21 = ( int32_t ) 0x00200000UL,	/*!< PMW output channel 21 */
S    LEDPWM_Channel_22 = ( int32_t ) 0x00400000UL,	/*!< PMW output channel 22 */
S    LEDPWM_Channel_23 = ( int32_t ) 0x00800000UL,	/*!< PMW output channel 23 */
S    LEDPWM_Channel_24 = ( int32_t ) 0x01000000UL,	/*!< PMW output channel 24 */
S    LEDPWM_Channel_25 = ( int32_t ) 0x02000000UL,	/*!< PMW output channel 25 */
S    LEDPWM_Channel_26 = ( int32_t ) 0x04000000UL,	/*!< PMW output channel 26 */
S    LEDPWM_Channel_27 = ( int32_t ) 0x08000000UL,	/*!< PMW output channel 27 */
S    LEDPWM_Channel_28 = ( int32_t ) 0x10000000UL,	/*!< PMW output channel 28 */
S    LEDPWM_Channel_29 = ( int32_t ) 0x20000000UL,	/*!< PMW output channel 29 */
S    LEDPWM_Channel_30 = ( int32_t ) 0x40000000UL,	/*!< PMW output channel 30 */
S    LEDPWM_Channel_31 = ( int32_t ) 0x80000000UL,	/*!< PMW output channel 31 */
S    LEDPWM_Channel_0_31 = ( int32_t ) 0xFFFFFFFFUL, /*!< PMW output channel ALL */
S    LEDPWM_Channel_32 = ( int32_t ) 0x80000001UL	, /*!<  PMW output channel 32 */
S    LEDPWM_Channel_33 = ( int32_t ) 0x80000002UL,	/*!< PMW output channel 33 */
S    LEDPWM_Channel_34 = ( int32_t ) 0x80000004UL	, /*!<  PMW output channel 34 */
S    LEDPWM_Channel_35 = ( int32_t ) 0x80000008UL,	/*!< PMW output channel 35 */
S    LEDPWM_Channel_36 = ( int32_t ) 0x80000010UL	, /*!<  PMW output channel 36 */
S    LEDPWM_Channel_37 = ( int32_t ) 0x80000020UL,	/*!< PMW output channel 37*/
S    LEDPWM_Channel_38 = ( int32_t ) 0x80000040UL,	/*!< PMW output channel 38*/
S    LEDPWM_Channel_32_38 = ( int32_t ) 0x8000007UL,	/*!< PMW output channel 32_38 */
S} LEDPWM_Channel_Typedef;
S
S#define IS_LEDPWM_CHANNEL(CHANNEL) (((CHANNEL) & (uint32_t)0xFFFFFF00) == 0x00)
N#endif
N/**
N * @}
N */
N
N
N/** @brief LEDPWM_IT LEDPWM Interrupt
N * @{
N */
Ntypedef enum
N{
N    LEDPWM_IT_INTEN = ( uint16_t ) LEDPWM_CON_INTEN,	/*!< LEDPWM Interrupt: LEDPWM Interrupt */
X    LEDPWM_IT_INTEN = ( uint16_t ) (0x1L << (8U)),	 
N} LEDPWM_IT_TypeDef;
N
N#define IS_LEDPWM_IT(IT) ((((IT) & (uint16_t)0xFEFF) == 0x00) && ((IT) != (uint16_t)0x0000))
N
N/**
N * @}
N */
N
N/** @brief LEDPWM_Flag LEDPWM Flag
N * @{
N */
Ntypedef enum
N{
N    LEDPWM_Flag_LEDPWMIF  = ( uint8_t ) LEDPWM_STS_PWMIF,	/*!< LEDPWM Interrupt: LEDPWM Interrupt */
X    LEDPWM_Flag_LEDPWMIF  = ( uint8_t ) (0x1L << (0U)),	 
N} LEDPWM_Flag_TypeDef;
N
N#define IS_LEDPWM_FLAG(FLAG) ((((FLAG) & (uint8_t)0xFE) == 0x00) && ((FLAG) != (uint8_t)0x00))
N
N#define IS_GET_LEDPWM_FLAG(FLAG) ((FLAG) == LEDPWM_Flag_LEDPWMIF)
N/**
N * @}
N */
N
N
N/**
N * @}
N */
N/* End of enumerations -----------------------------------------------------*/
N
N/* Exported struct ------------------------------------------------------------*/
N/** @defgroup LEDPWM_Exported_Struct LEDPWM Exported Struct
N * @{
N */
N
N/** @brief LEDPWM Time base Configuration Structure definition
N * @{
N */
Ntypedef struct
N{
N    uint16_t LEDPWM_Prescaler; /*!<  Specifies the predivision.
N																			This parameter can be a value of @ref LEDPWM_Prescaler_TypeDef */
N
N    uint16_t LEDPWM_AlignedMode; /*!< Specifies the aligne mode.
N																			This parameter can be a value of @ref LEDPWM_AlignedMode_TypeDef */
N
N    uint8_t LEDPWM_Cycle;   /*!< Specifies the cycle.
N															 */
N
N    uint64_t LEDPWM_OutputChannel; /*!< Specifies the output Channel.
N																			 This parameter can be a value of @ref LEDPWM_Channel_Typedef */
N
N    uint64_t LEDPWM_LowPolarityChannl; /*!< Specifies the low polarity Channel.
N																				 This parameter can be a value of @ref LEDPWM_Channel_Typedef */
N#if defined(SC32f11xx)
X#if 0L
S    uint32_t LEDPWM_OutputChannel0; /*!< Specifies the output Channel.
S																			 This parameter can be a value of @ref LEDPWM_Channel_Typedef */
S
S    uint64_t LEDPWM_OutputChannel1; /*!< Specifies the output Channel.
S																			 This parameter can be a value of @ref LEDPWM_Channel_Typedef */
S
S    uint64_t LEDPWM_LowPolarityChannl0; /*!< Specifies the low polarity Channel.
S																				 This parameter can be a value of @ref LEDPWM_Channel_Typedef */
S
S    uint64_t LEDPWM_LowPolarityChannl1; /*!< Specifies the low polarity Channel.
S																				 This parameter can be a value of @ref LEDPWM_Channel_Typedef */
N#endif
N} LEDPWM_InitTypeDef;
N/**
N * @}
N */
N/**
N * @}
N */
N/* End of struct -----------------------------------------------------*/
N
N/** @addtogroup LEDPWM_Functions LEDPWM Functions
N * @{
N */
N
N/* LEDPWM Base functions ********************************************************/
Nvoid LEDPWM_DeInit ( void );
Nvoid LEDPWM_StructInit ( LEDPWM_InitTypeDef* LEDPWM_InitStruct );
Nvoid LEDPWM_Init ( LEDPWM_InitTypeDef* LEDPWM_InitStruct );
Nvoid LEDPWM_Cmd ( FunctionalState NewState );
Nvoid LEDPWM_SetCycle ( uint8_t LEDPWM_Cycle );
Nuint8_t LEDPWM_GetCycle ( void );
Nvoid LEDPWM_SetPrescaler ( LEDPWM_Prescaler_TypeDef LEDPWM_Prescaler );
NLEDPWM_Prescaler_TypeDef LEDPWM_GetPrescaler ( void );
Nvoid LEDPWM_SetDuty ( LEDPWM_Channel_Typedef LEDPWM_Channel, uint8_t LEDPWM_Duty );
Nuint8_t LEDPWM_GetDuty ( LEDPWM_Channel_Typedef LEDPWM_Channel );
N
N/* Interrupt Handler functions  ***********************************************/
Nvoid LEDPWM_ITConfig ( uint16_t LEDPWM_IT, FunctionalState NewState );
NFlagStatus LEDPWM_GetFlagStatus ( uint16_t LEDPWM_FLAG );
Nvoid LEDPWM_ClearFlag ( uint16_t LEDPWM_FLAG );
N
N/**
N * @}
N */
N/* End of functions --------------------------------------------------*/
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 44 "..\FWLib\SC32F1XXX_Lib\inc\sc32_conf.h" 2
N#include "sc32f1xxx_lcd.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx_lcd.h" 1
N/**
N ******************************************************************************
N * @file    sc32f1xxx_LCD.h
N * @author  SOC AE Team
N * @version V1.5
N * @date     26-08-2024
N * @brief   Header file of LCD module.
N ******************************************************************************
N * @attention
N *
N *1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only
N *intended for use with SinOne products. No other uses are authorized. This
N *software is owned by SinOne Microelectronics Co.,Ltd. and is protected under
N *all applicable laws, including copyright laws.
N *2.The software which is for guidance only aims at providing customers with
N *coding information regarding their products in order for them to save time.
N *As a result, SinOne shall not be held liable for any direct, indirect or
N *consequential damages with respect to any claims arising from the content of
N *such software and/or the use made by customers of the coding information
N *contained herein in connection with their products.
N *
N *  COPYRIGHT 2024 SinOne Microelectronics
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __sc32f1xxx_LCD_H
N#define __sc32f1xxx_LCD_H
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "sc32f1xxx.h"
N#include "sc32.h"
N#include "sc32f1xxx_rcc.h"
N
N/** @addtogroup sc32f1xxx_StdPeriph_Driver
N * @{
N */
N
N/** @addtogroup LCD
N * @{
N */
N
N/* Exported enumerations ------------------------------------------------------------*/
N/** @defgroup LCD_Exported_Enumerations LCD Exported Enumerations
N * @{
N */
N
N/** @brief LCD_FrameFre LCD Frame Frequency
N * @{
N */
Ntypedef enum
N{
N    LCD_FrameFre_A32Hz	 = ( uint32_t ) ( ( 0x00U << DDR_CON_DDRCK_Pos ) | DDR_CON_TYPE ), /*!< The LCD/LED frame frequency of typeA is 32Hz */
X    LCD_FrameFre_A32Hz	 = ( uint32_t ) ( ( 0x00U << (8U) ) | (0x1L << (4U)) ),  
N    LCD_FrameFre_A64Hz	 = ( uint32_t ) ( ( 0x01U << DDR_CON_DDRCK_Pos ) | DDR_CON_TYPE ), /*!< The LCD/LED frame frequency of typeA is 64Hz */
X    LCD_FrameFre_A64Hz	 = ( uint32_t ) ( ( 0x01U << (8U) ) | (0x1L << (4U)) ),  
N    LCD_FrameFre_A128Hz  = ( uint32_t ) ( ( 0x02U << DDR_CON_DDRCK_Pos ) | DDR_CON_TYPE ), /*!< The LCD/LED frame frequency of typeA is 128Hz */
X    LCD_FrameFre_A128Hz  = ( uint32_t ) ( ( 0x02U << (8U) ) | (0x1L << (4U)) ),  
N    LCD_FrameFre_B64Hz	 = ( uint32_t ) ( 0x00U << DDR_CON_DDRCK_Pos ),	 /*!< The LCD/LED frame frequency of typeB is 64Hz */
X    LCD_FrameFre_B64Hz	 = ( uint32_t ) ( 0x00U << (8U) ),	  
N    LCD_FrameFre_B128Hz	 = ( uint32_t ) ( 0x01U << DDR_CON_DDRCK_Pos ), /*!< The LCD/LED frame frequency of typeB is 128Hz*/
X    LCD_FrameFre_B128Hz	 = ( uint32_t ) ( 0x01U << (8U) ),  
N    LCD_FrameFre_B256Hz	 = ( uint32_t ) ( 0x02U << DDR_CON_DDRCK_Pos ), /*!< The LCD/LED frame frequency of typeB is 256Hz*/
X    LCD_FrameFre_B256Hz	 = ( uint32_t ) ( 0x02U << (8U) ),  
N    LCD_FrameFre_ACustom	 = ( uint32_t ) ( DDR_CON_TRIMODE | DDR_CON_TYPE ),             /*!< The LCD/LED frame frequency of typeA is customized*/
X    LCD_FrameFre_ACustom	 = ( uint32_t ) ( (0x1L << (15U)) | (0x1L << (4U)) ),              
N    LCD_FrameFre_BCustom	 = ( uint32_t ) ( DDR_CON_TRIMODE ), /*!< The LCD/LED frame frequency of typeB is customized*/
X    LCD_FrameFre_BCustom	 = ( uint32_t ) ( (0x1L << (15U)) ),  
N} LCD_FrameFre_TypeDef;
N
N#define IS_LCD_FRAMEFRE(FRAMEFRE) (((FRAMEFRE) == LCD_FrameFre_A32Hz) || \
N                                      ((FRAMEFRE) == LCD_FrameFre_A64Hz) || \
N                                      ((FRAMEFRE) == LCD_FrameFre_A128Hz) || \
N                                      ((FRAMEFRE) == LCD_FrameFre_B64Hz) || \
N                                      ((FRAMEFRE) == LCD_FrameFre_B128Hz) || \
N                                      ((FRAMEFRE) == LCD_FrameFre_B256Hz) || \
N                                      ((FRAMEFRE) == LCD_FrameFre_B128Hz) || \
N                                      ((FRAMEFRE) == LCD_FrameFre_B256Hz))
X#define IS_LCD_FRAMEFRE(FRAMEFRE) (((FRAMEFRE) == LCD_FrameFre_A32Hz) ||                                       ((FRAMEFRE) == LCD_FrameFre_A64Hz) ||                                       ((FRAMEFRE) == LCD_FrameFre_A128Hz) ||                                       ((FRAMEFRE) == LCD_FrameFre_B64Hz) ||                                       ((FRAMEFRE) == LCD_FrameFre_B128Hz) ||                                       ((FRAMEFRE) == LCD_FrameFre_B256Hz) ||                                       ((FRAMEFRE) == LCD_FrameFre_B128Hz) ||                                       ((FRAMEFRE) == LCD_FrameFre_B256Hz))
N/**
N * @}
N */
N
N
N
N/** @brief LCD_Duty LCD DUTY
N * @{
N */
N#if defined(SC32f10xx) || defined(SC32f12xx)
X#if 1L || 0L
Ntypedef enum
N{
N    LCD_Duty_1_8 = ( uint32_t ) ( 0x00U << DDR_CFG_DUTY_Pos ),		/*!< LCD/LED display duty cycle: 1/8    */
X    LCD_Duty_1_8 = ( uint32_t ) ( 0x00U << (4U) ),		 
N    LCD_Duty_1_6 = ( uint32_t ) ( 0x01U << DDR_CFG_DUTY_Pos ),		/*!< LCD/LED display duty cycle: 1/6    */
X    LCD_Duty_1_6 = ( uint32_t ) ( 0x01U << (4U) ),		 
N    LCD_Duty_1_5 = ( uint32_t ) ( 0x02U << DDR_CFG_DUTY_Pos ),		/*!< LCD/LED display duty cycle: 1/5    */
X    LCD_Duty_1_5 = ( uint32_t ) ( 0x02U << (4U) ),		 
N    LCD_Duty_1_4_SEG0_27COM4_7
N        = ( uint32_t ) ( 0x03U << DDR_CFG_DUTY_Pos ),								/*!< LCD/LED display duty cycle: 1/4    */
X        = ( uint32_t ) ( 0x03U << (4U) ),								 
N    LCD_Duty_1_4_SEG4_27COM0_3
N        = ( uint32_t ) ( ( 0x03U << DDR_CFG_DUTY_Pos ) | DDR_CFG_SCS ),		/*!< LCD/LED display duty cycle: 1/4    */
X        = ( uint32_t ) ( ( 0x03U << (4U) ) | (0x1L << (7U)) ),		 
N} LCD_Duty_TypeDef;
N
N#define IS_LCD_DUTY(DUTY) (((DUTY) == LCD_Duty_1_8) ||   \
N																((DUTY) == LCD_Duty_1_6) ||   \
N																((DUTY) == LCD_Duty_1_5) ||   \
N																((DUTY) == LCD_Duty_1_4_SEG0_27COM4_7) ||   \
N																((DUTY) == LCD_Duty_1_4_SEG4_27COM0_3))
X#define IS_LCD_DUTY(DUTY) (((DUTY) == LCD_Duty_1_8) ||   																((DUTY) == LCD_Duty_1_6) ||   																((DUTY) == LCD_Duty_1_5) ||   																((DUTY) == LCD_Duty_1_4_SEG0_27COM4_7) ||   																((DUTY) == LCD_Duty_1_4_SEG4_27COM0_3))
N#elif defined(SC32f11xx)
Stypedef enum
S{
S    LCD_Duty_1_8 = ( uint32_t ) ( 0x00U << DDR_CFG_DUTY_Pos ),		/*!< LCD/LED display duty cycle: 1/8    */
S    LCD_Duty_1_6 = ( uint32_t ) ( 0x01U << DDR_CFG_DUTY_Pos ),		/*!< LCD/LED display duty cycle: 1/6    */
S    LCD_Duty_1_5 = ( uint32_t ) ( 0x02U << DDR_CFG_DUTY_Pos ),		/*!< LCD/LED display duty cycle: 1/5    */
S    LCD_Duty_1_4_SEG0_34COM4_7
S        = ( uint32_t ) ( 0x03U << DDR_CFG_DUTY_Pos ),								/*!< LCD/LED display duty cycle: 1/4    */
S    LCD_Duty_1_4_SEG4_34COM0_3
S        = ( uint32_t ) ( ( 0x03U << DDR_CFG_DUTY_Pos ) | DDR_CFG_SCS ),		/*!< LCD/LED display duty cycle: 1/4    */
S} LCD_Duty_TypeDef;
S
S#define IS_LCD_DUTY(DUTY) (((DUTY) == LCD_Duty_1_8) ||   \
S																((DUTY) == LCD_Duty_1_6) ||   \
S																((DUTY) == LCD_Duty_1_5) ||   \
S																((DUTY) == LCD_Duty_1_4_SEG0_34COM4_7) ||   \
S																((DUTY) == LCD_Duty_1_4_SEG4_34COM0_3))
X#define IS_LCD_DUTY(DUTY) (((DUTY) == LCD_Duty_1_8) ||   																((DUTY) == LCD_Duty_1_6) ||   																((DUTY) == LCD_Duty_1_5) ||   																((DUTY) == LCD_Duty_1_4_SEG0_34COM4_7) ||   																((DUTY) == LCD_Duty_1_4_SEG4_34COM0_3))
N#endif
N/**
N * @}
N */
N
N/** @brief LCD_Bias  LCD Bias Voltage
N * @{
N */
Ntypedef enum
N{
N    LCD_Bias_1_4 = ( uint32_t ) ( 0x00U << DDR_CON_BIAS_Pos ), /*!< Display drive bias voltage Settings:1/3 */
X    LCD_Bias_1_4 = ( uint32_t ) ( 0x00U << (1U) ),  
N    LCD_Bias_1_3 = ( uint32_t ) ( 0x01U << DDR_CON_BIAS_Pos ), /*!< Display drive bias voltage Settings:1/4 */
X    LCD_Bias_1_3 = ( uint32_t ) ( 0x01U << (1U) ),  
N} LCD_Bias_TypeDef;
N
N#define IS_LCD_BIAS(BIAS) (((BIAS) == LCD_Bias_1_3) || \
N												   ((BIAS) == LCD_Bias_1_4))
X#define IS_LCD_BIAS(BIAS) (((BIAS) == LCD_Bias_1_3) || 												   ((BIAS) == LCD_Bias_1_4))
N/**
N * @}
N */
N
N/** @brief LCD_VOIRSIF LCD Quick Charge State
N * @{
N */
Ntypedef enum
N{
N    LCD_VOIRSIF_Disable = ( uint32_t ) ( 0x00U << DDR_CON_VOIRSF_Pos ), /*!< Quick charge: Disable */
X    LCD_VOIRSIF_Disable = ( uint32_t ) ( 0x00U << (3U) ),  
N    LCD_VOIRSIF_Enable = ( uint32_t ) ( 0x01U << DDR_CON_VOIRSF_Pos ), /*!< Quick charge: Enable */
X    LCD_VOIRSIF_Enable = ( uint32_t ) ( 0x01U << (3U) ),  
N} LCD_VOIRSIF_TypeDef;
N
N#define IS_LCD_VOIRSIF(VOIRSIF) (((VOIRSIF) == LCD_VOIRSIF_DISABLE) || \
N												        ((VOIRSIF) == LCD_VOIRSIF_ENABLE))
X#define IS_LCD_VOIRSIF(VOIRSIF) (((VOIRSIF) == LCD_VOIRSIF_DISABLE) || 												        ((VOIRSIF) == LCD_VOIRSIF_ENABLE))
N/**
N * @}
N */
N
N/** @brief LCD_ResSel LCD resistor select
N * @{
N */
Ntypedef enum
N{
N    LCD_ResSel_33K  = ( uint8_t ) ( 0x00U << DDR_CON_VOIRSF_Pos ), /*!< LCD voltage outlet voltage divider resistor:33K */
X    LCD_ResSel_33K  = ( uint8_t ) ( 0x00U << (3U) ),  
N    LCD_ResSel_100K = ( uint8_t ) ( 0x01U << DDR_CON_VOIRSF_Pos ), /*!< LCD voltage outlet voltage divider resistor:100K */
X    LCD_ResSel_100K = ( uint8_t ) ( 0x01U << (3U) ),  
N    LCD_ResSel_300K = ( uint8_t ) ( 0x02U << DDR_CON_VOIRSF_Pos ),	/*!< LCD voltage outlet voltage divider resistor:300K */
X    LCD_ResSel_300K = ( uint8_t ) ( 0x02U << (3U) ),	 
N    LCD_ResSel_800K = ( uint8_t ) ( 0x03U << DDR_CON_VOIRSF_Pos ), /*!< LCD voltage outlet voltage divider resistor:800K */
X    LCD_ResSel_800K = ( uint8_t ) ( 0x03U << (3U) ),  
N} LCD_ResSel_TypeDef;
N
N#define IS_LCD_RESSEL(RES) (((RES) == LCD_ResSel_33K) || \
N                            ((RES) == LCD_ResSel_100K) || \
N                            ((RES) == LCD_ResSel_300K) || \
N													  ((RES) == LCD_ResSel_800K))
X#define IS_LCD_RESSEL(RES) (((RES) == LCD_ResSel_33K) ||                             ((RES) == LCD_ResSel_100K) ||                             ((RES) == LCD_ResSel_300K) || 													  ((RES) == LCD_ResSel_800K))
N/**
N * @}
N */
N
N/** @brief LCD_Channel
N * @{
N */
N#if defined(SC32f10xx) || defined(SC32f12xx)
X#if 1L || 0L
Ntypedef enum
N{
N    LCD_Channel_Less = ( int32_t ) 0x00000000U,	/*!< PMW output channel 0 */
N    LCD_Channel_0 = ( int32_t ) 0x00000001U,	/*!< PMW output channel 0 */
N    LCD_Channel_1 = ( int32_t ) 0x00000002U,	/*!< PMW output channel 1 */
N    LCD_Channel_2 = ( int32_t ) 0x00000004U,	/*!< PMW output channel 2 */
N    LCD_Channel_3 = ( int32_t ) 0x00000008U,	/*!< PMW output channel 3 */
N    LCD_Channel_4 = ( int32_t ) 0x00000010U,	/*!< PMW output channel 4 */
N    LCD_Channel_5 = ( int32_t ) 0x00000020U,	/*!< PMW output channel 5 */
N    LCD_Channel_6 = ( int32_t ) 0x00000040U,	/*!< PMW output channel 6 */
N    LCD_Channel_7 = ( int32_t ) 0x00000080U,	/*!< PMW output channel 7 */
N    LCD_Channel_8 = ( int32_t ) 0x00000100U,	/*!< PMW output channel 8 */
N    LCD_Channel_9 = ( int32_t ) 0x00000200U,	/*!< PMW output channel 9 */
N    LCD_Channel_10 = ( int32_t ) 0x00000400U, /*!< PMW output channel 10 */
N    LCD_Channel_11 = ( int32_t ) 0x00000800U, /*!< PMW output channel 11 */
N    LCD_Channel_12 = ( int32_t ) 0x00001000U, /*!< PMW output channel 12 */
N    LCD_Channel_13 = ( int32_t ) 0x00002000U, /*!< PMW output channel 13 */
N    LCD_Channel_14 = ( int32_t ) 0x00004000U, /*!< PMW output channel 14 */
N    LCD_Channel_15 = ( int32_t ) 0x00008000U, /*!< PMW output channel 15 */
N    LCD_Channel_16 = ( int32_t ) 0x00010000U, /*!< PMW output channel 16 */
N    LCD_Channel_17 = ( int32_t ) 0x00020000U, /*!< PMW output channel 17 */
N    LCD_Channel_18 = ( int32_t ) 0x00040000U, /*!< PMW output channel 18 */
N    LCD_Channel_19 = ( int32_t ) 0x00080000U, /*!< PMW output channel 19 */
N    LCD_Channel_20 = ( int32_t ) 0x00100000U, /*!< PMW output channel 20 */
N    LCD_Channel_21 = ( int32_t ) 0x00200000U, /*!< PMW output channel 21 */
N    LCD_Channel_22 = ( int32_t ) 0x00400000U, /*!< PMW output channel 22 */
N    LCD_Channel_23 = ( int32_t ) 0x00800000U, /*!< PMW output channel 23 */
N    LCD_Channel_24 = ( int32_t ) 0x01000000U, /*!< PMW output channel 24 */
N    LCD_Channel_25 = ( int32_t ) 0x02000000U, /*!< PMW output channel 25 */
N    LCD_Channel_26 = ( int32_t ) 0x04000000U, /*!< PMW output channel 26 */
N    LCD_Channel_27 = ( int32_t ) 0x08000000U, /*!< PMW output channel 27 */
N    LCD_Channel_28 = ( int32_t ) 0x10000000U, /*!< PMW output channel 28 */
N    LCD_Channel_29 = ( int32_t ) 0x20000000U, /*!< PMW output channel 29 */
N    LCD_Channel_30 = ( int32_t ) 0x40000000U, /*!< PMW output channel 30 */
N    LCD_Channel_31 = ( int32_t ) 0x80000000U, /*!< PMW output channel 31 */
N} LCD_Channel_Typedef;
N
N
N#define IS_LCD_Channel(Channel) ((Channel) <= (LCD_Channel_All))
N#elif defined(SC32f11xx)
Stypedef enum
S{
S    LCD_Channel_Less = ( int32_t ) 0x00000000U,	/*!< LCD output channel 0 */
S    LCD_Channel_0 = ( int32_t ) 0x00000001U,
S    LCD_Channel_1 = ( int32_t ) 0x00000002U,
S    LCD_Channel_2 = ( int32_t ) 0x00000004U,
S    LCD_Channel_3 = ( int32_t ) 0x00000008U,
S    LCD_Channel_4 = ( int32_t ) 0x00000010U,
S    LCD_Channel_5 = ( int32_t ) 0x00000020U,
S    LCD_Channel_6 = ( int32_t ) 0x00000040U,
S    LCD_Channel_7 = ( int32_t ) 0x00000080U,
S    LCD_Channel_8 = ( int32_t ) 0x00000100U,
S    LCD_Channel_9 = ( int32_t ) 0x00000200U,
S    LCD_Channel_10 = ( int32_t ) 0x00000400U,
S    LCD_Channel_11 = ( int32_t ) 0x00000800U,
S    LCD_Channel_12 = ( int32_t ) 0x00001000U,
S    LCD_Channel_13 = ( int32_t ) 0x00002000U,
S    LCD_Channel_14 = ( int32_t ) 0x00004000U,
S    LCD_Channel_15 = ( int32_t ) 0x00008000U,
S    LCD_Channel_16 = ( int32_t ) 0x00010000U,
S    LCD_Channel_17 = ( int32_t ) 0x00020000U,
S    LCD_Channel_18 = ( int32_t ) 0x00040000U,
S    LCD_Channel_19 = ( int32_t ) 0x00080000U,
S    LCD_Channel_20 = ( int32_t ) 0x00100000U,
S    LCD_Channel_21 = ( int32_t ) 0x00200000U,
S    LCD_Channel_22 = ( int32_t ) 0x00400000U,
S    LCD_Channel_23 = ( int32_t ) 0x00800000U,
S    LCD_Channel_24 = ( int32_t ) 0x01000000U,
S    LCD_Channel_25 = ( int32_t ) 0x02000000U,
S    LCD_Channel_26 = ( int32_t ) 0x04000000U,
S    LCD_Channel_27 = ( int32_t ) 0x08000000U,
S    LCD_Channel_28 = ( int32_t ) 0x10000000U,
S    LCD_Channel_29 = ( int32_t ) 0x20000000U,
S    LCD_Channel_30 = ( int32_t ) 0x40000000U,
S    LCD_Channel_31 = ( int32_t ) 0x80000000U,
S} LCD_Channel_Typedef;
S#define LCD_Channel_32 (uint64_t)0x100000000
S#define LCD_Channel_33 (uint64_t)0x200000000
S#define LCD_Channel_34 (uint64_t)0x400000000
S#define IS_LCD_Channel(Channel) ((Channel) <= (LCD_Channel_All))
S
N#endif
N/**
N * @}
N */
N
N/** @brief LCD_RAMRegister
N * @{
N */
N#if defined(SC32f10xx) || defined(SC32f12xx)
X#if 1L || 0L
Ntypedef enum
N{
N    LCD_RAMRegister_0 = 0x00000000U,
N    LCD_RAMRegister_1 = 0x00000001U,
N    LCD_RAMRegister_2 = 0x00000002U,
N    LCD_RAMRegister_3 = 0x00000003U,
N    LCD_RAMRegister_4 = 0x00000004U,
N    LCD_RAMRegister_5 = 0x00000005U,
N    LCD_RAMRegister_6 = 0x00000006U,
N    LCD_RAMRegister_7 = 0x00000007U,
N    LCD_RAMRegister_8 = 0x00000008U,
N    LCD_RAMRegister_9 = 0x00000009U,
N    LCD_RAMRegister_10 = 0x0000000AU,
N    LCD_RAMRegister_11 = 0x0000000BU,
N    LCD_RAMRegister_12 = 0x0000000CU,
N    LCD_RAMRegister_13 = 0x0000000DU,
N    LCD_RAMRegister_14 = 0x0000000EU,
N    LCD_RAMRegister_15 = 0x0000000FU,
N    LCD_RAMRegister_16 = 0x00000010U,
N    LCD_RAMRegister_17 = 0x00000011U,
N    LCD_RAMRegister_18 = 0x00000012U,
N    LCD_RAMRegister_19 = 0x00000013U,
N    LCD_RAMRegister_20 = 0x00000014U,
N    LCD_RAMRegister_21 = 0x00000015U,
N    LCD_RAMRegister_22 = 0x00000016U,
N    LCD_RAMRegister_23 = 0x00000017U,
N    LCD_RAMRegister_24 = 0x00000018U,
N    LCD_RAMRegister_25 = 0x00000019U,
N    LCD_RAMRegister_26 = 0x0000001AU,
N    LCD_RAMRegister_27 = 0x0000001BU,
N} LCD_RAMRegister_Typedef;
N
N#define IS_LCD_RAM_REGISTER(REGISTER) ((REGISTER) <= (LCD_RAMRegister27))
N#elif defined(SC32f11xx)
Stypedef enum
S{
S    LCD_RAMRegister_0 = 0x00000000U,
S    LCD_RAMRegister_1 = 0x00000001U,
S    LCD_RAMRegister_2 = 0x00000002U,
S    LCD_RAMRegister_3 = 0x00000003U,
S    LCD_RAMRegister_4 = 0x00000004U,
S    LCD_RAMRegister_5 = 0x00000005U,
S    LCD_RAMRegister_6 = 0x00000006U,
S    LCD_RAMRegister_7 = 0x00000007U,
S    LCD_RAMRegister_8 = 0x00000008U,
S    LCD_RAMRegister_9 = 0x00000009U,
S    LCD_RAMRegister_10 = 0x0000000AU,
S    LCD_RAMRegister_11 = 0x0000000BU,
S    LCD_RAMRegister_12 = 0x0000000CU,
S    LCD_RAMRegister_13 = 0x0000000DU,
S    LCD_RAMRegister_14 = 0x0000000EU,
S    LCD_RAMRegister_15 = 0x0000000FU,
S    LCD_RAMRegister_16 = 0x00000010U,
S    LCD_RAMRegister_17 = 0x00000011U,
S    LCD_RAMRegister_18 = 0x00000012U,
S    LCD_RAMRegister_19 = 0x00000013U,
S    LCD_RAMRegister_20 = 0x00000014U,
S    LCD_RAMRegister_21 = 0x00000015U,
S    LCD_RAMRegister_22 = 0x00000016U,
S    LCD_RAMRegister_23 = 0x00000017U,
S    LCD_RAMRegister_24 = 0x00000018U,
S    LCD_RAMRegister_25 = 0x00000019U,
S    LCD_RAMRegister_26 = 0x0000001AU,
S    LCD_RAMRegister_27 = 0x0000001BU,
S    LCD_RAMRegister_28 = 0x0000001CU,
S    LCD_RAMRegister_29 = 0x0000001DU,
S    LCD_RAMRegister_30 = 0x0000001EU,
S    LCD_RAMRegister_31 = 0x0000001FU,
S    LCD_RAMRegister_32 = 0x00000020U,
S    LCD_RAMRegister_33 = 0x00000021U,
S    LCD_RAMRegister_34 = 0x00000022U,
S
S} LCD_RAMRegister_Typedef;
S#define IS_LCD_RAM_REGISTER(REGISTER) ((REGISTER) <= (LCD_RAMRegister_34))
N#endif
N
Ntypedef enum
N{
N    LCD_COMEN_0 = 0x00000001U,
N    LCD_COMEN_1 = 0x00000002U,
N    LCD_COMEN_2 = 0x00000004U,
N    LCD_COMEN_3 = 0x00000008U,
N    LCD_COMEN_4 = 0x00000010U,
N    LCD_COMEN_5 = 0x00000020U,
N    LCD_COMEN_6 = 0x00000040U,
N    LCD_COMEN_7 = 0x00000080U,
N} LCD_COMEN_Typedef;
N
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N/* End of enumerations -----------------------------------------------------*/
N
N/* Exported struct ------------------------------------------------------------*/
N/** @defgroup LCD_Exported_Struct LCD Exported Struct
N * @{
N */
N
N/** @brief LCD Display Init structure definition
N * @{
N */
Ntypedef struct
N{
N    uint16_t LCD_FrameFre;				/*!< Specifies the frame frequency.
N																			This parameter can be a value of @ref LCD_FrameFre_TypeDef */
N
N    uint16_t LCD_Duty;						/*!< Specifies the display duty cycle.
N																			This parameter can be a value of @ref LCD_Duty_TypeDef */
N
N    uint16_t LCD_VOIRSIF;		/*!<  Specifies whether LCD VOIRSIF is enabled or disabled.
N																			This parameter can be a value of @ref LCD_VOIRSIF_TypeDef */
N
N    uint16_t LCD_Bias;						/*!<  Specifies the bias voltage.
N																			This parameter can be a value of @ref LCD_Bias_TypeDef */
N
N    uint16_t LCD_ResSel;						/*!<  Specifies the voltage outlet voltage divider resistor.
N																				This parameter can be a value of @ref LCD_ResSel_TypeDef */
N
N    uint16_t LCD_Voltage;						/*!<  Specifies the voltage.
N																				The VLCD is computed using the following formula:
N																				VLCD = VDD*(17+VLCD[3:0]/32) */
N
N    uint32_t LCD_ComPin;						/*!< Specifies the Com Pin.
N																				Each bit represents a Seg channel,Support 8 channels.*/
N#if defined (SC32f10xx) || defined(SC32f12xx)
X#if 1L || 0L
N    uint32_t LCD_SegPin;						/*!< Specifies the Seg Pin.
N																				Each bit represents a Seg channel,Support 28 channels.*/
N#elif defined (SC32f11xx)
S    uint64_t LCD_SegPin;            /*!< Specifies the Seg Pin.
S																				Each bit represents a Seg channel,Support 35 channels.*/
N#endif
N} LCD_InitTypeDef;
N/**
N * @}
N */
N
N/**
N * @}
N */
N/* End of struct -----------------------------------------------------*/
N
N/** @addtogroup LCD_Exported_Functions LCD Exported Functions
N * @{
N */
N
N/* Initialization and Configuration functions ***********************************************/
Nvoid LCD_DeInit ( void );
Nvoid LCD_Init ( LCD_InitTypeDef* LCD_InitStruct );
Nvoid LCD_StructInit ( LCD_InitTypeDef* LCD_InitStruct );
Nvoid LCD_Cmd ( FunctionalState NewState );
N
N/* Initialization and Configuration functions ***********************************************/
Nvoid LCD_COMConfig ( LCD_COMEN_Typedef COMSelect, FunctionalState NewState );
Nvoid LCD_SEGConfig ( uint64_t SEGSelect, FunctionalState NewState );
Nvoid LCD_Write ( LCD_RAMRegister_Typedef LCD_RAMRegister, uint8_t LCD_Data );
Nvoid LCD_CustomModeScan ( void );
N
N/**
N * @}
N */
N/* End of exported functions --------------------------------------------------*/
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 45 "..\FWLib\SC32F1XXX_Lib\inc\sc32_conf.h" 2
N#include "sc32f1xxx_led.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx_led.h" 1
N/**
N ******************************************************************************
N * @file    sc32f1xxx_LED.h
N * @author  SOC AE Team
N * @version V1.5
N * @date     26-08-2024
N * @brief   Header file of LED module.
N ******************************************************************************
N * @attention
N *
N *1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only
N *intended for use with SinOne products. No other uses are authorized. This
N *software is owned by SinOne Microelectronics Co.,Ltd. and is protected under
N *all applicable laws, including copyright laws.
N *2.The software which is for guidance only aims at providing customers with
N *coding information regarding their products in order for them to save time.
N *As a result, SinOne shall not be held liable for any direct, indirect or
N *consequential damages with respect to any claims arising from the content of
N *such software and/or the use made by customers of the coding information
N *contained herein in connection with their products.
N *
N *  COPYRIGHT 2024 SinOne Microelectronics
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __sc32f1xxx_LED_H
N#define __sc32f1xxx_LED_H
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "sc32f1xxx.h"
N#include "sc32.h"
N#include "sc32f1xxx_rcc.h"
N
N/** @addtogroup sc32f1xxx_StdPeriph_Driver
N * @{
N */
N
N/** @addtogroup LED
N * @{
N */
N
N/* Exported enumerations ------------------------------------------------------------*/
N/** @defgroup LED_Exported_Enumerations LED Exported Enumerations
N * @{
N */
N
N/** @brief LED_FrameFre LED Frame Frequency
N * @{
N */
Ntypedef enum
N{
N    LED_FrameFre_A32Hz	 = ( uint32_t ) ( ( 0x00U << DDR_CON_DDRCK_Pos ) | DDR_CON_TYPE ), /*!< The LED/LED frame frequency of typeA is 32Hz */
X    LED_FrameFre_A32Hz	 = ( uint32_t ) ( ( 0x00U << (8U) ) | (0x1L << (4U)) ),  
N    LED_FrameFre_A64Hz	 = ( uint32_t ) ( ( 0x01U << DDR_CON_DDRCK_Pos ) | DDR_CON_TYPE ), /*!< The LED/LED frame frequency of typeA is 64Hz */
X    LED_FrameFre_A64Hz	 = ( uint32_t ) ( ( 0x01U << (8U) ) | (0x1L << (4U)) ),  
N    LED_FrameFre_A128Hz  = ( uint32_t ) ( ( 0x02U << DDR_CON_DDRCK_Pos ) | DDR_CON_TYPE ), /*!< The LED/LED frame frequency of typeA is 128Hz */
X    LED_FrameFre_A128Hz  = ( uint32_t ) ( ( 0x02U << (8U) ) | (0x1L << (4U)) ),  
N    LED_FrameFre_B64Hz	 = ( uint32_t ) ( 0x00U << DDR_CON_DDRCK_Pos ),	 /*!< The LED/LED frame frequency of typeB is 64Hz */
X    LED_FrameFre_B64Hz	 = ( uint32_t ) ( 0x00U << (8U) ),	  
N    LED_FrameFre_B128Hz	 = ( uint32_t ) ( 0x01U << DDR_CON_DDRCK_Pos ), /*!< The LED/LED frame frequency of typeB is 128Hz*/
X    LED_FrameFre_B128Hz	 = ( uint32_t ) ( 0x01U << (8U) ),  
N    LED_FrameFre_B256Hz	 = ( uint32_t ) ( 0x02U << DDR_CON_DDRCK_Pos ), /*!< The LED/LED frame frequency of typeB is 256Hz*/
X    LED_FrameFre_B256Hz	 = ( uint32_t ) ( 0x02U << (8U) ),  
N    LED_FrameFre_ACustom	 = ( uint32_t ) ( DDR_CON_TRIMODE | DDR_CON_TYPE ),             /*!< The LED/LED frame frequency of typeA is customized*/
X    LED_FrameFre_ACustom	 = ( uint32_t ) ( (0x1L << (15U)) | (0x1L << (4U)) ),              
N    LED_FrameFre_BCustom	 = ( uint32_t ) ( DDR_CON_TRIMODE ), /*!< The LED/LED frame frequency of typeB is customized*/
X    LED_FrameFre_BCustom	 = ( uint32_t ) ( (0x1L << (15U)) ),  
N} LED_FrameFre_TypeDef;
N
N#define IS_LED_FRAMEFRE(FRAMEFRE) (((FRAMEFRE) == LED_FrameFre_A32Hz) || \
N                                      ((FRAMEFRE) == LED_FrameFre_A64Hz) || \
N                                      ((FRAMEFRE) == LED_FrameFre_A128Hz) || \
N                                      ((FRAMEFRE) == LED_FrameFre_B64Hz) || \
N                                      ((FRAMEFRE) == LED_FrameFre_B128Hz) || \
N                                      ((FRAMEFRE) == LED_FrameFre_B256Hz) || \
N                                      ((FRAMEFRE) == LED_FrameFre_B128Hz) || \
N                                      ((FRAMEFRE) == LED_FrameFre_B256Hz))
X#define IS_LED_FRAMEFRE(FRAMEFRE) (((FRAMEFRE) == LED_FrameFre_A32Hz) ||                                       ((FRAMEFRE) == LED_FrameFre_A64Hz) ||                                       ((FRAMEFRE) == LED_FrameFre_A128Hz) ||                                       ((FRAMEFRE) == LED_FrameFre_B64Hz) ||                                       ((FRAMEFRE) == LED_FrameFre_B128Hz) ||                                       ((FRAMEFRE) == LED_FrameFre_B256Hz) ||                                       ((FRAMEFRE) == LED_FrameFre_B128Hz) ||                                       ((FRAMEFRE) == LED_FrameFre_B256Hz))
N/**
N * @}
N */
N
N
N
N/** @brief LED_Duty LED Duty
N * @{
N */
N#if defined(SC32f10xx) || defined(SC32f12xx)
X#if 1L || 0L
Ntypedef enum
N{
N    LED_Duty_1_8 = ( uint32_t ) ( 0x00U << DDR_CFG_DUTY_Pos ),		/*!< LED/LED display duty cycle: 1/8    */
X    LED_Duty_1_8 = ( uint32_t ) ( 0x00U << (4U) ),		 
N    LED_Duty_1_6 = ( uint32_t ) ( 0x01U << DDR_CFG_DUTY_Pos ),		/*!< LED/LED display duty cycle: 1/6    */
X    LED_Duty_1_6 = ( uint32_t ) ( 0x01U << (4U) ),		 
N    LED_Duty_1_5 = ( uint32_t ) ( 0x02U << DDR_CFG_DUTY_Pos ),		/*!< LED/LED display duty cycle: 1/5    */
X    LED_Duty_1_5 = ( uint32_t ) ( 0x02U << (4U) ),		 
N    LED_Duty_1_4_SEG0_27COM4_7
N        = ( uint32_t ) ( 0x03U << DDR_CFG_DUTY_Pos ),								/*!< LED/LED display duty cycle: 1/4    */
X        = ( uint32_t ) ( 0x03U << (4U) ),								 
N    LED_Duty_1_4_SEG4_27COM0_3
N        = ( uint32_t ) ( ( 0x03U << DDR_CFG_DUTY_Pos ) | DDR_CFG_SCS ),		/*!< LED/LED display duty cycle: 1/4    */
X        = ( uint32_t ) ( ( 0x03U << (4U) ) | (0x1L << (7U)) ),		 
N} LED_Duty_TypeDef;
N
N#define IS_LED_DUTY(DUTY) (((DUTY) == LED_Duty_1_8) ||   \
N													((DUTY) == LED_Duty_1_6) ||   \
N													((DUTY) == LED_Duty_1_5) ||   \
N													((DUTY) == LED_Duty_1_4_SEG0_27COM4_7) ||   \
N													((DUTY) == LED_Duty_1_4_SEG4_27COM0_3))
X#define IS_LED_DUTY(DUTY) (((DUTY) == LED_Duty_1_8) ||   													((DUTY) == LED_Duty_1_6) ||   													((DUTY) == LED_Duty_1_5) ||   													((DUTY) == LED_Duty_1_4_SEG0_27COM4_7) ||   													((DUTY) == LED_Duty_1_4_SEG4_27COM0_3))
N#elif defined(SC32f11xx)
Stypedef enum
S{
S    LED_Duty_1_8 = ( uint32_t ) ( 0x00U << DDR_CFG_DUTY_Pos ),		/*!< LED/LED display duty cycle: 1/8    */
S    LED_Duty_1_6 = ( uint32_t ) ( 0x01U << DDR_CFG_DUTY_Pos ),		/*!< LED/LED display duty cycle: 1/6    */
S    LED_Duty_1_5 = ( uint32_t ) ( 0x02U << DDR_CFG_DUTY_Pos ),		/*!< LED/LED display duty cycle: 1/5    */
S    LED_Duty_1_4_SEG0_34COM4_7
S        = ( uint32_t ) ( 0x03U << DDR_CFG_DUTY_Pos ),								/*!< LED/LED display duty cycle: 1/4    */
S    LED_Duty_1_4_SEG4_34COM0_3
S        = ( uint32_t ) ( ( 0x03U << DDR_CFG_DUTY_Pos ) | DDR_CFG_SCS ),		/*!< LED/LED display duty cycle: 1/4    */
S} LED_Duty_TypeDef;
S
S#define IS_LED_DUTY(DUTY) (((DUTY) == LED_Duty_1_8) ||   \
S													((DUTY) == LED_Duty_1_6) ||   \
S													((DUTY) == LED_Duty_1_5) ||   \
S													((DUTY) == LED_Duty_1_4_SEG0_34COM4_7) ||   \
S													((DUTY) == LED_Duty_1_4_SEG4_34COM0_3))
X#define IS_LED_DUTY(DUTY) (((DUTY) == LED_Duty_1_8) ||   													((DUTY) == LED_Duty_1_6) ||   													((DUTY) == LED_Duty_1_5) ||   													((DUTY) == LED_Duty_1_4_SEG0_34COM4_7) ||   													((DUTY) == LED_Duty_1_4_SEG4_34COM0_3))
N#endif
N/**
N * @}
N */
N
N
N/** @brief  LED_Channel
N * @{
N */
N#if defined(SC32f10xx) || defined(SC32f12xx)
X#if 1L || 0L
Ntypedef enum
N{
N    LED_Channel_Less = ( int32_t ) 0x00000000U,	/*!< PMW output channel 0 */
N    LED_Channel_0 = ( int32_t ) 0x00000001U,	/*!< PMW output channel 0 */
N    LED_Channel_1 = ( int32_t ) 0x00000002U,	/*!< PMW output channel 1 */
N    LED_Channel_2 = ( int32_t ) 0x00000004U,	/*!< PMW output channel 2 */
N    LED_Channel_3 = ( int32_t ) 0x00000008U,	/*!< PMW output channel 3 */
N    LED_Channel_4 = ( int32_t ) 0x00000010U,	/*!< PMW output channel 4 */
N    LED_Channel_5 = ( int32_t ) 0x00000020U,	/*!< PMW output channel 5 */
N    LED_Channel_6 = ( int32_t ) 0x00000040U,	/*!< PMW output channel 6 */
N    LED_Channel_7 = ( int32_t ) 0x00000080U,	/*!< PMW output channel 7 */
N    LED_Channel_8 = ( int32_t ) 0x00000100U,	/*!< PMW output channel 8 */
N    LED_Channel_9 = ( int32_t ) 0x00000200U,	/*!< PMW output channel 9 */
N    LED_Channel_10 = ( int32_t ) 0x00000400U, /*!< PMW output channel 10 */
N    LED_Channel_11 = ( int32_t ) 0x00000800U, /*!< PMW output channel 11 */
N    LED_Channel_12 = ( int32_t ) 0x00001000U, /*!< PMW output channel 12 */
N    LED_Channel_13 = ( int32_t ) 0x00002000U, /*!< PMW output channel 13 */
N    LED_Channel_14 = ( int32_t ) 0x00004000U, /*!< PMW output channel 14 */
N    LED_Channel_15 = ( int32_t ) 0x00008000U, /*!< PMW output channel 15 */
N    LED_Channel_16 = ( int32_t ) 0x00010000U, /*!< PMW output channel 16 */
N    LED_Channel_17 = ( int32_t ) 0x00020000U, /*!< PMW output channel 17 */
N    LED_Channel_18 = ( int32_t ) 0x00040000U, /*!< PMW output channel 18 */
N    LED_Channel_19 = ( int32_t ) 0x00080000U, /*!< PMW output channel 19 */
N    LED_Channel_20 = ( int32_t ) 0x00100000U, /*!< PMW output channel 20 */
N    LED_Channel_21 = ( int32_t ) 0x00200000U, /*!< PMW output channel 21 */
N    LED_Channel_22 = ( int32_t ) 0x00400000U, /*!< PMW output channel 22 */
N    LED_Channel_23 = ( int32_t ) 0x00800000U, /*!< PMW output channel 23 */
N    LED_Channel_24 = ( int32_t ) 0x01000000U, /*!< PMW output channel 24 */
N    LED_Channel_25 = ( int32_t ) 0x02000000U, /*!< PMW output channel 25 */
N    LED_Channel_26 = ( int32_t ) 0x04000000U, /*!< PMW output channel 26 */
N    LED_Channel_27 = ( int32_t ) 0x08000000U, /*!< PMW output channel 27 */
N    LED_Channel_28 = ( int32_t ) 0x10000000U, /*!< PMW output channel 28 */
N    LED_Channel_29 = ( int32_t ) 0x20000000U, /*!< PMW output channel 29 */
N    LED_Channel_30 = ( int32_t ) 0x40000000U, /*!< PMW output channel 30 */
N    LED_Channel_31 = ( int32_t ) 0x80000000U, /*!< PMW output channel 31 */
N} LED_Channel_Typedef;
N
N#define IS_LED_Channel(Channel) ((Channel) <= (LED_Channel_All))
N#elif  defined(SC32f11xx)
Stypedef enum
S{
S    LED_Channel_Less = ( int32_t ) 0x00000000U,	/*!< No channels are selected */
S    LED_Channel_0 = ( int32_t ) 0x00000001U,
S    LED_Channel_1 = ( int32_t ) 0x00000002U,
S    LED_Channel_2 = ( int32_t ) 0x00000004U,
S    LED_Channel_3 = ( int32_t ) 0x00000008U,
S    LED_Channel_4 = ( int32_t ) 0x00000010U,
S    LED_Channel_5 = ( int32_t ) 0x00000020U,
S    LED_Channel_6 = ( int32_t ) 0x00000040U,
S    LED_Channel_7 = ( int32_t ) 0x00000080U,
S    LED_Channel_8 = ( int32_t ) 0x00000100U,
S    LED_Channel_9 = ( int32_t ) 0x00000200U,
S    LED_Channel_10 = ( int32_t ) 0x00000400U,
S    LED_Channel_11 = ( int32_t ) 0x00000800U,
S    LED_Channel_12 = ( int32_t ) 0x00001000U,
S    LED_Channel_13 = ( int32_t ) 0x00002000U,
S    LED_Channel_14 = ( int32_t ) 0x00004000U,
S    LED_Channel_15 = ( int32_t ) 0x00008000U,
S    LED_Channel_16 = ( int32_t ) 0x00010000U,
S    LED_Channel_17 = ( int32_t ) 0x00020000U,
S    LED_Channel_18 = ( int32_t ) 0x00040000U,
S    LED_Channel_19 = ( int32_t ) 0x00080000U,
S    LED_Channel_20 = ( int32_t ) 0x00100000U,
S    LED_Channel_21 = ( int32_t ) 0x00200000U,
S    LED_Channel_22 = ( int32_t ) 0x00400000U,
S    LED_Channel_23 = ( int32_t ) 0x00800000U,
S    LED_Channel_24 = ( int32_t ) 0x01000000U,
S    LED_Channel_25 = ( int32_t ) 0x02000000U,
S    LED_Channel_26 = ( int32_t ) 0x04000000U,
S    LED_Channel_27 = ( int32_t ) 0x08000000U,
S    LED_Channel_28 = ( int32_t ) 0x10000000U,
S    LED_Channel_29 = ( int32_t ) 0x20000000U,
S    LED_Channel_30 = ( int32_t ) 0x40000000U,
S    LED_Channel_31 = ( int32_t ) 0x80000000U,
S} LED_Channel_Typedef;
S#define LED_Channel_32 (uint64_t)0x100000000
S#define LED_Channel_33 (uint64_t)0x200000000
S#define LED_Channel_34 (uint64_t)0x400000000
S#define IS_LED_Channel(Channel) ((Channel) <= (LED_Channel_All))
N#endif
N/**
N * @}
N */
N
N/** @brief LED_RAMRegister
N * @{
N */
N#if defined(SC32f10xx) || defined(SC32f12xx)
X#if 1L || 0L
Ntypedef enum
N{
N    LED_RAMRegister_0 = 0x00000000U,
N    LED_RAMRegister_1 = 0x00000001U,
N    LED_RAMRegister_2 = 0x00000002U,
N    LED_RAMRegister_3 = 0x00000003U,
N    LED_RAMRegister_4 = 0x00000004U,
N    LED_RAMRegister_5 = 0x00000005U,
N    LED_RAMRegister_6 = 0x00000006U,
N    LED_RAMRegister_7 = 0x00000007U,
N    LED_RAMRegister_8 = 0x00000008U,
N    LED_RAMRegister_9 = 0x00000009U,
N    LED_RAMRegister_10 = 0x0000000AU,
N    LED_RAMRegister_11 = 0x0000000BU,
N    LED_RAMRegister_12 = 0x0000000CU,
N    LED_RAMRegister_13 = 0x0000000DU,
N    LED_RAMRegister_14 = 0x0000000EU,
N    LED_RAMRegister_15 = 0x0000000FU,
N    LED_RAMRegister_16 = 0x00000010U,
N    LED_RAMRegister_17 = 0x00000011U,
N    LED_RAMRegister_18 = 0x00000012U,
N    LED_RAMRegister_19 = 0x00000013U,
N    LED_RAMRegister_20 = 0x00000014U,
N    LED_RAMRegister_21 = 0x00000015U,
N    LED_RAMRegister_22 = 0x00000016U,
N    LED_RAMRegister_23 = 0x00000017U,
N    LED_RAMRegister_24 = 0x00000018U,
N    LED_RAMRegister_25 = 0x00000019U,
N    LED_RAMRegister_26 = 0x0000001AU,
N    LED_RAMRegister_27 = 0x0000001BU,
N} LED_RAMRegister_Typedef;
N
N#define IS_LED_RAM_REGISTER(REGISTER) ((REGISTER) <= (LED_RAMRegister27))
N#elif  defined(SC32f11xx)
Stypedef enum
S{
S    LED_RAMRegister_0 = 0x00000000U,
S    LED_RAMRegister_1 = 0x00000001U,
S    LED_RAMRegister_2 = 0x00000002U,
S    LED_RAMRegister_3 = 0x00000003U,
S    LED_RAMRegister_4 = 0x00000004U,
S    LED_RAMRegister_5 = 0x00000005U,
S    LED_RAMRegister_6 = 0x00000006U,
S    LED_RAMRegister_7 = 0x00000007U,
S    LED_RAMRegister_8 = 0x00000008U,
S    LED_RAMRegister_9 = 0x00000009U,
S    LED_RAMRegister_10 = 0x0000000AU,
S    LED_RAMRegister_11 = 0x0000000BU,
S    LED_RAMRegister_12 = 0x0000000CU,
S    LED_RAMRegister_13 = 0x0000000DU,
S    LED_RAMRegister_14 = 0x0000000EU,
S    LED_RAMRegister_15 = 0x0000000FU,
S    LED_RAMRegister_16 = 0x00000010U,
S    LED_RAMRegister_17 = 0x00000011U,
S    LED_RAMRegister_18 = 0x00000012U,
S    LED_RAMRegister_19 = 0x00000013U,
S    LED_RAMRegister_20 = 0x00000014U,
S    LED_RAMRegister_21 = 0x00000015U,
S    LED_RAMRegister_22 = 0x00000016U,
S    LED_RAMRegister_23 = 0x00000017U,
S    LED_RAMRegister_24 = 0x00000018U,
S    LED_RAMRegister_25 = 0x00000019U,
S    LED_RAMRegister_26 = 0x0000001AU,
S    LED_RAMRegister_27 = 0x0000001BU,
S    LED_RAMRegister_28 = 0x0000001CU,
S    LED_RAMRegister_29 = 0x0000001DU,
S    LED_RAMRegister_30 = 0x0000001EU,
S    LED_RAMRegister_31 = 0x0000001FU,
S    LED_RAMRegister_32 = 0x00000020U,
S    LED_RAMRegister_33 = 0x00000021U,
S    LED_RAMRegister_34 = 0x00000022U,
S    LED_RAMRegister_35 = 0x00000023U,
S
S
S} LED_RAMRegister_Typedef;
S
S#define IS_LED_RAM_REGISTER(REGISTER) ((REGISTER) <= (LED_RAMRegister_34))
N#endif
N/**
N * @}
N */
Ntypedef enum
N{
N    LED_COMEN_0 = 0x00000001U,
N    LED_COMEN_1 = 0x00000002U,
N    LED_COMEN_2 = 0x00000004U,
N    LED_COMEN_3 = 0x00000008U,
N    LED_COMEN_4 = 0x00000010U,
N    LED_COMEN_5 = 0x00000020U,
N    LED_COMEN_6 = 0x00000040U,
N    LED_COMEN_7 = 0x00000080U,
N} LED_COMEN_Typedef;
N
N/**
N * @}
N */
N/* End of enumerations -----------------------------------------------------*/
N
N/* Exported struct ------------------------------------------------------------*/
N/** @defgroup LED_Exported_Struct LED Exported Struct
N * @{
N */
N
N/** @brief LED Base Configuration Structure definition
N * @{
N */
Ntypedef struct
N{
N
N    uint16_t LED_FrameFre; /*!< Specifies the frame frequency.
N																					This parameter can be a value of @ref LED_FrameFre_TypeDef */
N
N    uint16_t LED_Duty; /*!< Specifies the display duty cycle.
N																			This parameter can be a value of @ref LED_Duty_TypeDef */
N
N    uint32_t LED_ComPin; /*!< Specifies the Com Pin.
N																Each bit represents a Seg channel,Support 8 channels.*/
N#if defined (SC32f10xx) || defined(SC32f12xx)
X#if 1L || 0L
N    uint32_t LED_SegPin; /*!< Specifies the Seg Pin.
N																Each bit represents a Seg channel,Support 28 channels.*/
N#elif defined(SC32f11xx)
S    uint64_t LED_SegPin; /*!< Specifies the Seg Pin.
S																Each bit represents a Seg channel,Support 35 channels.*/
N#endif
N} LED_InitTypeDef;
N/**
N * @}
N */
N
N/**
N * @}
N */
N/* End of struct -----------------------------------------------------*/
N
N/** @addtogroup LED_Exported_Functions LED Exported Functions
N * @{
N */
N
N/* Initialization and Configuration functions ***********************************************/
Nvoid LED_DeInit ( void );
Nvoid LED_Init ( LED_InitTypeDef* LCD_InitStruct );
Nvoid LED_StructInit ( LED_InitTypeDef* LED_InitStruct );
Nvoid LED_Cmd ( FunctionalState NewState );
N
N/* Initialization and Configuration functions ***********************************************/
Nvoid LED_COMConfig ( LED_COMEN_Typedef COMSelect, FunctionalState NewState );
Nvoid LED_SEGConfig ( uint64_t SEGSelect, FunctionalState NewState );
Nvoid LED_Write ( LED_RAMRegister_Typedef LED_RAMRegister, uint8_t LED_Data );
Nvoid LED_CustomModeScan ( void );
N
N/**
N * @}
N */
N/* End of exported functions --------------------------------------------------*/
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 46 "..\FWLib\SC32F1XXX_Lib\inc\sc32_conf.h" 2
N#endif
N#include "sc32f1xxx_tim.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx_tim.h" 1
N/**
N ******************************************************************************
N * @file    sc32f1xxx_tim.h
N * @author  SOC AE Team
N * @version V1.6
N * @date    04-09-2024
N * @brief   Header file of TIM module.
N ******************************************************************************
N * @attention
N *
N *1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only
N *intended for use with SinOne products. No other uses are authorized. This
N *software is owned by SinOne Microelectronics Co.,Ltd. and is protected under
N *all applicable laws, including copyright laws.
N *2.The software which is for guidance only aims at providing customers with
N *coding information regarding their products in order for them to save time.
N *As a result, SinOne shall not be held liable for any direct, indirect or
N *consequential damages with respect to any claims arising from the content of
N *such software and/or the use made by customers of the coding information
N *contained herein in connection with their products.
N *
N *  COPYRIGHT 2024 SinOne Microelectronics
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __sc32f1xxx_TIM_H
N#define __sc32f1xxx_TIM_H
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "sc32f1xxx.h"
N#include "sc32.h"
N#include "sc32f1xxx_rcc.h"
N
N/** @addtogroup sc32f1xxx_StdPeriph_Driver
N * @{
N */
N
N/** @addtogroup TIM
N * @{
N */
N
N/** @defgroup TIM_Enumerations TIM Enumerations
N * @{
N */
N
N/** @brief TIM_Prescaler_TypeDef TIM Prescaler
N * @{
N */
Ntypedef enum
N{
N    TIM_PRESCALER_1   = ( uint16_t ) ( 0x00U << TIM_CON_TIMCLK_Pos ), /*!< Clock division: Fsource/1    */
X    TIM_PRESCALER_1   = ( uint16_t ) ( 0x00U << (8U) ),  
N    TIM_PRESCALER_2   = ( uint16_t ) ( 0x01U << TIM_CON_TIMCLK_Pos ), /*!< Clock division: Fsource/2    */
X    TIM_PRESCALER_2   = ( uint16_t ) ( 0x01U << (8U) ),  
N    TIM_PRESCALER_4   = ( uint16_t ) ( 0x02U << TIM_CON_TIMCLK_Pos ), /*!< Clock division: Fsource/4    */
X    TIM_PRESCALER_4   = ( uint16_t ) ( 0x02U << (8U) ),  
N    TIM_PRESCALER_8   = ( uint16_t ) ( 0x03U << TIM_CON_TIMCLK_Pos ), /*!< Clock division: Fsource/8    */
X    TIM_PRESCALER_8   = ( uint16_t ) ( 0x03U << (8U) ),  
N    TIM_PRESCALER_16  = ( uint16_t ) ( 0x04U << TIM_CON_TIMCLK_Pos ), /*!< Clock division: Fsource/16    */
X    TIM_PRESCALER_16  = ( uint16_t ) ( 0x04U << (8U) ),  
N    TIM_PRESCALER_32  = ( uint16_t ) ( 0x05U << TIM_CON_TIMCLK_Pos ), /*!< Clock division: Fsource/32    */
X    TIM_PRESCALER_32  = ( uint16_t ) ( 0x05U << (8U) ),  
N    TIM_PRESCALER_64  = ( uint16_t ) ( 0x06U << TIM_CON_TIMCLK_Pos ), /*!< Clock division: Fsource/64    */
X    TIM_PRESCALER_64  = ( uint16_t ) ( 0x06U << (8U) ),  
N    TIM_PRESCALER_128 = ( uint16_t ) ( 0x07U << TIM_CON_TIMCLK_Pos ), /*!< Clock division: Fsource/128    */
X    TIM_PRESCALER_128 = ( uint16_t ) ( 0x07U << (8U) ),  
N} TIM_Prescaler_TypeDef;
N
N#define IS_TIM_PRESCALER(PRESCALER) (((PRESCALER) == TIM_PRESCALER_1) ||  \
N                                     ((PRESCALER) == TIM_PRESCALER_2) ||  \
N                                     ((PRESCALER) == TIM_PRESCALER_4) ||  \
N                                     ((PRESCALER) == TIM_PRESCALER_8) ||  \
N                                     ((PRESCALER) == TIM_PRESCALER_16) || \
N                                     ((PRESCALER) == TIM_PRESCALER_32) || \
N                                     ((PRESCALER) == TIM_PRESCALER_64) || \
N                                     ((PRESCALER) == TIM_PRESCALER_128))
X#define IS_TIM_PRESCALER(PRESCALER) (((PRESCALER) == TIM_PRESCALER_1) ||                                       ((PRESCALER) == TIM_PRESCALER_2) ||                                       ((PRESCALER) == TIM_PRESCALER_4) ||                                       ((PRESCALER) == TIM_PRESCALER_8) ||                                       ((PRESCALER) == TIM_PRESCALER_16) ||                                      ((PRESCALER) == TIM_PRESCALER_32) ||                                      ((PRESCALER) == TIM_PRESCALER_64) ||                                      ((PRESCALER) == TIM_PRESCALER_128))
N/**
N * @}
N */
N
N/** @brief TIM_WorkMode TIM WorkMode
N * @{
N */
Ntypedef enum
N{
N    TIM_WorkMode_Timer   = ( uint16_t ) ( 0x00U << TIM_CON_CTSEL_Pos ), /*!< Work Mode: Timer Mode */
X    TIM_WorkMode_Timer   = ( uint16_t ) ( 0x00U << (1U) ),  
N    TIM_WorkMode_Counter = ( uint16_t ) ( 0x01U << TIM_CON_CTSEL_Pos ), /*!< Work Mode: Counter Mode */
X    TIM_WorkMode_Counter = ( uint16_t ) ( 0x01U << (1U) ),  
N} TIM_WorkMode_Typedef;
N
N#define IS_TIM_WORKMODE(MODE) (((MODE) == TIM_WorkMode_Timer) || \
N                               ((MODE) == TIM_WorkMode_Counter))
X#define IS_TIM_WORKMODE(MODE) (((MODE) == TIM_WorkMode_Timer) ||                                ((MODE) == TIM_WorkMode_Counter))
N/**
N * @}
N */
N
N/** @brief TIM_CounterMode TIM Counter Mode
N * @{
N */
Ntypedef enum
N{
N    TIM_CounterMode_Up      = ( uint16_t ) ( 0x00U << TIM_CON_DEC_Pos ), /*!< Counter mode: up-counter */
X    TIM_CounterMode_Up      = ( uint16_t ) ( 0x00U << (6U) ),  
N    TIM_CounterMode_Down_UP = ( uint16_t ) ( 0x01U << TIM_CON_DEC_Pos ), /*!< Counter mode: down or up counter */
X    TIM_CounterMode_Down_UP = ( uint16_t ) ( 0x01U << (6U) ),  
N} TIM_CounterMode_Typedef;
N
N#define IS_TIM_COUNTERMODE(MODE) (((MODE) == TIM_CounterMode_Up) || \
N                                  ((MODE) == TIM_CounterMode_Down_UP))
X#define IS_TIM_COUNTERMODE(MODE) (((MODE) == TIM_CounterMode_Up) ||                                   ((MODE) == TIM_CounterMode_Down_UP))
N/**
N * @}
N */
N
N/** @brief TIM_EXENX TIM EXENX
N * @{
N */
Ntypedef enum
N{
N    TIM_EXENX_Disable  = ( uint16_t ) ( 0x00U << TIM_CON_EXENX_Pos ), /*!< External load pin disable */
X    TIM_EXENX_Disable  = ( uint16_t ) ( 0x00U << (5U) ),  
N    TIM_EXENX_Enable	 = ( uint16_t ) ( 0x01U << TIM_CON_EXENX_Pos ), /*!< External load pin enable */
X    TIM_EXENX_Enable	 = ( uint16_t ) ( 0x01U << (5U) ),  
N} TIM_EXENX_Typedef;
N
N#define IS_TIM_EXENX(STATE) (((STATE) == TIM_EXENX_Disable) || \
N                                  ((STATE) == TIM_EXENX_Enable))
X#define IS_TIM_EXENX(STATE) (((STATE) == TIM_EXENX_Disable) ||                                   ((STATE) == TIM_EXENX_Enable))
N/**
N * @}
N */
N
N/** @brief TIM_RICPIN TIM Rising Input Capture Pin
N * @{
N */
Ntypedef enum
N{
N    TIM_RICPin_Disable = ( uint16_t ) ( 0x00U << TIM_CON_EXENR_Pos ), /*!< No rising input is required for capture   */
X    TIM_RICPin_Disable = ( uint16_t ) ( 0x00U << (2U) ),  
N    TIM_RICPin_Tn      = ( uint16_t ) ( 0x01U << TIM_CON_EXENR_Pos ), /*!< TIM rising input capture pin is Tn   */
X    TIM_RICPin_Tn      = ( uint16_t ) ( 0x01U << (2U) ),  
N} TIM_RICPIN_Typedef;
N
N#define IS_TIM_RICPin(RICPin) (((RICPin) == TIM_RICPin_Disable) || \
N                               ((RICPin) == TIM_RICPin_Tn))
X#define IS_TIM_RICPin(RICPin) (((RICPin) == TIM_RICPin_Disable) ||                                ((RICPin) == TIM_RICPin_Tn))
N/**
N * @}
N */
N
N/** @brief TIM_FICPIN TIM Falling Input Capture Pin
N * @{
N */
Ntypedef enum
N{
N    TIM_FICPin_Disable = ( uint16_t ) ( 0x00U ), /*!< No rising input is required for capture   */
N    TIM_FICPin_Tn      = ( uint16_t ) ( TIM_CON_EXENF ), /*!< TIM failing input capture pin is Tn   */
X    TIM_FICPin_Tn      = ( uint16_t ) ( (0x1L << (3U)) ),  
N    TIM_FICPin_TnEx    = ( uint16_t ) ( TIM_CON_EXENX | TIM_CON_FSEL ), /*!< TIM failing input capture pin is TnEx   */
X    TIM_FICPin_TnEx    = ( uint16_t ) ( (0x1L << (5U)) | (0x1L << (4U)) ),  
N} TIM_FICPIN_Typedef;
N
N#define IS_TIM_FICPin(FICPin) (((FICPin) == TIM_FICPin_Disable) || \
N                               ((FICPin) == TIM_FICPin_Tn)  || \
N	                             ((FICPin) == TIM_FICPin_TnEx))
X#define IS_TIM_FICPin(FICPin) (((FICPin) == TIM_FICPin_Disable) ||                                ((FICPin) == TIM_FICPin_Tn)  || 	                             ((FICPin) == TIM_FICPin_TnEx))
N/**
N * @}
N */
N
N/** @brief TIM_PWMChannel TIM PWM Channel
N * @{
N */
Ntypedef enum
N{
N    TIM_PWMChannel_Less  = ( uint16_t ) 0x00, /*!< No channels are selected */
N    TIM_PWMChannel_PWMB = ( uint16_t ) 0x01, /*!< PMWB output channel */
N    TIM_PWMChannel_PWMA = ( uint16_t ) 0x02, /*!< PMWA output channel */
N    TIM_PWMChannel_ALL  = (uint16_t)0x03, /*!< PMW All output channel */
N} TIM_PWMChannel_Typedef;
N
N#define IS_TIM_PWMCHANNEL(CHANNEL) (((CHANNEL) & (uint32_t)0xFFFC) == 0x00)
N/**
N * @}
N */
N
N/** @brief TIM_PinRemap TIM Pin Remap
N * @{
N */
N#if defined(SC32f10xx) ||defined(SC32f11xx)||defined(SC32f15xx)
X#if 1L ||0L||0L
Ntypedef enum
N{
N    TIM_PinRemap_Default   = ( uint32_t ) ( 0x00 << TIM_CON_SPOS_Pos ), /*!< TIM Pin Remap: Disable */
X    TIM_PinRemap_Default   = ( uint32_t ) ( 0x00 << (19U) ),  
N    TIM_PinRemap_A    = ( uint32_t ) ( 0x01 << TIM_CON_SPOS_Pos ), /*!< TIM  Pin Remap: Remap mode A*/
X    TIM_PinRemap_A    = ( uint32_t ) ( 0x01 << (19U) ),  
N#if defined(SC32f15xx)
X#if 0L
S	TIM_PinRemap_B    = ( uint32_t ) ( 0x02 << TIM_CON_SPOS_Pos ), /*!< TIM  Pin Remap: Remap mode B*/
N#endif
N} TIM_PinRemap_TypeDef;
N#if defined(SC32f10xx) ||defined(SC32f11xx)
X#if 1L ||0L
N#define IS_TIM_PINREMAP(REMAP) (((REMAP) == TIM_PinRemap_Default) ||  \
N																((REMAP) == TIM_PinRemap_A))
X#define IS_TIM_PINREMAP(REMAP) (((REMAP) == TIM_PinRemap_Default) ||  																((REMAP) == TIM_PinRemap_A))
N#elif defined(SC32f15xx)
S#define IS_TIM_PINREMAP(REMAP) (((REMAP) == TIM_PinRemap_Default) ||  \
S                                ((REMAP) == TIM_PinRemap_A) ||  \
S																((REMAP) == TIM_PinRemap_B))
X#define IS_TIM_PINREMAP(REMAP) (((REMAP) == TIM_PinRemap_Default) ||                                  ((REMAP) == TIM_PinRemap_A) ||  																((REMAP) == TIM_PinRemap_B))
N#endif
N#endif
N/**
N * @}
N */
N
N/** @brief TIM_IT TIM Interrupt
N * @{
N */
Ntypedef enum
N{
N    TIM_IT_INTEN = ( uint8_t ) TIM_IDE_INTEN, /*!< TIM Interrupt: TIM Interrupt Enable */
X    TIM_IT_INTEN = ( uint8_t ) (0x1L << (0U)),  
N    TIM_IT_TI    = ( uint8_t ) TIM_IDE_TIE, /*!< TIM Interrupt: TIM overflow  */
X    TIM_IT_TI    = ( uint8_t ) (0x1L << (1U)),  
N    TIM_IT_EXR   = ( uint8_t ) TIM_IDE_EXIRE, /*!< TIM Interrupt: Rising edge capture */
X    TIM_IT_EXR   = ( uint8_t ) (0x1L << (2U)),  
N    TIM_IT_EXF   = ( uint8_t ) TIM_IDE_EXIFE, /*!< TIM Interrupt: Falling edge capture */
X    TIM_IT_EXF   = ( uint8_t ) (0x1L << (3U)),  
N} TIM_IT_TypeDef;
N
N#define IS_TIM_IT(IT) ((((IT) & (uint8_t)0xF0) == 0x00) && ((IT) != (uint8_t)0x00))
N/**
N * @}
N */
N
N/** @brief TIM_Flag TIM Flag
N * @{
N */
Ntypedef enum
N{
N    TIM_Flag_TI  = ( uint8_t ) 0x01, /*!< TIM Flag: TIM overflow */
N    TIM_Flag_EXR = ( uint8_t ) 0x02, /*!< TIM Flag: Immediate mode */
N    TIM_Flag_EXF = ( uint8_t ) 0x04, /*!< TIM Flag: Immediate mode */
N} TIM_Flag_TypeDef;
N
N#define IS_TIM_FLAG(FLAG) ((((FLAG) & (uint8_t)0xF8) == 0x00) && ((FLAG) != (uint8_t)0x00))
N
N#define IS_GET_TIM_FLAG(FLAG) (((FLAG) == TIM_Flag_TI) ||  \
N                               ((FLAG) == TIM_Flag_EXR) || \
N                               ((FLAG) == TIM_Flag_EXF))
X#define IS_GET_TIM_FLAG(FLAG) (((FLAG) == TIM_Flag_TI) ||                                 ((FLAG) == TIM_Flag_EXR) ||                                ((FLAG) == TIM_Flag_EXF))
N/**
N * @}
N */
N
N/** @brief TIM_DMAReq TIM DMAReq
N * @{
N */
Ntypedef enum
N{
N    TIM_DMAReq_TI  = ( uint8_t ) TIM_IDE_TIDE, /*!< TIM DMA: TIM overflow */
X    TIM_DMAReq_TI  = ( uint8_t ) (0x1L << (4U)),  
N    TIM_DMAReq_CAPR = ( uint8_t ) TIM_IDE_CAPRDE, /*!< TIM DMA: Rising edge capture */
X    TIM_DMAReq_CAPR = ( uint8_t ) (0x1L << (5)),  
N    TIM_DMAReq_CAPF = ( uint8_t ) TIM_IDE_CAPFDE, /*!< TIM DMA: Falling edge capture */
X    TIM_DMAReq_CAPF = ( uint8_t ) (0x1L << (6U)),  
N} TIM_DMAReq_TypeDef;
N
N#define IS_TIM_DMAREQ(DMAREQ) ((((DMAREQ) & (uint8_t)0x8F) == 0x00) && ((DMAREQ) != 0x00))
N/**
N * @}
N */
N
N/**
N * @}
N */
N/* End of enumerations -----------------------------------------------------*/
N
N/** @brief TIM_Constants TIM Constants
N  * @{
N  */
N#if defined(SC32f10xx) ||  defined(SC32f11xx) ||  defined(SC32f12xx)
X#if 1L ||  0L ||  0L
N#define IS_TIM_ALL_PERIPH(PERIPH) (((PERIPH) == TIM0) || \
N																	((PERIPH) == TIM1) || \
N																	((PERIPH) == TIM2) || \
N																	((PERIPH) == TIM3) || \
N																	((PERIPH) == TIM4) || \
N																	((PERIPH) == TIM5) || \
N																	((PERIPH) == TIM6) || \
N																	((PERIPH) == TIM7))
X#define IS_TIM_ALL_PERIPH(PERIPH) (((PERIPH) == TIM0) || 																	((PERIPH) == TIM1) || 																	((PERIPH) == TIM2) || 																	((PERIPH) == TIM3) || 																	((PERIPH) == TIM4) || 																	((PERIPH) == TIM5) || 																	((PERIPH) == TIM6) || 																	((PERIPH) == TIM7))
N#elif  defined(SC32f15xx)
S#define IS_TIM_ALL_PERIPH(PERIPH) (((PERIPH) == TIM0) || \
S                                   ((PERIPH) == TIM1) || \
S                                   ((PERIPH) == TIM2) || \
S                                   ((PERIPH) == TIM3) )
X#define IS_TIM_ALL_PERIPH(PERIPH) (((PERIPH) == TIM0) ||                                    ((PERIPH) == TIM1) ||                                    ((PERIPH) == TIM2) ||                                    ((PERIPH) == TIM3) )
S#define IS_TIM_REMAP_PERIPH(PERIPH) (((PERIPH) == TIM0) || \
S                                   ((PERIPH) == TIM1) || \
S                                   ((PERIPH) == TIM2) || \
S                                   ((PERIPH) == TIM3) )
X#define IS_TIM_REMAP_PERIPH(PERIPH) (((PERIPH) == TIM0) ||                                    ((PERIPH) == TIM1) ||                                    ((PERIPH) == TIM2) ||                                    ((PERIPH) == TIM3) )
N#endif
N#define IS_TIM_TN_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
N																	((PERIPH) == TIM2) || \
N																	((PERIPH) == TIM3) || \
N																	((PERIPH) == TIM4) || \
N																	((PERIPH) == TIM5) || \
N																	((PERIPH) == TIM6) || \
N																	((PERIPH) == TIM7))
X#define IS_TIM_TN_PERIPH(PERIPH) (((PERIPH) == TIM1) || 																	((PERIPH) == TIM2) || 																	((PERIPH) == TIM3) || 																	((PERIPH) == TIM4) || 																	((PERIPH) == TIM5) || 																	((PERIPH) == TIM6) || 																	((PERIPH) == TIM7))
N
N#define IS_TIM_TNEX_PERIPH(PERIPH) ((PERIPH) == TIM0)
N
N#define IS_TIM_DMA_PERIPH(PERIPH) (((PERIPH) == TIM0) || \
N																	((PERIPH) == TIM1))
X#define IS_TIM_DMA_PERIPH(PERIPH) (((PERIPH) == TIM0) || 																	((PERIPH) == TIM1))
N#if defined(SC32f10xx)
X#if 1L
N#define IS_TIM_REMAP_PERIPH(PERIPH) (((PERIPH) == TIM2) || \
N                                    ((PERIPH) == TIM3) || \
N                                    ((PERIPH) == TIM7))
X#define IS_TIM_REMAP_PERIPH(PERIPH) (((PERIPH) == TIM2) ||                                     ((PERIPH) == TIM3) ||                                     ((PERIPH) == TIM7))
N#elif  defined(SC32f11xx)
S#define IS_TIM_REMAP_PERIPH(PERIPH) (((PERIPH) == TIM2) || \
S                                    ((PERIPH) == TIM3) || \
S                                    ((PERIPH) == TIM4) ||\
S																		((PERIPH) == TIM5) ||\
S																		((PERIPH) == TIM6) ||\
S																		((PERIPH) == TIM7))
X#define IS_TIM_REMAP_PERIPH(PERIPH) (((PERIPH) == TIM2) ||                                     ((PERIPH) == TIM3) ||                                     ((PERIPH) == TIM4) ||																		((PERIPH) == TIM5) ||																		((PERIPH) == TIM6) ||																		((PERIPH) == TIM7))
S
N#endif
N
N/**
N * @}
N */
N/* End of constants -----------------------------------------------------*/
N
N/** @defgroup TIM_Struct TIM Struct
N * @{
N */
N
N/** @brief TIM_TimeBaseInitTypeDef TIM Time base Configuration Structure definition
N * @{
N */
Ntypedef struct
N{
N    uint16_t TIM_Prescaler; /*!<  Specifies the clock division.
N                                      This parameter can be a value of @ref TIM_Prescaler_TypeDef */
N
N    uint16_t TIM_WorkMode; /*!< Specifies the Word mode.
N                                          This parameter can be a value of @ref TIM_WordMode_Typedef */
N
N    uint16_t TIM_CounterMode; /*!< Specifies the Counter mode.
N                                      This parameter can be a value of @ref TIM_CounterMode_Typedef */
N
N    uint16_t TIM_EXENX; /*!< Specifies whether falling edge reloading on the TnEX pin is enabled.
N                                 This parameter can be a value of @ref	TnEX_Reload	*/
N
N    uint16_t TIM_Preload; /*!< Specifies the preload value to be loaded into the active
N                                  Auto-Reload Register at the next update event.
N                                  This parameter can be a number between Min_Data = 0x0000 and Max_Data = 0xFFFF.  */
N
N} TIM_TimeBaseInitTypeDef;
N/**
N * @}
N */
N
N/** @brief TIM_IC_InitTypeDef Configuration Structure definition
N * @{
N */
Ntypedef struct
N{
N    uint16_t TIM_RICPIN; /*!<  Specifies the rising input capture pin.
N                                      This parameter can be a value of @ref TIM_RICPIN_Typedef */
N
N    uint16_t TIM_FICPIN; /*!<  Specifies the failing input capture pin.
N                                      This parameter can be a value of @ref TIM_FICPIN_Typedef */
N
N} TIM_IC_InitTypeDef;
N/**
N * @}
N */
N
N/** @brief TIM_PWM TIM PWM
N * @{
N */
Ntypedef struct
N{
N    uint16_t TIM_PWMOutputChannl; /*!<	TIM PWM Channel to be enabled.
N																			 This parameter can be a value of @ref TIM_PWMChannel_Typedef */
N
N    uint16_t TIM_PWMLowPolarityChannl; /*!< TIM PWM Channl Polarity is set to Low.
N                                            This parameter can be a value of @ref TIM_PWMChannel_Typedef */
N
N} TIM_PWM_InitTypeDef;
N/**
N * @}
N */
N
N/**
N * @}
N */
N/* End of struct -----------------------------------------------------*/
N
N/** @addtogroup TIM_Functions TIM Functions
N * @{
N */
N
N/* Time Base functions ********************************************************/
Nvoid TIM_DeInit ( TIM_TypeDef* TIMx );
Nvoid TIM_TIMBaseInit ( TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct );
Nvoid TIM_TimeBaseStructInit ( TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct );
Nvoid TIM_SetCounter ( TIM_TypeDef* TIMx, uint32_t Counter );
Nuint32_t TIM_GetCounter ( TIM_TypeDef* TIMx );
Nvoid TIM_SetAutoreload ( TIM_TypeDef* TIMx, uint16_t Autoreload );
Nuint16_t TIM_GetAutoreload ( TIM_TypeDef* TIMx );
Nvoid TIM_SetPerscaler ( TIM_TypeDef* TIMx, TIM_Prescaler_TypeDef TIM_Perscaler );
NTIM_Prescaler_TypeDef TIM_GetPrescaler ( TIM_TypeDef* TIMx );
Nvoid TIM_Cmd ( TIM_TypeDef* TIMx, FunctionalState NewState );
N
N/* Timer Input Capture functions **********************************************/
Nvoid TIM_ICInit ( TIM_TypeDef* TIMx, TIM_IC_InitTypeDef* TIM_IC_InitStruct );
Nvoid TIM_ICStructInit ( TIM_IC_InitTypeDef* TIM_IC_InitStruct );
Nvoid TIM_ICCmd ( TIM_TypeDef* TIMx, FunctionalState NewState );
Nuint32_t TIM_GetRisingCapture ( TIM_TypeDef* TIMx );
Nuint32_t TIM_GetFailingCapture ( TIM_TypeDef* TIMx );
N
N/* Timer PWM functions **********************************************/
Nvoid TIM_PWMInit ( TIM_TypeDef* TIMx, TIM_PWM_InitTypeDef* TIM_PWM_InitStruct );
Nvoid TIM_PWMStructInit ( TIM_PWM_InitTypeDef* TIM_PWM_InitStruct );
Nvoid TIM_PWMSetDuty ( TIM_TypeDef* TIMx, TIM_PWMChannel_Typedef TIM_PWMChannel, uint16_t PWM_DutyValue );
Nuint16_t TIM_PWMGetDuty ( TIM_TypeDef* TIMx, TIM_PWMChannel_Typedef TIM_PWMChannel );
N
N/* Clocks Output management functions**********************************************/
Nvoid TIM_ClockOutputCmd ( TIM_TypeDef* TIMx, FunctionalState NewState );
N
N/* Pin Remap functions**********************************************/
N#if defined(SC32f10xx) || defined(SC32f11xx)|| defined(SC32f15xx)
X#if 1L || 0L|| 0L
Nvoid TIM_PinRemapConfig ( TIM_TypeDef* TIMx, TIM_PinRemap_TypeDef TIM_Remap );
N#endif
N/* Interrupts, DMA and flags management functions  ***********************************************/
Nvoid TIM_ITConfig ( TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState );
NFlagStatus TIM_GetFlagStatus ( TIM_TypeDef* TIMx, TIM_Flag_TypeDef TIM_FLAG );
Nvoid TIM_ClearFlag ( TIM_TypeDef* TIMx, uint16_t TIM_FLAG );
Nvoid TIM_DMACmd ( TIM_TypeDef* TIMx, uint16_t TIM_DMAReq, FunctionalState NewState );
N
N/**
N * @}
N */
N
N/* End of exported functions --------------------------------------------------*/
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 48 "..\FWLib\SC32F1XXX_Lib\inc\sc32_conf.h" 2
N#include "sc32f1xxx_dma.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx_dma.h" 1
N/**
N ******************************************************************************
N * @file    sc32f1xxx_dma.h
N * @author  SOC AE Team
N * @version V1.6
N * @date    04-09-2024
N * @brief   Header file of DMA module.
N *
N ******************************************************************************
N * @attention
N *
N *1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only
N *intended for use with SinOne products. No other uses are authorized. This
N *software is owned by SinOne Microelectronics Co.,Ltd. and is protected under
N *all applicable laws, including copyright laws.
N *2.The software which is for guidance only aims at providing customers with
N *coding information regarding their products in order for them to save time.
N *As a result, SinOne shall not be held liable for any direct, indirect or
N *consequential damages with respect to any claims arising from the content of
N *such software and/or the use made by customers of the coding information
N *contained herein in connection with their products.
N *
N *  COPYRIGHT 2024 SinOne Microelectronics
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __sc32f1xxx_DMA_H
N#define __sc32f1xxx_DMA_H
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "sc32f1xxx.h"
N#include "sc32.h"
N#include "sc32f1xxx_rcc.h"
N
N/** @addtogroup sc32f1xxx_StdPeriph_Driver
N * @{
N */
N
N/** @addtogroup DMA
N * @{
N */
N
N/* Exported enumerations ------------------------------------------------------------*/
N/** @defgroup DMA_Exported_Enumerations DMA Exported Enumerations
N * @{
N */
N
N/** @brief DMA_Priority DMA Priority
N * @{
N */
Ntypedef enum
N{
N    DMA_Priority_LOW				= ( ( uint32_t ) 0x00U << DMA_CFG_PL_Pos ),		/*!< Priority level: Low       */
X    DMA_Priority_LOW				= ( ( uint32_t ) 0x00U << (0U) ),		 
N    DMA_Priority_MEDIUM 		= ( ( uint32_t ) 0x01U << DMA_CFG_PL_Pos ),		/*!< Priority level: Medium    */
X    DMA_Priority_MEDIUM 		= ( ( uint32_t ) 0x01U << (0U) ),		 
N    DMA_Priority_HIGH				= ( ( uint32_t ) 0x02U << DMA_CFG_PL_Pos ),		/*!< Priority level: High      */
X    DMA_Priority_HIGH				= ( ( uint32_t ) 0x02U << (0U) ),		 
N    DMA_Priority_VERY_HIGH	= ( ( uint32_t ) 0x03U << DMA_CFG_PL_Pos ),		/*!< Priority level: Very High */
X    DMA_Priority_VERY_HIGH	= ( ( uint32_t ) 0x03U << (0U) ),		 
N} DMA_Priority_TypeDef;
N
N#define IS_DMA_PROIORITY(PROIORITY) (((PROIORITY) == DMA_Priority_LOW) || \
N                                    ((PROIORITY) == DMA_Priority_MEDIUM) || \
N                                    ((PROIORITY) == DMA_Priority_HIGH) || \
N                                    ((PROIORITY) == DMA_Priority_VERY_HIGH))
X#define IS_DMA_PROIORITY(PROIORITY) (((PROIORITY) == DMA_Priority_LOW) ||                                     ((PROIORITY) == DMA_Priority_MEDIUM) ||                                     ((PROIORITY) == DMA_Priority_HIGH) ||                                     ((PROIORITY) == DMA_Priority_VERY_HIGH))
N/**
N * @}
N */
N
N/** @brief DMA_CircularMode DMA CircularMode
N * @{
N */
Ntypedef enum
N{
N    DMA_CircularMode_Disable	  = ( ( uint32_t ) 0x00U << DMA_CFG_CIRC_Pos ), /*!< DMA Mode: Disable */
X    DMA_CircularMode_Disable	  = ( ( uint32_t ) 0x00U << (4U) ),  
N    DMA_CircularMode_Enable	= ( ( uint32_t ) 0x01U << DMA_CFG_CIRC_Pos ), /*!< DMA Mode: Enable */
X    DMA_CircularMode_Enable	= ( ( uint32_t ) 0x01U << (4U) ),  
N} DMA_CircularMode_TypeDef;
N
N#define IS_DMA_CIRCULARMODE(MODE) (((MODE) == DMA_CircularMode_Disable ) || \
N                           ((MODE) == DMA_CircularMode_Enable))
X#define IS_DMA_CIRCULARMODE(MODE) (((MODE) == DMA_CircularMode_Disable ) ||                            ((MODE) == DMA_CircularMode_Enable))
N/**
N * @}
N */
N
N/** @brief DMA_DataSize DMA Data DataSize
N * @{
N */
Ntypedef enum
N{
N    DMA_DataSize_Byte			= ( ( uint32_t ) 0x00U << DMA_CFG_TXWIDTH_Pos ),		 /*!< Peripheral data alignment: Byte     */
X    DMA_DataSize_Byte			= ( ( uint32_t ) 0x00U << (2U) ),		  
N    DMA_DataSize_HakfWord	= ( ( uint32_t ) 0x01U << DMA_CFG_TXWIDTH_Pos ),		 /*!< Peripheral data alignment: HalfWord */
X    DMA_DataSize_HakfWord	= ( ( uint32_t ) 0x01U << (2U) ),		  
N    DMA_DataSize_Word			= ( ( uint32_t ) 0x02U << DMA_CFG_TXWIDTH_Pos ),		 /*!< Peripheral data alignment: Word     */
X    DMA_DataSize_Word			= ( ( uint32_t ) 0x02U << (2U) ),		  
N} DMA_DataSize_TypeDef;
N
N#define IS_DMA_DATASIZE(SIZE) (((SIZE) == DMA_DataSize_Byte) || \
N                               ((SIZE) == DMA_DataSize_HakfWord) || \
N                               ((SIZE) == DMA_DataSize_Word))
X#define IS_DMA_DATASIZE(SIZE) (((SIZE) == DMA_DataSize_Byte) ||                                ((SIZE) == DMA_DataSize_HakfWord) ||                                ((SIZE) == DMA_DataSize_Word))
N/**
N * @}
N */
N
N/** @brief DMA_TargetMode DMA Target Address Change Mode
N * @{
N */
Ntypedef enum
N{
N    DMA_TargetMode_FIXED		= ( ( uint32_t ) 0x00U << DMA_CFG_DAINC_Pos ), /*!< DMA Target Mode: Fixed address */
X    DMA_TargetMode_FIXED		= ( ( uint32_t ) 0x00U << (8U) ),  
N    DMA_TargetMode_INC			= ( ( uint32_t ) 0x01U << DMA_CFG_DAINC_Pos ), /*!< DMA Target Mode: Address increase */
X    DMA_TargetMode_INC			= ( ( uint32_t ) 0x01U << (8U) ),  
N    DMA_TargetMode_DEC			= ( ( uint32_t ) 0x02U << DMA_CFG_DAINC_Pos ), /*!< DMA Target Mode: Address decrease */
X    DMA_TargetMode_DEC			= ( ( uint32_t ) 0x02U << (8U) ),  
N    DMA_TargetMode_INC_CIRC	= ( ( uint32_t ) 0x03U << DMA_CFG_DAINC_Pos ), /*!< DMA Target Mode: Address increase loop */
X    DMA_TargetMode_INC_CIRC	= ( ( uint32_t ) 0x03U << (8U) ),  
N} DMA_TargetMode_TypeDef;
N
N#define IS_DMA_TARGERT_MODE(MODE) (((MODE) == DMA_TargetMode_FIXED ) || \
N                                  ((MODE) == DMA_TargetMode_INC) || \
N                                  ((MODE) == DMA_TargetMode_DEC) || \
N                                  ((MODE) == DMA_TargetMode_INC_CIRC))
X#define IS_DMA_TARGERT_MODE(MODE) (((MODE) == DMA_TargetMode_FIXED ) ||                                   ((MODE) == DMA_TargetMode_INC) ||                                   ((MODE) == DMA_TargetMode_DEC) ||                                   ((MODE) == DMA_TargetMode_INC_CIRC))
N/**
N * @}
N */
N
N/** @brief DMA_SourceMode DMA Source
N * @{
N */
Ntypedef enum
N{
N    DMA_SourceMode_FIXED		= ( ( uint32_t ) 0x00U << DMA_CFG_SAINC_Pos ),			/*!< DMA Source Mode: Fixed address */
X    DMA_SourceMode_FIXED		= ( ( uint32_t ) 0x00U << (10U) ),			 
N    DMA_SourceMode_INC			= ( ( uint32_t ) 0x01U << DMA_CFG_SAINC_Pos ),			/*!< DMA Source Mode: Address increase */
X    DMA_SourceMode_INC			= ( ( uint32_t ) 0x01U << (10U) ),			 
N    DMA_SourceMode_DEC			= ( ( uint32_t ) 0x02U << DMA_CFG_SAINC_Pos ),			/*!< DMA Source Mode: Address decrease */
X    DMA_SourceMode_DEC			= ( ( uint32_t ) 0x02U << (10U) ),			 
N    DMA_SourceMode_INC_CIRC = ( ( uint32_t ) 0x03U << DMA_CFG_SAINC_Pos ),			/*!< DMA Source Mode: Address increase loop */
X    DMA_SourceMode_INC_CIRC = ( ( uint32_t ) 0x03U << (10U) ),			 
N} DMA_SourceMode_TypeDef;
N
N#define IS_DMA_SOURCE_MODE(MODE) (((MODE) == DMA_SourceMode_FIXED ) || \
N                                  ((MODE) == DMA_SourceMode_INC) || \
N                                  ((MODE) == DMA_SourceMode_DEC) || \
N                                  ((MODE) == DMA_SourceMode_INC_CIRC))
X#define IS_DMA_SOURCE_MODE(MODE) (((MODE) == DMA_SourceMode_FIXED ) ||                                   ((MODE) == DMA_SourceMode_INC) ||                                   ((MODE) == DMA_SourceMode_DEC) ||                                   ((MODE) == DMA_SourceMode_INC_CIRC))
N/**
N * @}
N */
N
N/** @brief DMA_Burst  DMA Brust
N * @{
N */
Ntypedef enum
N{
N    DMA_Burst_Disable	= ( ( uint16_t ) 0x00000000 ), /*!< Brust Mode Disable */
N    DMA_Burst_1B		= ( ( ( uint16_t ) 0x07U << DMA_CFG_BURSIZE_Pos ) | DMA_CFG_TPTYPE ), /*!< Burst Mode: rease 1 */
X    DMA_Burst_1B		= ( ( ( uint16_t ) 0x07U << (12U) ) | (0x1L << (15U)) ),  
N    DMA_Burst_2B		= ( ( ( uint16_t ) 0x06U << DMA_CFG_BURSIZE_Pos ) | DMA_CFG_TPTYPE ), /*!< Burst Mode: rease 2 */
X    DMA_Burst_2B		= ( ( ( uint16_t ) 0x06U << (12U) ) | (0x1L << (15U)) ),  
N    DMA_Burst_4B		= ( ( ( uint16_t ) 0x05U << DMA_CFG_BURSIZE_Pos ) | DMA_CFG_TPTYPE ), /*!< Burst Mode: rease 4 */
X    DMA_Burst_4B		= ( ( ( uint16_t ) 0x05U << (12U) ) | (0x1L << (15U)) ),  
N    DMA_Burst_8B		= ( ( ( uint16_t ) 0x04U << DMA_CFG_BURSIZE_Pos ) | DMA_CFG_TPTYPE ), /*!< Burst Mode: rease 8 */
X    DMA_Burst_8B		= ( ( ( uint16_t ) 0x04U << (12U) ) | (0x1L << (15U)) ),  
N    DMA_Burst_16B		= ( ( ( uint16_t ) 0x03U << DMA_CFG_BURSIZE_Pos ) | DMA_CFG_TPTYPE ), /*!< Burst Mode: rease 16 */
X    DMA_Burst_16B		= ( ( ( uint16_t ) 0x03U << (12U) ) | (0x1L << (15U)) ),  
N    DMA_Burst_32B		= ( ( ( uint16_t ) 0x02U << DMA_CFG_BURSIZE_Pos ) | DMA_CFG_TPTYPE ), /*!< Burst Mode: rease 32 */
X    DMA_Burst_32B		= ( ( ( uint16_t ) 0x02U << (12U) ) | (0x1L << (15U)) ),  
N    DMA_Burst_64B		= ( ( ( uint16_t ) 0x01U << DMA_CFG_BURSIZE_Pos ) | DMA_CFG_TPTYPE ), /*!< Burst Mode: rease 64 */
X    DMA_Burst_64B		= ( ( ( uint16_t ) 0x01U << (12U) ) | (0x1L << (15U)) ),  
N    DMA_Burst_128B	= ( ( ( uint16_t ) 0x00U << DMA_CFG_BURSIZE_Pos ) | DMA_CFG_TPTYPE ), /*!< Burst Mode: rease 128 */
X    DMA_Burst_128B	= ( ( ( uint16_t ) 0x00U << (12U) ) | (0x1L << (15U)) ),  
N} DMA_Burst_TypeDef;
N
N#define IS_DMA_BURST(BURST) (((BURST) == DMA_Burst_Disable) || \
N                             ((BURST) == DMA_Burst_1B)    || \
N                             ((BURST) == DMA_Burst_2B)    || \
N                             ((BURST) == DMA_Burst_4B)    || \
N                             ((BURST) == DMA_Burst_8B)    || \
N                             ((BURST) == DMA_Burst_16B)   || \
N                             ((BURST) == DMA_Burst_32B)   || \
N                             ((BURST) == DMA_Burst_64B)   || \
N                             ((BURST) == DMA_Burst_128B))
X#define IS_DMA_BURST(BURST) (((BURST) == DMA_Burst_Disable) ||                              ((BURST) == DMA_Burst_1B)    ||                              ((BURST) == DMA_Burst_2B)    ||                              ((BURST) == DMA_Burst_4B)    ||                              ((BURST) == DMA_Burst_8B)    ||                              ((BURST) == DMA_Burst_16B)   ||                              ((BURST) == DMA_Burst_32B)   ||                              ((BURST) == DMA_Burst_64B)   ||                              ((BURST) == DMA_Burst_128B))
N/**
N * @}
N */
N
N/** @brief DMA_Request  DMA Request Source
N * @{
N */
Ntypedef enum
N{
N    DMA_Request_Null			= ( ( uint32_t ) 0x0000U << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: Null    */
X    DMA_Request_Null			= ( ( uint32_t ) 0x0000U << (24U) ),			 
N    DMA_Request_UART0_TX	= ( ( uint32_t ) 0x0002U << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: UART0 TX    */
X    DMA_Request_UART0_TX	= ( ( uint32_t ) 0x0002U << (24U) ),			 
N    DMA_Request_UART0_RX	= ( ( uint32_t ) 0x0003U << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: UART0 RX    */
X    DMA_Request_UART0_RX	= ( ( uint32_t ) 0x0003U << (24U) ),			 
N    DMA_Request_UART1_TX	= ( ( uint32_t ) 0x0004U << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: UART1 TX    */
X    DMA_Request_UART1_TX	= ( ( uint32_t ) 0x0004U << (24U) ),			 
N    DMA_Request_UART1_RX	= ( ( uint32_t ) 0x0005U << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: UART1 RX    */
X    DMA_Request_UART1_RX	= ( ( uint32_t ) 0x0005U << (24U) ),			 
N    DMA_Request_SPI0_TX		= ( ( uint32_t ) 0x000CU << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: SPI0 TX    */
X    DMA_Request_SPI0_TX		= ( ( uint32_t ) 0x000CU << (24U) ),			 
N    DMA_Request_SPI0_RX		= ( ( uint32_t ) 0x000DU << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: SPI0 RX    */
X    DMA_Request_SPI0_RX		= ( ( uint32_t ) 0x000DU << (24U) ),			 
N    DMA_Request_SPI1_TX		= ( ( uint32_t ) 0x000EU << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: SPI1 TX    */
X    DMA_Request_SPI1_TX		= ( ( uint32_t ) 0x000EU << (24U) ),			 
N    DMA_Request_SPI1_RX		= ( ( uint32_t ) 0x000FU << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: SPI1 RX    */
X    DMA_Request_SPI1_RX		= ( ( uint32_t ) 0x000FU << (24U) ),			 
N    DMA_Request_TWI0_TX		= ( ( uint32_t ) 0x0014U << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: TWI0 TX    */
X    DMA_Request_TWI0_TX		= ( ( uint32_t ) 0x0014U << (24U) ),			 
N    DMA_Request_TWI0_RX		= ( ( uint32_t ) 0x0015U << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: TWI0 RX    */
X    DMA_Request_TWI0_RX		= ( ( uint32_t ) 0x0015U << (24U) ),			 
N    DMA_Request_TIM1_TI		= ( ( uint32_t ) 0x0021U << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: TIM1 TI    */
X    DMA_Request_TIM1_TI		= ( ( uint32_t ) 0x0021U << (24U) ),			 
N    DMA_Request_TIM1_CAPF	= ( ( uint32_t ) 0x0022U << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: TIM1 Falling edge capture */
X    DMA_Request_TIM1_CAPF	= ( ( uint32_t ) 0x0022U << (24U) ),			 
N    DMA_Request_TIM1_CAPR	= ( ( uint32_t ) 0x0023U << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: TIM1 Rising edge capture  */
X    DMA_Request_TIM1_CAPR	= ( ( uint32_t ) 0x0023U << (24U) ),			 
N    DMA_Request_TIM2_TI		= ( ( uint32_t ) 0x0024U << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: TIM2 TI    */
X    DMA_Request_TIM2_TI		= ( ( uint32_t ) 0x0024U << (24U) ),			 
N    DMA_Request_TIM2_CAPF	= ( ( uint32_t ) 0x0025U << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: TIM2 Falling edge capture */
X    DMA_Request_TIM2_CAPF	= ( ( uint32_t ) 0x0025U << (24U) ),			 
N    DMA_Request_TIM2_CAPR	= ( ( uint32_t ) 0x0026U << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: TIM2 Rising edge capture  */
X    DMA_Request_TIM2_CAPR	= ( ( uint32_t ) 0x0026U << (24U) ),			 
N    DMA_Request_TIM6_TI		= ( ( uint32_t ) 0x0030U << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: TIM6 TI    */
X    DMA_Request_TIM6_TI		= ( ( uint32_t ) 0x0030U << (24U) ),			 
N    DMA_Request_TIM6_CAPF	= ( ( uint32_t ) 0x0022U << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: TIM6 Falling edge capture */
X    DMA_Request_TIM6_CAPF	= ( ( uint32_t ) 0x0022U << (24U) ),			 
N    DMA_Request_TIM6_CAPR	= ( ( uint32_t ) 0x0023U << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: TIM6 Rising edge capture  */
X    DMA_Request_TIM6_CAPR	= ( ( uint32_t ) 0x0023U << (24U) ),			 
N    DMA_Request_ADC				= ( ( uint32_t ) 0x003BU << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: ADC    */
X    DMA_Request_ADC				= ( ( uint32_t ) 0x003BU << (24U) ),			 
N#if defined(SC32f10xx) || defined(SC32f11xx) || defined(SC32f15xx)
X#if 1L || 0L || 0L
N    DMA_Request_DMA0			= ( ( uint32_t ) 0x003CU << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: DMA0    */
X    DMA_Request_DMA0			= ( ( uint32_t ) 0x003CU << (24U) ),			 
N    DMA_Request_DMA1			= ( ( uint32_t ) 0x003DU << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: DMA1    */
X    DMA_Request_DMA1			= ( ( uint32_t ) 0x003DU << (24U) ),			 
N    DMA_Request_DMA2			= ( ( uint32_t ) 0x003EU << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: DMA2    */
X    DMA_Request_DMA2			= ( ( uint32_t ) 0x003EU << (24U) ),			 
N    DMA_Request_DMA3			= ( ( uint32_t ) 0x003FU << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: DMA3    */
X    DMA_Request_DMA3			= ( ( uint32_t ) 0x003FU << (24U) ),			 
N#elif defined(SC32f12xx)
S    DMA_Request_DMA0			= ( ( uint32_t ) 0x003EU << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: DMA0    */
S    DMA_Request_DMA1			= ( ( uint32_t ) 0x003FU << DMA_CFG_REQSRC_Pos ),			/*!< DMA Requtest: DMA1    */
N#endif
N} DMA_Request_TypeDef;
N
N
N
N/**
N * @}
N */
N
N/** @brief DMA_State DMA State
N * @{
N */
Ntypedef enum
N{
N    DMA_State_IDLE				= ( ( uint32_t ) 0x00U << DMA_STS_STATUS_Pos ),			 /*!< DMA idle state */
X    DMA_State_IDLE				= ( ( uint32_t ) 0x00U << (4U) ),			  
N    DMA_State_SOURCE			= ( ( uint32_t ) 0x01U << DMA_STS_STATUS_Pos ),			 /*!< DMA write source address */
X    DMA_State_SOURCE			= ( ( uint32_t ) 0x01U << (4U) ),			  
N    DMA_State_BUSY				= ( ( uint32_t ) 0x02U << DMA_STS_STATUS_Pos ),			 /*!< DMA reads the source address data and writes to the destination address */
X    DMA_State_BUSY				= ( ( uint32_t ) 0x02U << (4U) ),			  
N    DMA_State_DESTINATION	= ( ( uint32_t ) 0x03U << DMA_STS_STATUS_Pos ),			 /*!< DMA write destination address */
X    DMA_State_DESTINATION	= ( ( uint32_t ) 0x03U << (4U) ),			  
N    DMA_State_HANG				= ( ( uint32_t ) 0x04U << DMA_STS_STATUS_Pos ),			 /*!< DMA Hang state */
X    DMA_State_HANG				= ( ( uint32_t ) 0x04U << (4U) ),			  
N    DMA_State_PAUSE				= ( ( uint32_t ) 0x05U << DMA_STS_STATUS_Pos ),			 /*!< DMA Pause state */
X    DMA_State_PAUSE				= ( ( uint32_t ) 0x05U << (4U) ),			  
N    DMA_State_BURST				= ( ( uint32_t ) 0x06U << DMA_STS_STATUS_Pos ),			 /*!< DMA Burst transmission */
X    DMA_State_BURST				= ( ( uint32_t ) 0x06U << (4U) ),			  
N    DMA_State_STOP				= ( ( uint32_t ) 0x07U << DMA_STS_STATUS_Pos ),			 /*!< DMA Stop state */
X    DMA_State_STOP				= ( ( uint32_t ) 0x07U << (4U) ),			  
N} DMA_State_TypeDef;
N
N#define IS_DMA_SASTE(SASTE) (((SASTE) == DMA_State_IDLE) || \
N                            ((SASTE) == DMA_State_SOURCE) || \
N                            ((SASTE) == DMA_State_BUSY) || \
N                            ((SASTE) == DMA_State_DESTINATION) || \
N                            ((SASTE) == DMA_State_HANG) || \
N                            ((SASTE) == DMA_State_PAUSE) || \
N                            ((SASTE) == DMA_State_BURST)) || \
N                            ((SASTE) == DMA_State_STOP))
X#define IS_DMA_SASTE(SASTE) (((SASTE) == DMA_State_IDLE) ||                             ((SASTE) == DMA_State_SOURCE) ||                             ((SASTE) == DMA_State_BUSY) ||                             ((SASTE) == DMA_State_DESTINATION) ||                             ((SASTE) == DMA_State_HANG) ||                             ((SASTE) == DMA_State_PAUSE) ||                             ((SASTE) == DMA_State_BURST)) ||                             ((SASTE) == DMA_State_STOP))
N/**
N * @}
N */
N
N
N/** @brief DMA_IT DMA Interrupt
N * @{
N */
Ntypedef enum
N{
N    DMA_IT_INTEN = ( ( uint32_t ) DMA_CFG_INTEN ),			/*!< DMA IT: INTEN    */
X    DMA_IT_INTEN = ( ( uint32_t ) (0x1L << (16U)) ),			 
N    DMA_IT_TCIE	 = ( ( uint32_t ) DMA_CFG_TCIE ),			/*!< DMA IT: TCIE    */
X    DMA_IT_TCIE	 = ( ( uint32_t ) (0x1L << (17U)) ),			 
N    DMA_IT_HTIE	 = ( ( uint32_t ) DMA_CFG_HTIE ),			/*!< DMA IT: HTIE    */
X    DMA_IT_HTIE	 = ( ( uint32_t ) (0x1L << (18U)) ),			 
N    DMA_IT_TEIE	 = ( ( uint32_t ) DMA_CFG_TEIE ),			/*!< DMA IT: TEIE    */
X    DMA_IT_TEIE	 = ( ( uint32_t ) (0x1L << (19U)) ),			 
N} DMA_IT_TypeDef;
N
N#define IS_DMA_IT(IT) ((((IT) & (uint8_t)0xF0) == 0x00) && ((IT) != (uint8_t)0x00))
N/**
N * @}
N */
N
N/** @brief DMA_Flag  DMA Flag
N * @{
N */
Ntypedef enum
N{
N    DMA_FLAG_GIF	= ( ( uint8_t ) DMA_STS_GIF ),			/*!< DMA FLAG: Global interrupt flag */
X    DMA_FLAG_GIF	= ( ( uint8_t ) (0x1L << (0U)) ),			 
N    DMA_FLAG_TCIF	= ( ( uint8_t ) DMA_STS_TCIF ),		/*!< DMA FLAG: Transmission completion interrupt flag bit */
X    DMA_FLAG_TCIF	= ( ( uint8_t ) (0x1L << (1U)) ),		 
N    DMA_FLAG_HTIF	= ( ( uint8_t ) DMA_STS_HTIF ),		/*!< DMA FLAG: Transmit half interrupt flag */
X    DMA_FLAG_HTIF	= ( ( uint8_t ) (0x1L << (2U)) ),		 
N    DMA_FLAG_TEIF	= ( ( uint8_t ) DMA_STS_TEIF ),		/*!< DMA FLAG: Transmission error interrupt flag   */
X    DMA_FLAG_TEIF	= ( ( uint8_t ) (0x1L << (3U)) ),		 
N} DMA_Flag_TypeDef;
N
N#define IS_DMA_FLAG(FLAG) ((((FLAG) & (uint8_t)0xF0) == 0x00) && ((FLAG) != (uint8_t)0x00))
N
N#define IS_GET_DMA_FLAG(FLAG) (((FLAG) == DMA_FLAG_GIF) ||  \
N                               ((FLAG) == DMA_FLAG_TCIF) || \
N															 ((FLAG) == DMA_FLAG_HTIF) || \
N                               ((FLAG) == DMA_FLAG_TEIF))
X#define IS_GET_DMA_FLAG(FLAG) (((FLAG) == DMA_FLAG_GIF) ||                                 ((FLAG) == DMA_FLAG_TCIF) || 															 ((FLAG) == DMA_FLAG_HTIF) ||                                ((FLAG) == DMA_FLAG_TEIF))
N/**
N * @}
N */
N
N/** @brief DMA_DMAReq DMA DMAReq
N * @{
N */
Ntypedef enum
N{
N    DMA_DMAReq_CHRQ = ( uint32_t ) DMA_CFG_CHRQ, /*!< TIM DMA: TIM overflow */
X    DMA_DMAReq_CHRQ = ( uint32_t ) (0x1L << (23U)),  
N} DMA_DMAReq_TypeDef;
N
N#define IS_DMA_DMAREQ(REQ) ((REQ) == DMA_DMAReq_CHRQ)
N/**
N * @}
N */
N
N
N/**
N * @}
N */
N/* End of enumerations -----------------------------------------------------*/
N
N/** @defgroup DMA_InitTypeDef TIM Exported Struct
N * @{
N */
N/** @brief DMA_InitTypeDef
N * @{
N */
Ntypedef struct
N{
N    uint16_t DMA_Priority; /*!<  Specifies the software priority for the DMAy Streamx.
N																	This parameter can be a value of @ref DMA_Priority_level */
N
N    uint16_t DMA_CircularMode; /*!< Specifies the DMA mode.
N																	This parameter can be a value of @ref DMA_CircularMode_TypeDef */
N
N
N    uint16_t DMA_DataSize; /*!< Specifies the DMA data width.
N																		This parameter can be a value of @ref DMA_DataSize_TypeDef */
N
N    uint16_t DMA_TargetMode; /*!< Specifies the DMA target address change mode.
N																	This parameter can be a value of @ref DMA_TargetMode_TypeDef */
N
N    uint16_t DMA_SourceMode; /*!< Specifies the DMA source address change mode.
N																	This parameter can be a value of @ref DMA_Burst_TypeDef */
N
N
N    uint16_t DMA_Burst; /*!< Specifies the counter dierction.
N														This parameter can be a value of @ref DMA_Burst_TypeDef */
N
N
N    uint32_t DMA_BufferSize;   /*!< Specifies the buffer size, in data unit, of the specified Stream.*/
N
N
N    uint32_t DMA_Request;/*!< DMA request source.
N																	This parameter can be a value of @ref DMA_Request_TypeDef */
N
N    uint32_t DMA_SrcAddress; /*!< The source memory Buffer address. */
N
N    uint32_t DMA_DstAddress; /*!< The destination memory Buffer address. */
N
N} DMA_InitTypeDef;
N/**
N * @}
N */
N
N/**
N * @}
N */
N/* End of struct -----------------------------------------------------*/
N
N/* Private macros ------------------------------------------------------------*/
N#if defined(SC32f10xx) || defined(SC32f11xx) || defined(SC32f15xx)
X#if 1L || 0L || 0L
N#define IS_DMA_ALL_PERIPH(PERIPH) (((PERIPH) == DMA0) || \
N																	 ((PERIPH) == DMA1) || \
N																	 ((PERIPH) == DMA2) || \
N																	 ((PERIPH) == DMA3))
X#define IS_DMA_ALL_PERIPH(PERIPH) (((PERIPH) == DMA0) || 																	 ((PERIPH) == DMA1) || 																	 ((PERIPH) == DMA2) || 																	 ((PERIPH) == DMA3))
N#elif defined(SC32f12xx)
S#define IS_DMA_ALL_PERIPH(PERIPH) (((PERIPH) == DMA0) || \
S																	 ((PERIPH) == DMA1))
X#define IS_DMA_ALL_PERIPH(PERIPH) (((PERIPH) == DMA0) || 																	 ((PERIPH) == DMA1))
N#endif
N/**
N * @}
N */
N/* End of macros -----------------------------------------------------*/
N
N/** @addtogroup DMA_Functions DMA Functions
N * @{
N */
N/* Initialization and de-initialization functions *****************/
Nvoid DMA_DeInit ( DMA_TypeDef* DMAx );
Nvoid DMA_Init ( DMA_TypeDef* DMAx, DMA_InitTypeDef* DMA_InitStruct );
Nvoid DMA_StructInit ( DMA_InitTypeDef* DMA_InitStruct );
Nvoid DMA_Cmd ( DMA_TypeDef* DMAx, FunctionalState NewState );
Nvoid DMA_PauseCmd ( DMA_TypeDef* DMAx, FunctionalState NewState );
Nvoid DMA_CHRQCmd ( DMA_TypeDef* DMAx, FunctionalState NewState );
Nvoid DMA_ChannelReset ( DMA_TypeDef* DMAx );
N/* Initialization and de-initialization functions *****************/
Nvoid DMA_SetSrcAddress ( DMA_TypeDef* DMAx, uint32_t SrcAddress );
Nvoid DMA_SetDstAddress ( DMA_TypeDef* DMAx, uint32_t DstAddress );
Nvoid DMA_SetCurrDataCounter ( DMA_TypeDef* DMAx, uint32_t Counter );
Nuint32_t DMA_GetCurrDataCounter ( DMA_TypeDef* DMAx );
Nvoid DMA_SoftwareTrigger ( DMA_TypeDef* DMAx );
N
N/* Interrupts, DMA and flags management functions ***********************/
NDMA_State_TypeDef DMA_GetStatus ( DMA_TypeDef* DMAx );
Nvoid DMA_ITConfig ( DMA_TypeDef* DMAx, uint32_t DMA_IT, FunctionalState NewState );
NFlagStatus DMA_GetFlagStatus ( DMA_TypeDef* DMAx, DMA_Flag_TypeDef DMA_FLAG );
Nvoid DMA_ClearFlag ( DMA_TypeDef* DMAx, uint32_t DMA_FLAG );
Nvoid DMA_DMACmd ( DMA_TypeDef* DMAx, uint32_t DMA_DMARequest, FunctionalState NewState );
N
N/**
N * @}
N */
N/* End of functions --------------------------------------------------------*/
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 49 "..\FWLib\SC32F1XXX_Lib\inc\sc32_conf.h" 2
N#include "sc32f1xxx_pwr.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx_pwr.h" 1
N/**
N ******************************************************************************
N * @file    sc32f1xxx_PWR.h
N * @author  SOC AE Team
N * @version V1.6
N * @date    04-09-2024
N * @brief   Header file of PWR module.
N ******************************************************************************
N * @attention
N *
N *1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only
N *intended for use with SinOne products. No other uses are authorized. This
N *software is owned by SinOne Microelectronics Co.,Ltd. and is protected under
N *all applicable laws, including copyright laws.
N *2.The software which is for guidance only aims at providing customers with
N *coding information regarding their products in order for them to save time.
N *As a result, SinOne shall not be held liable for any direct, indirect or
N *consequential damages with respect to any claims arising from the content of
N *such software and/or the use made by customers of the coding information
N *contained herein in connection with their products.
N *
N *  COPYRIGHT 2024 SinOne Microelectronics
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __sc32f1xxx_PWR_H
N#define __sc32f1xxx_PWR_H
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "sc32f1xxx.h"
N#include "sc32.h"
N#include "sc32f1xxx_rcc.h"
N
N/** @addtogroup sc32f1xxx_StdPeriph_Driver
N * @{
N */
N
N/** @addtogroup PWR
N * @{
N */
N
N/** @defgroup PWR_Enumerations PWR Enumerations
N * @{
N */
N
N/** @brief PWR_IDLEEntry PWR IDLE Mode Entry
N * @{
N */
Ntypedef enum
N{
N    PWR_IDLEEntry_WFI = ( ( uint8_t ) 0x01 ), /*!< WFI SLEEP Mode   */
N    PWR_IDLEEntry_WFE = ( ( uint8_t ) 0x02 ), /*!< WFE SLEEP Mode   */
N
N} PWR_IDLEEntry_TypeDef;
N
N#define IS_PWR_IDLE_ENTRY(ENTRY) (((ENTRY) == PWR_IDLEEntry_WFI) || \
N                                   ((ENTRY) == PWR_IDLEEntry_WFE))
X#define IS_PWR_IDLE_ENTRY(ENTRY) (((ENTRY) == PWR_IDLEEntry_WFI) ||                                    ((ENTRY) == PWR_IDLEEntry_WFE))
N/**
N * @}
N */
N
N/** @brief PWR_STOPEntry PWR STOP Mode Entry
N * @{
N */
Ntypedef enum
N{
N    PWR_STOPEntry_WFI = ( ( uint8_t ) 0x01 ), /*!< WFI STOP Mode   */
N    PWR_STOPEntry_WFE = ( ( uint8_t ) 0x02 ), /*!< WFE STOP Mode   */
N
N} PWR_STOPEntry_TypeDef;
N
N#define IS_PWR_STOP_ENTRY(ENTRY) (((ENTRY) == PWR_STOPEntry_WFI) || \
N                                   ((ENTRY) == PWR_STOPEntry_WFE))
X#define IS_PWR_STOP_ENTRY(ENTRY) (((ENTRY) == PWR_STOPEntry_WFI) ||                                    ((ENTRY) == PWR_STOPEntry_WFE))
N/**
N * @}
N */
N
N/**
N * @}
N */
N/* End of PWR Enumerations.	*/
N
N/** @addtogroup PWR_Functions PWR Functions
N * @{
N */
N
N/* Low Power modes configuration functions ********************************************************/
Nvoid PWR_EnterIDLEMode ( uint8_t PWR_IDLEEntry );
Nvoid PWR_EnterSTOPMode ( uint8_t PWR_STOPEntry );
N/**
N * @}
N */
N/* End of PWR Functions.	*/
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 50 "..\FWLib\SC32F1XXX_Lib\inc\sc32_conf.h" 2
N#if defined(SC32f11xx)
X#if 0L
S#include "sc32f1xxx_pga.h"
S#include "sc32f1xxx_can.h"	
N#endif
N#if defined(SC32f12xx)
X#if 0L
S#include "sc32f1xxx_op.h"	
N#endif
N#if defined(SC32f15xx)
X#if 0L
S#include "sc32f1xxx_dac.h"	
S#include "sc32f1xxx_can.h"
S#include "sc32f1xxx_temper.h"
S#include "sc32f1xxx_spi1_twi1.h"
S#include "sc32f1xxx_op.h"
S#include "sc32f1xxx_qep.h"
S#include "sc32f1xxx_vref.h"
N#endif
N#endif
N
L 20 "..\User\SC_Init.h" 2
N
Nvoid SC_Init(void);
Nvoid SC_NVIC_Init(void);
Nvoid SC_SYSTICK_Init(void);
Nvoid SC_RCC_Init(void);
Nvoid SC_OPTION_Init(void);
Nvoid SC_GPIO_Init(void);
Nvoid SC_UART0_Init(void);
Nvoid SC_UART1_Init(void);
Nvoid SC_UART2_Init(void);
Nvoid SC_UART3_Init(void);
N#if defined (SC32f12xx)
X#if 0L
Svoid SC_UART4_Init(void);
Svoid SC_UART5_Init(void);
N#endif
Nvoid SC_TIM0_Init(void);
Nvoid SC_TIM1_Init(void);
Nvoid SC_TIM2_Init(void);
Nvoid SC_TIM3_Init(void);
Nvoid SC_TIM4_Init(void);
Nvoid SC_TIM5_Init(void);
Nvoid SC_TIM6_Init(void);
Nvoid SC_TIM7_Init(void);
Nvoid SC_PWM0_Init(void);
Nvoid SC_LEDPWM_Init(void);
Nvoid SC_INT_Init(void);
Nvoid SC_ADC_Init(void);
Nvoid SC_IAP_Init(void);
Nvoid SC_TWI1_Init(void);
Nvoid SC_TWI0_Init(void);
Nvoid SC_SPI0_Init(void);
Nvoid SC_SPI1_Init(void);
N#if defined (SC32f12xx)
X#if 0L
Svoid SC_SPI2_Init(void);
N#endif
Nvoid SC_BTM_Init(void);
Nvoid SC_CRC_Init(void);
Nvoid SC_DMA0_Init(void);
Nvoid SC_DMA1_Init(void);
N#if defined (SC32f10xx)
X#if 1L
Nvoid SC_DMA2_Init(void);
Nvoid SC_DMA3_Init(void);
N#endif
Nvoid SC_WDT_Init(void);
Nvoid SC_PWR_Init(void);
Nvoid SC_LCD_Init(void);
Nvoid SC_LED_Init(void);
Nvoid SC_ACMP_Init(void);
N#if defined (SC32f12xx)
X#if 0L
Svoid SC_OP_Init(void);
N#endif
N#endif
N
N/**************************************Generated by EasyCodeCube*************************************/
N//Forbid editing areas between the labels !!!
N/*************************************.Generated by EasyCodeCube.************************************/
L 16 "..\User\SysFunVarDefine.c" 2
N#include "SC_it.h"
L 1 "..\User\SC_it.h" 1
N/**
N *****************************************************************************************************
N  * @copyright	(c)  
N  * @file	         SC_it.h
N  * @author	 
N  * @version 	     
N  * @date	         2024.03.11
N  * @brief	         Interrupt service program header file
N  * @details         
N *****************************************************************************************************
N * @attention
N *
N *****************************************************************************************************
N */
N#ifndef _SC_IT_H_
N#define	_SC_IT_H_
N
N#include "sc32_conf.h"
N
Nvoid INT0_IRQHandler(void);
Nvoid INT1_7_IRQHandler(void);
Nvoid INT8_11_IRQHandler(void);
Nvoid INT12_15_IRQHandler(void);
Nvoid RCC_IRQHandler(void);
N#if !defined (TK_USE_BTM)
X#if !0L
Nvoid BTM_IRQHandler(void);
N#endif
N#if defined (SC32f10xx)
X#if 1L
N	#if !defined (TK_USE_UART0_2)
X	#if !0L
N	void UART0_2_IRQHandler(void);
N	#endif
N	
N	#if !defined (TK_USE_UART1_3)
X	#if !0L
N	void UART1_3_IRQHandler(void);
N	#endif
N#elif defined (SC32f12xx)
S	#if !defined (TK_USE_UART0_2_4)
S		void UART0_2_4_IRQHandler(void);
S	#endif
S	
S	#if !defined (TK_USE_UART1_3_5)
S		void UART1_3_5_IRQHandler(void);
S	#endif
N#endif
Nvoid SPI0_IRQHandler(void);
N#if defined (SC32f10xx)
X#if 1L
Nvoid SPI1_IRQHandler(void);
N#elif defined (SC32f12xx)
Svoid SPI1_2_IRQHandler(void);
N#endif
Nvoid DMA0_IRQHandler(void);
Nvoid DMA1_IRQHandler(void);
N#if defined (SC32f10xx)
X#if 1L
Nvoid DMA2_IRQHandler(void);
Nvoid DMA3_IRQHandler(void);
N#endif
Nvoid TIMER0_IRQHandler(void);
Nvoid TIMER1_IRQHandler(void);
Nvoid TIMER2_IRQHandler(void);
Nvoid TIMER3_IRQHandler(void);
Nvoid TIMER4_5_IRQHandler(void);
Nvoid TIMER6_7_IRQHandler(void);
Nvoid PWM0_IRQHandler(void);
Nvoid LEDPWM_IRQHandler(void);
Nvoid TWI0_IRQHandler(void);
Nvoid TWI1_IRQHandler(void);
Nvoid ADC_IRQHandler(void);
Nvoid CMP_IRQHandler(void);
Nvoid SysTick_IRQHandler(void);
N#endif
N
N
N/**************************************Generated by EasyCodeCube*************************************/
N//Forbid editing areas between the labels !!!
N/*************************************.Generated by EasyCodeCube.************************************/
L 17 "..\User\SysFunVarDefine.c" 2
N#include "..\Drivers\SCDriver_list.h"
L 1 "..\User\..\Drivers\SCDriver_list.h" 1
N/**
N *****************************************************************************************************
N  * @copyright	(c)  Shenzhen Saiyuan Microelectronics Co., Ltd
N  * @file	         SCDriver_List.H
N  * @author	         Andy
N  * @version 	     V0.2
N  * @date	         2024.03.11
N  * @brief	         
N  * @details         
N *****************************************************************************************************
N * @attention
N *
N *****************************************************************************************************
N */
N#ifndef _SCDriver_List_H_
N#define _SCDriver_List_H_
N/*<Generated by EasyCodeCube begin>*/
N//Forbid editing areas between the labels !!!
N#include ".\TKDriver\C\TKDriver.h"
L 1 "..\User\..\Drivers\.\TKDriver\C\TKDriver.h" 1
N//*************************************************************************************************
N//  Copyright (c) 	
N//		:  SensorMethod.h
N//			: 
N//		:  
N// 		    :
N// 		:
N//		:    
N//************************************************************************************************
N#ifndef	_SENSORMETHOD_C_H
N#define	_SENSORMETHOD_C_H
N
N#include "sc32f1xxx.h"
N#include "SC32F1xxx_rcc.h"
N
Ntypedef	enum
N{
N	Circle = 0,		//
N	Bar = 1	,		//
N	wheel = 0,
N    slider =1
N}TKSlideModuleType;
N
Ntypedef struct
N{
N	TKSlideModuleType	TypeFlag;		//()		,Bar:Circle:
N	uint8_t  	TKChannel[16];	 		//()		6->5->4->3
N	uint8_t 	UsingTKChannelNumber;	//()		TK
N	uint16_t 	SideLevel;	            //()		1
N	
N	int16_t		SUBData;		        //()		DDiffer<SUB_DATADiffer0   
N	int16_t 	LIBData;		        //Differ>LIB_DATA
N	
N	uint8_t 	TKOrderChannel[16];		//()		TKindex
N	uint8_t 	MAXUpdateCount;			//()		10   
N	uint16_t    LastOutValue;			//()		
N	uint16_t 	OutValue;				//()		
N	uint16_t  	UpdateBaseLineNumber;	//()		
N	uint16_t	CouplingValue;			//()		(100~200),OutValue1->2->3->5->6->7,,OutValue1->2->3->4->3->4->5->6->7
N	uint16_t	DebugCouplingValue;		//()		DeBug,CouplingValue
N	uint16_t	TriggerFlagCount;		//()		
N	
N}TKSlideModulePCB;
N
N//<<<Use SPTML>>>
N#define USING_TKSlideModule_Number_Set 1 //USING_TKSlideModule_Number_Set 
N#define TypeFlag0 wheel //TypeFlag0 
N#define UsingTKChannelNumber0 0 //UsingTKChannelNumber0 
N#define SideLevel0 0 //SideLevel0 
N#define TKChannel0 0 //TKChannel0 
N#define LIBData0 0 //LIBData0 
N#define TypeFlag1 wheel //TypeFlag1 
N#define UsingTKChannelNumber1 0 //UsingTKChannelNumber1 
N#define SideLevel1 0 //SideLevel1 
N#define TKChannel1 0 //TKChannel1 
N#define LIBData1 0 //LIBData1 
N#define TypeFlag2 wheel //TypeFlag2 
N#define UsingTKChannelNumber2 0 //UsingTKChannelNumber2 
N#define SideLevel2 0 //SideLevel2 
N#define TKChannel2 0 //TKChannel2 
N#define LIBData2 0 //LIBData2 
N#define TypeFlag3 wheel //TypeFlag3 
N#define UsingTKChannelNumber3 0 //UsingTKChannelNumber3 
N#define SideLevel3 0 //SideLevel3 
N#define TKChannel3 0 //TKChannel3 
N#define LIBData3 0 //LIBData3 
N#define SCD_TK_Type 1 //SCD_TK_Type 
N#define SCD_Wheel 1 //SCD_Wheel 
N#define SCD_Slider 1 //SCD_Slider 
N#define SCD_Key 1 //SCD_Key 
N
Nextern uint8_t    TK_TouchKeyStatus;  //
Nextern  TKSlideModulePCB  TKSlideModulePCBArray[];
N
Nextern void   TK_Init(void);
Nextern void   TK_Restart(void);
Nextern uint32_t  TK_TouchKeyScan(void);
N//<<<end of SPTML>>>
N
N
N
Nextern uint8_t	 	ConfirmTouchCnt;
N
Nextern uint8_t   	RestAreaCnt[]; 
Nextern uint8_t   	TouchCnt[];				
Nextern uint8_t   	NoTouchCnt[];
Nextern uint8_t		CurrentChannel[];
Nextern uint8_t   	LowFingerDataCnt[];
Nextern int16_t   	DifferAccum[];
Nextern uint8_t	 	FloatAreaCnt[]; 
Nextern uint8_t	 	MultipleDealTpye;
Nextern int8_t		SetNoiseThreshold;
N
N#endif 
L 20 "..\User\..\Drivers\SCDriver_list.h" 2
N
N#include "..\Apps\IAP_Program.H"
L 1 "..\User\..\Drivers\..\Apps\IAP_Program.H" 1
N#ifndef _IAP_Program_H_
N#define _IAP_Program_H_
N
N#include "sc32_conf.h"
N
Nvoid IAP_Program(void);
N#endif
L 22 "..\User\..\Drivers\SCDriver_list.h" 2
N/*<Generated by EasyCodeCube end>*/
N#endif
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
L 18 "..\User\SysFunVarDefine.c" 2
N#include "HeadFiles\SysFunVarDefine.h"
L 1 "..\User\HeadFiles\SysFunVarDefine.h" 1
N/**
N *****************************************************************************************************
N  * @copyright	(c)  Shenzhen Saiyuan Microelectronics Co., Ltd
N  * @file	SysFunVarDefine.h
N  * @author	 
N  * @version 	
N  * @date	
N  * @brief	Store var control and function control extern
N  * @details 
N *****************************************************************************************************
N * @attention
N *
N *****************************************************************************************************
N */
N#ifndef SYS_FUN_VAR_DEFINE
N    #define SYS_FUN_VAR_DEFINE
N#include "CustomType.h"
L 1 "..\User\HeadFiles\CustomType.h" 1
N/**
N *****************************************************************************************************
N  * @copyright	(c)  Shenzhen Saiyuan Microelectronics Co., Ltd
N  * @file	CustomType.h
N  * @author	 
N  * @version 	
N  * @date	
N  * @brief	
N  * @details 
N *****************************************************************************************************
N * @attention
N *
N *****************************************************************************************************
N */
N#ifndef CUSTOM_TYPE_H
N    #define CUSTOM_TYPE_H
N#endif	
N
N/**************************************Generated by EasyCodeCube*************************************/
N//Forbid editing areas between the labels !!!
N
N/*************************************.Generated by EasyCodeCube.************************************/
L 18 "..\User\HeadFiles\SysFunVarDefine.h" 2
N#include "UserExport.h"
L 1 "..\User\HeadFiles\UserExport.h" 1
N/**
N *****************************************************************************************************
N  * @copyright	(c)  Shenzhen Saiyuan Microelectronics Co., Ltd
N  * @file	         UserExport.h
N  * @author	 
N  * @version 	
N  * @date	
N  * @brief	         Store head files
N  * @details 
N *****************************************************************************************************
N * @attention
N *
N *****************************************************************************************************
N */
N#ifndef USER_EXPORT_H
N    #define USER_EXPORT_H
N#endif	
N
N/**************************************Generated by EasyCodeCube*************************************/
N//Forbid editing areas between the labels !!!
N/*************************************.Generated by EasyCodeCube.************************************/
N
L 19 "..\User\HeadFiles\SysFunVarDefine.h" 2
N#include "FunctionType.h"
L 1 "..\User\HeadFiles\FunctionType.h" 1
N/**
N *****************************************************************************************************
N  * @copyright	(c)  Shenzhen Saiyuan Microelectronics Co., Ltd
N  * @file	         Function.h
N  * @author	 
N  * @version 	
N  * @date	
N  * @brief	         Store quote of the function 
N  * @details 
N *****************************************************************************************************
N * @attention
N *
N *****************************************************************************************************
N */
N#ifndef FUNCTION_H
N    #define FUNCTION_H
N#endif	
N
N/**************************************Generated by EasyCodeCube*************************************/
N//Forbid editing areas between the labels !!!
Nextern void IcResourceInit(void);
N/*************************************.Generated by EasyCodeCube.************************************/
L 20 "..\User\HeadFiles\SysFunVarDefine.h" 2
N#include "CompCtrlDefine.h"
L 1 "..\User\HeadFiles\CompCtrlDefine.h" 1
N/**
N *****************************************************************************************************
N  * @copyright	(c)  Shenzhen Saiyuan Microelectronics Co., Ltd
N  * @file	CompCtrlDefine.h
N  * @author	 
N  * @version 	
N  * @date	
N  * @brief	Store composite control define
N  * @details 
N *****************************************************************************************************
N * @attention
N *
N *****************************************************************************************************
N */
N#ifndef COMP_CTRL_DEFINE_H
N    #define COMP_CTRL_DEFINE_H
N#endif	
N
N/**************************************Generated by EasyCodeCube*************************************/
N//Forbid editing areas between the labels !!!
N
N/*************************************.Generated by EasyCodeCube.************************************/
L 21 "..\User\HeadFiles\SysFunVarDefine.h" 2
N#endif
N
N/**************************************Generated by EasyCodeCube*************************************/
N//Forbid editing areas between the labels !!!
N
N/*************************************.Generated by EasyCodeCube.************************************/
L 19 "..\User\SysFunVarDefine.c" 2
N//**********************************************************************
N/**************************************Generated by EasyCodeCube*************************************/
N//Forbid editing areas between the labels !!!
N
N/*************************************.Generated by EasyCodeCube.************************************/
