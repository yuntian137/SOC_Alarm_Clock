; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\main.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\main.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\Buzz\Inc -I..\Drivers\TKDriver\C -I..\ADC_IAP\Inc -ID:\keil\ARM\PACK\Keil\SC32F1xxx_DFP\1.0.6\Device\SC32F10xx\FWLib\SC32_Lib\inc -D__MICROLIB -D__UVISION_VERSION=534 -DSC32F10xx -DSC32f10xx --omf_browse=..\output\main.crf ..\User\main.c]
                          THUMB

                          AREA ||i.DataProcessing||, CODE, READONLY, ALIGN=2

                  DataProcessing PROC
;;;39     uint32_t TK_exKeyValueFlag;
;;;40     void DataProcessing(uint32_t value)
000000  490a              LDR      r1,|L1.44|
;;;41     {
;;;42         switch (TK_exKeyValueFlag)
000002  6809              LDR      r1,[r1,#0]  ; TK_exKeyValueFlag
000004  2201              MOVS     r2,#1
000006  0452              LSLS     r2,r2,#17
000008  1a89              SUBS     r1,r1,r2
00000a  d005              BEQ      |L1.24|
00000c  1a89              SUBS     r1,r1,r2
00000e  d107              BNE      |L1.32|
;;;43         {
;;;44         case 0x00040000:
;;;45             exKeyValue = 18;// 模式/确认
000010  2112              MOVS     r1,#0x12
000012  4a07              LDR      r2,|L1.48|
000014  7011              STRB     r1,[r2,#0]
;;;46             break;
000016  e007              B        |L1.40|
                  |L1.24|
;;;47         case 0x00020000:
;;;48             exKeyValue = 17;// 返回
000018  2111              MOVS     r1,#0x11
00001a  4a05              LDR      r2,|L1.48|
00001c  7011              STRB     r1,[r2,#0]
;;;49             break;
00001e  e003              B        |L1.40|
                  |L1.32|
;;;50         default:
;;;51             exKeyValue = 0xff;
000020  21ff              MOVS     r1,#0xff
000022  4a03              LDR      r2,|L1.48|
000024  7011              STRB     r1,[r2,#0]
;;;52             break;
000026  bf00              NOP      
                  |L1.40|
000028  bf00              NOP                            ;46
;;;53         }
;;;54     }
00002a  4770              BX       lr
;;;55     uint8_t first_Press;
                          ENDP

                  |L1.44|
                          DCD      TK_exKeyValueFlag
                  |L1.48|
                          DCD      exKeyValue

                          AREA ||i.Delay_ms||, CODE, READONLY, ALIGN=1

                  Delay_ms PROC
;;;243    
;;;244    void Delay_ms(uint16_t xms)
000000  b570              PUSH     {r4-r6,lr}
;;;245    {
000002  4604              MOV      r4,r0
;;;246        int i;
;;;247        for (i = 0; i < xms; i++)
000004  2500              MOVS     r5,#0
000006  e004              B        |L2.18|
                  |L2.8|
;;;248        {
;;;249            Delay_us(1000);
000008  207d              MOVS     r0,#0x7d
00000a  00c0              LSLS     r0,r0,#3
00000c  f7fffffe          BL       Delay_us
000010  1c6d              ADDS     r5,r5,#1              ;247
                  |L2.18|
000012  42a5              CMP      r5,r4                 ;247
000014  dbf8              BLT      |L2.8|
;;;250        }
;;;251    }
000016  bd70              POP      {r4-r6,pc}
;;;252    
                          ENDP


                          AREA ||i.Delay_us||, CODE, READONLY, ALIGN=2

                  Delay_us PROC
;;;235    
;;;236    void Delay_us(uint16_t xus)
000000  b510              PUSH     {r4,lr}
;;;237    {
000002  4604              MOV      r4,r0
;;;238        TIM_Cmd(TIM1,ENABLE); 
000004  2101              MOVS     r1,#1
000006  4808              LDR      r0,|L3.40|
000008  f7fffffe          BL       TIM_Cmd
;;;239        while(TIM1->TIM_CNT < xus);
00000c  bf00              NOP      
                  |L3.14|
00000e  4806              LDR      r0,|L3.40|
000010  6840              LDR      r0,[r0,#4]
000012  42a0              CMP      r0,r4
000014  d3fb              BCC      |L3.14|
;;;240        TIM1->TIM_CNT = 0;
000016  2000              MOVS     r0,#0
000018  4903              LDR      r1,|L3.40|
00001a  6048              STR      r0,[r1,#4]
;;;241        TIM_Cmd(TIM1,DISABLE); 
00001c  2100              MOVS     r1,#0
00001e  4802              LDR      r0,|L3.40|
000020  f7fffffe          BL       TIM_Cmd
;;;242    }
000024  bd10              POP      {r4,pc}
;;;243    
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      0x40020140

                          AREA ||i.UpdateDisplay||, CODE, READONLY, ALIGN=2

                  UpdateDisplay PROC
;;;56     uint8_t cnt;
;;;57     void UpdateDisplay(uint8_t KeyValue)
000000  b510              PUSH     {r4,lr}
;;;58     {
000002  4604              MOV      r4,r0
;;;59         if (exKeyValue != 0XFF) // 松手前只出一次键
000004  4816              LDR      r0,|L4.96|
000006  7800              LDRB     r0,[r0,#0]  ; exKeyValue
000008  28ff              CMP      r0,#0xff
00000a  d023              BEQ      |L4.84|
;;;60         {
;;;61             gTkIsValid = 1;
00000c  2001              MOVS     r0,#1
00000e  4915              LDR      r1,|L4.100|
000010  7008              STRB     r0,[r1,#0]
;;;62             KeyValue = exKeyValue;
000012  4813              LDR      r0,|L4.96|
000014  7804              LDRB     r4,[r0,#0]  ; exKeyValue
;;;63             if (first_Press == 0)
000016  4814              LDR      r0,|L4.104|
000018  7800              LDRB     r0,[r0,#0]  ; first_Press
00001a  2800              CMP      r0,#0
00001c  d11f              BNE      |L4.94|
;;;64             {
;;;65                 if (KeyValue == 17)
00001e  2c11              CMP      r4,#0x11
000020  d105              BNE      |L4.46|
;;;66                 {
;;;67                     cnt++;
000022  4812              LDR      r0,|L4.108|
000024  7800              LDRB     r0,[r0,#0]  ; cnt
000026  1c40              ADDS     r0,r0,#1
000028  4910              LDR      r1,|L4.108|
00002a  7008              STRB     r0,[r1,#0]
00002c  e00e              B        |L4.76|
                  |L4.46|
;;;68                 }
;;;69                 else if (KeyValue == 18)
00002e  2c12              CMP      r4,#0x12
000030  d10c              BNE      |L4.76|
;;;70                 {
;;;71                     cnt = 0;
000032  2000              MOVS     r0,#0
000034  490d              LDR      r1,|L4.108|
000036  7008              STRB     r0,[r1,#0]
;;;72                     // 先关灯
;;;73                     GPIO_SetBits(GPIOC, GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_10 | GPIO_Pin_11); // 先关闭所有 LED
000038  21c3              MOVS     r1,#0xc3
00003a  0109              LSLS     r1,r1,#4
00003c  480c              LDR      r0,|L4.112|
00003e  f7fffffe          BL       GPIO_SetBits
;;;74                     GPIO_SetBits(GPIOA, GPIO_Pin_7 | GPIO_Pin_8);                             // 先关闭所有 LED
000042  21ff              MOVS     r1,#0xff
000044  3181              ADDS     r1,r1,#0x81
000046  480b              LDR      r0,|L4.116|
000048  f7fffffe          BL       GPIO_SetBits
                  |L4.76|
;;;75                 }
;;;76     
;;;77                 first_Press = 1;
00004c  2001              MOVS     r0,#1
00004e  4906              LDR      r1,|L4.104|
000050  7008              STRB     r0,[r1,#0]
000052  e004              B        |L4.94|
                  |L4.84|
;;;78             }
;;;79         }
;;;80         else
;;;81         {
;;;82             gTkIsValid = 0;
000054  2000              MOVS     r0,#0
000056  4903              LDR      r1,|L4.100|
000058  7008              STRB     r0,[r1,#0]
;;;83             first_Press = 0;
00005a  4903              LDR      r1,|L4.104|
00005c  7008              STRB     r0,[r1,#0]
                  |L4.94|
;;;84         }
;;;85     }
00005e  bd10              POP      {r4,pc}
;;;86     void test_TK_LED(uint8_t cnt_LED)
                          ENDP

                  |L4.96|
                          DCD      exKeyValue
                  |L4.100|
                          DCD      gTkIsValid
                  |L4.104|
                          DCD      first_Press
                  |L4.108|
                          DCD      ||cnt||
                  |L4.112|
                          DCD      0x40011200
                  |L4.116|
                          DCD      0x40011000

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;109    uint32_t tim_cnt2;
;;;110    int main(void)
000000  b508              PUSH     {r3,lr}
;;;111    {
;;;112        /*<Generated by EasyCodeCube begin>*/
;;;113        /*<UserCodeStart>*//*<SinOne-Tag><36>*/
;;;114        IcResourceInit();
000002  f7fffffe          BL       IcResourceInit
;;;115        TIM_Cmd(TIM2, DISABLE);
000006  2100              MOVS     r1,#0
000008  482f              LDR      r0,|L5.200|
00000a  f7fffffe          BL       TIM_Cmd
;;;116        //Buzzer_SetVolume(50);
;;;117        //TK_Init();                    //重要步骤1：TK的初始化函数
;;;118        /*读取掉电保存设置*/
;;;119        loadAlarmSettings();
00000e  f7fffffe          BL       loadAlarmSettings
000012  9000              STR      r0,[sp,#0]
;;;120        Delay_ms(500);//延迟启动
000014  20ff              MOVS     r0,#0xff
000016  30f5              ADDS     r0,r0,#0xf5
000018  f7fffffe          BL       Delay_ms
;;;121        //LED = loadAlarmSettings();
;;;122        //test_TK_LED(LED.hour);//测试点灯
;;;123        /*<UserCodeEnd>*//*<SinOne-Tag><36>*/
;;;124    
;;;125        /*<UserCodeStart>*/ /*<SinOne-Tag><4>*/
;;;126        /*****MainLoop*****/
;;;127        while (1)
00001c  e052              B        |L5.196|
                  |L5.30|
;;;128        {
;;;129            /*<UserCodeStart>*/ /*<SinOne-Tag><14>*/
;;;130            /***User program***/
;;;131            // b = IAP_Program();
;;;132            switch (Task_state)
00001e  482b              LDR      r0,|L5.204|
000020  7800              LDRB     r0,[r0,#0]  ; Task_state
000022  0003              MOVS     r3,r0
000024  f7fffffe          BL       __ARM_common_switch8
000028  0504084a          DCB      0x05,0x04,0x08,0x4a
00002c  4b4c4d00          DCB      0x4b,0x4c,0x4d,0x00
;;;133            {
;;;134            case 0: // init
;;;135                    //            GPIO_SetBits(GPIOC, GPIO_Pin_4);  // LED1
;;;136                    //            GPIO_SetBits(GPIOC, GPIO_Pin_5);  // LED2
;;;137                    //            GPIO_SetBits(GPIOC, GPIO_Pin_10); // LED3
;;;138                    //            GPIO_SetBits(GPIOC, GPIO_Pin_11); // LED4
;;;139                    //            GPIO_SetBits(GPIOA, GPIO_Pin_7);  // LED5
;;;140                    //            GPIO_SetBits(GPIOA, GPIO_Pin_8);  // LED6
;;;141                Task_state = 1;
000030  2001              MOVS     r0,#1
000032  4926              LDR      r1,|L5.204|
000034  7008              STRB     r0,[r1,#0]
;;;142                break;
000036  e044              B        |L5.194|
;;;143            case 1: // TK task
;;;144                    //                WDT->WDT_CON |= WDT_CON_CLRWDT; // 清watchdog
;;;145    
;;;146                //                // 重要步骤2：触摸键扫描一轮标志，是否调用TouchKeyScan()一定要根据此标志位置起�?
;;;147                //                if (TK_TouchKeyStatus & 0x80)
;;;148                //                { // 重要步骤3：清除标志位，需要外部清零
;;;149                //                    TK_TouchKeyStatus &= 0x7f;
;;;150                //                    // 重要步骤4：分析按键数据，并返回结果出来
;;;151                //                    TK_exKeyValueFlag = TK_TouchKeyScan();
;;;152                //                    DataProcessing(TK_exKeyValueFlag); // 按键数据处理函数
;;;153    
;;;154                    //                    UpdateDisplay(exKeyValue);
;;;155                    //                    TK_Restart(); // 启动下一轮转换
;;;156                    //                }
;;;157                    //                test_TK_LED(cnt);//测试点灯
;;;158                    // if(b)
;;;159                    // {
;;;160                    //     GPIO_ResetBits(GPIOA, GPIO_Pin_8); // LED6
;;;161                    // }else
;;;162                    // {
;;;163                    //     GPIO_ResetBits(GPIOA, GPIO_Pin_7); // LED5
;;;164                    //     GPIO_SetBits(GPIOA, GPIO_Pin_8); // LED6
;;;165                    // }
;;;166    
;;;167                    uint16_t adcValue = readADC(ADC_Channel_VDD_D4);
000038  201f              MOVS     r0,#0x1f
00003a  f7fffffe          BL       readADC
00003e  4607              MOV      r7,r0
;;;168                    float voltage = adcToVoltage(adcValue)*4;
000040  4638              MOV      r0,r7
000042  f7fffffe          BL       adcToVoltage
000046  4605              MOV      r5,r0
000048  2181              MOVS     r1,#0x81
00004a  05c9              LSLS     r1,r1,#23
00004c  f7fffffe          BL       __aeabi_fmul
000050  4604              MOV      r4,r0
;;;169    //                GPIO_SetBits(GPIOA, GPIO_Pin_7); // 关闭 LED5
;;;170    //                GPIO_SetBits(GPIOC, GPIO_Pin_11); // 关闭 LED4
;;;171    //                GPIO_SetBits(GPIOC, GPIO_Pin_10); // 关闭 LED3
;;;172    //                GPIO_SetBits(GPIOC, GPIO_Pin_5);  // 关闭 LED2
;;;173    //                GPIO_SetBits(GPIOC, GPIO_Pin_4);  // 关闭 LED1
;;;174    //                if(voltage >4.8) GPIO_ResetBits(GPIOA, GPIO_Pin_7); // LED5
;;;175    //                else if(voltage >4.6) GPIO_ResetBits(GPIOC, GPIO_Pin_11); // LED4
;;;176    //                else if(voltage >4) GPIO_ResetBits(GPIOC, GPIO_Pin_10); // LED3
;;;177    //                else if(voltage >3.8) GPIO_ResetBits(GPIOC, GPIO_Pin_5);
;;;178    //                else  GPIO_ResetBits(GPIOC, GPIO_Pin_4);
;;;179    
;;;180    
;;;181    
;;;182                    if (voltage < 4.5) // 如果电压低于1.0V
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       __aeabi_f2d
000058  4605              MOV      r5,r0
00005a  2200              MOVS     r2,#0
00005c  4b1c              LDR      r3,|L5.208|
00005e  f7fffffe          BL       __aeabi_cdcmple
000062  d203              BCS      |L5.108|
;;;183                    {
;;;184                        // saveAlarmSettings(cnt);//存数据
;;;185                        initIAP();
000064  f7fffffe          BL       initIAP
;;;186                        while (1);
000068  bf00              NOP      
                  |L5.106|
00006a  e7fe              B        |L5.106|
                  |L5.108|
;;;187                         
;;;188                    }
;;;189                    static uint8_t abc = 1;
;;;190                    if (abc)
00006c  4819              LDR      r0,|L5.212|
00006e  7800              LDRB     r0,[r0,#0]  ; abc
000070  2800              CMP      r0,#0
000072  d002              BEQ      |L5.122|
;;;191                    {
;;;192                        // initIAP();
;;;193                        abc = 0;
000074  2000              MOVS     r0,#0
000076  4917              LDR      r1,|L5.212|
000078  7008              STRB     r0,[r1,#0]
                  |L5.122|
;;;194                }
;;;195    
;;;196                Delay_ms(10);
00007a  200a              MOVS     r0,#0xa
00007c  f7fffffe          BL       Delay_ms
;;;197                tim_cnt1++;
000080  4815              LDR      r0,|L5.216|
000082  6800              LDR      r0,[r0,#0]  ; tim_cnt1
000084  1c40              ADDS     r0,r0,#1
000086  4914              LDR      r1,|L5.216|
000088  6008              STR      r0,[r1,#0]  ; tim_cnt1
;;;198                if (tim_cnt1 % 20 == 0)
00008a  2114              MOVS     r1,#0x14
00008c  4812              LDR      r0,|L5.216|
00008e  6800              LDR      r0,[r0,#0]  ; tim_cnt1
000090  f7fffffe          BL       __aeabi_uidivmod
000094  2900              CMP      r1,#0
000096  d110              BNE      |L5.186|
;;;199                {
;;;200                    tim_cnt2++;
000098  4810              LDR      r0,|L5.220|
00009a  6800              LDR      r0,[r0,#0]  ; tim_cnt2
00009c  1c40              ADDS     r0,r0,#1
00009e  490f              LDR      r1,|L5.220|
0000a0  6008              STR      r0,[r1,#0]  ; tim_cnt2
;;;201                    if (tim_cnt2 % 3 == 0)
0000a2  2103              MOVS     r1,#3
0000a4  480d              LDR      r0,|L5.220|
0000a6  6800              LDR      r0,[r0,#0]  ; tim_cnt2
0000a8  f7fffffe          BL       __aeabi_uidivmod
0000ac  2900              CMP      r1,#0
0000ae  d104              BNE      |L5.186|
;;;202                    {
;;;203                        GPIO_TogglePins(GPIOA, GPIO_Pin_8);
0000b0  21ff              MOVS     r1,#0xff
0000b2  3101              ADDS     r1,#1
0000b4  480a              LDR      r0,|L5.224|
0000b6  f7fffffe          BL       GPIO_TogglePins
                  |L5.186|
;;;204                    }
;;;205                }
;;;206    
;;;207                break;
0000ba  e002              B        |L5.194|
;;;208            case 2: // Buzz SET
;;;209                break;
0000bc  e001              B        |L5.194|
;;;210            case 3: // ADC SET
;;;211                //ADC_value1 = ADC_GetConversionValue(ADC);
;;;212                // ADC_value2 = readADC(ADC_Channel_13);
;;;213                // Voltage = adcToVoltage(ADC_value2);
;;;214                // Channel = ADC_GetChannel(ADC);
;;;215    
;;;216             
;;;217                
;;;218                break;
0000be  e000              B        |L5.194|
;;;219                case 4: // ADC get
;;;220                
;;;221                break;
0000c0  bf00              NOP      
                  |L5.194|
0000c2  bf00              NOP                            ;142
                  |L5.196|
0000c4  e7ab              B        |L5.30|
;;;222                }
;;;223    
;;;224            /*<UserCodeEnd>*//*<SinOne-Tag><14>*/
;;;225            /*<UserCodeStart>*//*<SinOne-Tag><77>*/
;;;226            /*<UserCodeEnd>*//*<SinOne-Tag><77>*/
;;;227            /*<UserCodeStart>*//*<SinOne-Tag><412>*/
;;;228            //IAP_Program();
;;;229            /*<UserCodeEnd>*//*<SinOne-Tag><412>*/
;;;230            /*<Begin-Inserted by EasyCodeCube for Condition>*/
;;;231        }
;;;232        /*<UserCodeEnd>*//*<SinOne-Tag><4>*/
;;;233        /*<Generated by EasyCodeCube end>*/
;;;234    }
;;;235    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L5.200|
                          DCD      0x40020180
                  |L5.204|
                          DCD      Task_state
                  |L5.208|
                          DCD      0x40120000
                  |L5.212|
                          DCD      abc
                  |L5.216|
                          DCD      tim_cnt1
                  |L5.220|
                          DCD      tim_cnt2
                  |L5.224|
                          DCD      0x40011000

                          AREA ||i.test_TK_LED||, CODE, READONLY, ALIGN=2

                  test_TK_LED PROC
;;;85     }
;;;86     void test_TK_LED(uint8_t cnt_LED)
000000  b510              PUSH     {r4,lr}
;;;87     {
000002  4604              MOV      r4,r0
;;;88         // 根据 cnt 的值点亮相应数量的 LED
;;;89         if (cnt_LED >= 1)
000004  2c01              CMP      r4,#1
000006  db03              BLT      |L6.16|
;;;90             GPIO_ResetBits(GPIOC, GPIO_Pin_4); // LED1
000008  2110              MOVS     r1,#0x10
00000a  4812              LDR      r0,|L6.84|
00000c  f7fffffe          BL       GPIO_ResetBits
                  |L6.16|
;;;91         if (cnt_LED >= 2)
000010  2c02              CMP      r4,#2
000012  db03              BLT      |L6.28|
;;;92             GPIO_ResetBits(GPIOC, GPIO_Pin_5); // LED2
000014  2120              MOVS     r1,#0x20
000016  480f              LDR      r0,|L6.84|
000018  f7fffffe          BL       GPIO_ResetBits
                  |L6.28|
;;;93         if (cnt_LED >= 3)
00001c  2c03              CMP      r4,#3
00001e  db04              BLT      |L6.42|
;;;94             GPIO_ResetBits(GPIOC, GPIO_Pin_10); // LED3
000020  2101              MOVS     r1,#1
000022  0289              LSLS     r1,r1,#10
000024  480b              LDR      r0,|L6.84|
000026  f7fffffe          BL       GPIO_ResetBits
                  |L6.42|
;;;95         if (cnt_LED >= 4)
00002a  2c04              CMP      r4,#4
00002c  db04              BLT      |L6.56|
;;;96             GPIO_ResetBits(GPIOC, GPIO_Pin_11); // LED4
00002e  2101              MOVS     r1,#1
000030  02c9              LSLS     r1,r1,#11
000032  4808              LDR      r0,|L6.84|
000034  f7fffffe          BL       GPIO_ResetBits
                  |L6.56|
;;;97         if (cnt_LED >= 5)
000038  2c05              CMP      r4,#5
00003a  db03              BLT      |L6.68|
;;;98             GPIO_ResetBits(GPIOA, GPIO_Pin_7); // LED5
00003c  2180              MOVS     r1,#0x80
00003e  4806              LDR      r0,|L6.88|
000040  f7fffffe          BL       GPIO_ResetBits
                  |L6.68|
;;;99         if (cnt_LED >= 6)
000044  2c06              CMP      r4,#6
000046  db04              BLT      |L6.82|
;;;100            GPIO_ResetBits(GPIOA, GPIO_Pin_8); // LED6
000048  21ff              MOVS     r1,#0xff
00004a  3101              ADDS     r1,#1
00004c  4802              LDR      r0,|L6.88|
00004e  f7fffffe          BL       GPIO_ResetBits
                  |L6.82|
;;;101    }
000052  bd10              POP      {r4,pc}
;;;102    /**
                          ENDP

                  |L6.84|
                          DCD      0x40011200
                  |L6.88|
                          DCD      0x40011000

                          AREA ||.data||, DATA, ALIGN=2

                  ADC_value1
000000  0000              DCB      0x00,0x00
                  ADC_value2
000002  0000              DCB      0x00,0x00
                  Channel
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  Voltage
                          DCD      0x00000000
                  LED
00000c  000000            DCB      0x00,0x00,0x00
                  exKeyValue
00000f  00                DCB      0x00
                  gTkIsValid
000010  00                DCB      0x00
                  Task_state
000011  000000            DCB      0x00,0x00,0x00
                  TK_exKeyValueFlag
                          DCD      0x00000000
                  first_Press
000018  00                DCB      0x00
                  ||cnt||
000019  00                DCB      0x00
                  b
00001a  0000              DCB      0x00,0x00
                  tim_cnt1
                          DCD      0x00000000
                  tim_cnt2
                          DCD      0x00000000
                  abc
000024  01                DCB      0x01

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d304              BCC      |L46.24|
                  |L46.14|
00000e  5d63              LDRB     r3,[r4,r5]
000010  005b              LSLS     r3,r3,#1
000012  18e3              ADDS     r3,r4,r3
000014  bc30              POP      {r4,r5}
000016  4718              BX       r3
                  |L46.24|
000018  461d              MOV      r5,r3
00001a  e7f8              B        |L46.14|
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\User\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_04ffa752____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___6_main_c_04ffa752____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_04ffa752____REVSH|
#line 478
|__asm___6_main_c_04ffa752____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
