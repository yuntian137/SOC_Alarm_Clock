; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\sc32f1xxx_uart.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\sc32f1xxx_uart.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\Buzz\Inc -I..\Drivers\TKDriver\C -I..\Mqtt\Inc -ID:\keil\ARM\PACK\Keil\SC32F1xxx_DFP\1.0.6\Device\SC32F10xx\FWLib\SC32_Lib\inc -D__MICROLIB -D__UVISION_VERSION=534 -DSC32F10xx -DSC32f10xx --omf_browse=..\output\sc32f1xxx_uart.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_uart.c]
                          THUMB

                          AREA ||i.Printf_UartInit||, CODE, READONLY, ALIGN=2

                  Printf_UartInit PROC
;;;750     */
;;;751    __attribute__((weak)) void Printf_UartInit ( UART_TypeDef* UARTx )
000000  4901              LDR      r1,|L1.8|
;;;752    {
;;;753    
;;;754        Printf_Uart = UARTx;
000002  6008              STR      r0,[r1,#0]  ; Printf_Uart
;;;755    }
000004  4770              BX       lr
;;;756    /*printf mapping function*/
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      Printf_Uart

                          AREA ||i.UART_ClearFlag||, CODE, READONLY, ALIGN=1

                  UART_ClearFlag PROC
;;;489     */
;;;490    void UART_ClearFlag ( UART_TypeDef* UARTx, uint16_t UART_FLAG )
000000  6041              STR      r1,[r0,#4]
;;;491    {
;;;492        /* Check the parameters */
;;;493        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;494    
;;;495        /* Clear the flags */
;;;496        UARTx->UART_STS = ( uint16_t ) UART_FLAG;
;;;497    }
000002  4770              BX       lr
;;;498    
                          ENDP


                          AREA ||i.UART_DMACmd||, CODE, READONLY, ALIGN=1

                  UART_DMACmd PROC
;;;516     */
;;;517    void UART_DMACmd ( UART_TypeDef* UARTx, uint16_t UART_DMAReq, FunctionalState NewState )
000000  b510              PUSH     {r4,lr}
;;;518    {
;;;519        /* Check the parameters */
;;;520        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;521        assert_param ( IS_UART_DMAREQ ( UART_DMAReq ) );
;;;522        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;523    
;;;524        if ( NewState != DISABLE )
000002  2a00              CMP      r2,#0
000004  d003              BEQ      |L3.14|
;;;525        {
;;;526            /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;527               DMAR bits in the UART IDE register */
;;;528            UARTx->UART_IDE |= UART_DMAReq;
000006  6903              LDR      r3,[r0,#0x10]
000008  430b              ORRS     r3,r3,r1
00000a  6103              STR      r3,[r0,#0x10]
00000c  e004              B        |L3.24|
                  |L3.14|
;;;529        }
;;;530        else
;;;531        {
;;;532            /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;533               DMAR bits in the UART IDE register */
;;;534            UARTx->UART_IDE &= ( uint16_t ) ~UART_DMAReq;
00000e  6903              LDR      r3,[r0,#0x10]
000010  43cc              MVNS     r4,r1
000012  b2a4              UXTH     r4,r4
000014  4023              ANDS     r3,r3,r4
000016  6103              STR      r3,[r0,#0x10]
                  |L3.24|
;;;535        }
;;;536    }
000018  bd10              POP      {r4,pc}
;;;537    /* End of UART_Group3.	*/
                          ENDP


                          AREA ||i.UART_DeInit||, CODE, READONLY, ALIGN=2

                  UART_DeInit PROC
;;;53      */
;;;54     void UART_DeInit ( UART_TypeDef* UARTx )
000000  b510              PUSH     {r4,lr}
;;;55     {
000002  4604              MOV      r4,r0
;;;56         assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;57     
;;;58         if ( UARTx == UART0 )
000004  4818              LDR      r0,|L4.104|
000006  4284              CMP      r4,r0
000008  d108              BNE      |L4.28|
;;;59         {
;;;60             /* Enable UART0 reset state */
;;;61             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART0, ENABLE );
00000a  2101              MOVS     r1,#1
00000c  2040              MOVS     r0,#0x40
00000e  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;62             /* Release UART0 from reset state */
;;;63             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART0, DISABLE );
000012  2100              MOVS     r1,#0
000014  2040              MOVS     r0,#0x40
000016  f7fffffe          BL       RCC_APB0PeriphResetCmd
00001a  e023              B        |L4.100|
                  |L4.28|
;;;64         }
;;;65         else if ( UARTx == UART1 )
00001c  4812              LDR      r0,|L4.104|
00001e  3060              ADDS     r0,r0,#0x60
000020  4284              CMP      r4,r0
000022  d108              BNE      |L4.54|
;;;66         {
;;;67             /* Enable UART1 reset state */
;;;68             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART1, ENABLE );
000024  2101              MOVS     r1,#1
000026  2080              MOVS     r0,#0x80
000028  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;69             /* Release UART1 from reset state */
;;;70             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART1, DISABLE );
00002c  2100              MOVS     r1,#0
00002e  2080              MOVS     r0,#0x80
000030  f7fffffe          BL       RCC_APB0PeriphResetCmd
000034  e016              B        |L4.100|
                  |L4.54|
;;;71         }
;;;72         else if ( UARTx == UART2 )
000036  480d              LDR      r0,|L4.108|
000038  4284              CMP      r4,r0
00003a  d108              BNE      |L4.78|
;;;73         {
;;;74             /* Enable UART2 reset state */
;;;75             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_UART2, ENABLE );
00003c  2101              MOVS     r1,#1
00003e  2080              MOVS     r0,#0x80
000040  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;76             /* Release UART2 from reset state */
;;;77             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_UART2, DISABLE );
000044  2100              MOVS     r1,#0
000046  2080              MOVS     r0,#0x80
000048  f7fffffe          BL       RCC_APB1PeriphResetCmd
00004c  e00a              B        |L4.100|
                  |L4.78|
;;;78         }
;;;79     #if !defined(SC32f15xx)
;;;80         else if ( UARTx == UART3 )
00004e  4808              LDR      r0,|L4.112|
000050  4284              CMP      r4,r0
000052  d107              BNE      |L4.100|
;;;81         {
;;;82             /* Enable UART3 reset state */
;;;83             RCC_APB2PeriphResetCmd ( RCC_APB2Periph_UART3, ENABLE );
000054  2101              MOVS     r1,#1
000056  2004              MOVS     r0,#4
000058  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;84             /* Release UART3 from reset state */
;;;85             RCC_APB2PeriphResetCmd ( RCC_APB2Periph_UART3, DISABLE );
00005c  2100              MOVS     r1,#0
00005e  2004              MOVS     r0,#4
000060  f7fffffe          BL       RCC_APB2PeriphResetCmd
                  |L4.100|
;;;86         }
;;;87     #endif
;;;88     #if  defined(SC32f11xx) || defined(SC32f12xx)
;;;89         if ( UARTx == UART4 )
;;;90         {
;;;91             /* Enable UART0 reset state */
;;;92             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_UART4, ENABLE );
;;;93             /* Release UART0 from reset state */
;;;94             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_UART4, DISABLE );
;;;95         }
;;;96         else if ( UARTx == UART5 )
;;;97         {
;;;98             /* Enable UART5 reset state */
;;;99             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART5, ENABLE );
;;;100            /* Release UART5 from reset state */
;;;101            RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART5, DISABLE );
;;;102        }
;;;103    #endif
;;;104    }
000064  bd10              POP      {r4,pc}
;;;105    
                          ENDP

000066  0000              DCW      0x0000
                  |L4.104|
                          DCD      0x40020020
                  |L4.108|
                          DCD      0x40021020
                  |L4.112|
                          DCD      0x40022020

                          AREA ||i.UART_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  UART_GetFlagStatus PROC
;;;446     */
;;;447    FlagStatus UART_GetFlagStatus ( UART_TypeDef* UARTx, UART_FLAG_TypeDef UART_FLAG )
000000  4602              MOV      r2,r0
;;;448    {
;;;449        ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;450        /* Check the parameters */
;;;451        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;452        assert_param ( IS_GET_UART_FLAG ( UART_FLAG ) );
;;;453    
;;;454        if ( ( UARTx->UART_STS & UART_FLAG ) != ( uint16_t ) RESET )
000004  6853              LDR      r3,[r2,#4]
000006  400b              ANDS     r3,r3,r1
000008  2b00              CMP      r3,#0
00000a  d001              BEQ      |L5.16|
;;;455        {
;;;456            bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L5.18|
                  |L5.16|
;;;457        }
;;;458        else
;;;459        {
;;;460            bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L5.18|
;;;461        }
;;;462        return bitstatus;
;;;463    }
000012  4770              BX       lr
;;;464    
                          ENDP


                          AREA ||i.UART_ITConfig||, CODE, READONLY, ALIGN=1

                  UART_ITConfig PROC
;;;404     */
;;;405    void UART_ITConfig ( UART_TypeDef* UARTx, uint16_t UART_IT, FunctionalState NewState )
000000  b510              PUSH     {r4,lr}
;;;406    {
;;;407        /* Check the parameters */
;;;408        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;409        assert_param ( IS_UART_IT ( UART_IT ) );
;;;410        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;411    
;;;412        if ( NewState != DISABLE )
000002  2a00              CMP      r2,#0
000004  d003              BEQ      |L6.14|
;;;413        {
;;;414            /* Enable the Interrupt sources */
;;;415            UARTx->UART_IDE |= UART_IT;
000006  6903              LDR      r3,[r0,#0x10]
000008  430b              ORRS     r3,r3,r1
00000a  6103              STR      r3,[r0,#0x10]
00000c  e004              B        |L6.24|
                  |L6.14|
;;;416        }
;;;417        else
;;;418        {
;;;419            /* Disable the Interrupt sources */
;;;420            UARTx->UART_IDE &= ( uint16_t ) ~UART_IT;
00000e  6903              LDR      r3,[r0,#0x10]
000010  43cc              MVNS     r4,r1
000012  b2a4              UXTH     r4,r4
000014  4023              ANDS     r3,r3,r4
000016  6103              STR      r3,[r0,#0x10]
                  |L6.24|
;;;421        }
;;;422    }
000018  bd10              POP      {r4,pc}
;;;423    
                          ENDP


                          AREA ||i.UART_Init||, CODE, READONLY, ALIGN=2

                  UART_Init PROC
;;;123     */
;;;124    void UART_Init ( UART_TypeDef* UARTx, UART_InitTypeDef* UART_InitStruct )
000000  b570              PUSH     {r4-r6,lr}
;;;125    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;126        uint32_t tmpreg;
;;;127        /* Check the parameters */
;;;128        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;129        assert_param ( IS_UART_Mode ( UART_InitStruct->UART_Mode ) );
;;;130    
;;;131        tmpreg = UARTx->UART_CON;
000006  6826              LDR      r6,[r4,#0]
;;;132        tmpreg &= ( uint32_t ) ~ ( UART_CON_SM01 | UART_CON_SM2 );
000008  08f6              LSRS     r6,r6,#3
00000a  00f6              LSLS     r6,r6,#3
;;;133        tmpreg |= ( uint32_t ) ( UART_InitStruct->UART_Mode );
00000c  68a8              LDR      r0,[r5,#8]
00000e  4306              ORRS     r6,r6,r0
;;;134        UARTx->UART_CON = tmpreg;
000010  6026              STR      r6,[r4,#0]
;;;135    
;;;136        if ( UART_InitStruct->UART_Mode == UART_Mode_8B )
000012  68a8              LDR      r0,[r5,#8]
000014  2800              CMP      r0,#0
000016  d108              BNE      |L7.42|
;;;137        {
;;;138            assert_param ( IS_UART_PRESCALER ( UART_InitStruct->UART_BaudRate ) );
;;;139    
;;;140            UARTx->UART_CON &= ~ ( uint32_t ) UART_CON_PERSCALER;
000018  6820              LDR      r0,[r4,#0]
00001a  2110              MOVS     r1,#0x10
00001c  4388              BICS     r0,r0,r1
00001e  6020              STR      r0,[r4,#0]
;;;141            UARTx->UART_CON |= ( uint32_t ) UART_InitStruct->UART_BaudRate;
000020  6820              LDR      r0,[r4,#0]
000022  6869              LDR      r1,[r5,#4]
000024  4308              ORRS     r0,r0,r1
000026  6020              STR      r0,[r4,#0]
000028  e00d              B        |L7.70|
                  |L7.42|
;;;142        }
;;;143        else
;;;144        {
;;;145            tmpreg = ( UART_InitStruct->UART_ClockFrequency / UART_InitStruct->UART_BaudRate );
00002a  6869              LDR      r1,[r5,#4]
00002c  6828              LDR      r0,[r5,#0]
00002e  f7fffffe          BL       __aeabi_uidivmod
000032  4606              MOV      r6,r0
;;;146            if ( tmpreg > 65535 )
000034  4804              LDR      r0,|L7.72|
000036  4286              CMP      r6,r0
000038  d904              BLS      |L7.68|
;;;147            {
;;;148                UARTx->UART_CON |= ( uint32_t ) UART_CON_PERSCALER;
00003a  6820              LDR      r0,[r4,#0]
00003c  2110              MOVS     r1,#0x10
00003e  4308              ORRS     r0,r0,r1
000040  6020              STR      r0,[r4,#0]
;;;149                tmpreg = tmpreg / 16;
000042  0936              LSRS     r6,r6,#4
                  |L7.68|
;;;150            }
;;;151            UARTx->UART_BAUD = tmpreg;
000044  60a6              STR      r6,[r4,#8]
                  |L7.70|
;;;152        }
;;;153    }
000046  bd70              POP      {r4-r6,pc}
;;;154    
                          ENDP

                  |L7.72|
                          DCD      0x0000ffff

                          AREA ||i.UART_PinRemapConfig||, CODE, READONLY, ALIGN=2

                  UART_PinRemapConfig PROC
;;;323     */
;;;324    void UART_PinRemapConfig ( UART_TypeDef* UARTx, UART_PinRemap_TypeDef UART_Remap )
000000  b510              PUSH     {r4,lr}
;;;325    {
000002  460a              MOV      r2,r1
;;;326        uint32_t tmpreg;
;;;327    
;;;328        /* Check the parameters */
;;;329    #if defined(SC32f10xx)
;;;330        if ( UARTx == UART2 )
000004  4b06              LDR      r3,|L8.32|
000006  4298              CMP      r0,r3
000008  d109              BNE      |L8.30|
;;;331        {
;;;332            tmpreg = UARTx->UART_CON;
00000a  6801              LDR      r1,[r0,#0]
;;;333    
;;;334            tmpreg &= ( uint32_t ) ( ~UART_CON_SPOS );
00000c  2403              MOVS     r4,#3
00000e  03a4              LSLS     r4,r4,#14
000010  460b              MOV      r3,r1
000012  43a3              BICS     r3,r3,r4
000014  4619              MOV      r1,r3
;;;335    
;;;336            tmpreg |= UART_Remap;
000016  460b              MOV      r3,r1
000018  4313              ORRS     r3,r3,r2
00001a  4619              MOV      r1,r3
;;;337    
;;;338            UARTx->UART_CON = tmpreg;
00001c  6001              STR      r1,[r0,#0]
                  |L8.30|
;;;339        }
;;;340    #elif defined(SC32f11xx)
;;;341        if ( UARTx == UART2 || UARTx == UART1 || UARTx == UART5 )
;;;342        {
;;;343            tmpreg = UARTx->UART_CON;
;;;344    
;;;345            tmpreg &= ( uint32_t ) ( ~UART_CON_SPOS );
;;;346    
;;;347            tmpreg |= UART_Remap;
;;;348    
;;;349            UARTx->UART_CON = tmpreg;
;;;350        }
;;;351    #elif defined(SC32f12xx) ||defined(SC32f15xx)
;;;352        tmpreg = UARTx->UART_CON;
;;;353    
;;;354        tmpreg &= ( uint32_t ) ( ~UART_CON_SPOS );
;;;355    
;;;356        tmpreg |= UART_Remap;
;;;357    
;;;358        UARTx->UART_CON = tmpreg;
;;;359    #endif
;;;360    }
00001e  bd10              POP      {r4,pc}
;;;361    
                          ENDP

                  |L8.32|
                          DCD      0x40021020

                          AREA ||i.UART_RXCmd||, CODE, READONLY, ALIGN=2

                  UART_RXCmd PROC
;;;208     */
;;;209    void UART_RXCmd ( UART_TypeDef* UARTx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;210    {
;;;211        /* Check the parameters */
;;;212        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;213        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;214    
;;;215        if ( NewState != DISABLE )
000002  d004              BEQ      |L9.14|
;;;216        {
;;;217            /* Enable the UART RX Function */
;;;218            UARTx->UART_CON |= UART_CON_RXEN;
000004  6802              LDR      r2,[r0,#0]
000006  2340              MOVS     r3,#0x40
000008  431a              ORRS     r2,r2,r3
00000a  6002              STR      r2,[r0,#0]
00000c  e003              B        |L9.22|
                  |L9.14|
;;;219        }
;;;220        else
;;;221        {
;;;222            /* Disable the UART RX Function */
;;;223            UARTx->UART_CON &= ( uint16_t ) ~UART_CON_RXEN;
00000e  6802              LDR      r2,[r0,#0]
000010  4b01              LDR      r3,|L9.24|
000012  401a              ANDS     r2,r2,r3
000014  6002              STR      r2,[r0,#0]
                  |L9.22|
;;;224        }
;;;225    }
000016  4770              BX       lr
;;;226    
                          ENDP

                  |L9.24|
                          DCD      0x0000ffbf

                          AREA ||i.UART_ReceiveData||, CODE, READONLY, ALIGN=1

                  UART_ReceiveData PROC
;;;281     */
;;;282    uint16_t UART_ReceiveData ( UART_TypeDef* UARTx )
000000  4601              MOV      r1,r0
;;;283    {
;;;284        /* Check the parameters */
;;;285        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;286    
;;;287        /* Receive Data */
;;;288        return ( uint16_t ) ( UARTx->UART_DATA & ( uint16_t ) 0x01FF );
000002  68c8              LDR      r0,[r1,#0xc]
000004  05c0              LSLS     r0,r0,#23
000006  0dc0              LSRS     r0,r0,#23
;;;289    }
000008  4770              BX       lr
;;;290    
                          ENDP


                          AREA ||i.UART_SendData||, CODE, READONLY, ALIGN=1

                  UART_SendData PROC
;;;257     */
;;;258    void UART_SendData ( UART_TypeDef* UARTx, uint16_t Data )
000000  05ca              LSLS     r2,r1,#23
;;;259    {
;;;260        /* Check the parameters */
;;;261        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;262    
;;;263        /* Transmit Data */
;;;264        UARTx->UART_DATA = ( Data & ( uint16_t ) 0x01FF );
000002  0dd2              LSRS     r2,r2,#23
000004  60c2              STR      r2,[r0,#0xc]
;;;265    }
000006  4770              BX       lr
;;;266    
                          ENDP


                          AREA ||i.UART_TXCmd||, CODE, READONLY, ALIGN=2

                  UART_TXCmd PROC
;;;172     */
;;;173    void UART_TXCmd ( UART_TypeDef* UARTx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;174    {
;;;175        /* Check the parameters */
;;;176        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;177        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;178    
;;;179        if ( NewState != DISABLE )
000002  d004              BEQ      |L12.14|
;;;180        {
;;;181            /* Enable the UART TX Function */
;;;182            UARTx->UART_CON |= UART_CON_TXEN;
000004  6802              LDR      r2,[r0,#0]
000006  2380              MOVS     r3,#0x80
000008  431a              ORRS     r2,r2,r3
00000a  6002              STR      r2,[r0,#0]
00000c  e003              B        |L12.22|
                  |L12.14|
;;;183        }
;;;184        else
;;;185        {
;;;186            /* Disable the UART TX Function */
;;;187            UARTx->UART_CON &= ( uint16_t ) ~UART_CON_TXEN;
00000e  6802              LDR      r2,[r0,#0]
000010  4b01              LDR      r3,|L12.24|
000012  401a              ANDS     r2,r2,r3
000014  6002              STR      r2,[r0,#0]
                  |L12.22|
;;;188        }
;;;189    }
000016  4770              BX       lr
;;;190    
                          ENDP

                  |L12.24|
                          DCD      0x0000ff7f

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;757    #if defined (__ARMCC_VERSION)||defined (__ICCARM__)
;;;758    __attribute__((weak)) int fputc ( int c, FILE* f )
000000  b530              PUSH     {r4,r5,lr}
;;;759    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;760        UART_SendData ( Printf_Uart, ( uint8_t ) c );
000006  b2e1              UXTB     r1,r4
000008  4809              LDR      r0,|L13.48|
00000a  6800              LDR      r0,[r0,#0]  ; Printf_Uart
00000c  f7fffffe          BL       UART_SendData
;;;761        while ( !UART_GetFlagStatus ( Printf_Uart, UART_Flag_TX ) );
000010  bf00              NOP      
                  |L13.18|
000012  2102              MOVS     r1,#2
000014  4806              LDR      r0,|L13.48|
000016  6800              LDR      r0,[r0,#0]  ; Printf_Uart
000018  f7fffffe          BL       UART_GetFlagStatus
00001c  2800              CMP      r0,#0
00001e  d0f8              BEQ      |L13.18|
;;;762        UART_ClearFlag ( Printf_Uart, UART_Flag_TX );
000020  2102              MOVS     r1,#2
000022  4803              LDR      r0,|L13.48|
000024  6800              LDR      r0,[r0,#0]  ; Printf_Uart
000026  f7fffffe          BL       UART_ClearFlag
;;;763        return c;
00002a  4620              MOV      r0,r4
;;;764    }
00002c  bd30              POP      {r4,r5,pc}
;;;765    #elif defined (__GNUC__)
                          ENDP

00002e  0000              DCW      0x0000
                  |L13.48|
                          DCD      Printf_Uart

                          AREA ||.data||, DATA, ALIGN=2

                  Printf_Uart
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_sc32f1xxx_uart_c_c95a8597____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___16_sc32f1xxx_uart_c_c95a8597____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_sc32f1xxx_uart_c_c95a8597____REVSH|
#line 478
|__asm___16_sc32f1xxx_uart_c_c95a8597____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
