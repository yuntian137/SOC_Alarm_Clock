; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\tkdriver.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\tkdriver.d --cpu=Cortex-M0+ --apcs=interwork --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\Buzz\Inc -I..\Drivers\TKDriver\C -ID:\keil\ARM\PACK\Keil\SC32F1xxx_DFP\1.0.6\Device\SC32F10xx\FWLib\SC32_Lib\inc -D__UVISION_VERSION=534 -DSC32F10xx -DSC32f10xx --omf_browse=..\output\tkdriver.crf ..\Drivers\TKDriver\C\TKDriver.C]
                          THUMB

                          AREA ||i.TK_GetBaseLineAdjustValue||, CODE, READONLY, ALIGN=2

                  TK_GetBaseLineAdjustValue PROC
;;;277    *****************************************************************************/
;;;278    uint8_t TK_GetBaseLineAdjustValue(uint8_t i)
000000  4901              LDR      r1,|L1.8|
;;;279    {	
;;;280         return SingleParameterBufferSet[i].BaseLineAdjusttmp; 
000002  5c08              LDRB     r0,[r1,r0]
;;;281    }
000004  4770              BX       lr
;;;282    
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      ||area_number.23||+0x7

                          AREA ||i.TK_GetBaselineUpdateThreshold||, CODE, READONLY, ALIGN=1

                  TK_GetBaselineUpdateThreshold PROC
;;;180    *****************************************************************************/
;;;181    uint16_t TK_GetBaselineUpdateThreshold(void)
000000  2064              MOVS     r0,#0x64
;;;182    {
;;;183    	return TKCFG[SET_UPDATE_SPEED]; 
;;;184    }
000002  4770              BX       lr
;;;185    
                          ENDP


                          AREA ||i.TK_GetCfgMsg||, CODE, READONLY, ALIGN=2

                  TK_GetCfgMsg PROC
;;;351    *****************************************************************************/
;;;352    uint8_t  TK_GetCfgMsg(uint8_t i,uint8_t j)
000000  b530              PUSH     {r4,r5,lr}
;;;353    {
;;;354    	switch(j)
;;;355    	{ 
;;;356    		case 0:  return TKChannelCfg[i][SET_TOUCH_FREQ]; 
000002  220a              MOVS     r2,#0xa
000004  4604              MOV      r4,r0
000006  4d0d              LDR      r5,|L3.60|
000008  4354              MULS     r4,r2,r4
;;;357    		case 1:  return TKChannelCfg[i][SET_RESOLUTION];
00000a  1962              ADDS     r2,r4,r5
00000c  000b              MOVS     r3,r1                 ;354
00000e  f7fffffe          BL       __ARM_common_switch8
000012  0705              DCB      0x07,0x05
000014  07090b12          DCB      0x07,0x09,0x0b,0x12
000018  0e101200          DCB      0x0e,0x10,0x12,0x00
00001c  5d28              LDRB     r0,[r5,r4]            ;356
;;;358    		case 2:  return TKChannelCfg[i][SET_GAIN_CFG];
;;;359    		case 3:  return TK_GetBaseLineAdjustValue(i);
;;;360    		case 4:  return TKCFG[SET_ANTIJAM];
;;;361    		case 5:  return TKChannelCfg[i][SET_RESOLUTION_FACTOR];
;;;362    		case 6:  return TKChannelCfg[i][SET_ICHA_FACTOR];
;;;363    		
;;;364    		default:return 0; 	 	
;;;365    	}
;;;366    }
00001e  bd30              POP      {r4,r5,pc}
000020  7890              LDRB     r0,[r2,#2]            ;357
000022  bd30              POP      {r4,r5,pc}
000024  78d0              LDRB     r0,[r2,#3]            ;358
000026  bd30              POP      {r4,r5,pc}
000028  4905              LDR      r1,|L3.64|
00002a  5c08              LDRB     r0,[r1,r0]
00002c  bd30              POP      {r4,r5,pc}
00002e  7850              LDRB     r0,[r2,#1]            ;361
000030  bd30              POP      {r4,r5,pc}
000032  7950              LDRB     r0,[r2,#5]            ;362
000034  bd30              POP      {r4,r5,pc}
000036  2000              MOVS     r0,#0                 ;364
000038  bd30              POP      {r4,r5,pc}
;;;367    
                          ENDP

00003a  0000              DCW      0x0000
                  |L3.60|
                          DCD      ||area_number.21||
                  |L3.64|
                          DCD      ||area_number.23||+0x7

                          AREA ||i.TK_GetCsFunction||, CODE, READONLY, ALIGN=1

                  TK_GetCsFunction PROC
;;;216    *****************************************************************************/
;;;217    uint8_t TK_GetCsFunction(void)
000000  2001              MOVS     r0,#1
;;;218    {
;;;219    	return SOCAPI_SET_CS_FUNCTION; 
;;;220    }
000002  4770              BX       lr
;;;221    
                          ENDP


                          AREA ||i.TK_GetCurrFingerValue||, CODE, READONLY, ALIGN=2

                  TK_GetCurrFingerValue PROC
;;;252    *****************************************************************************/
;;;253    uint16_t TK_GetCurrFingerValue(uint8_t i)
000000  210a              MOVS     r1,#0xa
;;;254    { 
;;;255    	return	TKChannelCfg[i][FINGER_THRESHOLD_H]*256+TKChannelCfg[i][FINGER_THRESHOLD_L] ;
000002  4348              MULS     r0,r1,r0
000004  4903              LDR      r1,|L5.20|
000006  1840              ADDS     r0,r0,r1
000008  7a01              LDRB     r1,[r0,#8]
00000a  7a40              LDRB     r0,[r0,#9]
00000c  0209              LSLS     r1,r1,#8
00000e  1808              ADDS     r0,r1,r0
000010  b280              UXTH     r0,r0
;;;256    }
000012  4770              BX       lr
;;;257    
                          ENDP

                  |L5.20|
                          DCD      ||area_number.21||

                          AREA ||i.TK_GetInitAutoUpdateTime||, CODE, READONLY, ALIGN=1

                  TK_GetInitAutoUpdateTime PROC
;;;192    *****************************************************************************/
;;;193    uint8_t TK_GetInitAutoUpdateTime(void)
000000  200a              MOVS     r0,#0xa
;;;194    {
;;;195    	return  TKCFG[INIT_AUTO_UPDATE_TIME];
;;;196    }
000002  4770              BX       lr
;;;197    
                          ENDP


                          AREA ||i.TK_GetScanTimeValue||, CODE, READONLY, ALIGN=2

                  TK_GetScanTimeValue PROC
;;;264    *****************************************************************************/
;;;265    uint8_t TK_GetScanTimeValue(uint8_t i)
000000  210a              MOVS     r1,#0xa
;;;266    { 
;;;267    	return TKChannelCfg[i][SCANTIME];
000002  4348              MULS     r0,r1,r0
000004  4901              LDR      r1,|L7.12|
000006  1840              ADDS     r0,r0,r1
000008  7900              LDRB     r0,[r0,#4]
;;;268    }
00000a  4770              BX       lr
;;;269    
                          ENDP

                  |L7.12|
                          DCD      ||area_number.21||

                          AREA ||i.TK_GetTKYzCnt||, CODE, READONLY, ALIGN=2

                  TK_GetTKYzCnt PROC
;;;240    *****************************************************************************/
;;;241    uint8_t TK_GetTKYzCnt(void)
000000  b510              PUSH     {r4,lr}
;;;242    {
;;;243    	return (ConfirmTouchCnt/3);
000002  4803              LDR      r0,|L8.16|
000004  2103              MOVS     r1,#3
000006  7800              LDRB     r0,[r0,#0]  ; ConfirmTouchCnt
000008  f7fffffe          BL       __aeabi_uidivmod
;;;244    }
00000c  bd10              POP      {r4,pc}
;;;245    
                          ENDP

00000e  0000              DCW      0x0000
                  |L8.16|
                          DCD      ||area_number.23||

                          AREA ||i.TK_GetTKYzThreshold||, CODE, READONLY, ALIGN=1

                  TK_GetTKYzThreshold PROC
;;;289    *****************************************************************************/
;;;290    uint16_t TK_GetTKYzThreshold(uint8_t i)
000000  b510              PUSH     {r4,lr}
;;;291    {	
;;;292    	uint16_t SetFingerThresholdtmp; 
;;;293    	
;;;294    	SetFingerThresholdtmp = TK_GetCurrFingerValue(i); 
000002  f7fffffe          BL       TK_GetCurrFingerValue
;;;295        SetFingerThresholdtmp = SetFingerThresholdtmp*SOCAPI_INHIBITION_ZONE/10;
000006  00c0              LSLS     r0,r0,#3
000008  210a              MOVS     r1,#0xa
00000a  f7fffffe          BL       __aeabi_uidivmod
00000e  b280              UXTH     r0,r0
;;;296    
;;;297    	return SetFingerThresholdtmp;
;;;298    }
000010  bd10              POP      {r4,pc}
;;;299    
                          ENDP


                          AREA ||i.TK_GetUpConfirmCnt||, CODE, READONLY, ALIGN=2

                  TK_GetUpConfirmCnt PROC
;;;228    *****************************************************************************/
;;;229    uint8_t TK_GetUpConfirmCnt(void)
000000  4801              LDR      r0,|L10.8|
;;;230    {
;;;231    	return ConfirmTouchCnt>>1;
000002  7800              LDRB     r0,[r0,#0]  ; ConfirmTouchCnt
000004  0840              LSRS     r0,r0,#1
;;;232    }
000006  4770              BX       lr
;;;233    
                          ENDP

                  |L10.8|
                          DCD      ||area_number.23||

                          AREA ||i.TK_IRQHandler||, CODE, READONLY, ALIGN=1

                  TK_IRQHandler PROC
;;;533    *****************************************************************************/
;;;534    void TK_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;535    {
;;;536    	TK_TouchKey_Service();
000002  f7fffffe          BL       TK_TouchKey_Service
;;;537    }	
000006  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i.TK_IsDoubleKeyOrSlideKey||, CODE, READONLY, ALIGN=1

                  TK_IsDoubleKeyOrSlideKey PROC
;;;204    *****************************************************************************/
;;;205    uint8_t TK_IsDoubleKeyOrSlideKey(void)
000000  2000              MOVS     r0,#0
;;;206    {
;;;207        return TKCFG[IsDoubleKey];
;;;208    }
000002  4770              BX       lr
;;;209    
                          ENDP


                          AREA ||i.TK_SetOneKeyPushResetTime||, CODE, READONLY, ALIGN=2

                  TK_SetOneKeyPushResetTime PROC
;;;168    *****************************************************************************/
;;;169    uint16_t TK_SetOneKeyPushResetTime(void)   
000000  4800              LDR      r0,|L13.4|
;;;170    {	  
;;;171    	return  TKCFG[SET_KEY_CONTI_TIME];
;;;172    }
000002  4770              BX       lr
;;;173    
                          ENDP

                  |L13.4|
                          DCD      0x00000bb8

                          AREA ||i.TK_SingleCurrentSensorChoose||, CODE, READONLY, ALIGN=2

                  TK_SingleCurrentSensorChoose PROC
;;;306    *****************************************************************************/
;;;307    void TK_SingleCurrentSensorChoose(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;308    {
;;;309    	uint8_t i = 0,j = 0,k = 0;
000002  2000              MOVS     r0,#0
;;;310    	uint8_t Ctk_Channel_mark = 0;
;;;311    	uint32_t CurrentSensorKey ; 		 
;;;312    	
;;;313    	CurrentSensorKey = SOCAPI_SET_TOUCHKEY_CHANNEL; 
;;;314    		
;;;315    	for(i=0;i<32;i++)
;;;316    	{
;;;317    		if((0x01L << i) & CurrentSensorKey)
;;;318    		{
;;;319    			CurrentChannel[Ctk_Channel_mark] = i;						//选择触摸当前的通道
000004  4b1b              LDR      r3,|L14.116|
000006  4601              MOV      r1,r0                 ;310
000008  4604              MOV      r4,r0                 ;313
00000a  2501              MOVS     r5,#1                 ;317
                  |L14.12|
00000c  462a              MOV      r2,r5                 ;317
00000e  4082              LSLS     r2,r2,r0              ;317
000010  4222              TST      r2,r4                 ;317
000012  d004              BEQ      |L14.30|
000014  5458              STRB     r0,[r3,r1]
000016  1c49              ADDS     r1,r1,#1
;;;320    			Ctk_Channel_mark++;
000018  b2c9              UXTB     r1,r1
;;;321    			if(Ctk_Channel_mark >= SOCAPI_SET_TOUCHKEY_TOTAL)
00001a  2903              CMP      r1,#3
00001c  d203              BCS      |L14.38|
                  |L14.30|
00001e  1c40              ADDS     r0,r0,#1
000020  b2c0              UXTB     r0,r0                 ;315
000022  2820              CMP      r0,#0x20              ;315
000024  d3f2              BCC      |L14.12|
                  |L14.38|
;;;322    				break;
;;;323    		}		
;;;324    	}
;;;325    	
;;;326    #ifdef USING_SlideModule
;;;327    	for(k = 0; k < UsingTKSlideModuleNumber; k ++)
000026  4814              LDR      r0,|L14.120|
000028  2400              MOVS     r4,#0
00002a  7800              LDRB     r0,[r0,#0]
00002c  4684              MOV      r12,r0
00002e  e01b              B        |L14.104|
                  |L14.48|
000030  4620              MOV      r0,r4                 ;309
;;;328    	{
;;;329    		for(i = 0;i<TKSlideModulePCBArray[k].UsingTKChannelNumber;i++)						//在CurrentChannel[]中取出滑条TK通道排列序号 
;;;330    		{
;;;331    			for(j=0;j<Ctk_Channel_mark;j++)
;;;332    			{
;;;333    				if(TKSlideModulePCBArray[k].TKChannel[i] == CurrentChannel[j])	//取序号
000032  2336              MOVS     r3,#0x36
000034  4358              MULS     r0,r3,r0
000036  4b0f              LDR      r3,|L14.116|
000038  2200              MOVS     r2,#0                 ;329
00003a  1d9b              ADDS     r3,r3,#6
00003c  18c5              ADDS     r5,r0,r3
00003e  e00e              B        |L14.94|
                  |L14.64|
000040  2000              MOVS     r0,#0                 ;331
000042  18ab              ADDS     r3,r5,r2
000044  e007              B        |L14.86|
                  |L14.70|
000046  4e0b              LDR      r6,|L14.116|
000048  785f              LDRB     r7,[r3,#1]
00004a  5c36              LDRB     r6,[r6,r0]
00004c  42b7              CMP      r7,r6
00004e  d100              BNE      |L14.82|
;;;334    				{
;;;335    					TKSlideModulePCBArray[k].TKOrderChannel[i]=j;	
000050  7618              STRB     r0,[r3,#0x18]
                  |L14.82|
000052  1c40              ADDS     r0,r0,#1
000054  b2c0              UXTB     r0,r0                 ;331
                  |L14.86|
000056  4288              CMP      r0,r1                 ;331
000058  d3f5              BCC      |L14.70|
00005a  1c52              ADDS     r2,r2,#1              ;331
00005c  b2d2              UXTB     r2,r2                 ;329
                  |L14.94|
00005e  7c68              LDRB     r0,[r5,#0x11]         ;329
000060  4290              CMP      r0,r2                 ;329
000062  d8ed              BHI      |L14.64|
000064  1c64              ADDS     r4,r4,#1              ;329
000066  b2e4              UXTB     r4,r4                 ;327
                  |L14.104|
000068  4564              CMP      r4,r12                ;327
00006a  d3e1              BCC      |L14.48|
;;;336    				}
;;;337    			}	
;;;338    		}
;;;339    	}
;;;340    #endif
;;;341    	
;;;342    	SingleCurrentChannelMax = Ctk_Channel_mark;							//当前选择的按键数 
00006c  4803              LDR      r0,|L14.124|
00006e  7001              STRB     r1,[r0,#0]
;;;343    }
000070  bdf0              POP      {r4-r7,pc}
;;;344    
                          ENDP

000072  0000              DCW      0x0000
                  |L14.116|
                          DCD      ||area_number.23||+0x4
                  |L14.120|
                          DCD      UsingTKSlideModuleNumber
                  |L14.124|
                          DCD      SingleCurrentChannelMax

                          AREA ||i.TK_TouchKeyCFGInit||, CODE, READONLY, ALIGN=2

                  TK_TouchKeyCFGInit PROC
;;;374    *****************************************************************************/
;;;375    void TK_TouchKeyCFGInit(void)
000000  b570              PUSH     {r4-r6,lr}
;;;376    {
;;;377    	uint8_t i;
;;;378    #ifdef USING_SlideModule
;;;379    	uint8_t	k;
;;;380    #endif	
;;;381    	
;;;382    	UsingTKSlideModuleNumber = USING_TKSlideModule_Number;
000002  4c14              LDR      r4,|L15.84|
000004  2001              MOVS     r0,#1
000006  7020              STRB     r0,[r4,#0]
;;;383    	ConfirmTouchCnt = TKCFG[CONFIRMTOUCHCNT];
000008  4d13              LDR      r5,|L15.88|
00000a  2005              MOVS     r0,#5
00000c  7028              STRB     r0,[r5,#0]
;;;384    	SetNoiseThreshold = TKCFG[NOISE];
00000e  2014              MOVS     r0,#0x14
000010  7068              STRB     r0,[r5,#1]
;;;385    	TK_SingleCurrentSensorChoose(); 
000012  f7fffffe          BL       TK_SingleCurrentSensorChoose
;;;386    	for(i=0;i< SingleCurrentChannelMax;i++)
000016  4912              LDR      r1,|L15.96|
000018  2000              MOVS     r0,#0
;;;387    	{
;;;388    		SingleParameterBufferSet[i].BaseLineAdjusttmp = TKChannelCfg[i][SET_ICHA];;	
00001a  4a10              LDR      r2,|L15.92|
00001c  1deb              ADDS     r3,r5,#7
00001e  7809              LDRB     r1,[r1,#0]            ;386
000020  e006              B        |L15.48|
                  |L15.34|
000022  260a              MOVS     r6,#0xa
000024  4346              MULS     r6,r0,r6
000026  18b6              ADDS     r6,r6,r2
000028  79b6              LDRB     r6,[r6,#6]
00002a  541e              STRB     r6,[r3,r0]
00002c  1c40              ADDS     r0,r0,#1
00002e  b2c0              UXTB     r0,r0                 ;386
                  |L15.48|
000030  4288              CMP      r0,r1                 ;386
000032  d3f6              BCC      |L15.34|
;;;389    	} 
;;;390    	UpdateBaseLNum = 0; 
000034  2200              MOVS     r2,#0
;;;391    	
;;;392    	
;;;393    #ifdef USING_SlideModule
;;;394    	for(k = 0; k < UsingTKSlideModuleNumber; k ++)
;;;395    	{
;;;396    		TKSlideModulePCBArray[k].UpdateBaseLineNumber = 0;
000036  4b08              LDR      r3,|L15.88|
000038  806a              STRH     r2,[r5,#2]            ;390
00003a  4610              MOV      r0,r2                 ;394
00003c  330a              ADDS     r3,r3,#0xa
00003e  7824              LDRB     r4,[r4,#0]            ;382
000040  e005              B        |L15.78|
                  |L15.66|
000042  2136              MOVS     r1,#0x36
000044  4341              MULS     r1,r0,r1
000046  18c9              ADDS     r1,r1,r3
000048  1c40              ADDS     r0,r0,#1
00004a  85ca              STRH     r2,[r1,#0x2e]
00004c  b2c0              UXTB     r0,r0                 ;394
                  |L15.78|
00004e  42a0              CMP      r0,r4                 ;394
000050  d3f7              BCC      |L15.66|
;;;397    	}
;;;398    #endif
;;;399    	
;;;400    }
000052  bd70              POP      {r4-r6,pc}
;;;401    
                          ENDP

                  |L15.84|
                          DCD      UsingTKSlideModuleNumber
                  |L15.88|
                          DCD      ||area_number.23||
                  |L15.92|
                          DCD      ||area_number.21||
                  |L15.96|
                          DCD      SingleCurrentChannelMax

                          AREA ||i.TK_TouchKeyScan||, CODE, READONLY, ALIGN=2

                  TK_TouchKeyScan PROC
;;;411    *****************************************************************************/
;;;412    uint32_t TK_TouchKeyScan(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;413    {
;;;414    #ifdef	USING_SlideModule
;;;415    	uint8_t   k;
;;;416    #endif
;;;417    	uint8_t   t;
;;;418        uint8_t   MultipleCnt = 0;//按键计数
;;;419    	uint32_t  Keyvalue ; 
;;;420    	uint32_t  KeyData = 0; 
000002  2000              MOVS     r0,#0
;;;421    	
;;;422    	if(TK_GetIsNeedUpdateBaseline() == 0)				//检测是否需要更新baseline 
000004  9000              STR      r0,[sp,#0]
000006  f7fffffe          BL       TK_GetIsNeedUpdateBaseline
00000a  2800              CMP      r0,#0
00000c  d004              BEQ      |L16.24|
;;;423    	{
;;;424    		Keyvalue = TK_SensorKeyFlag();					//Sensor判断, 这里如果bMultiple = 1 表示中间有干扰	 //分析按键，得出标准的通道bit 位 
;;;425    		
;;;426    
;;;427    #if (defined USING_TKKey_T1)		
;;;428    		for(t=0;t< SingleCurrentChannelMax;t++)
;;;429    		{
;;;430    			if((0x01L << t) & Keyvalue)
;;;431    			{
;;;432    				KeyData |= ((uint32_t)0x01 << (CurrentChannel[t]));              
;;;433    				MultipleCnt++;							
;;;434    			}
;;;435    		}                
;;;436    		
;;;437    		if(MultipleCnt >= 2) 	 									//进入多按键处理
;;;438    		{			
;;;439    			bMultiple = 1;			
;;;440    			if(MultipleCnt >= SOCAPI_MAX_KEY_NUM_INVALID)
;;;441    			{
;;;442    				TK_SetNeedUpdateBaseline(); 							// 立即更新baseline ,例如亚克力板盖上去
;;;443    			}
;;;444    			else
;;;445    			{					
;;;446    				if(TK_IsDoubleKeyOrSlideKey())
;;;447    				{
;;;448    					bMultiple = 0;
;;;449    				} 				 
;;;450    			}			
;;;451    		}			
;;;452    
;;;453    		if(bMultiple == 0)							//进入按键判断
;;;454    		{		
;;;455    			if(KeyData != 0x0)					    //单个按键达到多长时间就update baseline ,松手检测
;;;456    			{			
;;;457    				UpdateBaseLNum++; 
;;;458    			}
;;;459    			else	
;;;460    			{
;;;461    				UpdateBaseLNum = 0; 	
;;;462    			} 
;;;463    		}	
;;;464    		else
;;;465    		{   
;;;466    		    //考虑基线更新		
;;;467    			MultipleLNum++; 
;;;468    			KeyData = 0x00;
;;;469    		}
;;;470    #endif
;;;471    		
;;;472    #ifdef	USING_SlideModule
;;;473    	
;;;474    		for(k = 0; k < UsingTKSlideModuleNumber; k ++)
;;;475    		{
;;;476    			if(TKSlideModulePCBArray[k].OutValue != 0x00)					        //单个按键达到多长时间就update baseline ,松手检测
;;;477    			{	
;;;478    				if(TKSlideModulePCBArray[k].OutValue == TKSlideModulePCBArray[k].LastOutValue)
;;;479    				{		
;;;480    				   TKSlideModulePCBArray[k].UpdateBaseLineNumber++; 
;;;481    				}
;;;482    				else
;;;483    				{
;;;484    				   TKSlideModulePCBArray[k].LastOutValue = TKSlideModulePCBArray[k].OutValue;
;;;485    				   TKSlideModulePCBArray[k].UpdateBaseLineNumber = 0; 
;;;486    				}
;;;487    			}
;;;488    			else	
;;;489    			{
;;;490    				TKSlideModulePCBArray[k].UpdateBaseLineNumber = 0; 	
;;;491    			}
;;;492    
;;;493    			if(TKSlideModulePCBArray[k].UpdateBaseLineNumber >= TK_SetOneKeyPushResetTime())	  //按键超出最长输出时间更新基线
;;;494    			{
;;;495    				TK_SetNeedUpdateBaseline(); 
;;;496    				TKSlideModulePCBArray[k].UpdateBaseLineNumber = 0;
;;;497    			}
;;;498    		}
;;;499    #endif
;;;500    				
;;;501    
;;;502    #if (defined USING_TKKey_T1)
;;;503    		if(UpdateBaseLNum >= TK_SetOneKeyPushResetTime())	  //按键超出最长输出时间更新基线
;;;504    		{
;;;505     			TK_SetNeedUpdateBaseline(); 
;;;506    			UpdateBaseLNum = 0;
;;;507    		}
;;;508    				
;;;509    		if(MultipleLNum > SOCAPI_MAX_KEY_MUTIPLE)		  //干扰计数大于最大计数更新基线
;;;510     		{
;;;511    			TK_SetNeedUpdateBaseline(); 
;;;512    			MultipleDealTpye = 1; 
;;;513    			MultipleLNum = 0;
;;;514    		} 
;;;515    #endif
;;;516    		
;;;517    	}			
;;;518    	else
;;;519    	{
;;;520    		TK_MultipleDeal(TKCFG[AUTO_UPDATE_TIME]);			//基线复位处理
00000e  2002              MOVS     r0,#2
000010  f7fffffe          BL       TK_MultipleDeal
                  |L16.20|
;;;521    	}  
;;;522    	
;;;523    	return KeyData;
000014  9800              LDR      r0,[sp,#0]
;;;524    		
;;;525    }
000016  bdf8              POP      {r3-r7,pc}
                  |L16.24|
000018  f7fffffe          BL       TK_SensorKeyFlag
00001c  2500              MOVS     r5,#0                 ;474
00001e  462e              MOV      r6,r5                 ;474
000020  4f0e              LDR      r7,|L16.92|
000022  e016              B        |L16.82|
                  |L16.36|
000024  2036              MOVS     r0,#0x36              ;476
000026  4368              MULS     r0,r5,r0              ;476
000028  19c4              ADDS     r4,r0,r7              ;476
00002a  8da0              LDRH     r0,[r4,#0x2c]         ;476
00002c  2800              CMP      r0,#0                 ;476
00002e  d00d              BEQ      |L16.76|
000030  8d61              LDRH     r1,[r4,#0x2a]         ;478
000032  4288              CMP      r0,r1                 ;478
000034  d109              BNE      |L16.74|
000036  8de0              LDRH     r0,[r4,#0x2e]         ;480
000038  4909              LDR      r1,|L16.96|
00003a  1c40              ADDS     r0,r0,#1              ;480
00003c  b280              UXTH     r0,r0                 ;480
00003e  85e0              STRH     r0,[r4,#0x2e]         ;480
000040  4288              CMP      r0,r1                 ;493
000042  d304              BCC      |L16.78|
000044  f7fffffe          BL       TK_SetNeedUpdateBaseline
000048  e000              B        |L16.76|
                  |L16.74|
00004a  8560              STRH     r0,[r4,#0x2a]         ;484
                  |L16.76|
00004c  85e6              STRH     r6,[r4,#0x2e]         ;490
                  |L16.78|
00004e  1c6d              ADDS     r5,r5,#1              ;490
000050  b2ed              UXTB     r5,r5                 ;474
                  |L16.82|
000052  4804              LDR      r0,|L16.100|
000054  7800              LDRB     r0,[r0,#0]            ;474  ; UsingTKSlideModuleNumber
000056  4285              CMP      r5,r0                 ;474
000058  d3e4              BCC      |L16.36|
00005a  e7db              B        |L16.20|
;;;526    
                          ENDP

                  |L16.92|
                          DCD      ||area_number.23||+0xa
                  |L16.96|
                          DCD      0x00000bb8
                  |L16.100|
                          DCD      UsingTKSlideModuleNumber

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  SingleChannelsBaseLineUpdatePar
                          %        18

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  TKCFG
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000005
                          DCD      0x0000000a
                          DCD      0x00000bb8
                          DCD      0x000000c8
                          DCD      0x00000064
                          DCD      0x00000002
                          DCD      0x00000001
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000000
                          DCD      0x00000001
                          DCD      0x0000ffff
                          DCD      0x0000ffff
                          DCD      0x00000014

                          AREA ||area_number.21||, DATA, READONLY, ALIGN=0

                          EXPORTAS ||area_number.21||, ||.constdata||
                  TKChannelCfg
000000  06022e04          DCB      0x06,0x02,0x2e,0x04
000004  08030e05          DCB      0x08,0x03,0x0e,0x05
000008  0fff0602          DCB      0x0f,0xff,0x06,0x02
00000c  2e040803          DCB      0x2e,0x04,0x08,0x03
000010  11050fff          DCB      0x11,0x05,0x0f,0xff
000014  06022e04          DCB      0x06,0x02,0x2e,0x04
000018  08030f05          DCB      0x08,0x03,0x0f,0x05
00001c  0fff              DCB      0x0f,0xff

                          AREA ||.data||, DATA, ALIGN=0

                  MultipleDealTpye
000000  00                DCB      0x00

                          AREA ||area_number.23||, DATA, ALIGN=1

                          EXPORTAS ||area_number.23||, ||.data||
                  ConfirmTouchCnt
000000  00                DCB      0x00
                  SetNoiseThreshold
000001  00                DCB      0x00
                  UpdateBaseLNum
000002  0000              DCB      0x00,0x00
                  CurrentChannel
000004  000000            DCB      0x00,0x00,0x00
                  SingleParameterBufferSet
000007  00                DCB      0x00
000008  0000              DCB      0x00,0x00
                  TKSlideModulePCBArray
00000a  011d              DCB      0x01,0x1d
00000c  1e1f0000          DCB      0x1e,0x1f,0x00,0x00
                          %        8
000018  00000003          DCB      0x00,0x00,0x00,0x03
00001c  00200014          DCW      0x0020,0x0014
000020  0064              DCW      0x0064
000022  0000              DCB      0x00,0x00
                          %        12
000030  00000100          DCB      0x00,0x00,0x01,0x00
000034  00000000          DCW      0x0000,0x0000
000038  00000096          DCW      0x0000,0x0096
00003c  00000000          DCW      0x0000,0x0000

                          AREA ||area_number.24||, DATA, ALIGN=0

                          EXPORTAS ||area_number.24||, ||.data||
                  CFG_OVERLOW_MAX_COUNT
000000  0a                DCB      0x0a

                          AREA ||area_number.25||, DATA, ALIGN=0

                          EXPORTAS ||area_number.25||, ||.data||
                  CFG_RESET_BASELINE_CNT
000000  0a                DCB      0x0a

                          AREA ||area_number.26||, DATA, ALIGN=0

                          EXPORTAS ||area_number.26||, ||.data||
                  CFG_CYCLE_CNT
000000  20                DCB      0x20

                          AREA ||area_number.27||, DATA, ALIGN=0

                          EXPORTAS ||area_number.27||, ||.data||
                  TK_TouchKeyStatus
000000  00                DCB      0x00

                          AREA ||area_number.28||, DATA, ALIGN=0

                          EXPORTAS ||area_number.28||, ||.data||
                  RestAreaCnt
000000  000000            DCB      0x00,0x00,0x00

                          AREA ||area_number.29||, DATA, ALIGN=0

                          EXPORTAS ||area_number.29||, ||.data||
                  TouchCnt
000000  000000            DCB      0x00,0x00,0x00

                          AREA ||area_number.30||, DATA, ALIGN=0

                          EXPORTAS ||area_number.30||, ||.data||
                  NoTouchCnt
000000  000000            DCB      0x00,0x00,0x00

                          AREA ||area_number.31||, DATA, ALIGN=0

                          EXPORTAS ||area_number.31||, ||.data||
                  LowFingerDataCnt
000000  000000            DCB      0x00,0x00,0x00

                          AREA ||area_number.32||, DATA, ALIGN=0

                          EXPORTAS ||area_number.32||, ||.data||
                  FloatAreaCnt
000000  000000            DCB      0x00,0x00,0x00

                          AREA ||area_number.33||, DATA, ALIGN=1

                          EXPORTAS ||area_number.33||, ||.data||
                  DifferAccum
                          DCDU     0x00000000
000004  0000              DCB      0x00,0x00

                          AREA ||area_number.34||, DATA, ALIGN=0

                          EXPORTAS ||area_number.34||, ||.data||
                  CombineParameterBufferSet
000000  000000            DCB      0x00,0x00,0x00

                          AREA ||area_number.35||, DATA, ALIGN=1

                          EXPORTAS ||area_number.35||, ||.data||
                  MultipleLNum
000000  0000              DCB      0x00,0x00

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d200              BCS      |L119.16|
00000e  461d              MOV      r5,r3
                  |L119.16|
000010  5d63              LDRB     r3,[r4,r5]
000012  005b              LSLS     r3,r3,#1
000014  18e3              ADDS     r3,r4,r3
000016  bc30              POP      {r4,r5}
000018  4718              BX       r3
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Drivers\\TKDriver\\C\\TKDriver.C"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_TKDriver_C_TKCFG____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___10_TKDriver_C_TKCFG____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_TKDriver_C_TKCFG____REVSH|
#line 478
|__asm___10_TKDriver_C_TKCFG____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
