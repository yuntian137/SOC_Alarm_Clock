; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\tkdriver.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\tkdriver.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\Buzz\Inc -I..\Drivers\TKDriver\C -ID:\keil\ARM\PACK\Keil\SC32F1xxx_DFP\1.0.6\Device\SC32F10xx\FWLib\SC32_Lib\inc -D__MICROLIB -D__UVISION_VERSION=534 -DSC32F10xx -DSC32f10xx --omf_browse=..\output\tkdriver.crf ..\Drivers\TKDriver\C\TKDriver.C]
                          THUMB

                          AREA ||i.TK_GetBaseLineAdjustValue||, CODE, READONLY, ALIGN=2

                  TK_GetBaseLineAdjustValue PROC
;;;277    *****************************************************************************/
;;;278    uint8_t TK_GetBaseLineAdjustValue(uint8_t i)
000000  4601              MOV      r1,r0
;;;279    {	
;;;280         return SingleParameterBufferSet[i].BaseLineAdjusttmp; 
000002  4801              LDR      r0,|L1.8|
000004  5c40              LDRB     r0,[r0,r1]
;;;281    }
000006  4770              BX       lr
;;;282    
                          ENDP

                  |L1.8|
                          DCD      SingleParameterBufferSet

                          AREA ||i.TK_GetBaselineUpdateThreshold||, CODE, READONLY, ALIGN=2

                  TK_GetBaselineUpdateThreshold PROC
;;;180    *****************************************************************************/
;;;181    uint16_t TK_GetBaselineUpdateThreshold(void)
000000  4801              LDR      r0,|L2.8|
;;;182    {
;;;183    	return TKCFG[SET_UPDATE_SPEED]; 
000002  8b80              LDRH     r0,[r0,#0x1c]  ; TKCFG
000004  b280              UXTH     r0,r0
;;;184    }
000006  4770              BX       lr
;;;185    
                          ENDP

                  |L2.8|
                          DCD      TKCFG

                          AREA ||i.TK_GetCfgMsg||, CODE, READONLY, ALIGN=2

                  TK_GetCfgMsg PROC
;;;351    *****************************************************************************/
;;;352    uint8_t  TK_GetCfgMsg(uint8_t i,uint8_t j)
000000  b510              PUSH     {r4,lr}
;;;353    {
000002  4602              MOV      r2,r0
000004  460c              MOV      r4,r1
;;;354    	switch(j)
000006  0023              MOVS     r3,r4
000008  f7fffffe          BL       __ARM_common_switch8
00000c  07050a10          DCB      0x07,0x05,0x0a,0x10
000010  161a1e24          DCB      0x16,0x1a,0x1e,0x24
000014  2a00              DCB      0x2a,0x00
;;;355    	{ 
;;;356    		case 0:  return TKChannelCfg[i][SET_TOUCH_FREQ]; 
000016  200a              MOVS     r0,#0xa
000018  4350              MULS     r0,r2,r0
00001a  4912              LDR      r1,|L3.100|
00001c  5c08              LDRB     r0,[r1,r0]
                  |L3.30|
;;;357    		case 1:  return TKChannelCfg[i][SET_RESOLUTION];
;;;358    		case 2:  return TKChannelCfg[i][SET_GAIN_CFG];
;;;359    		case 3:  return TK_GetBaseLineAdjustValue(i);
;;;360    		case 4:  return TKCFG[SET_ANTIJAM];
;;;361    		case 5:  return TKChannelCfg[i][SET_RESOLUTION_FACTOR];
;;;362    		case 6:  return TKChannelCfg[i][SET_ICHA_FACTOR];
;;;363    		
;;;364    		default:return 0; 	 	
;;;365    	}
;;;366    }
00001e  bd10              POP      {r4,pc}
000020  200a              MOVS     r0,#0xa               ;357
000022  4350              MULS     r0,r2,r0              ;357
000024  490f              LDR      r1,|L3.100|
000026  1840              ADDS     r0,r0,r1              ;357
000028  7880              LDRB     r0,[r0,#2]            ;357
00002a  e7f8              B        |L3.30|
00002c  200a              MOVS     r0,#0xa               ;358
00002e  4350              MULS     r0,r2,r0              ;358
000030  490c              LDR      r1,|L3.100|
000032  1840              ADDS     r0,r0,r1              ;358
000034  78c0              LDRB     r0,[r0,#3]            ;358
000036  e7f2              B        |L3.30|
000038  4610              MOV      r0,r2                 ;359
00003a  f7fffffe          BL       TK_GetBaseLineAdjustValue
00003e  e7ee              B        |L3.30|
000040  4809              LDR      r0,|L3.104|
000042  8d00              LDRH     r0,[r0,#0x28]         ;360  ; TKCFG
000044  b2c0              UXTB     r0,r0                 ;360
000046  e7ea              B        |L3.30|
000048  200a              MOVS     r0,#0xa               ;361
00004a  4350              MULS     r0,r2,r0              ;361
00004c  4905              LDR      r1,|L3.100|
00004e  1840              ADDS     r0,r0,r1              ;361
000050  7840              LDRB     r0,[r0,#1]            ;361
000052  e7e4              B        |L3.30|
000054  200a              MOVS     r0,#0xa               ;362
000056  4350              MULS     r0,r2,r0              ;362
000058  4902              LDR      r1,|L3.100|
00005a  1840              ADDS     r0,r0,r1              ;362
00005c  7940              LDRB     r0,[r0,#5]            ;362
00005e  e7de              B        |L3.30|
000060  2000              MOVS     r0,#0                 ;364
000062  e7dc              B        |L3.30|
;;;367    
                          ENDP

                  |L3.100|
                          DCD      TKChannelCfg
                  |L3.104|
                          DCD      TKCFG

                          AREA ||i.TK_GetCsFunction||, CODE, READONLY, ALIGN=1

                  TK_GetCsFunction PROC
;;;216    *****************************************************************************/
;;;217    uint8_t TK_GetCsFunction(void)
000000  2001              MOVS     r0,#1
;;;218    {
;;;219    	return SOCAPI_SET_CS_FUNCTION; 
;;;220    }
000002  4770              BX       lr
;;;221    
                          ENDP


                          AREA ||i.TK_GetCurrFingerValue||, CODE, READONLY, ALIGN=2

                  TK_GetCurrFingerValue PROC
;;;252    *****************************************************************************/
;;;253    uint16_t TK_GetCurrFingerValue(uint8_t i)
000000  4601              MOV      r1,r0
;;;254    { 
;;;255    	return	TKChannelCfg[i][FINGER_THRESHOLD_H]*256+TKChannelCfg[i][FINGER_THRESHOLD_L] ;
000002  200a              MOVS     r0,#0xa
000004  4348              MULS     r0,r1,r0
000006  4a06              LDR      r2,|L5.32|
000008  1880              ADDS     r0,r0,r2
00000a  7a00              LDRB     r0,[r0,#8]
00000c  0202              LSLS     r2,r0,#8
00000e  200a              MOVS     r0,#0xa
000010  4348              MULS     r0,r1,r0
000012  4b03              LDR      r3,|L5.32|
000014  18c0              ADDS     r0,r0,r3
000016  7a40              LDRB     r0,[r0,#9]
000018  1810              ADDS     r0,r2,r0
00001a  b280              UXTH     r0,r0
;;;256    }
00001c  4770              BX       lr
;;;257    
                          ENDP

00001e  0000              DCW      0x0000
                  |L5.32|
                          DCD      TKChannelCfg

                          AREA ||i.TK_GetInitAutoUpdateTime||, CODE, READONLY, ALIGN=2

                  TK_GetInitAutoUpdateTime PROC
;;;192    *****************************************************************************/
;;;193    uint8_t TK_GetInitAutoUpdateTime(void)
000000  4801              LDR      r0,|L6.8|
;;;194    {
;;;195    	return  TKCFG[INIT_AUTO_UPDATE_TIME];
000002  7c00              LDRB     r0,[r0,#0x10]  ; TKCFG
;;;196    }
000004  4770              BX       lr
;;;197    
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      TKCFG

                          AREA ||i.TK_GetScanTimeValue||, CODE, READONLY, ALIGN=2

                  TK_GetScanTimeValue PROC
;;;264    *****************************************************************************/
;;;265    uint8_t TK_GetScanTimeValue(uint8_t i)
000000  4601              MOV      r1,r0
;;;266    { 
;;;267    	return TKChannelCfg[i][SCANTIME];
000002  200a              MOVS     r0,#0xa
000004  4348              MULS     r0,r1,r0
000006  4a02              LDR      r2,|L7.16|
000008  1880              ADDS     r0,r0,r2
00000a  7900              LDRB     r0,[r0,#4]
;;;268    }
00000c  4770              BX       lr
;;;269    
                          ENDP

00000e  0000              DCW      0x0000
                  |L7.16|
                          DCD      TKChannelCfg

                          AREA ||i.TK_GetTKYzCnt||, CODE, READONLY, ALIGN=2

                  TK_GetTKYzCnt PROC
;;;240    *****************************************************************************/
;;;241    uint8_t TK_GetTKYzCnt(void)
000000  b510              PUSH     {r4,lr}
;;;242    {
;;;243    	return (ConfirmTouchCnt/3);
000002  2103              MOVS     r1,#3
000004  4802              LDR      r0,|L8.16|
000006  7800              LDRB     r0,[r0,#0]  ; ConfirmTouchCnt
000008  f7fffffe          BL       __aeabi_idivmod
00000c  b2c0              UXTB     r0,r0
;;;244    }
00000e  bd10              POP      {r4,pc}
;;;245    
                          ENDP

                  |L8.16|
                          DCD      ConfirmTouchCnt

                          AREA ||i.TK_GetTKYzThreshold||, CODE, READONLY, ALIGN=1

                  TK_GetTKYzThreshold PROC
;;;289    *****************************************************************************/
;;;290    uint16_t TK_GetTKYzThreshold(uint8_t i)
000000  b570              PUSH     {r4-r6,lr}
;;;291    {	
000002  4605              MOV      r5,r0
;;;292    	uint16_t SetFingerThresholdtmp; 
;;;293    	
;;;294    	SetFingerThresholdtmp = TK_GetCurrFingerValue(i); 
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       TK_GetCurrFingerValue
00000a  4604              MOV      r4,r0
;;;295        SetFingerThresholdtmp = SetFingerThresholdtmp*SOCAPI_INHIBITION_ZONE/10;
00000c  00e0              LSLS     r0,r4,#3
00000e  210a              MOVS     r1,#0xa
000010  f7fffffe          BL       __aeabi_idivmod
000014  b284              UXTH     r4,r0
;;;296    
;;;297    	return SetFingerThresholdtmp;
000016  4620              MOV      r0,r4
;;;298    }
000018  bd70              POP      {r4-r6,pc}
;;;299    
                          ENDP


                          AREA ||i.TK_GetUpConfirmCnt||, CODE, READONLY, ALIGN=2

                  TK_GetUpConfirmCnt PROC
;;;228    *****************************************************************************/
;;;229    uint8_t TK_GetUpConfirmCnt(void)
000000  4801              LDR      r0,|L10.8|
;;;230    {
;;;231    	return ConfirmTouchCnt>>1;
000002  7800              LDRB     r0,[r0,#0]  ; ConfirmTouchCnt
000004  1040              ASRS     r0,r0,#1
;;;232    }
000006  4770              BX       lr
;;;233    
                          ENDP

                  |L10.8|
                          DCD      ConfirmTouchCnt

                          AREA ||i.TK_IRQHandler||, CODE, READONLY, ALIGN=1

                  TK_IRQHandler PROC
;;;533    *****************************************************************************/
;;;534    void TK_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;535    {
;;;536    	TK_TouchKey_Service();
000002  f7fffffe          BL       TK_TouchKey_Service
;;;537    }	
000006  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i.TK_IsDoubleKeyOrSlideKey||, CODE, READONLY, ALIGN=2

                  TK_IsDoubleKeyOrSlideKey PROC
;;;204    *****************************************************************************/
;;;205    uint8_t TK_IsDoubleKeyOrSlideKey(void)
000000  4801              LDR      r0,|L12.8|
;;;206    {
;;;207        return TKCFG[IsDoubleKey];
000002  7900              LDRB     r0,[r0,#4]  ; TKCFG
;;;208    }
000004  4770              BX       lr
;;;209    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      TKCFG

                          AREA ||i.TK_SetOneKeyPushResetTime||, CODE, READONLY, ALIGN=2

                  TK_SetOneKeyPushResetTime PROC
;;;168    *****************************************************************************/
;;;169    uint16_t TK_SetOneKeyPushResetTime(void)   
000000  4801              LDR      r0,|L13.8|
;;;170    {	  
;;;171    	return  TKCFG[SET_KEY_CONTI_TIME];
000002  8a80              LDRH     r0,[r0,#0x14]  ; TKCFG
000004  b280              UXTH     r0,r0
;;;172    }
000006  4770              BX       lr
;;;173    
                          ENDP

                  |L13.8|
                          DCD      TKCFG

                          AREA ||i.TK_SingleCurrentSensorChoose||, CODE, READONLY, ALIGN=2

                  TK_SingleCurrentSensorChoose PROC
;;;306    *****************************************************************************/
;;;307    void TK_SingleCurrentSensorChoose(void)
000000  b570              PUSH     {r4-r6,lr}
;;;308    {
;;;309    	uint8_t i = 0,j = 0,k = 0;
000002  2000              MOVS     r0,#0
000004  2300              MOVS     r3,#0
000006  2100              MOVS     r1,#0
;;;310    	uint8_t Ctk_Channel_mark = 0;
000008  2200              MOVS     r2,#0
;;;311    	uint32_t CurrentSensorKey ; 		 
;;;312    	
;;;313    	CurrentSensorKey = SOCAPI_SET_TOUCHKEY_CHANNEL; 
00000a  24ff              MOVS     r4,#0xff
00000c  02e4              LSLS     r4,r4,#11
;;;314    		
;;;315    	for(i=0;i<32;i++)
00000e  bf00              NOP      
000010  e00d              B        |L14.46|
                  |L14.18|
;;;316    	{
;;;317    		if((0x01L << i) & CurrentSensorKey)
000012  2501              MOVS     r5,#1
000014  4085              LSLS     r5,r5,r0
000016  4025              ANDS     r5,r5,r4
000018  2d00              CMP      r5,#0
00001a  d006              BEQ      |L14.42|
;;;318    		{
;;;319    			CurrentChannel[Ctk_Channel_mark] = i;						//选择触摸当前的通道
00001c  4d1b              LDR      r5,|L14.140|
00001e  54a8              STRB     r0,[r5,r2]
;;;320    			Ctk_Channel_mark++;
000020  1c55              ADDS     r5,r2,#1
000022  b2ea              UXTB     r2,r5
;;;321    			if(Ctk_Channel_mark >= SOCAPI_SET_TOUCHKEY_TOTAL)
000024  2a08              CMP      r2,#8
000026  db00              BLT      |L14.42|
;;;322    				break;
000028  e003              B        |L14.50|
                  |L14.42|
00002a  1c45              ADDS     r5,r0,#1              ;315
00002c  b2e8              UXTB     r0,r5                 ;315
                  |L14.46|
00002e  2820              CMP      r0,#0x20              ;315
000030  dbef              BLT      |L14.18|
                  |L14.50|
000032  bf00              NOP      
;;;323    		}		
;;;324    	}
;;;325    	
;;;326    #ifdef USING_SlideModule
;;;327    	for(k = 0; k < UsingTKSlideModuleNumber; k ++)
000034  2100              MOVS     r1,#0
000036  e022              B        |L14.126|
                  |L14.56|
;;;328    	{
;;;329    		for(i = 0;i<TKSlideModulePCBArray[k].UsingTKChannelNumber;i++)						//在CurrentChannel[]中取出滑条TK通道排列序号 
000038  2000              MOVS     r0,#0
00003a  e017              B        |L14.108|
                  |L14.60|
;;;330    		{
;;;331    			for(j=0;j<Ctk_Channel_mark;j++)
00003c  2300              MOVS     r3,#0
00003e  e011              B        |L14.100|
                  |L14.64|
;;;332    			{
;;;333    				if(TKSlideModulePCBArray[k].TKChannel[i] == CurrentChannel[j])	//取序号
000040  2536              MOVS     r5,#0x36
000042  434d              MULS     r5,r1,r5
000044  4e12              LDR      r6,|L14.144|
000046  19ad              ADDS     r5,r5,r6
000048  1c6d              ADDS     r5,r5,#1
00004a  5c2d              LDRB     r5,[r5,r0]
00004c  4e0f              LDR      r6,|L14.140|
00004e  5cf6              LDRB     r6,[r6,r3]
000050  42b5              CMP      r5,r6
000052  d105              BNE      |L14.96|
;;;334    				{
;;;335    					TKSlideModulePCBArray[k].TKOrderChannel[i]=j;	
000054  2536              MOVS     r5,#0x36
000056  434d              MULS     r5,r1,r5
000058  4e0d              LDR      r6,|L14.144|
00005a  19ad              ADDS     r5,r5,r6
00005c  3518              ADDS     r5,r5,#0x18
00005e  542b              STRB     r3,[r5,r0]
                  |L14.96|
000060  1c5d              ADDS     r5,r3,#1              ;331
000062  b2eb              UXTB     r3,r5                 ;331
                  |L14.100|
000064  4293              CMP      r3,r2                 ;331
000066  dbeb              BLT      |L14.64|
000068  1c45              ADDS     r5,r0,#1              ;329
00006a  b2e8              UXTB     r0,r5                 ;329
                  |L14.108|
00006c  2536              MOVS     r5,#0x36              ;329
00006e  434d              MULS     r5,r1,r5              ;329
000070  4e07              LDR      r6,|L14.144|
000072  19ad              ADDS     r5,r5,r6              ;329
000074  7c6d              LDRB     r5,[r5,#0x11]         ;329
000076  4285              CMP      r5,r0                 ;329
000078  dce0              BGT      |L14.60|
00007a  1c4d              ADDS     r5,r1,#1              ;327
00007c  b2e9              UXTB     r1,r5                 ;327
                  |L14.126|
00007e  4d05              LDR      r5,|L14.148|
000080  782d              LDRB     r5,[r5,#0]            ;327  ; UsingTKSlideModuleNumber
000082  42a9              CMP      r1,r5                 ;327
000084  dbd8              BLT      |L14.56|
;;;336    				}
;;;337    			}	
;;;338    		}
;;;339    	}
;;;340    #endif
;;;341    	
;;;342    	SingleCurrentChannelMax = Ctk_Channel_mark;							//当前选择的按键数 
000086  4d04              LDR      r5,|L14.152|
000088  702a              STRB     r2,[r5,#0]
;;;343    }
00008a  bd70              POP      {r4-r6,pc}
;;;344    
                          ENDP

                  |L14.140|
                          DCD      CurrentChannel
                  |L14.144|
                          DCD      TKSlideModulePCBArray
                  |L14.148|
                          DCD      UsingTKSlideModuleNumber
                  |L14.152|
                          DCD      SingleCurrentChannelMax

                          AREA ||i.TK_TouchKeyCFGInit||, CODE, READONLY, ALIGN=2

                  TK_TouchKeyCFGInit PROC
;;;374    *****************************************************************************/
;;;375    void TK_TouchKeyCFGInit(void)
000000  b530              PUSH     {r4,r5,lr}
;;;376    {
;;;377    	uint8_t i;
;;;378    #ifdef USING_SlideModule
;;;379    	uint8_t	k;
;;;380    #endif	
;;;381    	
;;;382    	UsingTKSlideModuleNumber = USING_TKSlideModule_Number;
000002  2001              MOVS     r0,#1
000004  4916              LDR      r1,|L15.96|
000006  7008              STRB     r0,[r1,#0]
;;;383    	ConfirmTouchCnt = TKCFG[CONFIRMTOUCHCNT];
000008  4816              LDR      r0,|L15.100|
00000a  7b00              LDRB     r0,[r0,#0xc]  ; TKCFG
00000c  4916              LDR      r1,|L15.104|
00000e  7008              STRB     r0,[r1,#0]
;;;384    	SetNoiseThreshold = TKCFG[NOISE];
000010  4814              LDR      r0,|L15.100|
000012  6c00              LDR      r0,[r0,#0x40]  ; TKCFG
000014  b240              SXTB     r0,r0
000016  4915              LDR      r1,|L15.108|
000018  7008              STRB     r0,[r1,#0]
;;;385    	TK_SingleCurrentSensorChoose(); 
00001a  f7fffffe          BL       TK_SingleCurrentSensorChoose
;;;386    	for(i=0;i< SingleCurrentChannelMax;i++)
00001e  2500              MOVS     r5,#0
000020  e008              B        |L15.52|
                  |L15.34|
;;;387    	{
;;;388    		SingleParameterBufferSet[i].BaseLineAdjusttmp = TKChannelCfg[i][SET_ICHA];;	
000022  200a              MOVS     r0,#0xa
000024  4368              MULS     r0,r5,r0
000026  4912              LDR      r1,|L15.112|
000028  1840              ADDS     r0,r0,r1
00002a  7980              LDRB     r0,[r0,#6]
00002c  4911              LDR      r1,|L15.116|
00002e  5548              STRB     r0,[r1,r5]
000030  1c68              ADDS     r0,r5,#1              ;386
000032  b2c5              UXTB     r5,r0                 ;386
                  |L15.52|
000034  4810              LDR      r0,|L15.120|
000036  7800              LDRB     r0,[r0,#0]            ;386  ; SingleCurrentChannelMax
000038  4285              CMP      r5,r0                 ;386
00003a  dbf2              BLT      |L15.34|
;;;389    	} 
;;;390    	UpdateBaseLNum = 0; 
00003c  2000              MOVS     r0,#0
00003e  490f              LDR      r1,|L15.124|
000040  8008              STRH     r0,[r1,#0]
;;;391    	
;;;392    	
;;;393    #ifdef USING_SlideModule
;;;394    	for(k = 0; k < UsingTKSlideModuleNumber; k ++)
000042  2400              MOVS     r4,#0
000044  e007              B        |L15.86|
                  |L15.70|
;;;395    	{
;;;396    		TKSlideModulePCBArray[k].UpdateBaseLineNumber = 0;
000046  2100              MOVS     r1,#0
000048  2036              MOVS     r0,#0x36
00004a  4360              MULS     r0,r4,r0
00004c  4a0c              LDR      r2,|L15.128|
00004e  1880              ADDS     r0,r0,r2
000050  85c1              STRH     r1,[r0,#0x2e]
000052  1c60              ADDS     r0,r4,#1              ;394
000054  b2c4              UXTB     r4,r0                 ;394
                  |L15.86|
000056  4802              LDR      r0,|L15.96|
000058  7800              LDRB     r0,[r0,#0]            ;394  ; UsingTKSlideModuleNumber
00005a  4284              CMP      r4,r0                 ;394
00005c  dbf3              BLT      |L15.70|
;;;397    	}
;;;398    #endif
;;;399    	
;;;400    }
00005e  bd30              POP      {r4,r5,pc}
;;;401    
                          ENDP

                  |L15.96|
                          DCD      UsingTKSlideModuleNumber
                  |L15.100|
                          DCD      TKCFG
                  |L15.104|
                          DCD      ConfirmTouchCnt
                  |L15.108|
                          DCD      SetNoiseThreshold
                  |L15.112|
                          DCD      TKChannelCfg
                  |L15.116|
                          DCD      SingleParameterBufferSet
                  |L15.120|
                          DCD      SingleCurrentChannelMax
                  |L15.124|
                          DCD      UpdateBaseLNum
                  |L15.128|
                          DCD      TKSlideModulePCBArray

                          AREA ||i.TK_TouchKeyScan||, CODE, READONLY, ALIGN=2

                  TK_TouchKeyScan PROC
;;;411    *****************************************************************************/
;;;412    uint32_t TK_TouchKeyScan(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;413    {
;;;414    #ifdef	USING_SlideModule
;;;415    	uint8_t   k;
;;;416    #endif
;;;417    	uint8_t   t;
;;;418        uint8_t   MultipleCnt = 0;//按键计数
000002  2600              MOVS     r6,#0
;;;419    	uint32_t  Keyvalue ; 
;;;420    	uint32_t  KeyData = 0; 
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;421    	
;;;422    	if(TK_GetIsNeedUpdateBaseline() == 0)				//检测是否需要更新baseline 
000008  f7fffffe          BL       TK_GetIsNeedUpdateBaseline
00000c  2800              CMP      r0,#0
00000e  d171              BNE      |L16.244|
;;;423    	{
;;;424    		Keyvalue = TK_SensorKeyFlag();					//Sensor判断, 这里如果bMultiple = 1 表示中间有干扰	 //分析按键，得出标准的通道bit 位 
000010  f7fffffe          BL       TK_SensorKeyFlag
000014  4607              MOV      r7,r0
;;;425    		
;;;426    
;;;427    #if (defined USING_TKKey_T1)		
;;;428    		for(t=0;t< SingleCurrentChannelMax;t++)
000016  2500              MOVS     r5,#0
000018  e00f              B        |L16.58|
                  |L16.26|
;;;429    		{
;;;430    			if((0x01L << t) & Keyvalue)
00001a  2001              MOVS     r0,#1
00001c  40a8              LSLS     r0,r0,r5
00001e  4038              ANDS     r0,r0,r7
000020  2800              CMP      r0,#0
000022  d008              BEQ      |L16.54|
;;;431    			{
;;;432    				KeyData |= ((uint32_t)0x01 << (CurrentChannel[t]));              
000024  4853              LDR      r0,|L16.372|
000026  5d41              LDRB     r1,[r0,r5]
000028  2001              MOVS     r0,#1
00002a  4088              LSLS     r0,r0,r1
00002c  9900              LDR      r1,[sp,#0]
00002e  4308              ORRS     r0,r0,r1
000030  9000              STR      r0,[sp,#0]
;;;433    				MultipleCnt++;							
000032  1c70              ADDS     r0,r6,#1
000034  b2c6              UXTB     r6,r0
                  |L16.54|
000036  1c68              ADDS     r0,r5,#1              ;428
000038  b2c5              UXTB     r5,r0                 ;428
                  |L16.58|
00003a  484f              LDR      r0,|L16.376|
00003c  7800              LDRB     r0,[r0,#0]            ;428  ; SingleCurrentChannelMax
00003e  4285              CMP      r5,r0                 ;428
000040  dbeb              BLT      |L16.26|
;;;434    			}
;;;435    		}                
;;;436    		
;;;437    		if(MultipleCnt >= 2) 	 									//进入多按键处理
000042  2e02              CMP      r6,#2
000044  db0e              BLT      |L16.100|
;;;438    		{			
;;;439    			bMultiple = 1;			
000046  2001              MOVS     r0,#1
000048  494c              LDR      r1,|L16.380|
00004a  7008              STRB     r0,[r1,#0]
;;;440    			if(MultipleCnt >= SOCAPI_MAX_KEY_NUM_INVALID)
00004c  2e03              CMP      r6,#3
00004e  db02              BLT      |L16.86|
;;;441    			{
;;;442    				TK_SetNeedUpdateBaseline(); 							// 立即更新baseline ,例如亚克力板盖上去
000050  f7fffffe          BL       TK_SetNeedUpdateBaseline
000054  e006              B        |L16.100|
                  |L16.86|
;;;443    			}
;;;444    			else
;;;445    			{					
;;;446    				if(TK_IsDoubleKeyOrSlideKey())
000056  f7fffffe          BL       TK_IsDoubleKeyOrSlideKey
00005a  2800              CMP      r0,#0
00005c  d002              BEQ      |L16.100|
;;;447    				{
;;;448    					bMultiple = 0;
00005e  2000              MOVS     r0,#0
000060  4946              LDR      r1,|L16.380|
000062  7008              STRB     r0,[r1,#0]
                  |L16.100|
;;;449    				} 				 
;;;450    			}			
;;;451    		}			
;;;452    
;;;453    		if(bMultiple == 0)							//进入按键判断
000064  4845              LDR      r0,|L16.380|
000066  7800              LDRB     r0,[r0,#0]  ; bMultiple
000068  2800              CMP      r0,#0
00006a  d10c              BNE      |L16.134|
;;;454    		{		
;;;455    			if(KeyData != 0x0)					    //单个按键达到多长时间就update baseline ,松手检测
00006c  9800              LDR      r0,[sp,#0]
00006e  2800              CMP      r0,#0
000070  d005              BEQ      |L16.126|
;;;456    			{			
;;;457    				UpdateBaseLNum++; 
000072  4843              LDR      r0,|L16.384|
000074  8800              LDRH     r0,[r0,#0]  ; UpdateBaseLNum
000076  1c40              ADDS     r0,r0,#1
000078  4941              LDR      r1,|L16.384|
00007a  8008              STRH     r0,[r1,#0]
00007c  e00a              B        |L16.148|
                  |L16.126|
;;;458    			}
;;;459    			else	
;;;460    			{
;;;461    				UpdateBaseLNum = 0; 	
00007e  2000              MOVS     r0,#0
000080  493f              LDR      r1,|L16.384|
000082  8008              STRH     r0,[r1,#0]
000084  e006              B        |L16.148|
                  |L16.134|
;;;462    			} 
;;;463    		}	
;;;464    		else
;;;465    		{   
;;;466    		    //考虑基线更新		
;;;467    			MultipleLNum++; 
000086  483f              LDR      r0,|L16.388|
000088  8800              LDRH     r0,[r0,#0]  ; MultipleLNum
00008a  1c40              ADDS     r0,r0,#1
00008c  493d              LDR      r1,|L16.388|
00008e  8008              STRH     r0,[r1,#0]
;;;468    			KeyData = 0x00;
000090  2000              MOVS     r0,#0
000092  9000              STR      r0,[sp,#0]
                  |L16.148|
;;;469    		}
;;;470    #endif
;;;471    		
;;;472    #ifdef	USING_SlideModule
;;;473    	
;;;474    		for(k = 0; k < UsingTKSlideModuleNumber; k ++)
000094  2400              MOVS     r4,#0
000096  e047              B        |L16.296|
                  |L16.152|
;;;475    		{
;;;476    			if(TKSlideModulePCBArray[k].OutValue != 0x00)					        //单个按键达到多长时间就update baseline ,松手检测
000098  2036              MOVS     r0,#0x36
00009a  4360              MULS     r0,r4,r0
00009c  493a              LDR      r1,|L16.392|
00009e  1840              ADDS     r0,r0,r1
0000a0  8d80              LDRH     r0,[r0,#0x2c]
0000a2  2800              CMP      r0,#0
0000a4  d027              BEQ      |L16.246|
;;;477    			{	
;;;478    				if(TKSlideModulePCBArray[k].OutValue == TKSlideModulePCBArray[k].LastOutValue)
0000a6  2036              MOVS     r0,#0x36
0000a8  4360              MULS     r0,r4,r0
0000aa  1840              ADDS     r0,r0,r1
0000ac  8d81              LDRH     r1,[r0,#0x2c]
0000ae  2036              MOVS     r0,#0x36
0000b0  4360              MULS     r0,r4,r0
0000b2  4a35              LDR      r2,|L16.392|
0000b4  1880              ADDS     r0,r0,r2
0000b6  8d40              LDRH     r0,[r0,#0x2a]
0000b8  4281              CMP      r1,r0
0000ba  d10b              BNE      |L16.212|
;;;479    				{		
;;;480    				   TKSlideModulePCBArray[k].UpdateBaseLineNumber++; 
0000bc  2036              MOVS     r0,#0x36
0000be  4360              MULS     r0,r4,r0
0000c0  4611              MOV      r1,r2
0000c2  1840              ADDS     r0,r0,r1
0000c4  8dc0              LDRH     r0,[r0,#0x2e]
0000c6  1c40              ADDS     r0,r0,#1
0000c8  b281              UXTH     r1,r0
0000ca  2036              MOVS     r0,#0x36
0000cc  4360              MULS     r0,r4,r0
0000ce  1880              ADDS     r0,r0,r2
0000d0  85c1              STRH     r1,[r0,#0x2e]
0000d2  e016              B        |L16.258|
                  |L16.212|
;;;481    				}
;;;482    				else
;;;483    				{
;;;484    				   TKSlideModulePCBArray[k].LastOutValue = TKSlideModulePCBArray[k].OutValue;
0000d4  2036              MOVS     r0,#0x36
0000d6  4360              MULS     r0,r4,r0
0000d8  492b              LDR      r1,|L16.392|
0000da  1840              ADDS     r0,r0,r1
0000dc  8d81              LDRH     r1,[r0,#0x2c]
0000de  2036              MOVS     r0,#0x36
0000e0  4360              MULS     r0,r4,r0
0000e2  4a29              LDR      r2,|L16.392|
0000e4  1880              ADDS     r0,r0,r2
0000e6  8541              STRH     r1,[r0,#0x2a]
;;;485    				   TKSlideModulePCBArray[k].UpdateBaseLineNumber = 0; 
0000e8  2100              MOVS     r1,#0
0000ea  2036              MOVS     r0,#0x36
0000ec  4360              MULS     r0,r4,r0
0000ee  1880              ADDS     r0,r0,r2
0000f0  85c1              STRH     r1,[r0,#0x2e]
0000f2  e006              B        |L16.258|
                  |L16.244|
0000f4  e036              B        |L16.356|
                  |L16.246|
;;;486    				}
;;;487    			}
;;;488    			else	
;;;489    			{
;;;490    				TKSlideModulePCBArray[k].UpdateBaseLineNumber = 0; 	
0000f6  2100              MOVS     r1,#0
0000f8  2036              MOVS     r0,#0x36
0000fa  4360              MULS     r0,r4,r0
0000fc  4a22              LDR      r2,|L16.392|
0000fe  1880              ADDS     r0,r0,r2
000100  85c1              STRH     r1,[r0,#0x2e]
                  |L16.258|
;;;491    			}
;;;492    
;;;493    			if(TKSlideModulePCBArray[k].UpdateBaseLineNumber >= TK_SetOneKeyPushResetTime())	  //按键超出最长输出时间更新基线
000102  f7fffffe          BL       TK_SetOneKeyPushResetTime
000106  2136              MOVS     r1,#0x36
000108  4361              MULS     r1,r4,r1
00010a  4a1f              LDR      r2,|L16.392|
00010c  1889              ADDS     r1,r1,r2
00010e  8dc9              LDRH     r1,[r1,#0x2e]
000110  4288              CMP      r0,r1
000112  dc07              BGT      |L16.292|
;;;494    			{
;;;495    				TK_SetNeedUpdateBaseline(); 
000114  f7fffffe          BL       TK_SetNeedUpdateBaseline
;;;496    				TKSlideModulePCBArray[k].UpdateBaseLineNumber = 0;
000118  2100              MOVS     r1,#0
00011a  2036              MOVS     r0,#0x36
00011c  4360              MULS     r0,r4,r0
00011e  4a1a              LDR      r2,|L16.392|
000120  1880              ADDS     r0,r0,r2
000122  85c1              STRH     r1,[r0,#0x2e]
                  |L16.292|
000124  1c60              ADDS     r0,r4,#1              ;474
000126  b2c4              UXTB     r4,r0                 ;474
                  |L16.296|
000128  4818              LDR      r0,|L16.396|
00012a  7800              LDRB     r0,[r0,#0]            ;474  ; UsingTKSlideModuleNumber
00012c  4284              CMP      r4,r0                 ;474
00012e  dbb3              BLT      |L16.152|
;;;497    			}
;;;498    		}
;;;499    #endif
;;;500    				
;;;501    
;;;502    #if (defined USING_TKKey_T1)
;;;503    		if(UpdateBaseLNum >= TK_SetOneKeyPushResetTime())	  //按键超出最长输出时间更新基线
000130  f7fffffe          BL       TK_SetOneKeyPushResetTime
000134  4912              LDR      r1,|L16.384|
000136  8809              LDRH     r1,[r1,#0]  ; UpdateBaseLNum
000138  4288              CMP      r0,r1
00013a  dc04              BGT      |L16.326|
;;;504    		{
;;;505     			TK_SetNeedUpdateBaseline(); 
00013c  f7fffffe          BL       TK_SetNeedUpdateBaseline
;;;506    			UpdateBaseLNum = 0;
000140  2000              MOVS     r0,#0
000142  490f              LDR      r1,|L16.384|
000144  8008              STRH     r0,[r1,#0]
                  |L16.326|
;;;507    		}
;;;508    				
;;;509    		if(MultipleLNum > SOCAPI_MAX_KEY_MUTIPLE)		  //干扰计数大于最大计数更新基线
000146  480f              LDR      r0,|L16.388|
000148  8800              LDRH     r0,[r0,#0]  ; MultipleLNum
00014a  21ff              MOVS     r1,#0xff
00014c  312d              ADDS     r1,r1,#0x2d
00014e  4288              CMP      r0,r1
000150  dd0d              BLE      |L16.366|
;;;510     		{
;;;511    			TK_SetNeedUpdateBaseline(); 
000152  f7fffffe          BL       TK_SetNeedUpdateBaseline
;;;512    			MultipleDealTpye = 1; 
000156  2001              MOVS     r0,#1
000158  490d              LDR      r1,|L16.400|
00015a  7008              STRB     r0,[r1,#0]
;;;513    			MultipleLNum = 0;
00015c  2000              MOVS     r0,#0
00015e  4909              LDR      r1,|L16.388|
000160  8008              STRH     r0,[r1,#0]
000162  e004              B        |L16.366|
                  |L16.356|
;;;514    		} 
;;;515    #endif
;;;516    		
;;;517    	}			
;;;518    	else
;;;519    	{
;;;520    		TK_MultipleDeal(TKCFG[AUTO_UPDATE_TIME]);			//基线复位处理
000164  490b              LDR      r1,|L16.404|
000166  8c09              LDRH     r1,[r1,#0x20]  ; TKCFG
000168  b2c8              UXTB     r0,r1
00016a  f7fffffe          BL       TK_MultipleDeal
                  |L16.366|
;;;521    	}  
;;;522    	
;;;523    	return KeyData;
00016e  9800              LDR      r0,[sp,#0]
;;;524    		
;;;525    }
000170  bdf8              POP      {r3-r7,pc}
;;;526    
                          ENDP

000172  0000              DCW      0x0000
                  |L16.372|
                          DCD      CurrentChannel
                  |L16.376|
                          DCD      SingleCurrentChannelMax
                  |L16.380|
                          DCD      bMultiple
                  |L16.384|
                          DCD      UpdateBaseLNum
                  |L16.388|
                          DCD      MultipleLNum
                  |L16.392|
                          DCD      TKSlideModulePCBArray
                  |L16.396|
                          DCD      UsingTKSlideModuleNumber
                  |L16.400|
                          DCD      MultipleDealTpye
                  |L16.404|
                          DCD      TKCFG

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  DifferAccum
                          %        16
                  SingleChannelsBaseLineUpdatePar
                          %        48

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  TKCFG
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000005
                          DCD      0x0000000a
                          DCD      0x00000bb8
                          DCD      0x000000c8
                          DCD      0x00000064
                          DCD      0x00000002
                          DCD      0x00000001
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000000
                          DCD      0x00000001
                          DCD      0x0000ffff
                          DCD      0x0000ffff
                          DCD      0x00000040
                  TKChannelCfg
000044  04022804          DCB      0x04,0x02,0x28,0x04
000048  08033005          DCB      0x08,0x03,0x30,0x05
00004c  05e70402          DCB      0x05,0xe7,0x04,0x02
000050  28040803          DCB      0x28,0x04,0x08,0x03
000054  38050630          DCB      0x38,0x05,0x06,0x30
000058  04022804          DCB      0x04,0x02,0x28,0x04
00005c  08033205          DCB      0x08,0x03,0x32,0x05
000060  06150402          DCB      0x06,0x15,0x04,0x02
000064  28040803          DCB      0x28,0x04,0x08,0x03
000068  360505f2          DCB      0x36,0x05,0x05,0xf2
00006c  04022804          DCB      0x04,0x02,0x28,0x04
000070  08034005          DCB      0x08,0x03,0x40,0x05
000074  06760402          DCB      0x06,0x76,0x04,0x02
000078  28040803          DCB      0x28,0x04,0x08,0x03
00007c  38050640          DCB      0x38,0x05,0x06,0x40
000080  04022804          DCB      0x04,0x02,0x28,0x04
000084  08032805          DCB      0x08,0x03,0x28,0x05
000088  06500402          DCB      0x06,0x50,0x04,0x02
00008c  28040803          DCB      0x28,0x04,0x08,0x03
000090  2e0505ff          DCB      0x2e,0x05,0x05,0xff

                          AREA ||.data||, DATA, ALIGN=1

                  TK_TouchKeyStatus
000000  00                DCB      0x00
                  CurrentChannel
000001  000000            DCB      0x00,0x00,0x00
                          DCDU     0x00000000
000008  00                DCB      0x00
                  RestAreaCnt
000009  000000            DCB      0x00,0x00,0x00
                          DCDU     0x00000000
000010  00                DCB      0x00
                  TouchCnt
000011  000000            DCB      0x00,0x00,0x00
                          DCDU     0x00000000
000018  00                DCB      0x00
                  NoTouchCnt
000019  000000            DCB      0x00,0x00,0x00
                          DCDU     0x00000000
000020  00                DCB      0x00
                  LowFingerDataCnt
000021  000000            DCB      0x00,0x00,0x00
                          DCDU     0x00000000
000028  00                DCB      0x00
                  FloatAreaCnt
000029  000000            DCB      0x00,0x00,0x00
                          DCDU     0x00000000
000030  00                DCB      0x00
                  SingleParameterBufferSet
000031  000000            DCB      0x00,0x00,0x00
                          DCDU     0x00000000
000038  00                DCB      0x00
                  CombineParameterBufferSet
000039  000000            DCB      0x00,0x00,0x00
                          DCDU     0x00000000
000040  00                DCB      0x00
                  ConfirmTouchCnt
000041  00                DCB      0x00
                  SetNoiseThreshold
000042  00                DCB      0x00
                  MultipleDealTpye
000043  00                DCB      0x00
                  UpdateBaseLNum
000044  0000              DCB      0x00,0x00
                  MultipleLNum
000046  0000              DCB      0x00,0x00
                  TKSlideModulePCBArray
000048  011d1e1f          DCB      0x01,0x1d,0x1e,0x1f
                          %        12
000058  0003              DCB      0x00,0x03
00005a  0020              DCW      0x0020
00005c  00140064          DCW      0x0014,0x0064
000060  00000000          DCB      0x00,0x00,0x00,0x00
                          %        12
000070  0100              DCB      0x01,0x00
000072  0000              DCW      0x0000
000074  00000000          DCW      0x0000,0x0000
000078  00960000          DCW      0x0096,0x0000
00007c  0000              DCW      0x0000
                  CFG_OVERLOW_MAX_COUNT
00007e  0a                DCB      0x0a
                  CFG_RESET_BASELINE_CNT
00007f  0a                DCB      0x0a
                  CFG_CYCLE_CNT
000080  20                DCB      0x20

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d304              BCC      |L108.24|
                  |L108.14|
00000e  5d63              LDRB     r3,[r4,r5]
000010  005b              LSLS     r3,r3,#1
000012  18e3              ADDS     r3,r4,r3
000014  bc30              POP      {r4,r5}
000016  4718              BX       r3
                  |L108.24|
000018  461d              MOV      r5,r3
00001a  e7f8              B        |L108.14|
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Drivers\\TKDriver\\C\\TKDriver.C"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_TKDriver_C_TKCFG____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___10_TKDriver_C_TKCFG____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_TKDriver_C_TKCFG____REVSH|
#line 478
|__asm___10_TKDriver_C_TKCFG____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
