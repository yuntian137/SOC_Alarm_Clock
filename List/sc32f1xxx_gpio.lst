L 1 "..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_gpio.c"
N/********************************************************************************
N * @file    sc32f1xxx_gpio.c
N * @author  SOC AE Team
N * @version V1.6
N * @date    04-09-2024
N * @brief   GPIO function module
N *
N *******************************************************************************
N * @attention
N *
N *1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only
N *intended for use with SinOne products. No other uses are authorized. This
N *software is owned by SinOne Microelectronics Co.,Ltd. and is protected under
N *all applicable laws, including copyright laws.
N *2.The software which is for guidance only aims at providing customers with
N *coding information regarding their products in order for them to save time.
N *As a result, SinOne shall not be held liable for any direct, indirect or
N *consequential damages with respect to any claims arising from the content of
N *such software and/or the use made by customers of the coding information
N *contained herein in connection with their products.
N *
N *  COPYRIGHT 2024 SinOne Microelectronics
N */
N
N/* Includes ------------------------------------------------------------------*/
N#include "sc32f1xxx_gpio.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx_gpio.h" 1
N/**
N ******************************************************************************
N * @file    sc32f1xxx_gpio.h
N * @author  SOC AE Team
N * @version V1.6
N * @date     04-09-2024
N * @brief   Header file of GPIO module.
N *
N ******************************************************************************
N * @attention
N *
N *1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only
N *intended for use with SinOne products. No other uses are authorized. This
N *software is owned by SinOne Microelectronics Co.,Ltd. and is protected under
N *all applicable laws, including copyright laws.
N *2.The software which is for guidance only aims at providing customers with
N *coding information regarding their products in order for them to save time.
N *As a result, SinOne shall not be held liable for any direct, indirect or
N *consequential damages with respect to any claims arising from the content of
N *such software and/or the use made by customers of the coding information
N *contained herein in connection with their products.
N *
N *  COPYRIGHT 2024 SinOne Microelectronics
N */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __sc32f1xxx_GPIO_H
N#define __sc32f1xxx_GPIO_H
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "sc32f1xxx.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx.h" 1
N/**
N  ******************************************************************************
N  * @file    SC32F1XXX.h
N  * @author  SOC SA Team
N  * @brief   CMSIS SC32F1xxx Device Peripheral Access Layer Header File.
N  *          The file is the unique include file that the application programmer
N  *          is using in the C source code, usually in main.c. This file contains:
N  *           - Configuration section that allows to select:
N  *              - The SC32F1xxx device used in the target application
N  *
N  ******************************************************************************
N	* @attention
N	*
N	*1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only 
N	*intended for use with SinOne products. No other uses are authorized. This 
N	*software is owned by SinOne Microelectronics Co.,Ltd. and is protected under 
N	*all applicable laws, including copyright laws. 
N	*2.The software which is for guidance only aims at providing customers with 
N	*coding information regarding their products in order for them to save time. 
N	*As a result, SinOne shall not be held liable for any direct, indirect or 
N	*consequential damages with respect to any claims arising from the content of 
N	*such software and/or the use made by customers of the coding information 
N	*contained herein in connection with their products.
N	*
N	*  COPYRIGHT 2024 SinOne Microelectronics
N	*/
N
N
N/** @addtogroup CMSIS_Device
N  * @{
N  */
N
N/** @addtogroup sc32f1xxx
N  * @{
N  */
N
N#ifndef SC32F1XXX_H
N#define SC32F1XXX_H
N
N
N#ifdef __cplusplus
Sextern "C" {
N#endif /* __cplusplus */
N
N/** @addtogroup Library_configuration_section
N  * @{
N  */
N
N#if !defined  (SC32F1)
X#if !0L
N#define SC32F1
N#endif /* SC32F1 */
N
N
N#if defined(SC32f10xx)
X#if 1L
N  #include "SC32f10xx.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\SC32f10xx.h" 1
N/**
N  ******************************************************************************
N  * @file    SC32F10XX.h
N  * @author  SOC SA Team
N  * @brief   CMSIS Cortex-M0+ Device Peripheral Access Layer Header File.
N  *          This file contains all the peripheral register's definitions, bits
N  *          definitions and memory mapping for SC32F10XX devices.
N  *
N  *          This file contains:
N  *           - Data structures and the address mapping for all peripherals
N  *           - Peripheral's registers declarations and bits definition
N  *           - Macros to access peripheral's registers hardware
N  *
N  ******************************************************************************
N * @attention
N *
N *1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only 
N *intended for use with SinOne products. No other uses are authorized. This 
N *software is owned by SinOne Microelectronics Co.,Ltd. and is protected under 
N *all applicable laws, including copyright laws. 
N *2.The software which is for guidance only aims at providing customers with 
N *coding information regarding their products in order for them to save time. 
N *As a result, SinOne shall not be held liable for any direct, indirect or 
N *consequential damages with respect to any claims arising from the content of 
N *such software and/or the use made by customers of the coding information 
N *contained herein in connection with their products.
N *
N *  COPYRIGHT 2024 SinOne Microelectronics
N */
N
N/** @addtogroup CMSIS_Device
N  * @{
N  */
N
N/** @addtogroup sc32f10xx
N  * @{
N  */
N
N#ifndef sc32f10xx_H
N#define sc32f10xx_H
N
N
N
N#ifdef __cplusplus
Sextern "C" {
N#endif /* __cplusplus */
N
N/** @addtogroup Configuration_section_for_CMSIS
N  * @{
N  */
N#if !defined  (LXT_VALUE) 
X#if !0L 
N  #define LXT_VALUE    ((uint32_t)32768) /*!< Default value of the External oscillator in Hz */
N#endif /* LXT_VALUE */
N#if !defined  (HXT_VALUE) 
X#if !0L 
N  #define HXT_VALUE    ((uint32_t)16000000) /*!< Default value of the External oscillator in Hz */
N#endif /* HXT_VALUE */
N#if !defined  (HIRC_VALUE) 
X#if !0L 
N  #define HIRC_VALUE    ((uint32_t)32000000) /*!< Default value of the External oscillator in Hz */
N#endif /* HIRC_VALUE */
N#if !defined  (LIRC_VALUE) 
X#if !0L 
N  #define LIRC_VALUE    ((uint32_t)32000) /*!< Default value of the External oscillator in Hz */
N#endif /* LIRC_VALUE */
N
N/**
N  * @brief Configuration of the Cortex-M0+ Processor and Core Peripherals
N   */
N#define __CM0PLUS_REV             0U /*!< Core Revision r0p0                            */
N#define __MPU_PRESENT             1U /*!< Coretex Mo+  provides an MPU                  */
N#define __VTOR_PRESENT            1U /*!< Vector  Table  Register supported             */
N#define __NVIC_PRIO_BITS          2U /*!< sc32f10xx uses 2 Bits for the Priority Levels 			*/
N#define __Vendor_SysTickConfig    0U /*!< Set to 1 if different SysTick Config is used  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup Peripheral_interrupt_number_definition
N  * @{
N  */
N
N/**
N * @brief sc32f10xx Interrupt Number Definition, according to the selected device
N *        in @ref Library_configuration_section
N */
N
N/*!< Interrupt Number Definition */
Ntypedef enum
N{
N  /******  Cortex-M0+ Processor Exceptions Numbers ***************************************************************/
N  NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                                          */
N  HardFault_IRQn              = -13,    /*!< 3 Cortex-M Hard Fault Interrupt                                   */
N  SVC_IRQn                    = -5,     /*!< 11 Cortex-M SV Call Interrupt                                     */
N  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M Pend SV Interrupt                                     */
N  SysTick_IRQn                = -1,     /*!< 15 Cortex-M System Tick Interrupt                                 */
N  /******  sc32f10xx specific Interrupt Numbers ****************************************************************/
N  INT0_IRQn                  = 0,      /*!< INT  0 Interrupt                                         	*/
N  INT1_7_IRQn                = 1,      /*!< INT Line from 1 to 7  Interrupt                       		*/
N  INT8_11_IRQn               = 2,      /*!< INT Line from 8 to 11  Interrupt                          */
N  INT12_15_IRQn              = 3,      /*!< INT Line from 12 to 15  Interrupt                         */
N  RCC_IRQn                    = 4,      /*!< RCC shut down Interrupts                                   */
N  BTM_IRQn                	  = 6,      /*!< BTM  Interrupts                                      			*/
N  UART0_2_IRQn                = 7,      /*!< UART0 and UART2 Interrupts                                 */
N  UART1_3_IRQn                = 8,      /*!< UART1 and UART3 Interrupts                                 */
N  SPI0_IRQn                		= 9,     	/*!< SPI0 Interrupts                           									*/
N  SPI1_IRQn                   = 10,     /*!< SPI1 Interrupts        																		*/
N  DMA0_IRQn                   = 11,     /*!< DMA0 Interrupts                                            */
N  DMA1_IRQn    			      		= 12,     /*!< DMA1 Interrupts            																*/
N  DMA2_IRQn                   = 13,     /*!< DMA2 Interrupts                                    				*/
N  DMA3_IRQn                   = 14,     /*!< DMA3 Interrupts                                            */
N  TIMER0_IRQn                 = 15,     /*!< TIMER0 global Interrupts                                   */
N  TIMER1_IRQn                 = 16,     /*!< TIMER1 global Interrupt                                    */
N  TIMER2_IRQn                 = 17,     /*!< TIMER2 global Interrupt                                    */
N  TIMER3_IRQn                 = 18,     /*!< TIMER3 global Interrupt                                    */
N  TIMER4_5_IRQn               = 19,     /*!< TIMER4 and TIMER5 global Interrupt                         */
N  TIMER6_7_IRQn               = 20,     /*!< TIMER6 global TIMER7 Interrupt                             */
N  PWM0_IRQn                  	= 21,     /*!< PWM0 Interrupt                                            	*/
N  LEDPWM_IRQn                 = 22,     /*!< LEDPWM Interrupt                                            	*/
N  TWI0_IRQn                  	= 23,     /*!< TWI0 Interrupt                                            	*/
N  TWI1_IRQn                  	= 24,     /*!< TWI1 Interrupt                                            	*/
N  ADC_IRQn                  	= 29,     /*!< ADC  Interrupt                                            	*/
N  CMP_IRQn                  	= 30,     /*!< CMP  Interrupt                                            	*/
N  TK_IRQn											= 31,     /*!< TouchKey  Interrupt                                   			*/
N} IRQn_Type;
N
N/**
N  * @}
N  */
N
N#include "core_cm0plus.h"               /* Cortex-M0+ processor and core peripherals */
L 1 "..\CMSIS\core_cm0plus.h" 1
N/**************************************************************************//**
N * @file     core_cm0plus.h
N * @brief    CMSIS Cortex-M0+ Core Peripheral Access Layer Header File
N * @version  V5.0.6
N * @date     28. May 2018
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM0PLUS_H_GENERIC
N#define __CORE_CM0PLUS_H_GENERIC
N
N#include <stdint.h>
L 1 "D:\keil\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 35 "..\CMSIS\core_cm0plus.h" 2
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex-M0+
N  @{
N */
N
N#include "cmsis_version.h"
L 1 "..\CMSIS\cmsis_version.h" 1
N/**************************************************************************//**
N * @file     cmsis_version.h
N * @brief    CMSIS Core(M) Version definitions
N * @version  V5.0.2
N * @date     19. April 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CMSIS_VERSION_H
N#define __CMSIS_VERSION_H
N
N/*  CMSIS Version definitions */
N#define __CM_CMSIS_VERSION_MAIN  ( 5U)                                      /*!< [31:16] CMSIS Core(M) main version */
N#define __CM_CMSIS_VERSION_SUB   ( 1U)                                      /*!< [15:0]  CMSIS Core(M) sub version */
N#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) | \
N                                   __CM_CMSIS_VERSION_SUB           )       /*!< CMSIS Core(M) version number */
X#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) |                                    __CM_CMSIS_VERSION_SUB           )        
N#endif
L 64 "..\CMSIS\core_cm0plus.h" 2
N 
N/*  CMSIS CM0+ definitions */
N#define __CM0PLUS_CMSIS_VERSION_MAIN (__CM_CMSIS_VERSION_MAIN)                  /*!< \deprecated [31:16] CMSIS HAL main version */
N#define __CM0PLUS_CMSIS_VERSION_SUB  (__CM_CMSIS_VERSION_SUB)                   /*!< \deprecated [15:0]  CMSIS HAL sub version */
N#define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) | \
N                                       __CM0PLUS_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL version number */
X#define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16U) |                                        __CM0PLUS_CMSIS_VERSION_SUB           )   
N
N#define __CORTEX_M                   (0U)                                       /*!< Cortex-M Core */
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0U
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TI_ARM__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
N#endif
N
N#include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
L 1 "..\CMSIS\cmsis_compiler.h" 1
N/**************************************************************************//**
N * @file     cmsis_compiler.h
N * @brief    CMSIS compiler generic header file
N * @version  V5.0.4
N * @date     10. January 2018
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_COMPILER_H
N#define __CMSIS_COMPILER_H
N
N#include <stdint.h>
N
N/*
N * Arm Compiler 4/5
N */
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "..\CMSIS\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS compiler ARMCC (Arm Compiler 5) header file
N * @version  V5.0.4
N * @date     10. January 2018
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060960 < 400677)
S  #error "Please use Arm Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* CMSIS compiler control architecture macros */
N#if ((defined (__TARGET_ARCH_6_M  ) && (__TARGET_ARCH_6_M   == 1)) || \
N     (defined (__TARGET_ARCH_6S_M ) && (__TARGET_ARCH_6S_M  == 1))   )
X#if ((0L && (__TARGET_ARCH_6_M   == 1)) ||      (1L && (1  == 1))   )
N  #define __ARM_ARCH_6M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7_M ) && (__TARGET_ARCH_7_M  == 1))
X#if (0L && (__TARGET_ARCH_7_M  == 1))
S  #define __ARM_ARCH_7M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7E_M) && (__TARGET_ARCH_7E_M == 1))
X#if (0L && (__TARGET_ARCH_7E_M == 1))
S  #define __ARM_ARCH_7EM__          1
N#endif
N
N  /* __ARM_ARCH_8M_BASE__  not applicable */
N  /* __ARM_ARCH_8M_MAIN__  not applicable */
N
N
N/* CMSIS compiler specific defines */
N#ifndef   __ASM
N  #define __ASM                                  __asm
N#endif
N#ifndef   __INLINE
N  #define __INLINE                               __inline
N#endif
N#ifndef   __STATIC_INLINE
N  #define __STATIC_INLINE                        static __inline
N#endif
N#ifndef   __STATIC_FORCEINLINE                 
N  #define __STATIC_FORCEINLINE                   static __forceinline
N#endif           
N#ifndef   __NO_RETURN
N  #define __NO_RETURN                            __declspec(noreturn)
N#endif
N#ifndef   __USED
N  #define __USED                                 __attribute__((used))
N#endif
N#ifndef   __WEAK
N  #define __WEAK                                 __attribute__((weak))
N#endif
N#ifndef   __PACKED
N  #define __PACKED                               __attribute__((packed))
N#endif
N#ifndef   __PACKED_STRUCT
N  #define __PACKED_STRUCT                        __packed struct
N#endif
N#ifndef   __PACKED_UNION
N  #define __PACKED_UNION                         __packed union
N#endif
N#ifndef   __UNALIGNED_UINT32        /* deprecated */
N  #define __UNALIGNED_UINT32(x)                  (*((__packed uint32_t *)(x)))
N#endif
N#ifndef   __UNALIGNED_UINT16_WRITE
N  #define __UNALIGNED_UINT16_WRITE(addr, val)    ((*((__packed uint16_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT16_READ
N  #define __UNALIGNED_UINT16_READ(addr)          (*((const __packed uint16_t *)(addr)))
N#endif
N#ifndef   __UNALIGNED_UINT32_WRITE
N  #define __UNALIGNED_UINT32_WRITE(addr, val)    ((*((__packed uint32_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT32_READ
N  #define __UNALIGNED_UINT32_READ(addr)          (*((const __packed uint32_t *)(addr)))
N#endif
N#ifndef   __ALIGNED
N  #define __ALIGNED(x)                           __attribute__((aligned(x)))
N#endif
N#ifndef   __RESTRICT
N  #define __RESTRICT                             __restrict
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/**
N  \brief   Enable IRQ Interrupts
N  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __enable_irq();     */
N
N
N/**
N  \brief   Disable IRQ Interrupts
N  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   Enable FIQ
S  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/**
S  \brief   Disable FIQ
S  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/**
S  \brief   Get Base Priority
S  \details Returns the current value of the Base Priority register.
S  \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/**
S  \brief   Set Base Priority
S  \details Assigns the given value to the Base Priority register.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Set Base Priority with condition
S  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
S           or the new value increases the BASEPRI priority level.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
S{
S  register uint32_t __regBasePriMax      __ASM("basepri_max");
S  __regBasePriMax = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Get Fault Mask
S  \details Returns the current value of the Fault Mask register.
S  \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/**
S  \brief   Set Fault Mask
S  \details Assigns the given value to the Fault Mask register.
S  \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1U);
S}
S
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N
N/**
N  \brief   Get FPSCR
N  \details Returns the current value of the Floating Point Status/Control register.
N  \return               Floating Point Status/Control register value
N */
N__STATIC_INLINE uint32_t __get_FPSCR(void)
Xstatic __inline uint32_t __get_FPSCR(void)
N{
N#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
N     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((0L && (__FPU_PRESENT == 1U)) &&      (1L && (0U    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
N#else
N   return(0U);
N#endif
N}
N
N
N/**
N  \brief   Set FPSCR
N  \details Assigns the given value to the Floating Point Status/Control register.
N  \param [in]    fpscr  Floating Point Status/Control value to set
N */
N__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
Xstatic __inline void __set_FPSCR(uint32_t fpscr)
N{
N#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
N     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((0L && (__FPU_PRESENT == 1U)) &&      (1L && (0U    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
N#else
N  (void)fpscr;
N#endif
N}
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0U)
N
N                  
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x78563412.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 0x34127856.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For example, 0x0080 becomes 0x8000.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int16_t __REVSH(int16_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int16_t __REVSH(int16_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    op1  Value to rotate
N  \param [in]    op2  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S  #define __RBIT                          __rbit
N#else
N__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
X__attribute__((always_inline)) static __inline uint32_t __RBIT(uint32_t value)
N{
N  uint32_t result;
N  uint32_t s = (4U /*sizeof(v)*/ * 8U) - 1U; /* extra shift needed at end */
N
N  result = value;                      /* r will be reversed bits of v; first get LSB of v */
N  for (value >>= 1U; value != 0U; value >>= 1U)
N  {
N    result <<= 1U;
N    result |= value & 1U;
N    s--;
N  }
N  result <<= s;                        /* shift when v's highest bits are zero */
N  return result;
N}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   LDR Exclusive (8 bit)
S  \details Executes a exclusive LDR instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
S#else
S  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (16 bit)
S  \details Executes a exclusive LDR instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
S#else
S  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (32 bit)
S  \details Executes a exclusive LDR instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
S#else
S  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (8 bit)
S  \details Executes a exclusive STR instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (16 bit)
S  \details Executes a exclusive STR instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (32 bit)
S  \details Executes a exclusive STR instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   Remove the exclusive lock
S  \details Removes the exclusive lock which is created by LDREX.
S */
S#define __CLREX                           __clrex
S
S
S/**
S  \brief   Signed Saturate
S  \details Saturates a signed value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (1..32)
S  \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/**
S  \brief   Unsigned Saturate
S  \details Saturates an unsigned value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (0..31)
S  \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/**
S  \brief   Rotate Right with Extend (32 bit)
S  \details Moves each bit of a bitstring right by one bit.
S           The carry input is shifted in at the left end of the bitstring.
S  \param [in]    value  Value to rotate
S  \return               Rotated value
S */
S#ifndef __NO_EMBEDDED_ASM
S__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
S{
S  rrx r0, r0
S  bx lr
S}
S#endif
S
S
S/**
S  \brief   LDRT Unprivileged (8 bit)
S  \details Executes a Unprivileged LDRT instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (16 bit)
S  \details Executes a Unprivileged LDRT instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (32 bit)
S  \details Executes a Unprivileged LDRT instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
S
S
S/**
S  \brief   STRT Unprivileged (8 bit)
S  \details Executes a Unprivileged STRT instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRBT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (16 bit)
S  \details Executes a Unprivileged STRT instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRHT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (32 bit)
S  \details Executes a Unprivileged STRT instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRT(value, ptr)                __strt(value, ptr)
S
N#else  /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#else   
N
N/**
N  \brief   Signed Saturate
N  \details Saturates a signed value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (1..32)
N  \return             Saturated value
N */
N__attribute__((always_inline)) __STATIC_INLINE int32_t __SSAT(int32_t val, uint32_t sat)
X__attribute__((always_inline)) static __inline int32_t __SSAT(int32_t val, uint32_t sat)
N{
N  if ((sat >= 1U) && (sat <= 32U))
N  {
N    const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);
N    const int32_t min = -1 - max ;
N    if (val > max)
N    {
N      return max;
N    }
N    else if (val < min)
N    {
N      return min;
N    }
N  }
N  return val;
N}
N
N/**
N  \brief   Unsigned Saturate
N  \details Saturates an unsigned value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (0..31)
N  \return             Saturated value
N */
N__attribute__((always_inline)) __STATIC_INLINE uint32_t __USAT(int32_t val, uint32_t sat)
X__attribute__((always_inline)) static __inline uint32_t __USAT(int32_t val, uint32_t sat)
N{
N  if (sat <= 31U)
N  {
N    const uint32_t max = ((1U << sat) - 1U);
N    if (val > (int32_t)max)
N    {
N      return max;
N    }
N    else if (val < 0)
N    {
N      return 0U;
N    }
N  }
N  return (uint32_t)val;
N}
N
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S
S#define __SADD8                           __sadd8
S#define __QADD8                           __qadd8
S#define __SHADD8                          __shadd8
S#define __UADD8                           __uadd8
S#define __UQADD8                          __uqadd8
S#define __UHADD8                          __uhadd8
S#define __SSUB8                           __ssub8
S#define __QSUB8                           __qsub8
S#define __SHSUB8                          __shsub8
S#define __USUB8                           __usub8
S#define __UQSUB8                          __uqsub8
S#define __UHSUB8                          __uhsub8
S#define __SADD16                          __sadd16
S#define __QADD16                          __qadd16
S#define __SHADD16                         __shadd16
S#define __UADD16                          __uadd16
S#define __UQADD16                         __uqadd16
S#define __UHADD16                         __uhadd16
S#define __SSUB16                          __ssub16
S#define __QSUB16                          __qsub16
S#define __SHSUB16                         __shsub16
S#define __USUB16                          __usub16
S#define __UQSUB16                         __uqsub16
S#define __UHSUB16                         __uhsub16
S#define __SASX                            __sasx
S#define __QASX                            __qasx
S#define __SHASX                           __shasx
S#define __UASX                            __uasx
S#define __UQASX                           __uqasx
S#define __UHASX                           __uhasx
S#define __SSAX                            __ssax
S#define __QSAX                            __qsax
S#define __SHSAX                           __shsax
S#define __USAX                            __usax
S#define __UQSAX                           __uqsax
S#define __UHSAX                           __uhsax
S#define __USAD8                           __usad8
S#define __USADA8                          __usada8
S#define __SSAT16                          __ssat16
S#define __USAT16                          __usat16
S#define __UXTB16                          __uxtb16
S#define __UXTAB16                         __uxtab16
S#define __SXTB16                          __sxtb16
S#define __SXTAB16                         __sxtab16
S#define __SMUAD                           __smuad
S#define __SMUADX                          __smuadx
S#define __SMLAD                           __smlad
S#define __SMLADX                          __smladx
S#define __SMLALD                          __smlald
S#define __SMLALDX                         __smlaldx
S#define __SMUSD                           __smusd
S#define __SMUSDX                          __smusdx
S#define __SMLSD                           __smlsd
S#define __SMLSDX                          __smlsdx
S#define __SMLSLD                          __smlsld
S#define __SMLSLDX                         __smlsldx
S#define __SEL                             __sel
S#define __QADD                            __qadd
S#define __QSUB                            __qsub
S
S#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
S                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
S
S#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
S                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
S
S#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
S                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
S
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 35 "..\CMSIS\cmsis_compiler.h" 2
N
N
N/*
N * Arm Compiler 6 (armclang)
N */
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armclang.h"
S
S
S/*
S * GNU Compiler
S */
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S
S/*
S * IAR Compiler
S */
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iccarm.h>
S
S
S/*
S * TI Arm Compiler
S */
S#elif defined ( __TI_ARM__ )
S  #include <cmsis_ccs.h>
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __attribute__((packed))
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __attribute__((packed)) T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void*)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)                           __attribute__((aligned(x)))
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S
S
S/*
S * TASKING Compiler
S */
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __packed__
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __packed__
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __packed__
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __packed__ T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)              __align(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S
S
S/*
S * COSMIC Compiler
S */
S#elif defined ( __CSMC__ )
S   #include <cmsis_csm.h>
S
S #ifndef   __ASM
S    #define __ASM                                  _asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    // NO RETURN is automatically detected hence no warning here
S    #define __NO_RETURN
S  #endif
S  #ifndef   __USED
S    #warning No compiler specific solution for __USED. __USED is ignored.
S    #define __USED
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __weak
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               @packed
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        @packed struct
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         @packed union
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    @packed struct T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S
S
S#else
S  #error Unknown compiler.
N#endif
N
N
N#endif /* __CMSIS_COMPILER_H */
N
L 116 "..\CMSIS\core_cm0plus.h" 2
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0PLUS_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0PLUS_H_DEPENDANT
N#define __CORE_CM0PLUS_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0PLUS_REV
S    #define __CM0PLUS_REV             0x0000U
S    #warning "__CM0PLUS_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0U
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __VTOR_PRESENT
S    #define __VTOR_PRESENT            0U
S    #warning "__VTOR_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex-M0+ */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core MPU Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
N    uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0U                                            /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[1U];                
N        uint32_t RESERVED0[31U];
N  __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[1U];                
N        uint32_t RSERVED1[31U];
N  __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[1U];                
N        uint32_t RESERVED2[31U];
N  __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[1U];                
N        uint32_t RESERVED3[31U];
N        uint32_t RESERVED4[64U];
N  __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
X  volatile uint32_t IP[8U];                  
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N#if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
X#if 1L && (1U == 1U)
N  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
X  volatile uint32_t VTOR;                    
N#else
S        uint32_t RESERVED0;
N#endif
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N        uint32_t RESERVED1;
N  __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED */
X  volatile uint32_t SHP[2U];                 
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N#if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
X#if 1L && (1U == 1U)
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_VTOR_TBLOFF_Pos                 8U                                            /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0xFFFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
N#endif
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (1U == 1U)
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
N  \brief    Type definitions for the Memory Protection Unit (MPU)
N  @{
N */
N
N/**
N  \brief  Structure type to access the Memory Protection Unit (MPU).
N */
Ntypedef struct
N{
N  __IM  uint32_t TYPE;                   /*!< Offset: 0x000 (R/ )  MPU Type Register */
X  volatile const  uint32_t TYPE;                    
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x004 (R/W)  MPU Control Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t RNR;                    /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register */
X  volatile uint32_t RNR;                     
N  __IOM uint32_t RBAR;                   /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register */
X  volatile uint32_t RBAR;                    
N  __IOM uint32_t RASR;                   /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register */
X  volatile uint32_t RASR;                    
N} MPU_Type;
N
N#define MPU_TYPE_RALIASES                  1U
N
N/* MPU Type Register Definitions */
N#define MPU_TYPE_IREGION_Pos               16U                                            /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8U                                            /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0U                                            /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register Definitions */
N#define MPU_CTRL_PRIVDEFENA_Pos             2U                                            /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1U                                            /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0U                                            /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register Definitions */
N#define MPU_RNR_REGION_Pos                  0U                                            /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register Definitions */
N#define MPU_RBAR_ADDR_Pos                   8U                                            /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0xFFFFFFUL << MPU_RBAR_ADDR_Pos)              /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4U                                            /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0U                                            /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register Definitions */
N#define MPU_RASR_ATTRS_Pos                 16U                                            /*!< MPU RASR: MPU Region Attribute field Position */
N#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
N
N#define MPU_RASR_XN_Pos                    28U                                            /*!< MPU RASR: ATTRS.XN Position */
N#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
N
N#define MPU_RASR_AP_Pos                    24U                                            /*!< MPU RASR: ATTRS.AP Position */
N#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19U                                            /*!< MPU RASR: ATTRS.TEX Position */
N#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
N
N#define MPU_RASR_S_Pos                     18U                                            /*!< MPU RASR: ATTRS.S Position */
N#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
N
N#define MPU_RASR_C_Pos                     17U                                            /*!< MPU RASR: ATTRS.C Position */
N#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
N
N#define MPU_RASR_B_Pos                     16U                                            /*!< MPU RASR: ATTRS.B Position */
N#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
N
N#define MPU_RASR_SRD_Pos                    8U                                            /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1U                                            /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENABLE_Pos                 0U                                            /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@} end of group CMSIS_MPU */
N#endif
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Cortex-M0+ Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible over DAP and not via processor.
N            Therefore they are not covered by the Cortex-M0+ header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Core Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (1U == 1U)
N  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit */
N  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N#ifdef CMSIS_NVIC_VIRTUAL
S  #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
S    #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
S  #endif
S  #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
N  #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
N  #define NVIC_EnableIRQ              __NVIC_EnableIRQ
N  #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
N  #define NVIC_DisableIRQ             __NVIC_DisableIRQ
N  #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
N  #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
N  #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
N/*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0+ */
N  #define NVIC_SetPriority            __NVIC_SetPriority
N  #define NVIC_GetPriority            __NVIC_GetPriority
N  #define NVIC_SystemReset            __NVIC_SystemReset
N#endif /* CMSIS_NVIC_VIRTUAL */
N
N#ifdef CMSIS_VECTAB_VIRTUAL
S  #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
S    #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
S  #endif
S  #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetVector              __NVIC_SetVector
N  #define NVIC_GetVector              __NVIC_GetVector
N#endif  /* (CMSIS_VECTAB_VIRTUAL) */
N
N#define NVIC_USER_IRQ_OFFSET          16
N
N
N/* The following EXC_RETURN values are saved the LR on exception entry */
N#define EXC_RETURN_HANDLER         (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */
N#define EXC_RETURN_THREAD_MSP      (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */
N#define EXC_RETURN_THREAD_PSP      (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */
N
N
N/* Interrupt Priorities are WORD accessible only under Armv6-M                  */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
N#define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
N#define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
N
N#define __NVIC_SetPriorityGrouping(X) (void)(X)
N#define __NVIC_GetPriorityGrouping()  (0U)
N
N/**
N  \brief   Enable Interrupt
N  \details Enables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Enable status
N  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt is not enabled.
N  \return             1  Interrupt is enabled.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISER[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Disable Interrupt
N  \details Disables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N    __ISB();
X    do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N  }
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N  \note    The priority cannot be set for every processor exception.
N */
N__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  = ((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2U)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N  else
N  {
N    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] = ((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2U)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2U)));
N  }
N  else
N  {
N    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2U)));
N  }
N}
N
N
N/**
N  \brief   Encode Priority
N  \details Encodes the priority for an interrupt with the given priority group,
N           preemptive priority value, and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]     PriorityGroup  Used priority group.
N  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N  \param [in]       SubPriority  Subpriority value (starting from 0).
N  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(2U)) ? (uint32_t)(2U) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(2U)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(2U));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/**
N  \brief   Decode Priority
N  \details Decodes an interrupt priority value with a given priority group to
N           preemptive priority value and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N  \param [in]     PriorityGroup  Used priority group.
N  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N  \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(2U)) ? (uint32_t)(2U) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(2U)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(2U));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N/**
N  \brief   Set Interrupt Vector
N  \details Sets an interrupt vector in SRAM based interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N           VTOR must been relocated to SRAM before.
N           If VTOR is not present address 0 must be mapped to SRAM.
N  \param [in]   IRQn      Interrupt number
N  \param [in]   vector    Address of interrupt handler function
N */
N__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
Xstatic __inline void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
N{
N#if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
X#if 1L && (1U == 1U)
N  uint32_t *vectors = (uint32_t *)SCB->VTOR;
X  uint32_t *vectors = (uint32_t *)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR;
N#else
S    uint32_t *vectors = (uint32_t *)0x0U;
N#endif
N  vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;
X  vectors[(int32_t)IRQn + 16] = vector;
N}
N
N
N/**
N  \brief   Get Interrupt Vector
N  \details Reads an interrupt vector from interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn      Interrupt number.
N  \return                 Address of interrupt handler function
N */
N__STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetVector(IRQn_Type IRQn)
N{
N#if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
X#if 1L && (1U == 1U)
N  uint32_t *vectors = (uint32_t *)SCB->VTOR;
X  uint32_t *vectors = (uint32_t *)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->VTOR;
N#else
S  uint32_t *vectors = (uint32_t *)0x0U;
N#endif
N  return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];
X  return vectors[(int32_t)IRQn + 16];
N
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
X__declspec(noreturn) static __inline void __NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FAUL << 16U) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2U));
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N/* ##########################  MPU functions  #################################### */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1U)
X#if 1L && (1U == 1U)
N
N#include "mpu_armv7.h"
L 1 "..\CMSIS\mpu_armv7.h" 1
N/******************************************************************************
N * @file     mpu_armv7.h
N * @brief    CMSIS MPU API for Armv7-M MPU
N * @version  V5.0.4
N * @date     10. January 2018
N ******************************************************************************/
N/*
N * Copyright (c) 2017-2018 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N 
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header    /* treat file as system include file */
N#endif
N 
N#ifndef ARM_MPU_ARMV7_H
N#define ARM_MPU_ARMV7_H
N
N#define ARM_MPU_REGION_SIZE_32B      ((uint8_t)0x04U) ///!< MPU Region Size 32 Bytes
N#define ARM_MPU_REGION_SIZE_64B      ((uint8_t)0x05U) ///!< MPU Region Size 64 Bytes
N#define ARM_MPU_REGION_SIZE_128B     ((uint8_t)0x06U) ///!< MPU Region Size 128 Bytes
N#define ARM_MPU_REGION_SIZE_256B     ((uint8_t)0x07U) ///!< MPU Region Size 256 Bytes
N#define ARM_MPU_REGION_SIZE_512B     ((uint8_t)0x08U) ///!< MPU Region Size 512 Bytes
N#define ARM_MPU_REGION_SIZE_1KB      ((uint8_t)0x09U) ///!< MPU Region Size 1 KByte
N#define ARM_MPU_REGION_SIZE_2KB      ((uint8_t)0x0AU) ///!< MPU Region Size 2 KBytes
N#define ARM_MPU_REGION_SIZE_4KB      ((uint8_t)0x0BU) ///!< MPU Region Size 4 KBytes
N#define ARM_MPU_REGION_SIZE_8KB      ((uint8_t)0x0CU) ///!< MPU Region Size 8 KBytes
N#define ARM_MPU_REGION_SIZE_16KB     ((uint8_t)0x0DU) ///!< MPU Region Size 16 KBytes
N#define ARM_MPU_REGION_SIZE_32KB     ((uint8_t)0x0EU) ///!< MPU Region Size 32 KBytes
N#define ARM_MPU_REGION_SIZE_64KB     ((uint8_t)0x0FU) ///!< MPU Region Size 64 KBytes
N#define ARM_MPU_REGION_SIZE_128KB    ((uint8_t)0x10U) ///!< MPU Region Size 128 KBytes
N#define ARM_MPU_REGION_SIZE_256KB    ((uint8_t)0x11U) ///!< MPU Region Size 256 KBytes
N#define ARM_MPU_REGION_SIZE_512KB    ((uint8_t)0x12U) ///!< MPU Region Size 512 KBytes
N#define ARM_MPU_REGION_SIZE_1MB      ((uint8_t)0x13U) ///!< MPU Region Size 1 MByte
N#define ARM_MPU_REGION_SIZE_2MB      ((uint8_t)0x14U) ///!< MPU Region Size 2 MBytes
N#define ARM_MPU_REGION_SIZE_4MB      ((uint8_t)0x15U) ///!< MPU Region Size 4 MBytes
N#define ARM_MPU_REGION_SIZE_8MB      ((uint8_t)0x16U) ///!< MPU Region Size 8 MBytes
N#define ARM_MPU_REGION_SIZE_16MB     ((uint8_t)0x17U) ///!< MPU Region Size 16 MBytes
N#define ARM_MPU_REGION_SIZE_32MB     ((uint8_t)0x18U) ///!< MPU Region Size 32 MBytes
N#define ARM_MPU_REGION_SIZE_64MB     ((uint8_t)0x19U) ///!< MPU Region Size 64 MBytes
N#define ARM_MPU_REGION_SIZE_128MB    ((uint8_t)0x1AU) ///!< MPU Region Size 128 MBytes
N#define ARM_MPU_REGION_SIZE_256MB    ((uint8_t)0x1BU) ///!< MPU Region Size 256 MBytes
N#define ARM_MPU_REGION_SIZE_512MB    ((uint8_t)0x1CU) ///!< MPU Region Size 512 MBytes
N#define ARM_MPU_REGION_SIZE_1GB      ((uint8_t)0x1DU) ///!< MPU Region Size 1 GByte
N#define ARM_MPU_REGION_SIZE_2GB      ((uint8_t)0x1EU) ///!< MPU Region Size 2 GBytes
N#define ARM_MPU_REGION_SIZE_4GB      ((uint8_t)0x1FU) ///!< MPU Region Size 4 GBytes
N
N#define ARM_MPU_AP_NONE 0U ///!< MPU Access Permission no access
N#define ARM_MPU_AP_PRIV 1U ///!< MPU Access Permission privileged access only
N#define ARM_MPU_AP_URO  2U ///!< MPU Access Permission unprivileged access read-only
N#define ARM_MPU_AP_FULL 3U ///!< MPU Access Permission full access
N#define ARM_MPU_AP_PRO  5U ///!< MPU Access Permission privileged access read-only
N#define ARM_MPU_AP_RO   6U ///!< MPU Access Permission read-only access
N
N/** MPU Region Base Address Register Value
N*
N* \param Region The region to be configured, number 0 to 15.
N* \param BaseAddress The base address for the region.
N*/
N#define ARM_MPU_RBAR(Region, BaseAddress) \
N  (((BaseAddress) & MPU_RBAR_ADDR_Msk) |  \
N   ((Region) & MPU_RBAR_REGION_Msk)    |  \
N   (MPU_RBAR_VALID_Msk))
X#define ARM_MPU_RBAR(Region, BaseAddress)   (((BaseAddress) & MPU_RBAR_ADDR_Msk) |     ((Region) & MPU_RBAR_REGION_Msk)    |     (MPU_RBAR_VALID_Msk))
N
N/**
N* MPU Memory Access Attributes
N* 
N* \param TypeExtField      Type extension field, allows you to configure memory access type, for example strongly ordered, peripheral.
N* \param IsShareable       Region is shareable between multiple bus masters.
N* \param IsCacheable       Region is cacheable, i.e. its value may be kept in cache.
N* \param IsBufferable      Region is bufferable, i.e. using write-back caching. Cacheable but non-bufferable regions use write-through policy.
N*/  
N#define ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable)   \
N  ((((TypeExtField ) << MPU_RASR_TEX_Pos) & MPU_RASR_TEX_Msk)                 | \
N   (((IsShareable ) << MPU_RASR_S_Pos) & MPU_RASR_S_Msk)                      | \
N   (((IsCacheable ) << MPU_RASR_C_Pos) & MPU_RASR_C_Msk)                      | \
N   (((IsBufferable ) << MPU_RASR_B_Pos) & MPU_RASR_B_Msk))
X#define ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable)     ((((TypeExtField ) << MPU_RASR_TEX_Pos) & MPU_RASR_TEX_Msk)                 |    (((IsShareable ) << MPU_RASR_S_Pos) & MPU_RASR_S_Msk)                      |    (((IsCacheable ) << MPU_RASR_C_Pos) & MPU_RASR_C_Msk)                      |    (((IsBufferable ) << MPU_RASR_B_Pos) & MPU_RASR_B_Msk))
N
N/**
N* MPU Region Attribute and Size Register Value
N* 
N* \param DisableExec       Instruction access disable bit, 1= disable instruction fetches.
N* \param AccessPermission  Data access permissions, allows you to configure read/write access for User and Privileged mode.
N* \param AccessAttributes  Memory access attribution, see \ref ARM_MPU_ACCESS_.
N* \param SubRegionDisable  Sub-region disable field.
N* \param Size              Region size of the region to be configured, for example 4K, 8K.
N*/
N#define ARM_MPU_RASR_EX(DisableExec, AccessPermission, AccessAttributes, SubRegionDisable, Size)      \
N  ((((DisableExec ) << MPU_RASR_XN_Pos) & MPU_RASR_XN_Msk)                                          | \
N   (((AccessPermission) << MPU_RASR_AP_Pos) & MPU_RASR_AP_Msk)                                      | \
N   (((AccessAttributes) ) & (MPU_RASR_TEX_Msk | MPU_RASR_S_Msk | MPU_RASR_C_Msk | MPU_RASR_B_Msk)))
X#define ARM_MPU_RASR_EX(DisableExec, AccessPermission, AccessAttributes, SubRegionDisable, Size)        ((((DisableExec ) << MPU_RASR_XN_Pos) & MPU_RASR_XN_Msk)                                          |    (((AccessPermission) << MPU_RASR_AP_Pos) & MPU_RASR_AP_Msk)                                      |    (((AccessAttributes) ) & (MPU_RASR_TEX_Msk | MPU_RASR_S_Msk | MPU_RASR_C_Msk | MPU_RASR_B_Msk)))
N  
N/**
N* MPU Region Attribute and Size Register Value
N* 
N* \param DisableExec       Instruction access disable bit, 1= disable instruction fetches.
N* \param AccessPermission  Data access permissions, allows you to configure read/write access for User and Privileged mode.
N* \param TypeExtField      Type extension field, allows you to configure memory access type, for example strongly ordered, peripheral.
N* \param IsShareable       Region is shareable between multiple bus masters.
N* \param IsCacheable       Region is cacheable, i.e. its value may be kept in cache.
N* \param IsBufferable      Region is bufferable, i.e. using write-back caching. Cacheable but non-bufferable regions use write-through policy.
N* \param SubRegionDisable  Sub-region disable field.
N* \param Size              Region size of the region to be configured, for example 4K, 8K.
N*/                         
N#define ARM_MPU_RASR(DisableExec, AccessPermission, TypeExtField, IsShareable, IsCacheable, IsBufferable, SubRegionDisable, Size) \
N  ARM_MPU_RASR_EX(DisableExec, AccessPermission, ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable), SubRegionDisable, Size)
X#define ARM_MPU_RASR(DisableExec, AccessPermission, TypeExtField, IsShareable, IsCacheable, IsBufferable, SubRegionDisable, Size)   ARM_MPU_RASR_EX(DisableExec, AccessPermission, ARM_MPU_ACCESS_(TypeExtField, IsShareable, IsCacheable, IsBufferable), SubRegionDisable, Size)
N
N/**
N* MPU Memory Access Attribute for strongly ordered memory.
N*  - TEX: 000b
N*  - Shareable
N*  - Non-cacheable
N*  - Non-bufferable
N*/ 
N#define ARM_MPU_ACCESS_ORDERED ARM_MPU_ACCESS_(0U, 1U, 0U, 0U)
N
N/**
N* MPU Memory Access Attribute for device memory.
N*  - TEX: 000b (if non-shareable) or 010b (if shareable)
N*  - Shareable or non-shareable
N*  - Non-cacheable
N*  - Bufferable (if shareable) or non-bufferable (if non-shareable)
N*
N* \param IsShareable Configures the device memory as shareable or non-shareable.
N*/ 
N#define ARM_MPU_ACCESS_DEVICE(IsShareable) ((IsShareable) ? ARM_MPU_ACCESS_(0U, 1U, 0U, 1U) : ARM_MPU_ACCESS_(2U, 0U, 0U, 0U))
N
N/**
N* MPU Memory Access Attribute for normal memory.
N*  - TEX: 1BBb (reflecting outer cacheability rules)
N*  - Shareable or non-shareable
N*  - Cacheable or non-cacheable (reflecting inner cacheability rules)
N*  - Bufferable or non-bufferable (reflecting inner cacheability rules)
N*
N* \param OuterCp Configures the outer cache policy.
N* \param InnerCp Configures the inner cache policy.
N* \param IsShareable Configures the memory as shareable or non-shareable.
N*/ 
N#define ARM_MPU_ACCESS_NORMAL(OuterCp, InnerCp, IsShareable) ARM_MPU_ACCESS_((4U | (OuterCp)), IsShareable, ((InnerCp) & 2U), ((InnerCp) & 1U))
N
N/**
N* MPU Memory Access Attribute non-cacheable policy.
N*/
N#define ARM_MPU_CACHEP_NOCACHE 0U
N
N/**
N* MPU Memory Access Attribute write-back, write and read allocate policy.
N*/
N#define ARM_MPU_CACHEP_WB_WRA 1U
N
N/**
N* MPU Memory Access Attribute write-through, no write allocate policy.
N*/
N#define ARM_MPU_CACHEP_WT_NWA 2U
N
N/**
N* MPU Memory Access Attribute write-back, no write allocate policy.
N*/
N#define ARM_MPU_CACHEP_WB_NWA 3U
N
N
N/**
N* Struct for a single MPU Region
N*/
Ntypedef struct {
N  uint32_t RBAR; //!< The region base address register value (RBAR)
N  uint32_t RASR; //!< The region attribute and size register value (RASR) \ref MPU_RASR
N} ARM_MPU_Region_t;
N    
N/** Enable the MPU.
N* \param MPU_Control Default access permissions for unconfigured regions.
N*/
N__STATIC_INLINE void ARM_MPU_Enable(uint32_t MPU_Control)
Xstatic __inline void ARM_MPU_Enable(uint32_t MPU_Control)
N{
N  __DSB();
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N  __ISB();
X  do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->CTRL = MPU_Control | (1UL );
N#ifdef SCB_SHCSR_MEMFAULTENA_Msk
S  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
N#endif
N}
N
N/** Disable the MPU.
N*/
N__STATIC_INLINE void ARM_MPU_Disable(void)
Xstatic __inline void ARM_MPU_Disable(void)
N{
N  __DSB();
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N  __ISB();
X  do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N#ifdef SCB_SHCSR_MEMFAULTENA_Msk
S  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
N#endif
N  MPU->CTRL  &= ~MPU_CTRL_ENABLE_Msk;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->CTRL  &= ~(1UL );
N}
N
N/** Clear and disable the given MPU region.
N* \param rnr Region number to be cleared.
N*/
N__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
Xstatic __inline void ARM_MPU_ClrRegion(uint32_t rnr)
N{
N  MPU->RNR = rnr;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RNR = rnr;
N  MPU->RASR = 0U;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RASR = 0U;
N}
N
N/** Configure an MPU region.
N* \param rbar Value for RBAR register.
N* \param rsar Value for RSAR register.
N*/   
N__STATIC_INLINE void ARM_MPU_SetRegion(uint32_t rbar, uint32_t rasr)
Xstatic __inline void ARM_MPU_SetRegion(uint32_t rbar, uint32_t rasr)
N{
N  MPU->RBAR = rbar;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RBAR = rbar;
N  MPU->RASR = rasr;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RASR = rasr;
N}
N
N/** Configure the given MPU region.
N* \param rnr Region number to be configured.
N* \param rbar Value for RBAR register.
N* \param rsar Value for RSAR register.
N*/   
N__STATIC_INLINE void ARM_MPU_SetRegionEx(uint32_t rnr, uint32_t rbar, uint32_t rasr)
Xstatic __inline void ARM_MPU_SetRegionEx(uint32_t rnr, uint32_t rbar, uint32_t rasr)
N{
N  MPU->RNR = rnr;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RNR = rnr;
N  MPU->RBAR = rbar;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RBAR = rbar;
N  MPU->RASR = rasr;
X  ((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RASR = rasr;
N}
N
N/** Memcopy with strictly ordered memory access, e.g. for register targets.
N* \param dst Destination data is copied to.
N* \param src Source data is copied from.
N* \param len Amount of data words to be copied.
N*/
N__STATIC_INLINE void orderedCpy(volatile uint32_t* dst, const uint32_t* __RESTRICT src, uint32_t len)
Xstatic __inline void orderedCpy(volatile uint32_t* dst, const uint32_t* __restrict src, uint32_t len)
N{
N  uint32_t i;
N  for (i = 0U; i < len; ++i) 
N  {
N    dst[i] = src[i];
N  }
N}
N
N/** Load the given number of MPU regions from a table.
N* \param table Pointer to the MPU configuration table.
N* \param cnt Amount of regions to be configured.
N*/
N__STATIC_INLINE void ARM_MPU_Load(ARM_MPU_Region_t const* table, uint32_t cnt) 
Xstatic __inline void ARM_MPU_Load(ARM_MPU_Region_t const* table, uint32_t cnt) 
N{
N  const uint32_t rowWordSize = sizeof(ARM_MPU_Region_t)/4U;
N  while (cnt > MPU_TYPE_RALIASES) {
X  while (cnt > 1U) {
N    orderedCpy(&(MPU->RBAR), &(table->RBAR), MPU_TYPE_RALIASES*rowWordSize);
X    orderedCpy(&(((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RBAR), &(table->RBAR), 1U*rowWordSize);
N    table += MPU_TYPE_RALIASES;
X    table += 1U;
N    cnt -= MPU_TYPE_RALIASES;
X    cnt -= 1U;
N  }
N  orderedCpy(&(MPU->RBAR), &(table->RBAR), cnt*rowWordSize);
X  orderedCpy(&(((MPU_Type *) ((0xE000E000UL) + 0x0D90UL) )->RBAR), &(table->RBAR), cnt*rowWordSize);
N}
N
N#endif
L 1004 "..\CMSIS\core_cm0plus.h" 2
N
N#endif
N
N/* ##########################  FPU functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_FpuFunctions FPU Functions
N  \brief    Function that provides FPU type.
N  @{
N */
N
N/**
N  \brief   get FPU type
N  \details returns the FPU type
N  \returns
N   - \b  0: No FPU
N   - \b  1: Single precision FPU
N   - \b  2: Double + Single precision FPU
N */
N__STATIC_INLINE uint32_t SCB_GetFPUType(void)
Xstatic __inline uint32_t SCB_GetFPUType(void)
N{
N    return 0U;           /* No FPU */
N}
N
N
N/*@} end of CMSIS_Core_FpuFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
X#if 1L && (0U == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  __NVIC_SetPriority (SysTick_IRQn, (1UL << 2U) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0PLUS_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 130 "..\FWLib\SC32F1XXX_Lib\inc\SC32f10xx.h" 2
N#include "system_sc32f1xxx.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\system_sc32f1xxx.h" 1
N/**
N******************************************************************************
N* @file    SYSTEM_sc32f1xxx.h
N* @author  SOC SA Team
N* @brief   CMSIS Cortex-M0+ Device System Source File for sc32f1xxx devices.
N******************************************************************************
N* @attention
N*
N*1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only 
N*intended for use with SinOne products. No other uses are authorized. This 
N*software is owned by SinOne Microelectronics Co.,Ltd. and is protected under 
N*all applicable laws, including copyright laws. 
N*2.The software which is for guidance only aims at providing customers with 
N*coding information regarding their products in order for them to save time. 
N*As a result, SinOne shall not be held liable for any direct, indirect or 
N*consequential damages with respect to any claims arising from the content of 
N*such software and/or the use made by customers of the coding information 
N*contained herein in connection with their products.
N*
N*  COPYRIGHT 2024 SinOne Microelectronics
N*/
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup sc32f10xx_system
N  * @{
N  */
N
N/**
N  * @brief Define to prevent recursive inclusion
N  */
N#ifndef SYSTEM_SOC0003_H
N#define SYSTEM_SOC0003_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/** @addtogroup sc32f10xx_System_Includes
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N
N/** @addtogroup sc32f10xx_System_Exported_types
N  * @{
N  */
Nextern uint32_t SystemCoreClock;         /*!< System Clock Frequency (Core Clock) */
N
Nextern const uint32_t AHBPrescTable[16];  /*!<  AHB prescalers table values */
Nextern const uint32_t APBPrescTable[8];   /*!< APB prescalers table values */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32G0xx_System_Exported_Constants
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32G0xx_System_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32G0xx_System_Exported_Functions
N  * @{
N  */
N
Nextern void SystemInit(void);
Nextern void SystemCoreClockUpdate(void);
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*SYSTEM_STM32G0XX_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 131 "..\FWLib\SC32F1XXX_Lib\inc\SC32f10xx.h" 2
N#include <stdint.h>
N
N
N/** @addtogroup Exported_types
N  * @{
N  */
Ntypedef enum
N{
N  RESET = 0,
N  SET = !RESET
N} FlagStatus, ITStatus;
N
Ntypedef enum
N{
N  DISABLE = 0,
N  ENABLE = !DISABLE
N} FunctionalState;
N
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum
N{
N  SUCCESS = 0,
N  ERROR = !SUCCESS
N} ErrorStatus;
N
Ntypedef enum
N{
N  FALSE = 0,
N  TRUE = !FALSE
N} boolType;
N
Ntypedef enum
N{
N  Status_OK	 = 0,
N  Status_ERROR,
N  Status_BUSY,
N  Status_TIMEOUT
N} StatusTypeDef;
N
N/** @addtogroup Exported_macros
N  * @{
N  */
N#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
N
N#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
N
N#define READ_BIT(REG, BIT)    ((REG) & (BIT))
N
N#define CLEAR_REG(REG)        ((REG) = (0x0))
N
N#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
N
N#define READ_REG(REG)         ((REG))
N
N
N
N/* Peripheral for APB0=0x40020000
N	 Peripheral for APB1=0x40021000
N   Peripheral for APB2=0x40022000
N*/
N/**
N  * @brief RCCAPB0 for APB0,Peripheral offset =0x00
N  */
Ntypedef struct
N{
N  __IO uint32_t APB0_CFG;       	 /*!< APB0 Config register,      Address offset: 0x00 */
X  volatile uint32_t APB0_CFG;       	  
N  __IO uint32_t APB0_RST;          /*!< APB0 Reset register,       Address offset: 0x04 */
X  volatile uint32_t APB0_RST;           
N} RCCAPB0_TypeDef;
N
N/**
N  * @brief RCCAPB1 for APB1,Peripheral offset =0x00
N  */
Ntypedef struct
N{
N  __IO uint32_t APB1_CFG;       	 /*!< APB1 Config register,      Address offset: 0x00 */
X  volatile uint32_t APB1_CFG;       	  
N  __IO uint32_t APB1_RST;          /*!< APB1 Reset register,       Address offset: 0x04 */
X  volatile uint32_t APB1_RST;           
N} RCCAPB1_TypeDef;
N
N/**
N  * @brief RCCAPB2 for APB2,Peripheral offset =0x00
N  */
Ntypedef struct
N{
N  __IO uint32_t APB2_CFG;       	 /*!< APB2 Config register,      Address offset: 0x00 */
X  volatile uint32_t APB2_CFG;       	  
N  __IO uint32_t APB2_RST;          /*!< APB2 Reset register,       Address offset: 0x04 */
X  volatile uint32_t APB2_RST;           
N} RCCAPB2_TypeDef;
N
N
N/** @addtogroup Peripheral_registers_structures
N  * @{
N  */
N/**
N  * @brief UART0-1 for APB0,UART2 for APB1,UART3 for APB2,UART0/2/3 Peripheral offset =0x20,UART1 Peripheral offset=0x80
N  */
Ntypedef struct
N{
N  __IO uint32_t UART_CON;       	 /*!< UART Config register,      	Address offset: 0x00 */
X  volatile uint32_t UART_CON;       	  
N  __IO uint32_t UART_STS;          /*!< UART Status register,       Address offset: 0x04 */
X  volatile uint32_t UART_STS;           
N  __IO uint32_t UART_BAUD;         /*!< UART BaudRate register, 		Address offset: 0x08 */
X  volatile uint32_t UART_BAUD;          
N  __IO uint32_t UART_DATA;         /*!< UART Data register,   			Address offset: 0x0C */
X  volatile uint32_t UART_DATA;          
N  __IO uint32_t UART_IDE;     		 /*!< UART Interrupt /Dma Enable register,   Address offset: 0x10 */
X  volatile uint32_t UART_IDE;     		  
N} UART_TypeDef;
N
N/**
N  * @brief SPI0 for APB0,SPI1 for APB1 ,Peripheral offset =0x40
N  */
Ntypedef struct
N{
N  __IO uint32_t SPI_CON;       	  /*!< SPI Control register,      Address offset: 0x00 */
X  volatile uint32_t SPI_CON;       	   
N  __IO uint32_t SPI_STS;          /*!< SPI Status register,       Address offset: 0x04 */
X  volatile uint32_t SPI_STS;           
N  __IO uint32_t RESERVED;         /*!< Reserved, 									Address offset: 0x08 */
X  volatile uint32_t RESERVED;          
N  __IO uint32_t SPI_DATA;         /*!< SPI Data register,   			Address offset: 0x0C */
X  volatile uint32_t SPI_DATA;          
N  __IO uint32_t SPI_IDE;     		  /*!< SPI Interrupt /Dma Enable register,   Address offset: 0x10 */
X  volatile uint32_t SPI_IDE;     		   
N} SPI_TypeDef;
N
N/**
N  * @brief TWI0 for APB0,TWI1 for APB1 ,Peripheral offset =0x60
N  */
Ntypedef struct
N{
N  __IO uint32_t TWI_CON;       	  /*!< TWI Config register,      	Address offset: 0x00 */
X  volatile uint32_t TWI_CON;       	   
N  __IO uint32_t TWI_STS;          /*!< TWI Status register,       Address offset: 0x04 */
X  volatile uint32_t TWI_STS;           
N  __IO uint32_t TWI_ADD;          /*!< TWI Adress register, 			Address offset: 0x08 */
X  volatile uint32_t TWI_ADD;           
N  __IO uint32_t TWI_DATA;         /*!< TWI Data register,   			Address offset: 0x0C */
X  volatile uint32_t TWI_DATA;          
N  __IO uint32_t TWI_IDE;     		  /*!< TWI Interrupt /Dma Enable register,   Address offset: 0x10 */
X  volatile uint32_t TWI_IDE;     		   
N} TWI_TypeDef;
N
N/**
N  * @brief TIEMR0123 for APB0,TIEMR4567 for APB1, Peripheral offset=0x100+0x40*n(n=0,1,2,3)
N  */
Ntypedef struct
N{
N  __IO uint32_t TIM_CON;       		/*!< TCON register,      Address offset: 0x00 */
X  volatile uint32_t TIM_CON;       		 
N  __IO uint32_t TIM_CNT;          /*!< TCNT register,       Address offset: 0x04 */
X  volatile uint32_t TIM_CNT;           
N  __IO uint32_t TIM_RLD;          /*!< TIMER ReLoad register, Address offset: 0x08 */
X  volatile uint32_t TIM_RLD;           
N  __IO uint32_t TIM_STS;          /*!< TIMER Status register,   Address offset: 0x0C */
X  volatile uint32_t TIM_STS;           
N  __IO uint32_t TIM_PDTA_RCAP;    /*!< TIMER Rise Caputre Key register,   Address offset: 0x10 */
X  volatile uint32_t TIM_PDTA_RCAP;     
N  __IO uint32_t TIM_PDTB_FCAP;    /*!< TIMER fall Caputre register,   Address offset: 0x14 */
X  volatile uint32_t TIM_PDTB_FCAP;     
N  __IO uint32_t TIM_IDE;          /*!< TIMER Interrupt /Dma Enable register,  Address offset: 0x18 */
X  volatile uint32_t TIM_IDE;           
N} TIM_TypeDef;
N
N/**
N  * @brief PWM0 for APB0,PWM0 Peripheral offset=0x200,
N  */
Ntypedef struct
N{
N  __IO uint32_t PWM_CON;       		 /*!< Pwm Control register,      	Address offset: 0x00 */
X  volatile uint32_t PWM_CON;       		  
N  __IO uint32_t PWM_CHN;           /*!< PWM Channel register,       	Address offset: 0x04 */
X  volatile uint32_t PWM_CHN;            
N  __IO uint32_t PWM_STS;           /*!< PWM Status register, 				Address offset: 0x08 */
X  volatile uint32_t PWM_STS;            
N  __IO uint32_t PWM_INV;           /*!< PWM Inverse register,   			Address offset: 0x0C */
X  volatile uint32_t PWM_INV;            
N  __IO uint32_t PWM_DFR;    			 /*!< PWM Dead space register,   	Address offset: 0x10 */
X  volatile uint32_t PWM_DFR;    			  
N  __IO uint32_t PWM_FLT;    			 /*!< PWM FaiLure detection register,   Address offset: 0x14 */
X  volatile uint32_t PWM_FLT;    			  
N  __IO uint32_t PWM_CYCLE;         /*!< PWM Cycles register,  			Address offset: 0x18 */
X  volatile uint32_t PWM_CYCLE;          
N  __IO uint32_t RESERVED[5];       /*!< Reserved, 									Address offset: 0x1C */
X  volatile uint32_t RESERVED[5];        
N  __IO uint32_t PWM_DT[8];        /*!< PWM Duty register,@PWM0 PWM_DT[8] is Valied, 	Address offset: 0x30 */
X  volatile uint32_t PWM_DT[8];         
N} PWM_TypeDef;
N
N/**
N  * @brief LEDPWM for APB2,LEDPWM Peripheral offset=0x300,
N  */
Ntypedef struct
N{
N  __IO uint32_t LEDPWM_CON;       		 /*!< LEDPWM Control register,      	Address offset: 0x00 */
X  volatile uint32_t LEDPWM_CON;       		  
N  __IO uint32_t LEDPWM_CHN;           /*!< LEDPWM Channel register,       	Address offset: 0x04 */
X  volatile uint32_t LEDPWM_CHN;            
N  __IO uint32_t LEDPWM_STS;           /*!< LEDPWM Status register, 				Address offset: 0x08 */
X  volatile uint32_t LEDPWM_STS;            
N  __IO uint32_t LEDPWM_INV;           /*!< LEDPWM Inverse register,   			Address offset: 0x0C */
X  volatile uint32_t LEDPWM_INV;            
N  __IO uint32_t RESERVED0[2];       /*!< Reserved, 									Address offset: 0x1C */
X  volatile uint32_t RESERVED0[2];        
N  __IO uint32_t LEDPWM_CYCLE;         /*!< LEDPWM Cycles register,  			Address offset: 0x18 */
X  volatile uint32_t LEDPWM_CYCLE;          
N  __IO uint32_t RESERVED1[5];       /*!< Reserved, 									Address offset: 0x1C */
X  volatile uint32_t RESERVED1[5];        
N  __IO uint32_t LEDPWM_DT[32];        /*!< LEDPWM Duty register,@LEDPWM0 LEDPWM_DT[8] is Valied, 	Address offset: 0x30 */
X  volatile uint32_t LEDPWM_DT[32];         
N} LEDPWM_TypeDef;
N
N/**
N  * @brief BTM for APB2,Peripheral offset=0x100
N  */
Ntypedef struct
N{
N  __IO uint32_t BTM_CON;       	  /*!< ADC Control register,      Address offset: 0x00 */
X  volatile uint32_t BTM_CON;       	   
N  __IO uint32_t BTM_STS;          /*!< ADC Status register,       Address offset: 0x04 */
X  volatile uint32_t BTM_STS;           
N} BTM_TypeDef;
N
N/**
N  * @brief ADC for APB2,Peripheral offset=0x110
N  */
Ntypedef struct
N{
N  __IO uint32_t ADC_CON;       	  /*!< ADC Control register,      Address offset: 0x00 */
X  volatile uint32_t ADC_CON;       	   
N  __IO uint32_t ADC_STS;          /*!< ADC Status register,       Address offset: 0x04 */
X  volatile uint32_t ADC_STS;           
N  __IO uint32_t ADC_VALUE;        /*!< ADC Value register, 				Address offset: 0x08 */
X  volatile uint32_t ADC_VALUE;         
N  __IO uint32_t ADC_CFG;          /*!< ADC Config register,   		Address offset: 0x0C */
X  volatile uint32_t ADC_CFG;           
N} ADC_TypeDef;
N
N/**
N  * @brief CMP for APB2,Peripheral offset=0x130
N  */
Ntypedef struct
N{
N  __IO uint32_t CMP_STS;          /*!< CMP Status register,       Address offset: 0x00 */
X  volatile uint32_t CMP_STS;           
N  __IO uint32_t CMP_CFG;          /*!< CMP Config register, 				Address offset: 0x04 */
X  volatile uint32_t CMP_CFG;           
N} CMP_TypeDef;
N
N/**
N  * @brief TK for APB2,Peripheral offset=0x200
N  */
Ntypedef struct 
N{
N  __IO uint32_t TK_CHN;           /*!< TK Channel register,          	Address offset: 0x00 */
X  volatile uint32_t TK_CHN;            
N  __IO uint32_t RESERVED[2];      /*!< Reserved, 									  	Address offset: 0x04 */
X  volatile uint32_t RESERVED[2];       
N  __IO uint32_t TK_CON;           /*!< TK Control register, 				  Address offset: 0x0C */
X  volatile uint32_t TK_CON;            
N  __IO uint32_t TK_CFG;           /*!< TK Config register, 				  	Address offset: 0x10 */
X  volatile uint32_t TK_CFG;            
N  __IO uint32_t RESERVED0;			  /*!< Reserved, 									    Address offset: 0x14 */
X  volatile uint32_t RESERVED0;			   
N  __IO uint32_t TK_CNT;           /*!< TK RawData register, 				  Address offset: 0x18 */
X  volatile uint32_t TK_CNT;            
N  __IO uint32_t TK_TM;            /*!< TK TM register, 				 				Address offset: 0x1C */
X  volatile uint32_t TK_TM;             
N} TK_TypeDef;
N
N
N/**
N  * @brief LCD/LED for APB2,Peripheral offset=0x280
N  */
Ntypedef struct
N{
N  __IO uint32_t DDR_CON;          /*!< Display Drive Control register,                      Address offset: 0x00 */
X  volatile uint32_t DDR_CON;           
N  __IO uint32_t DDR_CFG;      		/*!< Display Drive Config register, 			                Address offset: 0x04 */
X  volatile uint32_t DDR_CFG;      		 
N  __IO uint32_t SEG_EN;           /*!< Segment IO Enable register, 				                  Address offset: 0x08 */
X  volatile uint32_t SEG_EN;            
N  __IO uint32_t RESERVED0;			  /*!< Reserved, 									    			                Address offset: 0x0C */
X  volatile uint32_t RESERVED0;			   
N  __IO uint32_t COM_EN;           /*!< COM IO Enable register register, 	                	Address offset: 0x10 */
X  volatile uint32_t COM_EN;            
N  __IO uint32_t RESERVED1[39];  /*!< Reserved,                                            Address offset: 0x14 */
X  volatile uint32_t RESERVED1[39];   
N  __IO uint32_t SEGRn[28];        /*!< COM port display drive output function register, 		Address offset: 0x50 */
X  volatile uint32_t SEGRn[28];         
N} LCD_LED_TypeDef;
N
N
N/*
N	 Peripheral for IOPORT=0x40011000
N*/
N/**
N  * @brief GPIO for IOPORT,Peripheral offset=0x100*n(n=0,1,2)
N  */
Ntypedef struct
N{
N  __IO uint32_t PIN;        			/*!< GPIOA,B,C register,               Address offset: 0x00         */
X  volatile uint32_t PIN;        			 
N  __IO uint32_t RESERVED0[7];		/*!< Reserved, 						   Address offset: 0x04 		*/
X  volatile uint32_t RESERVED0[7];		 
N  __IO uint32_t PXCON;     			/*!< GPIO port Control register,       Address offset: 0x20     	*/
X  volatile uint32_t PXCON;     			 
N  __IO uint32_t RESERVED1[7];		/*!< Reserved, 						   Address offset: 0x24 		*/
X  volatile uint32_t RESERVED1[7];		 
N  __IO uint32_t PXPH;       		/*!< GPIO port pull-up/pull-down register, Address offset: 0x40     */
X  volatile uint32_t PXPH;       		 
N  __IO uint32_t RESERVED2[7];		/*!< Reserved, 						   Address offset: 0x44 		*/
X  volatile uint32_t RESERVED2[7];		 
N  __IO uint32_t PXLEV;  			/*!< GPIO port Level register, 	       Address offset: 0x60    	    */
X  volatile uint32_t PXLEV;  			 
N} GPIO_TypeDef;
N
Ntypedef struct
N{
N  __IO uint8_t PIN_BIT[16];          /*!< GPIOA,B,C Bit register,               Address offset: 0x00      */
X  volatile uint8_t PIN_BIT[16];           
N  __IO uint8_t PIN_XR[16];       	 /*!< GPIOA,B,C Bit register,               Address offset: 0x20      */
X  volatile uint8_t PIN_XR[16];       	  
N
N} GPIO_BIT_TypeDef;
N
N
N/**
N  * @brief INT for IOPORT,Peripheral offset=0x300
N  */
Ntypedef struct
N{
N  __IO uint32_t INTF_IE;        /*!< INT Fall edge Enable register,   Address offset: 0x00      */
X  volatile uint32_t INTF_IE;         
N  __IO uint32_t RESERVED0[7];		/*!< Reserved, 									    	 Address offset: 0x04 			*/
X  volatile uint32_t RESERVED0[7];		 
N  __IO uint32_t INTR_IE;     		/*!< INT Rise edge Enable register register,       Address offset: 0x20     	*/
X  volatile uint32_t INTR_IE;     		 
N  __IO uint32_t RESERVED1[7];		/*!< Reserved, 									    	 Address offset: 0x24 			*/
X  volatile uint32_t RESERVED1[7];		 
N  __IO uint32_t INT_SEL0;       /*!< INT0-7 Port Select register, Address offset: 0x40    */
X  volatile uint32_t INT_SEL0;        
N  __IO uint32_t RESERVED2[7];		/*!< Reserved, 									    	 Address offset: 0x44 			*/
X  volatile uint32_t RESERVED2[7];		 
N  __IO uint32_t INT_SEL1;       /*!< INT8-15 Port Select register, Address offset: 0x60    */
X  volatile uint32_t INT_SEL1;        
N  __IO uint32_t RESERVED3[7];		/*!< Reserved, 									    	 Address offset: 0x64 			*/
X  volatile uint32_t RESERVED3[7];		 
N  __IO uint32_t INTF_CON;       /*!< INT Fall Control  register, Address offset: 0x80    */
X  volatile uint32_t INTF_CON;        
N  __IO uint32_t RESERVED4[7];		/*!< Reserved, 									    	 Address offset: 0x84 			*/
X  volatile uint32_t RESERVED4[7];		 
N  __IO uint32_t INTR_CON;       /*!< INT Rise Control register, Address offset: 0xA0    */
X  volatile uint32_t INTR_CON;        
N  __IO uint32_t RESERVED5[7];		/*!< Reserved, 									    	 Address offset: 0xA4 			*/
X  volatile uint32_t RESERVED5[7];		 
N  __IO uint32_t INTF_STS;       /*!< INT Fall Status  register, Address offset: 0xC0    */
X  volatile uint32_t INTF_STS;        
N  __IO uint32_t RESERVED6[7];		/*!< Reserved, 									    	 Address offset: 0xC4 			*/
X  volatile uint32_t RESERVED6[7];		 
N  __IO uint32_t INTR_STS;       /*!< INT Rise status register, Address offset: 0xE0    */
X  volatile uint32_t INTR_STS;        
N  __IO uint32_t RESERVED7[7];		/*!< Reserved, 									    	 Address offset: 0xE4 			*/
X  volatile uint32_t RESERVED7[7];		 
N} INT_TypeDef;
N
N/*
N	 Peripheral for AHB=0x40000000
N*/
N/**
N  * @brief WDT for AHB,Peripheral offset=0x330
N  */
Ntypedef struct
N{
N  __IO uint32_t RESERVED0[3];     /*!< Reserved,      Address offset: 0x00 */
X  volatile uint32_t RESERVED0[3];      
N  __IO uint32_t WDT_CON;      		/*!< WDT Control register, 			Address offset: 0x0C */
X  volatile uint32_t WDT_CON;      		 
N  __IO uint32_t WDT_CFG;          /*!< WDT Config register, 			Address offset: 0x10 */
X  volatile uint32_t WDT_CFG;           
N} WDT_TypeDef;
N
N/**
N  * @brief IAP for AHB,Peripheral offset=0x3C0
N  */
Ntypedef struct
N{
N  __IO uint32_t IAPKEY;     			/*!< IAP KEY register,      		Address offset: 0x00 */
X  volatile uint32_t IAPKEY;     			 
N  __IO uint32_t IAP_SNB;      		/*!< IAP Sector Number register, 			Address offset: 0x04 */
X  volatile uint32_t IAP_SNB;      		 
N  __IO uint32_t RESERVED0;     		/*!< Reserved,      Address offset: 0x08 */
X  volatile uint32_t RESERVED0;     		 
N  __IO uint32_t IAP_CON;          /*!< IAP Control register, 			Address offset: 0x0C */
X  volatile uint32_t IAP_CON;           
N} IAP_TypeDef;
N
N
N/**
N  * @brief OPT for AHB,Peripheral offset=0x3F8
N  */
Ntypedef struct
N{
N  __IO uint32_t OPINX;     			/*!< IAP KEY register,      		Address offset: 0x00 */
X  volatile uint32_t OPINX;     			 
N  __IO uint32_t OPREG;      		/*!< IAP Sector Number register, 			Address offset: 0x04 */
X  volatile uint32_t OPREG;      		 
N} OPT_TypeDef;
N
N/**
N  * @brief CRC for AHB,Peripheral offset=0x2000
N  */
Ntypedef struct
N{
N  __IO uint32_t CRC_DR;     			/*!< CRC Data register,      		Address offset: 0x00 */
X  volatile uint32_t CRC_DR;     			 
N  __IO uint32_t CRC_CON;      		/*!< CRC Config register, 			Address offset: 0x04 */
X  volatile uint32_t CRC_CON;      		 
N  __IO uint32_t CRC_INT;     		  /*!< CRC Inital register,      Address offset: 0x08 */
X  volatile uint32_t CRC_INT;     		   
N  __IO uint32_t CRC_POL;          /*!< CRC Poly  register, 			Address offset: 0x0C */
X  volatile uint32_t CRC_POL;           
N} CRC_TypeDef;
N
N
N/**
N  * @brief RCCAHB for AHB,Peripheral offset =0x3000
N  */
Ntypedef struct
N{
N  __IO uint32_t AHB_CFG;       	 /*!< APB2 Config register,      Address offset: 0x00 */
X  volatile uint32_t AHB_CFG;       	  
N  __IO uint32_t AHB_RST;          /*!< APB2 Reset register,       Address offset: 0x04 */
X  volatile uint32_t AHB_RST;           
N} RCCAHB_TypeDef;
N
N/**
N  * @brief RCC for AHB,Peripheral offset=0x3014
N  */
Ntypedef struct
N{
N  __IO uint32_t RCC_KEY;          /*!< RCC Key register,    Address offset: 0x0C */
X  volatile uint32_t RCC_KEY;           
N  __IO uint32_t RESERVED0;        /*!< Reserved, 		Address offset: 0x10 */
X  volatile uint32_t RESERVED0;         
N  __IO uint32_t RCC_CFG0;     		/*!< RCC Config0 register,    Address offset: 0x14 */
X  volatile uint32_t RCC_CFG0;     		 
N  __IO uint32_t RCC_CFG1;      		/*!< RCC Config1 register, 		Address offset: 0x18 */
X  volatile uint32_t RCC_CFG1;      		 
N  __IO uint32_t PLL_CFG;     		  /*!< PLL Config register,     Address offset: 0x1C */
X  volatile uint32_t PLL_CFG;     		   
N  __IO uint32_t RCC_STS;          /*!< RCC Status  register, 		Address offset: 0x20 */
X  volatile uint32_t RCC_STS;           
N  __IO uint32_t RESERVED1;        /*!< Reserved, 			Address offset: 0x24 */
X  volatile uint32_t RESERVED1;         
N  __IO uint32_t SYST_CALIB;       /*!< RCC Calib  register, 			Address offset: 0x28 */
X  volatile uint32_t SYST_CALIB;        
N  __IO uint32_t NMI_CFG;          /*!< NMI CFG  register, 			Address offset: 0x2C */
X  volatile uint32_t NMI_CFG;           
N} RCC_TypeDef;			//V0.12
N
N
N/*
N	 Peripheral for DMA=AHB+0x10800
N*/
N/**
N  * @brief DMA0..DMA3 Peripheral offset=0x40*n(n=0,1,2,3)
N  */
Ntypedef struct
N{
N  __IO uint32_t DMA_SADR;     		/*!< DMA Source Adress register,    Address offset: 0x00 */
X  volatile uint32_t DMA_SADR;     		 
N  __IO uint32_t DMA_DADR;      		/*!< DMA Destination Adress register, 		Address offset: 0x04 */
X  volatile uint32_t DMA_DADR;      		 
N  __IO uint32_t DMA_CFG;     		  /*!< DMA Config register,     Address offset: 0x08 */
X  volatile uint32_t DMA_CFG;     		   
N  __IO uint32_t DMA_CNT;          /*!< DMA Count  register, 		Address offset: 0x0C */
X  volatile uint32_t DMA_CNT;           
N  __IO uint32_t DMA_STS;          /*!< DMA Status register, 		Address offset: 0x10 */
X  volatile uint32_t DMA_STS;           
N} DMA_TypeDef;
N
N
N
N
N/** @addtogroup Peripheral_memory_map
N  * @{
N  */
N#define FLASH_BASE            (0x08000000UL)  /*!< FLASH base address */
N#define SRAM_BASE             (0x20000000UL)  /*!< SRAM base address */
N#define PERIPH_BASE           (0x40000000UL)  /*!< Peripheral base address */
N#define IOPORT_BASE           (0x40011000UL)  /*!< IOPORT base address */
N#define ERAM_BASE             (0x50000000UL)  /*!< Extern Ram base address */
N#define SRAM_SIZE_MAX         (0x00008000UL)  /*!< maximum SRAM size (up to 32 KBytes) */
N#define PWMDUTY_OFFSET		    (0x00000040UL)	/*!< PwmDuty offset */
N#define	LXDRAM_OFFSET		      (0x00000040UL)
N
N//===============================================
N#define SECTOR_SIZE						512
N#define FLASH_SIZE            (SECTOR_SIZE*2*256)
N#define LDROM_SIZE						(SECTOR_SIZE*2*2)
N
N/*!< Peripheral memory map */
N#define AHBPERIPH_BASE				 (PERIPH_BASE)
N#define APB0PERIPH_BASE        (PERIPH_BASE+0x20000)
N#define APB1PERIPH_BASE        (PERIPH_BASE+0x21000)
N#define APB2PERIPH_BASE        (PERIPH_BASE+0x22000)
N#define DMAPERIPH_BASE         (PERIPH_BASE+0x10800)
N#define IOPORTPERIPH_BASE      (PERIPH_BASE+0x11000)
N
N/*!< AHB peripherals */
N#define WDT_BASE					     (AHBPERIPH_BASE +(0x00000330UL))
N#define IAP_BASE               (AHBPERIPH_BASE +(0x000003C0UL))
N#define OPT_BASE               (AHBPERIPH_BASE +(0x000003F8UL))
N#define CRC_BASE               (AHBPERIPH_BASE +(0x00002000UL))
N#define RCCAHB_BASE            (AHBPERIPH_BASE +(0x00003000UL))
N#define RCC_BASE               (AHBPERIPH_BASE +(0x0000300CUL))
N/*!< APB0 peripherals */
N#define RCCAPB0_BASE           (APB0PERIPH_BASE +(0x00000000UL))
N#define UART0_BASE             (APB0PERIPH_BASE +(0x00000020UL))
N#define UART1_BASE             (APB0PERIPH_BASE +(0x00000080UL))
N#define SPI0_BASE              (APB0PERIPH_BASE +(0x00000040UL))
N#define TWI0_BASE              (APB0PERIPH_BASE +(0x00000060UL))
N#define TIM0_BASE              (APB0PERIPH_BASE +(0x00000100UL))
N#define TIM1_BASE              (APB0PERIPH_BASE +(0x00000140UL))
N#define TIM2_BASE              (APB0PERIPH_BASE +(0x00000180UL))
N#define TIM3_BASE              (APB0PERIPH_BASE +(0x000001C0UL))
N#define PWM0_BASE              (APB0PERIPH_BASE +(0x00000200UL))
N/*!< APB1 peripherals */
N#define RCCAPB1_BASE           (APB1PERIPH_BASE +(0x00000000UL))
N#define UART2_BASE             (APB1PERIPH_BASE +(0x00000020UL))
N#define SPI1_BASE              (APB1PERIPH_BASE +(0x00000040UL))
N#define TWI1_BASE              (APB1PERIPH_BASE +(0x00000060UL))
N#define TIM4_BASE              (APB1PERIPH_BASE +(0x00000100UL))
N#define TIM5_BASE              (APB1PERIPH_BASE +(0x00000140UL))
N#define TIM6_BASE              (APB1PERIPH_BASE +(0x00000180UL))
N#define TIM7_BASE              (APB1PERIPH_BASE +(0x000001C0UL))
N/*!< APB2 peripherals */
N#define RCCAPB2_BASE           (APB2PERIPH_BASE +(0x00000000UL))
N#define UART3_BASE             (APB2PERIPH_BASE +(0x00000020UL))
N#define LEDPWM_BASE            (APB2PERIPH_BASE +(0x00000300UL))
N#define BTM_BASE               (APB2PERIPH_BASE +(0x00000100UL))
N#define ADC_BASE               (APB2PERIPH_BASE +(0x00000110UL))
N#define CMP_BASE               (APB2PERIPH_BASE +(0x00000130UL))
N#define TK_BASE                (APB2PERIPH_BASE +(0x00000200UL))
N#define LCD_LED_BASE           (APB2PERIPH_BASE +(0x00000280UL))
N/*!< DMA */
N#define DMA0_BASE              (DMAPERIPH_BASE +(0x00000000UL))
N#define DMA1_BASE              (DMAPERIPH_BASE +(0x00000040UL))
N#define DMA2_BASE              (DMAPERIPH_BASE +(0x00000080UL))
N#define DMA3_BASE              (DMAPERIPH_BASE +(0x000000C0UL))
N/*!< IOPORT */
N#define GPIOA_BASE             (IOPORTPERIPH_BASE +(0x00000000UL))
N#define GPIOB_BASE             (IOPORTPERIPH_BASE +(0x00000100UL))
N#define GPIOC_BASE             (IOPORTPERIPH_BASE +(0x00000200UL))
N#define INT_BASE               (IOPORTPERIPH_BASE +(0x00000300UL))
N#define FT_BIT_BASE            (IOPORTPERIPH_BASE +(0x000003C0UL))
N#define RT_BIT_BASE            (IOPORTPERIPH_BASE +(0x000003E0UL))
N/*!< IOPORT-Bit */
N#define GPIOA_BIT_BASE         (GPIOA_BASE+(0x00000000UL))
N#define GPIOB_BIT_BASE         (GPIOB_BASE+(0x00000000UL))
N#define GPIOC_BIT_BASE         (GPIOC_BASE+(0x00000000UL))
N/*!< IOPORT-OverTurn */
N#define GPIOA_OT_BASE          (GPIOA_BASE+(0x00000010UL))
N#define GPIOB_OT_BASE          (GPIOB_BASE+(0x00000010UL))
N#define GPIOC_OT_BASE          (GPIOC_BASE+(0x00000010UL))
N/*<PA.SetBit:n=0...15>*/
N#define PA_BIT(n)              (*((uint8_t*)((GPIOA_BIT_BASE + (n)))))
N#define PB_BIT(n)              (*((uint8_t*)((GPIOB_BIT_BASE + (n)))))
N#define PC_BIT(n)              (*((uint8_t*)((GPIOC_BIT_BASE + (n)))))
N/*<PA.OverTurn:n=0...15>*/
N#define PA_OT(n)               (*((uint8_t*)((GPIOA_OT_BASE + (n)))) = 1)
N#define PB_OT(n)               (*((uint8_t*)((GPIOB_OT_BASE + (n)))) = 1)
N#define PC_OT(n)               (*((uint8_t*)((GPIOC_OT_BASE + (n)))) = 1)
N/*<INTF/INTR.SetBit:n=0...15>*/
N#define FT_BIT(n)              (*((uint8_t*)((FT_BIT_BASE + (n)))))
N#define RT_BIT(n)              (*((uint8_t*)((RT_BIT_BASE + (n)))))
N
N/** @addtogroup Peripheral_declaration
N  * @{
N  */
N#define	RCC								 	((RCC_TypeDef *) RCC_BASE)
N#define RCCAHB             	((RCCAHB_TypeDef *) RCCAHB_BASE)
N#define RCCAPB0						  ((RCCAPB0_TypeDef *) RCCAPB0_BASE)
N#define RCCAPB1						  ((RCCAPB1_TypeDef *) RCCAPB1_BASE)
N#define RCCAPB2						  ((RCCAPB2_TypeDef *) RCCAPB2_BASE)
N#define UART0								((UART_TypeDef *) UART0_BASE)
N#define UART1								((UART_TypeDef *) UART1_BASE)
N#define UART2								((UART_TypeDef *) UART2_BASE)
N#define UART3								((UART_TypeDef *) UART3_BASE)
N#define SPI0								((SPI_TypeDef *) SPI0_BASE)
N#define SPI1								((SPI_TypeDef *) SPI1_BASE)
N#define TWI0								((TWI_TypeDef *) TWI0_BASE)
N#define TWI1								((TWI_TypeDef *) TWI1_BASE)
N#define TIM0								((TIM_TypeDef *) TIM0_BASE)
N#define TIM1								((TIM_TypeDef *) TIM1_BASE)
N#define TIM2								((TIM_TypeDef *) TIM2_BASE)
N#define TIM3								((TIM_TypeDef *) TIM3_BASE)
N#define TIM4								((TIM_TypeDef *) TIM4_BASE)
N#define TIM5								((TIM_TypeDef *) TIM5_BASE)
N#define TIM6								((TIM_TypeDef *) TIM6_BASE)
N#define TIM7								((TIM_TypeDef *) TIM7_BASE)
N#define PWM0								((PWM_TypeDef *) PWM0_BASE)
N#define LEDPWM							((LEDPWM_TypeDef *) LEDPWM_BASE)
N#define BTM									((BTM_TypeDef *) BTM_BASE)
N#define ADC									((ADC_TypeDef *) ADC_BASE)
N#define CMP									((CMP_TypeDef *) CMP_BASE)
N#define TK									((TK_TypeDef *) TK_BASE)
N#define LCD_LED							((LCD_LED_TypeDef *) LCD_LED_BASE)
N#define INT                 ((INT_TypeDef *) INT_BASE)
N#define WDT                	((WDT_TypeDef *) WDT_BASE)
N#define IAP                	((IAP_TypeDef *) IAP_BASE)
N#define CRC                	((CRC_TypeDef *) CRC_BASE)
N#define DMA0								((DMA_TypeDef *) DMA0_BASE)
N#define DMA1								((DMA_TypeDef *) DMA1_BASE)
N#define DMA2								((DMA_TypeDef *) DMA2_BASE)
N#define DMA3								((DMA_TypeDef *) DMA3_BASE)
N#define GPIOA								((GPIO_TypeDef *) GPIOA_BASE)
N#define GPIOB								((GPIO_TypeDef *) GPIOB_BASE)
N#define GPIOC								((GPIO_TypeDef *) GPIOC_BASE)
N//----------------------------------------------------------
N#define OPT                ((OPT_TypeDef *) OPT_BASE)
N//----------------------------------------------------------
N/** @addtogroup Peripheral_Registers_Bits_Definition
N* @{
N*/
N
N/******************************************************************************/
N/*                         Peripheral Registers Bits Definition               */
N/******************************************************************************/
N
N/******************************************************************************/
N/*                                                                            */
N/*                      RCC                    */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for RCC_CFG0 register  ********************/
N#define RCC_CFG0_LXTEN_Pos         				(0U)
N#define	RCC_CFG0_LXTEN_Msk								(0x1UL << RCC_CFG0_LXTEN_Pos)
N#define RCC_CFG0_LXTEN           					RCC_CFG0_LXTEN_Msk
N
N#define RCC_CFG0_LIRCEN_Pos        				(1U)
N#define	RCC_CFG0_LIRCEN_Msk								(0x1UL << RCC_CFG0_LIRCEN_Pos)
N#define RCC_CFG0_LIRCEN           				RCC_CFG0_LIRCEN_Msk
N
N#define RCC_CFG0_CRYHF_Pos         				(4U)
N#define	RCC_CFG0_CRYHF_Msk								(0x1UL << RCC_CFG0_CRYHF_Pos)
N#define RCC_CFG0_CRYHF           					RCC_CFG0_CRYHF_Msk
N
N#define RCC_CFG0_HXTEN_Pos         				(5U)
N#define	RCC_CFG0_HXTEN_Msk								(0x1UL << RCC_CFG0_HXTEN_Pos)
N#define RCC_CFG0_HXTEN          					RCC_CFG0_HXTEN_Msk
N
N#define RCC_CFG0_HIRCEN_Pos        				(6U)
N#define	RCC_CFG0_HIRCEN_Msk								(0x1UL << RCC_CFG0_HIRCEN_Pos)
N#define RCC_CFG0_HIRCEN          					RCC_CFG0_HIRCEN_Msk
N
N#define RCC_CFG0_SYSCLKSW_Pos      				(7U)
N#define	RCC_CFG0_SYSCLKSW_Msk							(0x1UL << RCC_CFG0_SYSCLKSW_Pos)
N#define RCC_CFG0_SYSCLKSW          				RCC_CFG0_SYSCLKSW_Msk
N
N#define RCC_CFG0_SYSCLKSEL_Pos     				(8U)
N#define	RCC_CFG0_SYSCLKSEL_Msk						(0x3UL << RCC_CFG0_SYSCLKSEL_Pos)
N#define RCC_CFG0_SYSCLKSEL         				RCC_CFG0_SYSCLKSEL_Msk
N
N#define RCC_CFG0_HPLDODP_Pos         			(11U)
N#define	RCC_CFG0_HPLDOD_Msk								(0x1UL << RCC_CFG0_HPLDODP_Pos)         
N#define RCC_CFG0_HPLDOD         					RCC_CFG0_HPLDOD_Msk
N
N#define RCC_CFG0_WAIT_Pos          				(12U)
N#define	RCC_CFG0_WAIT_Msk                 (0x3UL << RCC_CFG0_WAIT_Pos)
N#define RCC_CFG0_WAIT                     RCC_CFG0_WAIT_Msk
N
N#define RCC_CFG0_HIRC72EN_Pos            (14U)
N#define	RCC_CFG0_HIRC72EN_Msk            (0x1UL << RCC_CFG0_HIRC72EN_Pos)         
N#define RCC_CFG0_HIRC72EN         				RCC_CFG0_HIRC72EN_Msk
N
N#define RCC_CFG0_INTEN_Pos         				(15U)
N#define	RCC_CFG0_INTEN_Msk								(0x1UL << RCC_CFG0_INTEN_Pos)
N#define RCC_CFG0_INTEN         						RCC_CFG0_INTEN_Msk
N
N/********************  Bit definition for RCC_CFG1 register  ********************/
N#define RCC_CFG1_BTMCLKSEL_Pos         		(0U)
N#define	RCC_CFG1_BTMCLKSEL_Msk						(0x1UL << RCC_CFG1_BTMCLKSEL_Pos)
N#define RCC_CFG1_BTMCLKSEL           			RCC_CFG1_BTMCLKSEL_Msk
N
N#define RCC_CFG1_LCDCLKSEL_Pos         		(1U)
N#define	RCC_CFG1_LCDCLKSEL_Msk						(0x1UL << RCC_CFG1_LCDCLKSEL_Pos)
N#define RCC_CFG1_LCDCLKSEL           			RCC_CFG1_LCDCLKSEL_Msk
N
N#define RCC_CFG1_PWM0CLKSEL_Pos         	(2U)
N#define	RCC_CFG1_PWM0CLKSEL_Msk						(0x1UL << RCC_CFG1_PWM0CLKSEL_Pos)
N#define RCC_CFG1_PWM0CLKSEL           		RCC_CFG1_PWM0CLKSEL_Msk
N
N#define RCC_CFG1_STCLKSEL_Pos         		(5U)
N#define	RCC_CFG1_STCLKSEL_Msk							(0x3UL << RCC_CFG1_STCLKSEL_Pos)
N#define RCC_CFG1_STCLKSEL           			RCC_CFG1_STCLKSEL_Msk
N
N/********************  Bit definition for PLL_CFG register  ********************/
N#define PLL_CFG_PDIVP_Pos         				(0U)
N#define	PLL_CFG_PDIVP_Msk									(0x3UL << PLL_CFG_PDIVP_Pos)
N#define PLL_CFG_PDIVP           					PLL_CFG_PDIVP_Msk
N
N#define PLL_CFG_PLLQEN_Pos         				(5U)
N#define	PLL_CFG_PLLQEN_Msk								(0x1UL << PLL_CFG_PLLQEN_Pos)
N#define PLL_CFG_PLLQEN           					PLL_CFG_PLLQEN_Msk
N
N#define PLL_CFG_PLLREN_Pos         				(6U)
N#define	PLL_CFG_PLLREN_Msk								(0x1UL << PLL_CFG_PLLREN_Pos)
N#define PLL_CFG_PLLREN           					PLL_CFG_PLLREN_Msk
N
N#define PLL_CFG_PLLON_Pos         				(7U)
N#define	PLL_CFG_PLLON_Msk									(0x1UL << PLL_CFG_PLLON_Pos)
N#define PLL_CFG_PLLON           					PLL_CFG_PLLON_Msk
N
N#define PLL_CFG_NDIVN_Pos         				(8U)
N#define	PLL_CFG_NDIVN_Msk									(0xFFUL << PLL_CFG_NDIVN_Pos)
N#define PLL_CFG_NDIVN           					PLL_CFG_NDIVN_Msk
N
N#define PLL_CFG_MDIVM_Pos         				(16U)
N#define	PLL_CFG_MDIVM_Msk									(0x1FUL << PLL_CFG_MDIVM_Pos)
N#define PLL_CFG_MDIVM           					PLL_CFG_MDIVM_Msk
N
N#define PLL_CFG_PLLCLKSEL_Pos         		(23U)
N#define	PLL_CFG_PLLCLKSEL_Msk           	(0x1UL << PLL_CFG_PLLCLKSEL_Pos)
N#define PLL_CFG_PLLCLKSEL           			PLL_CFG_PLLCLKSEL_Msk
N
N/********************  Bit definition for RCC_STS register  ********************/
N#define RCC_STS_CLKFIF_Pos         				(0U)
N#define	RCC_STS_CLKFIF_Msk								(0x1UL << RCC_STS_CLKFIF_Pos)
N#define RCC_STS_CLKFIF           					RCC_STS_CLKFIF_Msk
N
N#define RCC_STS_LOCKERR_Pos         			(1U)
N#define	RCC_STS_LOCKERR_Msk								(0x1UL << RCC_STS_LOCKERR_Pos)
N#define RCC_STS_LOCKERR           				RCC_STS_LOCKERR_Msk
N
N#define RCC_STS_PLLRDY_Pos         				(2U)
N#define	RCC_STS_PLLRDY_Msk								(0x1UL << RCC_STS_PLLRDY_Pos)
N#define RCC_STS_PLLRDY          					RCC_STS_PLLRDY_Msk
N
N/********************  Bit definition for AHB_CFG register  ********************/
N#define AHB_CFG_DMAEN_Pos         				(0U)
N#define	AHB_CFG_DMAEN_Msk									(0x1UL << AHB_CFG_DMAEN_Pos)
N#define AHB_CFG_DMAEN           					AHB_CFG_DMAEN_Msk
N
N#define AHB_CFG_CRCEN_Pos         				(1U)
N#define	AHB_CFG_CRCEN_Msk									(0x1UL << AHB_CFG_CRCEN_Pos)
N#define AHB_CFG_CRCEN           					AHB_CFG_CRCEN_Msk
N
N#define AHB_CFG_IFBEN_Pos         				(2U)
N#define	AHB_CFG_IFBEN_Msk								(0x1UL << AHB_CFG_IFBEN_Pos)          
N#define AHB_CFG_IFBEN           					AHB_CFG_IFBEN_Msk
N
N#define AHB_CFG_CLKDIV_Pos         				(20U)
N#define	AHB_CFG_CLKDIV_Msk								(0x7UL << AHB_CFG_CLKDIV_Pos)
N#define AHB_CFG_CLKDIV           					AHB_CFG_CLKDIV_Msk
N
N/********************  Bit definition for AHB_RST register  ********************/
N#define AHB_RST_DMARST_Pos         				(0U)
N#define	AHB_RST_DMARST_Msk								(0x1UL << AHB_RST_DMARST_Pos)
N#define AHB_RST_DMARST           					AHB_RST_DMARST_Msk
N
N#define AHB_RST_CRCRST_Pos         				(1U)
N#define	AHB_RST_CRCRST_Msk								(0x1UL << AHB_RST_CRCRST_Pos)
N#define AHB_RST_CRCRST           					AHB_RST_CRCRST_Msk
N
N/********************  Bit definition for APB0_CFG register  ********************/
N#define APB0_CFG_TIM0EN_Pos         			(0U)
N#define	APB0_CFG_TIM0EN_Msk								(0x1UL << APB0_CFG_TIM0EN_Pos)
N#define APB0_CFG_TIM0EN           				APB0_CFG_TIM0EN_Msk
N
N#define APB0_CFG_TIM1EN_Pos         			(1U)
N#define	APB0_CFG_TIM1EN_Msk								(0x1UL << APB0_CFG_TIM1EN_Pos)
N#define APB0_CFG_TIM1EN           				APB0_CFG_TIM1EN_Msk
N
N#define APB0_CFG_TIM2EN_Pos         			(2U)
N#define	APB0_CFG_TIM2EN_Msk								(0x1UL << APB0_CFG_TIM2EN_Pos)
N#define APB0_CFG_TIM2EN           				APB0_CFG_TIM2EN_Msk
N
N#define APB0_CFG_TIM3EN_Pos         			(3U)
N#define	APB0_CFG_TIM3EN_Msk								(0x1UL << APB0_CFG_TIM3EN_Pos)
N#define APB0_CFG_TIM3EN           				APB0_CFG_TIM3EN_Msk
N
N#define APB0_CFG_TWI0EN_Pos         			(4U)
N#define	APB0_CFG_TWI0EN_Msk								(0x1UL << APB0_CFG_TWI0EN_Pos)
N#define APB0_CFG_TWI0EN           				APB0_CFG_TWI0EN_Msk
N
N#define APB0_CFG_SPI0EN_Pos         			(5U)
N#define	APB0_CFG_SPI0EN_Msk								(0x1UL << APB0_CFG_SPI0EN_Pos)
N#define APB0_CFG_SPI0EN           				APB0_CFG_SPI0EN_Msk
N
N#define APB0_CFG_UART0EN_Pos         			(6U)
N#define	APB0_CFG_UART0EN_Msk							(0x1UL << APB0_CFG_UART0EN_Pos)
N#define APB0_CFG_UART0EN           				APB0_CFG_UART0EN_Msk
N
N#define APB0_CFG_UART1EN_Pos         			(7U)
N#define	APB0_CFG_UART1EN_Msk							(0x1UL << APB0_CFG_UART1EN_Pos)
N#define APB0_CFG_UART1EN           				APB0_CFG_UART1EN_Msk
N
N#define APB0_CFG_PWM0EN_Pos         			(8U)
N#define	APB0_CFG_PWM0EN_Msk								(0x1UL << APB0_CFG_PWM0EN_Pos)
N#define APB0_CFG_PWM0EN           				APB0_CFG_PWM0EN_Msk
N
N#define APB0_CFG_CLKDIV_Pos         			(20U)
N#define	APB0_CFG_CLKDIV_Msk								(0x7UL << APB0_CFG_CLKDIV_Pos)
N#define APB0_CFG_CLKDIV           				APB0_CFG_CLKDIV_Msk
N
N#define APB0_CFG_ENAPB_Pos         				(23U)
N#define	APB0_CFG_ENAPB_Msk								(0x1UL << APB0_CFG_ENAPB_Pos)
N#define APB0_CFG_ENAPB           					APB0_CFG_ENAPB_Msk
N
N/********************  Bit definition for APB0_RST register  ********************/
N#define APB0_RST_TIM0RST_Pos         			(0U)
N#define	APB0_RST_TIM0RST_Msk							(0x1UL << APB0_RST_TIM0RST_Pos)
N#define APB0_RST_TIM0RST           				APB0_RST_TIM0RST_Msk
N
N#define APB0_RST_TIM1RST_Pos         			(1U)
N#define	APB0_RST_TIM1RST_Msk							(0x1UL << APB0_RST_TIM1RST_Pos)
N#define APB0_RST_TIM1RST           				APB0_RST_TIM1RST_Msk
N
N#define APB0_RST_TIM2RST_Pos         			(2U)
N#define	APB0_RST_TIM2RST_Msk							(0x1UL << APB0_RST_TIM2RST_Pos)
N#define APB0_RST_TIM2RST           				APB0_RST_TIM2RST_Msk
N
N#define APB0_RST_TIM3RST_Pos         			(3U)
N#define	APB0_RST_TIM3RST_Msk							(0x1UL << APB0_RST_TIM3RST_Pos)
N#define APB0_RST_TIM3RST           				APB0_RST_TIM3RST_Msk
N
N#define APB0_RST_TWI0RST_Pos         			(4U)
N#define	APB0_RST_TWI0RST_Msk							(0x1UL << APB0_RST_TWI0RST_Pos)
N#define APB0_RST_TWI0RST           				APB0_RST_TWI0RST_Msk
N
N#define APB0_RST_SPI0RST_Pos         			(5U)
N#define	APB0_RST_SPI0RST_Msk							(0x1UL << APB0_RST_SPI0RST_Pos)
N#define APB0_RST_SPI0RST           				APB0_RST_SPI0RST_Msk
N
N#define APB0_RST_UART0RST_Pos         		(6U)
N#define	APB0_RST_UART0RST_Msk							(0x1UL << APB0_RST_UART0RST_Pos)
N#define APB0_RST_UART0RST           			APB0_RST_UART0RST_Msk
N
N#define APB0_RST_UART1RST_Pos         		(7U)
N#define	APB0_RST_UART1RST_Msk							(0x1UL << APB0_RST_UART1RST_Pos)
N#define APB0_RST_UART1RST           			APB0_RST_UART1RST_Msk
N
N#define APB0_RST_PWM0RST_Pos         			(8U)
N#define	APB0_RST_PWM0RST_Msk							(0x1UL << APB0_RST_PWM0RST_Pos)
N#define APB0_RST_PWM0RST           				APB0_RST_PWM0RST_Msk
N
N
N/********************  Bit definition for APB1_CFG register  ********************/
N#define APB1_CFG_TIM4EN_Pos         			(0U)
N#define	APB1_CFG_TIM4EN_Msk								(0x1UL << APB1_CFG_TIM4EN_Pos)
N#define APB1_CFG_TIM4EN           				APB1_CFG_TIM4EN_Msk
N
N#define APB1_CFG_TIM5EN_Pos         			(1U)
N#define	APB1_CFG_TIM5EN_Msk								(0x1UL << APB1_CFG_TIM5EN_Pos)
N#define APB1_CFG_TIM5EN           				APB1_CFG_TIM5EN_Msk
N
N#define APB1_CFG_TIM6EN_Pos         			(2)
N#define	APB1_CFG_TIM6EN_Msk								(0x1UL << APB1_CFG_TIM6EN_Pos)
N#define APB1_CFG_TIM6EN           				APB1_CFG_TIM6EN_Msk
N
N#define APB1_CFG_TIM7EN_Pos         			(3U)
N#define	APB1_CFG_TIM7EN_Msk								(0x1UL << APB1_CFG_TIM7EN_Pos)
N#define APB1_CFG_TIM7EN           				APB1_CFG_TIM7EN_Msk
N
N#define APB1_CFG_TWI1EN_Pos         			(4U)
N#define	APB1_CFG_TWI1EN_Msk								(0x1UL << APB1_CFG_TWI1EN_Pos)
N#define APB1_CFG_TWI1EN           				APB1_CFG_TWI1EN_Msk
N
N#define APB1_CFG_UART2EN_Pos         			(7U)
N#define	APB1_CFG_UART2EN_Msk							(0x1UL << APB1_CFG_UART2EN_Pos)
N#define APB1_CFG_UART2EN           				APB1_CFG_UART2EN_Msk
N
N#define APB1_CFG_CLKDIV_Pos         			(20U)
N#define	APB1_CFG_CLKDIV_Msk								(0x7UL << APB1_CFG_CLKDIV_Pos)
N#define APB1_CFG_CLKDIV           				APB1_CFG_CLKDIV_Msk
N
N#define APB1_CFG_ENAPB_Pos         				(23U)
N#define	APB1_CFG_ENAPB_Msk								(0x1UL << APB1_CFG_ENAPB_Pos)
N#define APB1_CFG_ENAPB           					APB1_CFG_ENAPB_Msk
N
N/********************  Bit definition for APB1_RST register  ********************/
N#define APB1_RST_TIM4EN_Pos         			(0U)
N#define	APB1_RST_TIM4EN_Msk								(0x1UL << APB1_RST_TIM4EN_Pos)
N#define APB1_RST_TIM4EN           				APB1_RST_TIM4EN_Msk
N
N#define APB1_RST_TIM5EN_Pos         			(1U)
N#define	APB1_RST_TIM5EN_Msk								(0x1UL << APB1_RST_TIM5EN_Pos)
N#define APB1_RST_TIM5EN           				APB1_RST_TIM5EN_Msk
N
N#define APB1_RST_TIM6EN_Pos         			(2)
N#define	APB1_RST_TIM6EN_Msk								(0x1UL << APB1_RST_TIM6EN_Pos)
N#define APB1_RST_TIM6EN           				APB1_RST_TIM6EN_Msk
N
N#define APB1_RST_TIM7EN_Pos         			(3U)
N#define	APB1_RST_TIM7EN_Msk								(0x1UL << APB1_RST_TIM7EN_Pos)
N#define APB1_RST_TIM7EN           				APB1_RST_TIM7EN_Msk
N
N#define APB1_RST_TWI1EN_Pos         			(4U)
N#define	APB1_RST_TWI1EN_Msk								(0x1UL << APB1_RST_TWI1EN_Pos)
N#define APB1_RST_TWI1EN           				APB1_RST_TWI1EN_Msk
N
N#define APB1_RST_UART2EN_Pos         			(7U)
N#define	APB1_RST_UART2EN_Msk							(0x1UL << APB1_RST_UART2EN_Pos)
N#define APB1_RST_UART2EN           				APB1_RST_UART2EN_Msk
N
N/********************  Bit definition for APB2_CFG register  ********************/
N#define APB2_CFG_LEDPWMEN_Pos         			(0U)
N#define	APB2_CFG_LEDPWMEN_Msk								(0x1UL << APB2_CFG_LEDPWMEN_Pos)
N#define APB2_CFG_LEDPWMEN           				APB2_CFG_LEDPWMEN_Msk
N
N#define APB2_CFG_LCDEN_Pos         				(0U)
N#define	APB2_CFG_LCDEN_Msk								(0x3UL << APB2_CFG_LCDEN_Pos)
N#define APB2_CFG_LCDEN           					APB2_CFG_LCDEN_Msk
N
N#define APB2_CFG_UART3EN_Pos         			(2U)
N#define	APB2_CFG_UART3EN_Msk							(0x1UL << APB2_CFG_UART3EN_Pos)
N#define APB2_CFG_UART3EN           				APB2_CFG_UART3EN_Msk
N
N#define APB2_CFG_CLKDIV_Pos         			(20U)
N#define	APB2_CFG_CLKDIV_Msk								(0x7UL << APB2_CFG_CLKDIV_Pos)
N#define APB2_CFG_CLKDIV           				APB2_CFG_CLKDIV_Msk
N
N#define APB2_CFG_ENAPB_Pos         				(23U)
N#define	APB2_CFG_ENAPB_Msk								(0x1UL << APB2_CFG_ENAPB_Pos)
N#define APB2_CFG_ENAPB           					APB2_CFG_ENAPB_Msk
N
N/********************  Bit definition for APB2_RST register  ********************/
N#define APB2_RST_LEDPWMRST_Pos         			(0U)
N#define	APB2_RST_LEDPWMRST_Msk							(0x1UL << APB2_RST_LEDPWMRST_Pos)
N#define APB2_RST_LEDPWMRST          				APB2_CFG_LEDPWMEN_Msk
N
N#define APB2_RST_LCDRST_Pos         			(1U)
N#define	APB2_RST_LCDRST_Msk								(0x1UL << APB2_RST_LCDRST_Pos)
N#define APB2_RST_LCDRST           				APB2_RST_LCDRST_Msk
N
N#define APB2_RST_UART3RST_Pos         		(2U)
N#define	APB2_RST_UART3RST_Msk							(0x1UL << APB2_RST_UART3RST_Pos)
N#define APB2_RST_UART3RST           			APB2_RST_UART3RST_Msk
N
N
N/************private bit *************************************/
N#define APB0_CFG_RDMODE_Pos         			(31U)
N#define	APB0_CFG_RDMODE_Msk								(0x1UL << APB0_CFG_RDMODE_Pos)
N#define APB0_CFG_RDMODE           				APB0_CFG_RDMODE_Msk
N
N#define APB1_CFG_RDMODE_Pos         			(31U)
N#define	APB1_CFG_RDMODE_Msk								(0x1UL << APB1_CFG_RDMODE_Pos)
N#define APB1_CFG_RDMODE           				APB1_CFG_RDMODE_Msk
N
N#define APB2_CFG_RDMODE_Pos         			(31U)
N#define	APB2_CFG_RDMODE_Msk								(0x1UL << APB2_CFG_RDMODE_Pos)
N#define APB2_CFG_RDMODE           				APB2_CFG_RDMODE_Msk
N/********************  Bit definition for NMI_CFG register  ********************/ 
N#define NMI_CFG_CSSEN_Pos         			  (0U)
N#define	NMI_CFG_CSSEN_Msk							    (0x1UL << NMI_CFG_CSSEN_Pos)          
N#define NMI_CFG_CSSEN          			    	NMI_CFG_CSSEN_Msk
N
N#define NMI_CFG_CMPEN_Pos         			  (1U)
N#define	NMI_CFG_CMPEN_Msk							    (0x1UL << NMI_CFG_CMPEN_Pos)          
N#define NMI_CFG_CMPEN          			    	NMI_CFG_CMPEN_Msk
N
N#define NMI_CFG_INT0EN_Pos         			  (2U)
N#define	NMI_CFG_INT0EN_Msk							  (0x1UL << NMI_CFG_INT0EN_Pos)          
N#define NMI_CFG_INT0EN          			    NMI_CFG_INT0EN_Msk
N/******************************************************************************/
N/*                                                                            */
N/*                      ADC                    */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for ADC_CON register  ********************/
N#define ADC_CON_ADCIS_Pos         				(0U)
N#define	ADC_CON_ADCIS_Msk									(0x1FUL << ADC_CON_ADCIS_Pos)
N#define ADC_CON_ADCIS          						ADC_CON_ADCIS_Msk
N
N#define ADC_CON_ADCS_Pos         					(7U)
N#define	ADC_CON_ADCS_Msk									(0x1UL << ADC_CON_ADCS_Pos)
N#define ADC_CON_ADCS          						ADC_CON_ADCS_Msk
N
N#define ADC_CON_INTEN_Pos         				(8U)
N#define	ADC_CON_INTEN_Msk									(0x1UL << ADC_CON_INTEN_Pos)
N#define ADC_CON_INTEN          						ADC_CON_INTEN_Msk
N
N#define ADC_CON_CONT_Pos         					(11U)
N#define	ADC_CON_CONT_Msk									(0x1UL << ADC_CON_CONT_Pos)
N#define ADC_CON_CONT          						ADC_CON_CONT_Msk
N
N#define ADC_CON_DMAEN_Pos         				(12U)
N#define	ADC_CON_DMAEN_Msk									(0x1UL << ADC_CON_DMAEN_Pos)
N#define ADC_CON_DMAEN          						ADC_CON_DMAEN_Msk
N
N#define ADC_CON_ADCEN_Pos         				(15U)
N#define	ADC_CON_ADCEN_Msk									(0x1UL << ADC_CON_ADCEN_Pos)
N#define ADC_CON_ADCEN          						ADC_CON_ADCEN_Msk
N
N#define ADC_CON_LOWSP_Pos         				(16U)
N#define	ADC_CON_LOWSP_Msk									(0x7UL << ADC_CON_LOWSP_Pos)
N#define ADC_CON_LOWSP          						ADC_CON_LOWSP_Msk
N
N#define ADC_CON_VREFS_Pos         				(20U)
N#define	ADC_CON_VREFS_Msk									(0x3UL << ADC_CON_VREFS_Pos)
N#define ADC_CON_VREFS          						ADC_CON_VREFS_Msk
N/********************  Bit definition for ADC_STS register  ********************/
N#define ADC_STS_EOC_Pos         					(0U)
N#define	ADC_STS_EOC_Msk										(0x01UL << ADC_STS_EOC_Pos)
N#define ADC_STS_EOC          							ADC_STS_EOC_Msk
N
N/********************  Bit definition for ADC_CFG register  ********************/
N#define ADC_CFG_AIN0_Pos         					(0U)
N#define	ADC_CFG_AIN0_Msk									(0x1L << ADC_CFG_AIN0_Pos)
N#define ADC_CFG_AIN0          						ADC_CFG_AIN0_Msk
N
N#define ADC_CFG_AIN1_Pos         					(1U)
N#define	ADC_CFG_AIN1_Msk									(0x1L << ADC_CFG_AIN1_Pos)
N#define ADC_CFG_AIN1          						ADC_CFG_AIN1_Msk
N
N#define ADC_CFG_AIN2_Pos         					(2U)
N#define	ADC_CFG_AIN2_Msk									(0x1L << ADC_CFG_AIN2_Pos)
N#define ADC_CFG_AIN2          						ADC_CFG_AIN2_Msk
N
N#define ADC_CFG_AIN3_Pos         					(3U)
N#define	ADC_CFG_AIN3_Msk									(0x1L << ADC_CFG_AIN3_Pos)
N#define ADC_CFG_AIN3          						ADC_CFG_AIN3_Msk
N
N#define ADC_CFG_AIN4_Pos         					(4U)
N#define	ADC_CFG_AIN4_Msk									(0x1L << ADC_CFG_AIN4_Pos)
N#define ADC_CFG_AIN4          						ADC_CFG_AIN4_Msk
N
N#define ADC_CFG_AIN5_Pos         					(5U)
N#define	ADC_CFG_AIN5_Msk									(0x1L << ADC_CFG_AIN5_Pos)
N#define ADC_CFG_AIN5          						ADC_CFG_AIN5_Msk
N
N#define ADC_CFG_AIN6_Pos         					(6U)
N#define	ADC_CFG_AIN6_Msk									(0x1L << ADC_CFG_AIN6_Pos)
N#define ADC_CFG_AIN6          						ADC_CFG_AIN6_Msk
N
N#define ADC_CFG_AIN7_Pos         					(7U)
N#define	ADC_CFG_AIN7_Msk									(0x1L << ADC_CFG_AIN7_Pos)
N#define ADC_CFG_AIN7          						ADC_CFG_AIN7_Msk
N
N#define ADC_CFG_AIN8_Pos         					(8U)
N#define	ADC_CFG_AIN8_Msk									(0x1L << ADC_CFG_AIN8_Pos)
N#define ADC_CFG_AIN8          						ADC_CFG_AIN8_Msk
N
N#define ADC_CFG_AIN9_Pos         					(9U)
N#define	ADC_CFG_AIN9_Msk									(0x1L << ADC_CFG_AIN9_Pos)
N#define ADC_CFG_AIN9          						ADC_CFG_AIN9_Msk
N
N#define ADC_CFG_AIN10_Pos         				(10U)
N#define	ADC_CFG_AIN10_Msk									(0x1L << ADC_CFG_AIN10_Pos)
N#define ADC_CFG_AIN10          						ADC_CFG_AIN10_Msk
N
N#define ADC_CFG_AIN11_Pos         				(11U)
N#define	ADC_CFG_AIN11_Msk									(0x1L << ADC_CFG_AIN11_Pos)
N#define ADC_CFG_AIN11          						ADC_CFG_AIN11_Msk
N
N#define ADC_CFG_AIN12_Pos         				(12U)
N#define	ADC_CFG_AIN12_Msk									(0x1L << ADC_CFG_AIN12_Pos)
N#define ADC_CFG_AIN12          						ADC_CFG_AIN12_Msk
N
N#define ADC_CFG_AIN13_Pos         				(13U)
N#define	ADC_CFG_AIN13_Msk									(0x1L << ADC_CFG_AIN13_Pos)
N#define ADC_CFG_AIN13          						ADC_CFG_AIN13_Msk
N
N#define ADC_CFG_AIN14_Pos         				(14U)
N#define	ADC_CFG_AIN14_Msk									(0x1L << ADC_CFG_AIN14_Pos)
N#define ADC_CFG_AIN14          						ADC_CFG_AIN14_Msk
N
N#define ADC_CFG_AIN15_Pos         				(15U)
N#define	ADC_CFG_AIN15_Msk									(0x1L << ADC_CFG_AIN15_Pos)
N#define ADC_CFG_AIN15          						ADC_CFG_AIN15_Msk
N
N#define ADC_CFG_AIN16_Pos         				(16U)
N#define	ADC_CFG_AIN16_Msk									(0x1L << ADC_CFG_AIN16_Pos)
N#define ADC_CFG_AIN16          						ADC_CFG_AIN16_Msk
N
N/********************  Bit definition for ADC_ADCV register  ********************/
N#define ADC_ADCV_OVERRUN_Pos         			(31U)
N#define	ADC_CFG_OVERRUN_Msk								(0x1L << ADC_ADCV_OVERRUN_Pos)
N#define ADC_CFG_OVERRUN          					ADC_CFG_OVERRUN_Msk
N
N/******************************************************************************/
N/*                                                                            */
N/*                      BTM                    */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for BTM_CON register  ********************/
N#define BTM_CON_BTMFS_Pos         				(0U)
N#define	BTM_CON_BTMFS_Msk									(0x0FL << BTM_CON_BTMFS_Pos)
N#define BTM_CON_BTMFS          						BTM_CON_BTMFS_Msk
N
N#define BTM_CON_INTEN_Pos         				(6U)
N#define	BTM_CON_INTEN_Msk									(0x1L << BTM_CON_INTEN_Pos)
N#define BTM_CON_INTEN          						BTM_CON_INTEN_Msk
N
N#define BTM_CON_BTMEN_Pos         				(7U)
N#define	BTM_CON_BTMEN_Msk									(0x1L << BTM_CON_BTMEN_Pos)
N#define BTM_CON_BTMEN          						BTM_CON_BTMEN_Msk
N
N/********************  Bit definition for BTM_STS register  ********************/
N#define BTM_STS_BTMIF_Pos         				(0U)
N#define	BTM_STS_BTMIF_Msk                 (0x1L << BTM_STS_BTMIF_Pos)
N#define BTM_STS_BTMIF                     BTM_STS_BTMIF_Msk
N
N/******************************************************************************/
N/*                                                                            */
N/*                      CMP                    */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for CMP_CFG register  ********************/
N#define CMP_CFG_CMPIS_Pos         				(0U)
N#define	CMP_CFG_CMPIS_Msk									(0x3L << CMP_CFG_CMPIS_Pos)
N#define CMP_CFG_CMPIS          						CMP_CFG_CMPIS_Msk
N
N#define CMP_CFG_CMPP_Pos         					(4U)
N#define	CMP_CFG_CMPP_Msk									(0x1L << CMP_CFG_CMPP_Pos)
N#define CMP_CFG_CMPP          						CMP_CFG_CMPP_Msk
N
N#define CMP_CFG_CMPIM_Pos         				(5U)
N#define	CMP_CFG_CMPIM_Msk									(0x3L << CMP_CFG_CMPIM_Pos)
N#define CMP_CFG_CMPIM          						CMP_CFG_CMPIM_Msk
N
N#define CMP_CFG_CMPEN_Pos         				(7U)
N#define	CMP_CFG_CMPEN_Msk									(0x1L << CMP_CFG_CMPEN_Pos)
N#define CMP_CFG_CMPEN         						CMP_CFG_CMPEN_Msk
N
N#define CMP_CFG_CMPRF_Pos         				(8U)
N#define	CMP_CFG_CMPRF_Msk									(0x0FL << CMP_CFG_CMPRF_Pos)
N#define CMP_CFG_CMPRF        							CMP_CFG_CMPRF_Msk
N/********************  Bit definition for CMP_STS register  ********************/
N#define CMP_STS_CMPIF_Pos         				(0U)
N#define	CMP_STS_CMPIF_Msk									(0x1L << CMP_STS_CMPIF_Pos)
N#define CMP_STS_CMPIF          						CMP_STS_CMPIF_Msk
N
N#define CMP_STS_CMPSTA_Pos         				(1U)
N#define	CMP_STS_CMPSTA_Msk								(0x1L << CMP_STS_CMPSTA_Pos)
N#define CMP_STS_CMPSTA          					CMP_STS_CMPSTA_Msk
N/******************************************************************************/
N/*                                                                            */
N/*                      CRC                   */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for CRC_CON register  ********************/
N#define CRC_CON_CRCRST_Pos         				(0U)
N#define	CRC_CON_CRCRST_Msk								(0x1L << CRC_CON_CRCRST_Pos)
N#define CRC_CON_CRCRST          					CRC_CON_CRCRST_Msk
N
N#define CRC_CON_POLYSIZE_Pos         			(6U)
N#define	CRC_CON_POLYSIZE_Msk							(0x3L << CRC_CON_POLYSIZE_Pos)
N#define CRC_CON_POLYSIZE          				CRC_CON_POLYSIZE_Msk
N
N/******************************************************************************/
N/*                                                                            */
N/*                      DMA                   																*/
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for DMA_CFG register  ********************/
N#define DMA_CFG_PL_Pos         						(0U)
N#define	DMA_CFG_PL_Msk										(0x3L << DMA_CFG_PL_Pos)
N#define DMA_CFG_PL          							DMA_CFG_PL_Msk
N
N#define DMA_CFG_TXWIDTH_Pos         			(2U)
N#define	DMA_CFG_TXWIDTH_Msk							(0x3L << DMA_CFG_TXWIDTH_Pos)
N#define DMA_CFG_TXWIDTH          				DMA_CFG_TXWIDTH_Msk
N
N#define DMA_CFG_CIRC_Pos         					(4U)
N#define	DMA_CFG_CIRC_Msk									(0x1L << DMA_CFG_CIRC_Pos)
N#define DMA_CFG_CIRC          						DMA_CFG_CIRC_Msk
N
N#define DMA_CFG_PAUSE_Pos         				(5U)
N#define	DMA_CFG_PAUSE_Msk									(0x1L << DMA_CFG_PAUSE_Pos)
N#define DMA_CFG_PAUSE          						DMA_CFG_PAUSE_Msk
N
N#define DMA_CFG_CHRST_Pos         				(6U)
N#define	DMA_CFG_CHRST_Msk									(0x1L << DMA_CFG_CHRST_Pos)
N#define DMA_CFG_CHRST          						DMA_CFG_CHRST_Msk
N
N#define DMA_CFG_CHEN_Pos         					(7U)
N#define	DMA_CFG_CHEN_Msk									(0x1L << DMA_CFG_CHEN_Pos)
N#define DMA_CFG_CHEN          						DMA_CFG_CHEN_Msk
N
N#define DMA_CFG_DAINC_Pos         				(8U)
N#define	DMA_CFG_DAINC_Msk									(0x3L << DMA_CFG_DAINC_Pos)
N#define DMA_CFG_DAINC         						DMA_CFG_DAINC_Msk
N
N#define DMA_CFG_SAINC_Pos         				(10U)
N#define	DMA_CFG_SAINC_Msk									(0x3L << DMA_CFG_SAINC_Pos)
N#define DMA_CFG_SAINC         						DMA_CFG_SAINC_Msk
N
N#define DMA_CFG_BURSIZE_Pos         			(12U)
N#define	DMA_CFG_BURSIZE_Msk								(0x7L << DMA_CFG_BURSIZE_Pos)
N#define DMA_CFG_BURSIZE         					DMA_CFG_BURSIZE_Msk
N
N#define DMA_CFG_TPTYPE_Pos         				(15U)
N#define	DMA_CFG_TPTYPE_Msk								(0x1L << DMA_CFG_TPTYPE_Pos)
N#define DMA_CFG_TPTYPE        						DMA_CFG_TPTYPE_Msk
N
N#define DMA_CFG_INTEN_Pos         				(16U)
N#define	DMA_CFG_INTEN_Msk									(0x1L << DMA_CFG_INTEN_Pos)
N#define DMA_CFG_INTEN        							DMA_CFG_INTEN_Msk
N
N#define DMA_CFG_TCIE_Pos         					(17U)
N#define	DMA_CFG_TCIE_Msk									(0x1L << DMA_CFG_TCIE_Pos)
N#define DMA_CFG_TCIE        							DMA_CFG_TCIE_Msk
N
N#define DMA_CFG_HTIE_Pos         					(18U)
N#define	DMA_CFG_HTIE_Msk									(0x1L << DMA_CFG_HTIE_Pos)
N#define DMA_CFG_HTIE        							DMA_CFG_HTIE_Msk
N
N#define DMA_CFG_TEIE_Pos         					(19U)
N#define	DMA_CFG_TEIE_Msk									(0x1L << DMA_CFG_TEIE_Pos)
N#define DMA_CFG_TEIE        							DMA_CFG_TEIE_Msk
N
N#define DMA_CFG_CHRQ_Pos         					(23U)
N#define	DMA_CFG_CHRQ_Msk									(0x1L << DMA_CFG_CHRQ_Pos)
N#define DMA_CFG_CHRQ        							DMA_CFG_CHRQ_Msk
N
N
N#define DMA_CFG_REQSRC_Pos         				(24U)
N#define	DMA_CFG_REQSRC_Msk								(0x3FL << DMA_CFG_CHRQ_Pos)
N#define DMA_CFG_REQSRC        						DMA_CFG_CHRQ_Msk
N
N/********************  Bit definition for DMA_STS register  ********************/
N#define DMA_STS_GIF_Pos         					(0U)
N#define	DMA_STS_GIF_Msk										(0x1L << DMA_STS_GIF_Pos)
N#define DMA_STS_GIF        								DMA_STS_GIF_Msk
N
N#define DMA_STS_TCIF_Pos         					(1U)
N#define	DMA_STS_TCIF_Msk									(0x1L << DMA_STS_TCIF_Pos)
N#define DMA_STS_TCIF        							DMA_STS_TCIF_Msk
N
N#define DMA_STS_HTIF_Pos         					(2U)
N#define	DMA_STS_HTIF_Msk									(0x1L << DMA_STS_HTIF_Pos)
N#define DMA_STS_HTIF        							DMA_STS_HTIF_Msk
N
N#define DMA_STS_TEIF_Pos         					(3U)
N#define	DMA_STS_TEIF_Msk									(0x1L << DMA_STS_TEIF_Pos)
N#define DMA_STS_TEIF        							DMA_STS_TEIF_Msk
N
N#define DMA_STS_STATUS_Pos         				(4U)
N#define	DMA_STS_STATUS_Msk								(0x0FL << DMA_STS_STATUS_Pos)
N#define DMA_STS_STATUS        						DMA_STS_STATUS_Msk
N
N#define DMA_STS_SWREQ_Pos         				(8U)
N#define	DMA_STS_SWREQ_Msk									(0x1L << DMA_STS_SWREQ_Pos)
N#define DMA_STS_SWREQ       							DMA_STS_SWREQ_Msk
N
N/******************************************************************************/
N/*                                                                            */
N/*                      IAP                   																*/
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for IAP_CON register  ********************/
N#define IAP_CON_CMD_Pos         					(0U)
N#define	IAP_CON_CMD_Msk										(0x3L << IAP_CON_CMD_Pos)
N#define IAP_CON_CMD          							IAP_CON_CMD_Msk
N
N#define IAP_CON_PRG_Pos         					(4U)
N#define	IAP_CON_PRG_Msk										(0x1L << IAP_CON_PRG_Pos)
N#define IAP_CON_PRG         							IAP_CON_PRG_Msk
N
N#define IAP_CON_SERASE_Pos         				(5U)
N#define	IAP_CON_SERASE_Msk								(0x1L << IAP_CON_SERASE_Pos)
N#define IAP_CON_SERASE         						IAP_CON_SERASE_Msk
N
N#define IAP_CON_ERASE_Pos         				(7U)
N#define	IAP_CON_ERASE_Msk									(0x1L << IAP_CON_ERASE_Pos)
N#define IAP_CON_ERASE         						IAP_CON_ERASE_Msk
N
N#define IAP_CON_RST_Pos         					(8U)
N#define	IAP_CON_RST_Msk										(0x1L << IAP_CON_RST_Pos)
N#define IAP_CON_RST         							IAP_CON_RST_Msk
N
N#define IAP_CON_BTLD_Pos         					(9U)
N#define	IAP_CON_BTLD_Msk									(0x3L << IAP_CON_BTLD_Pos)
N#define IAP_CON_BTLD         							IAP_CON_BTLD_Msk
N
N#define IAP_CON_LOCK_Pos         					(31)
N#define	IAP_CON_LOCK_Msk									(0x1UL << IAP_CON_LOCK_Pos)     	//V0.12     
N#define IAP_CON_LOCK         							IAP_CON_LOCK_Msk
N
N/******************************************************************************/
N/*                                                                            */
N/*                      INT                   																*/
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for INT_FIE register  ********************/
N#define INT_FIE_ENF0_Pos         				(0U)
N#define	INT_FIE_ENF0_Msk									(0x1L << INT_FIE_ENF0_Pos)
N#define INT_FIE_ENF0          						INT_FIE_ENF0_Msk
N
N#define INT_FIE_ENF1_Pos         				(1U)
N#define	INT_FIE_ENF1_Msk									(0x1L << INT_FIE_ENF1_Pos)
N#define INT_FIE_ENF1          						INT_FIE_ENF1_Msk
N
N#define INT_FIE_ENF2_Pos         				(2U)
N#define	INT_FIE_ENF2_Msk									(0x1L << INT_FIE_ENF2_Pos)
N#define INT_FIE_ENF2          						INT_FIE_ENF2_Msk
N
N#define INT_FIE_ENF3_Pos         				(3U)
N#define	INT_FIE_ENF3_Msk									(0x1L << INT_FIE_ENF3_Pos)
N#define INT_FIE_ENF3          						INT_FIE_ENF3_Msk
N
N#define INT_FIE_ENF4_Pos         				(4U)
N#define	INT_FIE_ENF4_Msk									(0x1L << INT_FIE_ENF4_Pos)
N#define INT_FIE_ENF4          						INT_FIE_ENF4_Msk
N
N#define INT_FIE_ENF5_Pos         				(5U)
N#define	INT_FIE_ENF5_Msk									(0x1L << INT_FIE_ENF5_Pos)
N#define INT_FIE_ENF5          						INT_FIE_ENF5_Msk
N
N#define INT_FIE_ENF6_Pos         				(6U)
N#define	INT_FIE_ENF6_Msk									(0x1L << INT_FIE_ENF6_Pos)
N#define INT_FIE_ENF6          						INT_FIE_ENF6_Msk
N
N#define INT_FIE_ENF7_Pos         				(7U)
N#define	INT_FIE_ENF7_Msk									(0x1L << INT_FIE_ENF7_Pos)
N#define INT_FIE_ENF7          						INT_FIE_ENF7_Msk
N
N#define INT_FIE_ENF8_Pos         				(8U)
N#define	INT_FIE_ENF8_Msk									(0x1L << INT_FIE_ENF8_Pos)
N#define INT_FIE_ENF8          						INT_FIE_ENF8_Msk
N
N#define INT_FIE_ENF9_Pos         				(9U)
N#define	INT_FIE_ENF9_Msk									(0x1L << INT_FIE_ENF9_Pos)
N#define INT_FIE_ENF9          						INT_FIE_ENF9_Msk
N
N#define INT_FIE_ENF10_Pos         				(10U)
N#define	INT_FIE_ENF10_Msk								(0x1L << INT_FIE_ENF10_Pos)
N#define INT_FIE_ENF10          					INT_FIE_ENF10_Msk
N
N#define INT_FIE_ENF11_Pos         				(11U)
N#define	INT_FIE_ENF11_Msk								(0x1L << INT_FIE_ENF11_Pos)
N#define INT_FIE_ENF11          					INT_FIE_ENF11_Msk
N
N#define INT_FIE_ENF12_Pos         				(12U)
N#define	INT_FIE_ENF12_Msk								(0x1L << INT_FIE_ENF12_Pos)
N#define INT_FIE_ENF12          					INT_FIE_ENF12_Msk
N
N#define INT_FIE_ENF13_Pos         				(13U)
N#define	INT_FIE_ENF13_Msk								(0x1L << INT_FIE_ENF13_Pos)
N#define INT_FIE_ENF13          					INT_FIE_ENF13_Msk
N
N#define INT_FIE_ENF14_Pos         				(14U)
N#define	INT_FIE_ENF14_Msk								(0x1L << INT_FIE_ENF14_Pos)
N#define INT_FIE_ENF14          					INT_FIE_ENF14_Msk
N
N#define INT_FIE_ENF15_Pos         				(15U)
N#define	INT_FIE_ENF15_Msk								(0x1L << INT_FIE_ENF15_Pos)
N#define INT_FIE_ENF15          					INT_FIE_ENF15_Msk
N/********************  Bit definition for INT_RIE register  ********************/
N#define INT_RIE_ENR0_Pos         				(0U)
N#define	INT_RIE_ENR0_Msk									(0x1L << INT_RIE_ENR0_Pos)
N#define INT_RIE_ENR0          						INT_RIE_ENR0_Msk
N
N#define INT_RIE_ENR1_Pos         				(1U)
N#define	INT_RIE_ENR1_Msk									(0x1L << INT_RIE_ENR1_Pos)
N#define INT_RIE_ENR1          						INT_RIE_ENR1_Msk
N
N#define INT_RIE_ENR2_Pos         				(2U)
N#define	INT_RIE_ENR2_Msk									(0x1L << INT_RIE_ENR2_Pos)
N#define INT_RIE_ENR2          						INT_RIE_ENR2_Msk
N
N#define INT_RIE_ENR3_Pos         				(3U)
N#define	INT_RIE_ENR3_Msk									(0x1L << INT_RIE_ENR3_Pos)
N#define INT_RIE_ENR3          						INT_RIE_ENR3_Msk
N
N#define INT_RIE_ENR4_Pos         				(4U)
N#define	INT_RIE_ENR4_Msk									(0x1L << INT_RIE_ENR4_Pos)
N#define INT_RIE_ENR4          						INT_RIE_ENR4_Msk
N
N#define INT_RIE_ENR5_Pos         				(5U)
N#define	INT_RIE_ENR5_Msk									(0x1L << INT_RIE_ENR5_Pos)
N#define INT_RIE_ENR5          						INT_RIE_ENR5_Msk
N
N#define INT_RIE_ENR6_Pos         				(6U)
N#define	INT_RIE_ENR6_Msk									(0x1L << INT_RIE_ENR6_Pos)
N#define INT_RIE_ENR6          						INT_RIE_ENR6_Msk
N
N#define INT_RIE_ENR7_Pos         				(7U)
N#define	INT_RIE_ENR7_Msk									(0x1L << INT_RIE_ENR7_Pos)
N#define INT_RIE_ENR7          						INT_RIE_ENR7_Msk
N
N#define INT_RIE_ENR8_Pos         				(8U)
N#define	INT_RIE_ENR8_Msk									(0x1L << INT_RIE_ENR8_Pos)
N#define INT_RIE_ENR8          						INT_RIE_ENR8_Msk
N
N#define INT_RIE_ENR9_Pos         				(9U)
N#define	INT_RIE_ENR9_Msk									(0x1L << INT_RIE_ENR9_Pos)
N#define INT_RIE_ENR9          						INT_RIE_ENR9_Msk
N
N#define INT_RIE_ENR10_Pos         				(10U)
N#define	INT_RIE_ENR10_Msk								(0x1L << INT_RIE_ENR10_Pos)
N#define INT_RIE_ENR10          					INT_RIE_ENR10_Msk
N
N#define INT_RIE_ENR11_Pos         				(11U)
N#define	INT_RIE_ENR11_Msk								(0x1L << INT_RIE_ENR11_Pos)
N#define INT_RIE_ENR11          					INT_RIE_ENR11_Msk
N
N#define INT_RIE_ENR12_Pos         				(12U)
N#define	INT_RIE_ENR12_Msk								(0x1L << INT_RIE_ENR12_Pos)
N#define INT_RIE_ENR12          					INT_RIE_ENR12_Msk
N
N#define INT_RIE_ENR13_Pos         				(13U)
N#define	INT_RIE_ENR13_Msk								(0x1L << INT_RIE_ENR13_Pos)
N#define INT_RIE_ENR13          					INT_RIE_ENR13_Msk
N
N#define INT_RIE_ENR14_Pos         				(14U)
N#define	INT_RIE_ENR14_Msk								(0x1L << INT_RIE_ENR14_Pos)
N#define INT_RIE_ENR14          					INT_RIE_ENR14_Msk
N
N#define INT_RIE_ENR15_Pos         				(15U)
N#define	INT_RIE_ENR15_Msk								(0x1L << INT_RIE_ENR15_Pos)
N#define INT_RIE_ENR15          					INT_RIE_ENR15_Msk
N
N/********************  Bit definition for INT_SEL0 register  ********************/
N#define INT_SEL0_INT0SEL_Pos         		(0U)
N#define	INT_SEL0_INT0SEL_Msk							(0x0FL << INT_SEL0_INT0SEL_Pos)
N#define INT_SEL0_INT0SEL          				INT_SEL0_INT0SEL_Msk
N
N#define INT_SEL0_INT1SEL_Pos         		(4U)
N#define	INT_SEL0_INT1SEL_Msk							(0x0FL << INT_SEL0_INT1SEL_Pos)
N#define INT_SEL0_INT1SEL          				INT_SEL0_INT1SEL_Msk
N
N#define INT_SEL0_INT2SEL_Pos         		(8U)
N#define	INT_SEL0_INT2SEL_Msk							(0x0FL << INT_SEL0_INT2SEL_Pos)
N#define INT_SEL0_INT2SEL          				INT_SEL0_INT2SEL_Msk
N
N#define INT_SEL0_INT3SEL_Pos         		(12U)
N#define	INT_SEL0_INT3SEL_Msk							(0x0FL << INT_SEL0_INT3SEL_Pos)
N#define INT_SEL0_INT3SEL          				INT_SEL0_INT3SEL_Msk
N
N#define INT_SEL0_INT4SEL_Pos         		(16U)
N#define	INT_SEL0_INT4SEL_Msk							(0x0FL << INT_SEL0_INT4SEL_Pos)
N#define INT_SEL0_INT4SEL          				INT_SEL0_INT4SEL_Msk
N
N#define INT_SEL0_INT5SEL_Pos         		(20U)
N#define	INT_SEL0_INT5SEL_Msk							(0x0FL << INT_SEL0_INT5SEL_Pos)
N#define INT_SEL0_INT5SEL          				INT_SEL0_INT5SEL_Msk
N
N#define INT_SEL0_INT6SEL_Pos         		(24U)
N#define	INT_SEL0_INT6SEL_Msk							(0x0FL << INT_SEL0_INT6SEL_Pos)
N#define INT_SEL0_INT6SEL          				INT_SEL0_INT6SEL_Msk
N
N#define INT_SEL0_INT7SEL_Pos         		(28U)
N#define	INT_SEL0_INT7SEL_Msk							(0x0FL << INT_SEL0_INT7SEL_Pos)
N#define INT_SEL0_INT7SEL          				INT_SEL0_INT7SEL_Msk
N
N/********************  Bit definition for INT_SEL1 register  ********************/
N#define INT_SEL1_INT8SEL_Pos         		(0U)
N#define	INT_SEL1_INT8SEL_Msk							(0x0FL << INT_SEL1_INT8SEL_Pos)
N#define INT_SEL1_INT8SEL          				INT_SEL1_INT8SEL_Msk
N
N#define INT_SEL1_INT9SEL_Pos         		(4U)
N#define	INT_SEL1_INT9SEL_Msk							(0x0FL << INT_SEL1_INT9SEL_Pos)
N#define INT_SEL1_INT9SEL          				INT_SEL1_INT9SEL_Msk
N
N#define INT_SEL1_INT10SEL_Pos         		(8U)
N#define	INT_SEL1_INT10SEL_Msk						(0x0FL << INT_SEL1_INT10SEL_Pos)
N#define INT_SEL1_INT10SEL          			INT_SEL1_INT10SEL_Msk
N
N#define INT_SEL1_INT11SEL_Pos         		(12U)
N#define	INT_SEL1_INT11SEL_Msk						(0x0FL << INT_SEL1_INT11SEL_Pos)
N#define INT_SEL1_INT11SEL          			INT_SEL1_INT11SEL_Msk
N
N#define INT_SEL1_INT12SEL_Pos         		(16U)
N#define	INT_SEL1_INT12SEL_Msk						(0x0FL << INT_SEL1_INT12SEL_Pos)
N#define INT_SEL1_INT12SEL          			INT_SEL1_INT12SEL_Msk
N
N#define INT_SEL1_INT13SEL_Pos         		(20U)
N#define	INT_SEL1_INT13SEL_Msk						(0x0FL << INT_SEL1_INT13SEL_Pos)
N#define INT_SEL1_INT13SEL          			INT_SEL1_INT13SEL_Msk
N
N#define INT_SEL1_INT14SEL_Pos         		(24U)
N#define	INT_SEL1_INT14SEL_Msk						(0x0FL << INT_SEL1_INT14SEL_Pos)
N#define INT_SEL1_INT14SEL          			INT_SEL1_INT14SEL_Msk
N
N#define INT_SEL1_INT15SEL_Pos         		(28U)
N#define	INT_SEL1_INT15SEL_Msk						(0x0FL << INT_SEL1_INT15SEL_Pos)
N#define INT_SEL1_INT15SEL          			INT_SEL1_INT15SEL_Msk
N
N
N/********************  Bit definition for INT_RCON register  ********************/
N#define INT_RCON_FT0_Pos         				(0U)
N#define	INT_RCON_FT0_Msk									(0x1L << INT_RCON_FT0_Pos)
N#define INT_RCON_FT0          						INT_RCON_FT0_Msk
N
N#define INT_RCON_FT1_Pos         				(1U)
N#define	INT_RCON_FT_Msk									(0x1L << INT_RCON_FT1_Pos)
N#define INT_RCON_FT1          						INT_RCON_FT_Msk
N
N#define INT_RCON_FT2_Pos         				(2U)
N#define	INT_RCON_FT2_Msk									(0x1L << INT_RCON_FT2_Pos)
N#define INT_RCON_FT2          						INT_RCON_FT2_Msk
N
N#define INT_RCON_FT3_Pos         				(3U)
N#define	INT_RCON_FT3_Msk									(0x1L << INT_RCON_FT3_Pos)
N#define INT_RCON_FT3          						INT_RCON_FT3_Msk
N
N#define INT_RCON_FT4_Pos         				(4U)
N#define	INT_RCON_FT4_Msk									(0x1L << INT_RCON_FT4_Pos)
N#define INT_RCON_FT4          						INT_RCON_FT4_Msk
N
N#define INT_RCON_FT5_Pos         				(5U)
N#define	INT_RCON_FT5_Msk									(0x1L << INT_RCON_FT5_Pos)
N#define INT_RCON_FT5          						INT_RCON_FT5_Msk
N
N#define INT_RCON_FT6_Pos         				(6U)
N#define	INT_RCON_FT6_Msk									(0x1L << INT_RCON_FT6_Pos)
N#define INT_RCON_FT6          						INT_RCON_FT6_Msk
N
N#define INT_RCON_FT7_Pos         				(7U)
N#define	INT_RCON_FT7_Msk									(0x1L << INT_RCON_FT7_Pos)
N#define INT_RCON_FT          						INT_RCON_FT7_Msk
N
N#define INT_RCON_FT8_Pos         				(8U)
N#define	INT_RCON_FT8_Msk									(0x1L << INT_RCON_FT8_Pos)
N#define INT_RCON_FT8          						INT_RCON_FT8_Msk
N
N#define INT_RCON_FT9_Pos         				(9U)
N#define	INT_RCON_FT9_Msk									(0x1L << INT_RCON_FT9_Pos)
N#define INT_RCON_FT9          						INT_RCON_FT9_Msk
N
N#define INT_RCON_FT10_Pos         				(10U)
N#define	INT_RCON_FT10_Msk								(0x1L << INT_RCON_FT10_Pos)
N#define INT_RCON_FT10          					INT_RCON_FT10_Msk
N
N#define INT_RCON_FT11_Pos         				(11U)
N#define	INT_RCON_FT11_Msk								(0x1L << INT_RCON_FT11_Pos)
N#define INT_RCON_FT11          					INT_RCON_FT11_Msk
N
N#define INT_RCON_FT12_Pos         				(12U)
N#define	INT_RCON_FT12_Msk								(0x1L << INT_RCON_FT12_Pos)
N#define INT_RCON_FT12          					INT_RCON_FT12_Msk
N
N#define INT_RCON_FT13_Pos         				(13U)
N#define	INT_RCON_FT13_Msk								(0x1L << INT_RCON_FT13_Pos)
N#define INT_RCON_FT13          					INT_RCON_FT13_Msk
N
N#define INT_RCON_FT14_Pos         				(14U)
N#define	INT_RCON_FT14_Msk								(0x1L << INT_RCON_FT14_Pos)
N#define INT_RCON_FT14          					INT_RCON_FT14_Msk
N
N#define INT_RCON_FT15_Pos         				(15U)
N#define	INT_RCON_FT15_Msk								(0x1L << INT_RCON_FT15_Pos)
N#define INT_RCON_FT15          					INT_RCON_FT15_Msk
N
N/********************  Bit definition for INT_RCON register  ********************/
N#define INT_RCON_RT0_Pos         				(0U)
N#define	INT_RCON_RT0_Msk									(0x1L << INT_RCON_RT0_Pos)
N#define INT_RCON_RT0          						INT_RCON_RT0_Msk
N
N#define INT_RCON_RT1_Pos         				(1U)
N#define	INT_RCON_RT_Msk									(0x1L << INT_RCON_RT1_Pos)
N#define INT_RCON_RT1          						INT_RCON_RT_Msk
N
N#define INT_RCON_RT2_Pos         				(2U)
N#define	INT_RCON_RT2_Msk									(0x1L << INT_RCON_RT2_Pos)
N#define INT_RCON_RT2          						INT_RCON_RT2_Msk
N
N#define INT_RCON_RT3_Pos         				(3U)
N#define	INT_RCON_RT3_Msk									(0x1L << INT_RCON_RT3_Pos)
N#define INT_RCON_RT3          						INT_RCON_RT3_Msk
N
N#define INT_RCON_RT4_Pos         				(4U)
N#define	INT_RCON_RT4_Msk									(0x1L << INT_RCON_RT4_Pos)
N#define INT_RCON_RT4          						INT_RCON_RT4_Msk
N
N#define INT_RCON_RT5_Pos         				(5U)
N#define	INT_RCON_RT5_Msk									(0x1L << INT_RCON_RT5_Pos)
N#define INT_RCON_RT5          						INT_RCON_RT5_Msk
N
N#define INT_RCON_RT6_Pos         				(6U)
N#define	INT_RCON_RT6_Msk									(0x1L << INT_RCON_RT6_Pos)
N#define INT_RCON_RT6          						INT_RCON_RT6_Msk
N
N#define INT_RCON_RT7_Pos         				(7U)
N#define	INT_RCON_RT7_Msk									(0x1L << INT_RCON_RT7_Pos)
N#define INT_RCON_RT          						INT_RCON_RT7_Msk
N
N#define INT_RCON_RT8_Pos         				(8U)
N#define	INT_RCON_RT8_Msk									(0x1L << INT_RCON_RT8_Pos)
N#define INT_RCON_RT8          						INT_RCON_RT8_Msk
N
N#define INT_RCON_RT9_Pos         				(9U)
N#define	INT_RCON_RT9_Msk									(0x1L << INT_RCON_RT9_Pos)
N#define INT_RCON_RT9          						INT_RCON_RT9_Msk
N
N#define INT_RCON_RT10_Pos         				(10U)
N#define	INT_RCON_RT10_Msk								(0x1L << INT_RCON_RT10_Pos)
N#define INT_RCON_RT10          					INT_RCON_RT10_Msk
N
N#define INT_RCON_RT11_Pos         				(11U)
N#define	INT_RCON_RT11_Msk								(0x1L << INT_RCON_RT11_Pos)
N#define INT_RCON_RT11          					INT_RCON_RT11_Msk
N
N#define INT_RCON_RT12_Pos         				(12U)
N#define	INT_RCON_RT12_Msk								(0x1L << INT_RCON_RT12_Pos)
N#define INT_RCON_RT12          					INT_RCON_RT12_Msk
N
N#define INT_RCON_RT13_Pos         				(13U)
N#define	INT_RCON_RT13_Msk								(0x1L << INT_RCON_RT13_Pos)
N#define INT_RCON_RT13          					INT_RCON_RT13_Msk
N
N#define INT_RCON_RT14_Pos         				(14U)
N#define	INT_RCON_RT14_Msk								(0x1L << INT_RCON_RT14_Pos)
N#define INT_RCON_RT14          					INT_RCON_RT14_Msk
N
N#define INT_RCON_RT15_Pos         				(15U)
N#define	INT_RCON_RT15_Msk								(0x1L << INT_RCON_RT15_Pos)
N#define INT_RCON_RT15          					INT_RCON_RT15_Msk
N
N/********************  Bit definition for INT_FSTS register  ********************/
N#define INT_FSTS_FIF0_Pos         				(0U)
N#define	INT_FSTS_FIF0_Msk								(0x1L << INT_FSTS_FIF0_Pos)
N#define INT_FSTS_FIF0          					INT_FSTS_FIF0_Msk
N
N#define INT_FSTS_FIF1_Pos         				(1U)
N#define	INT_FSTS_FIF_Msk									(0x1L << INT_FSTS_FIF1_Pos)
N#define INT_FSTS_FIF1          					INT_FSTS_FIF_Msk
N
N#define INT_FSTS_FIF2_Pos         				(2U)
N#define	INT_FSTS_FIF2_Msk								(0x1L << INT_FSTS_FIF2_Pos)
N#define INT_FSTS_FIF2          					INT_FSTS_FIF2_Msk
N
N#define INT_FSTS_FIF3_Pos         				(3U)
N#define	INT_FSTS_FIF3_Msk								(0x1L << INT_FSTS_FIF3_Pos)
N#define INT_FSTS_FIF3          					INT_FSTS_FIF3_Msk
N
N#define INT_FSTS_FIF4_Pos         				(4U)
N#define	INT_FSTS_FIF4_Msk								(0x1L << INT_FSTS_FIF4_Pos)
N#define INT_FSTS_FIF4          					INT_FSTS_FIF4_Msk
N
N#define INT_FSTS_FIF5_Pos         				(5U)
N#define	INT_FSTS_FIF5_Msk								(0x1L << INT_FSTS_FIF5_Pos)
N#define INT_FSTS_FIF5          					INT_FSTS_FIF5_Msk
N
N#define INT_FSTS_FIF6_Pos         				(6U)
N#define	INT_FSTS_FIF6_Msk								(0x1L << INT_FSTS_FIF6_Pos)
N#define INT_FSTS_FIF6          					INT_FSTS_FIF6_Msk
N
N#define INT_FSTS_FIF7_Pos         				(7U)
N#define	INT_FSTS_FIF7_Msk								(0x1L << INT_FSTS_FIF7_Pos)
N#define INT_FSTS_FIF          						INT_FSTS_FIF7_Msk
N
N#define INT_FSTS_FIF8_Pos         				(8U)
N#define	INT_FSTS_FIF8_Msk								(0x1L << INT_FSTS_FIF8_Pos)
N#define INT_FSTS_FIF8          					INT_FSTS_FIF8_Msk
N
N#define INT_FSTS_FIF9_Pos         				(9U)
N#define	INT_FSTS_FIF9_Msk								(0x1L << INT_FSTS_FIF9_Pos)
N#define INT_FSTS_FIF9          					INT_FSTS_FIF9_Msk
N
N#define INT_FSTS_FIF10_Pos         			(10U)
N#define	INT_FSTS_FIF10_Msk								(0x1L << INT_FSTS_FIF10_Pos)
N#define INT_FSTS_FIF10          					INT_FSTS_FIF10_Msk
N
N#define INT_FSTS_FIF11_Pos         			(11U)
N#define	INT_FSTS_FIF11_Msk								(0x1L << INT_FSTS_FIF11_Pos)
N#define INT_FSTS_FIF11          					INT_FSTS_FIF11_Msk
N
N#define INT_FSTS_FIF12_Pos         			(12U)
N#define	INT_FSTS_FIF12_Msk								(0x1L << INT_FSTS_FIF12_Pos)
N#define INT_FSTS_FIF12          					INT_FSTS_FIF12_Msk
N
N#define INT_FSTS_FIF13_Pos         			(13U)
N#define	INT_FSTS_FIF13_Msk								(0x1L << INT_FSTS_FIF13_Pos)
N#define INT_FSTS_FIF13          					INT_FSTS_FIF13_Msk
N
N#define INT_FSTS_FIF14_Pos         			(14U)
N#define	INT_FSTS_FIF14_Msk								(0x1L << INT_FSTS_FIF14_Pos)
N#define INT_FSTS_FIF14          					INT_FSTS_FIF14_Msk
N
N#define INT_FSTS_FIF15_Pos         			(15U)
N#define	INT_FSTS_FIF15_Msk								(0x1L << INT_FSTS_FIF15_Pos)
N#define INT_FSTS_FIF15          					INT_FSTS_FIF15_Msk
N
N/********************  Bit definition for INT_FSTS register  ********************/
N#define INT_FSTS_RIF0_Pos         				(0U)
N#define	INT_FSTS_RIF0_Msk								(0x1L << INT_FSTS_RIF0_Pos)
N#define INT_FSTS_RIF0          					INT_FSTS_RIF0_Msk
N
N#define INT_FSTS_RIF1_Pos         				(1U)
N#define	INT_FSTS_RIF_Msk									(0x1L << INT_FSTS_RIF1_Pos)
N#define INT_FSTS_RIF1          					INT_FSTS_RIF_Msk
N
N#define INT_FSTS_RIF2_Pos         				(2U)
N#define	INT_FSTS_RIF2_Msk								(0x1L << INT_FSTS_RIF2_Pos)
N#define INT_FSTS_RIF2          					INT_FSTS_RIF2_Msk
N
N#define INT_FSTS_RIF3_Pos         				(3U)
N#define	INT_FSTS_RIF3_Msk								(0x1L << INT_FSTS_RIF3_Pos)
N#define INT_FSTS_RIF3          					INT_FSTS_RIF3_Msk
N
N#define INT_FSTS_RIF4_Pos         				(4U)
N#define	INT_FSTS_RIF4_Msk								(0x1L << INT_FSTS_RIF4_Pos)
N#define INT_FSTS_RIF4          					INT_FSTS_RIF4_Msk
N
N#define INT_FSTS_RIF5_Pos         				(5U)
N#define	INT_FSTS_RIF5_Msk								(0x1L << INT_FSTS_RIF5_Pos)
N#define INT_FSTS_RIF5          					INT_FSTS_RIF5_Msk
N
N#define INT_FSTS_RIF6_Pos         				(6U)
N#define	INT_FSTS_RIF6_Msk								(0x1L << INT_FSTS_RIF6_Pos)
N#define INT_FSTS_RIF6          					INT_FSTS_RIF6_Msk
N
N#define INT_FSTS_RIF7_Pos         				(7U)
N#define	INT_FSTS_RIF7_Msk								(0x1L << INT_FSTS_RIF7_Pos)
N#define INT_FSTS_RIF          						INT_FSTS_RIF7_Msk
N
N#define INT_FSTS_RIF8_Pos         				(8U)
N#define	INT_FSTS_RIF8_Msk								(0x1L << INT_FSTS_RIF8_Pos)
N#define INT_FSTS_RIF8          					INT_FSTS_RIF8_Msk
N
N#define INT_FSTS_RIF9_Pos         				(9U)
N#define	INT_FSTS_RIF9_Msk								(0x1L << INT_FSTS_RIF9_Pos)
N#define INT_FSTS_RIF9          					INT_FSTS_RIF9_Msk
N
N#define INT_FSTS_RIF10_Pos         			(10U)
N#define	INT_FSTS_RIF10_Msk								(0x1L << INT_FSTS_RIF10_Pos)
N#define INT_FSTS_RIF10          					INT_FSTS_RIF10_Msk
N
N#define INT_FSTS_RIF11_Pos         			(11U)
N#define	INT_FSTS_RIF11_Msk								(0x1L << INT_FSTS_RIF11_Pos)
N#define INT_FSTS_RIF11          					INT_FSTS_RIF11_Msk
N
N#define INT_FSTS_RIF12_Pos         			(12U)
N#define	INT_FSTS_RIF12_Msk								(0x1L << INT_FSTS_RIF12_Pos)
N#define INT_FSTS_RIF12          					INT_FSTS_RIF12_Msk
N
N#define INT_FSTS_RIF13_Pos         			(13U)
N#define	INT_FSTS_RIF13_Msk								(0x1L << INT_FSTS_RIF13_Pos)
N#define INT_FSTS_RIF13          					INT_FSTS_RIF13_Msk
N
N#define INT_FSTS_RIF14_Pos         			(14U)
N#define	INT_FSTS_RIF14_Msk								(0x1L << INT_FSTS_RIF14_Pos)
N#define INT_FSTS_RIF14          					INT_FSTS_RIF14_Msk
N
N#define INT_FSTS_RIF15_Pos         			(15U)
N#define	INT_FSTS_RIF15_Msk								(0x1L << INT_FSTS_RIF15_Pos)
N#define INT_FSTS_RIF15          					INT_FSTS_RIF15
N/******************************************************************************/
N/*                                                                            */
N/*                      LCD                  																*/
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for DDR_CON register  ********************/
N#define DDR_CON_DMOD_Pos         					(0U)
N#define	DDR_CON_DMOD_Msk									(0x1L << DDR_CON_DMOD_Pos)
N#define DDR_CON_DMOD          						DDR_CON_DMOD_Msk
N
N#define DDR_CON_BIAS_Pos         					(1U)
N#define	DDR_CON_BIAS_Msk									(0x1L << DDR_CON_BIAS_Pos)
N#define DDR_CON_BIAS          						DDR_CON_BIAS_Msk
N
N#define DDR_CON_VOIRSF_Pos         				(3U)
N#define	DDR_CON_VOIRSF_Msk								(0x1L << DDR_CON_VOIRSF_Pos)
N#define DDR_CON_VOIRSF          					DDR_CON_VOIRSF_Msk
N
N#define DDR_CON_TYPE_Pos         					(4U)
N#define	DDR_CON_TYPE_Msk									(0x1L << DDR_CON_TYPE_Pos)
N#define DDR_CON_TYPE          						DDR_CON_TYPE_Msk
N
N#define DDR_CON_DDRON_Pos         				(7U)
N#define	DDR_CON_DDRON_Msk									(0x1L << DDR_CON_DDRON_Pos)
N#define DDR_CON_DDRON          						DDR_CON_DDRON_Msk
N
N#define DDR_CON_DDRCK_Pos         				(8U)
N#define	DDR_CON_DDRCK_Msk									(0x3L << DDR_CON_DDRCK_Pos)
N#define DDR_CON_DDRCK          						DDR_CON_DDRCK_Msk
N
N#define DDR_CON_TRICOM_Pos         				(14U)
N#define	DDR_CON_TRICOM_Msk								(0x1L << DDR_CON_TRICOM_Pos)
N#define DDR_CON_TRICOM          					DDR_CON_TRICOM_Msk
N
N#define DDR_CON_TRIMODE_Pos         			(15U)
N#define	DDR_CON_TRIMODE_Msk								(0x1L << DDR_CON_TRIMODE_Pos)
N#define DDR_CON_TRIMODE          					DDR_CON_TRIMODE_Msk
N
N/********************  Bit definition for DDR_CFG register  ********************/
N#define DDR_CFG_DMOD_Pos         					(0U)
N#define	DDR_CFG_DMOD_Msk									(0x3L << DDR_CFG_DMOD_Pos)
N#define DDR_CFG_DMOD          						DDR_CFG_DMOD_Msk
N
N#define DDR_CFG_DUTY_Pos         					(4U)
N#define	DDR_CFG_DUTY_Msk									(0x3L << DDR_CFG_DUTY_Pos)
N#define DDR_CFG_DUTY          						DDR_CFG_DUTY_Msk
N
N#define DDR_CFG_SCS_Pos         					(7U)
N#define	DDR_CFG_SCS_Msk										(0x1L << DDR_CFG_SCS_Pos)
N#define DDR_CFG_SCS          							DDR_CFG_SCS_Msk
N
N#define DDR_CFG_VLCD_Pos         					(8U)
N#define	DDR_CFG_VLCD_Msk									(0x0FL << DDR_CFG_VLCD_Pos)
N#define DDR_CFG_VLCD          						DDR_CFG_VLCD_Msk
N/******************************************************************************/
N/*                                                                            */
N/*                      PWM0                 																*/
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for PWM_CON register  ********************/
N#define PWM_CON_PWMCLK_Pos         				(0U)
N#define	PWM_CON_PWMCLK_Msk									(0xFL << PWM_CON_PWMCLK_Pos)
N#define PWM_CON_PWMCLK          						PWM_CON_PWMCLK_Msk
N
N#define PWM_CON_PWMMD1_Pos         				(5U)
N#define	PWM_CON_PWMMD1_Msk									(0x1L << PWM_CON_PWMMD1_Pos)
N#define PWM_CON_PWMMD1          						PWM_CON_PWMMD1_Msk
N
N#define PWM_CON_PWMMD0_Pos         				(6U)
N#define	PWM_CON_PWMMD0_Msk									(0x1L << PWM_CON_PWMMD0_Pos)
N#define PWM_CON_PWMMD0          						PWM_CON_PWMMD0_Msk
N
N#define PWM_CON_ENPWM_Pos         					(7U)
N#define	PWM_CON_ENPWM_Msk									(0x1L << PWM_CON_ENPWM_Pos)
N#define PWM_CON_ENPWM          						PWM_CON_ENPWM_Msk
N
N#define PWM_CON_INTEN_Pos         					(8U)
N#define	PWM_CON_INTEN_Msk									(0x1L << PWM_CON_INTEN_Pos)
N#define PWM_CON_INTEN          						PWM_CON_INTEN_Msk
N/********************  Bit definition for PWM0_CHN register  ********************/
N#define PWM_CHN_ENPWM_Pos         				(0U)
N#define	PWM_CHN_ENPWM_Msk									(0x1L << PWM_CHN_ENPWM_Pos)
N#define PWM_CHN_ENPWM          						PWM_CHN_ENPWM_Msk
N
N#define PWM_CHN_ENLEDPWM_Pos         				(1U)
N#define	PWM_CHN_ENLEDPWM_Msk									(0x1L << PWM_CHN_ENLEDPWM_Pos)
N#define PWM_CHN_ENLEDPWM          						PWM_CHN_ENLEDPWM_Msk
N
N#define PWM_CHN_ENPWM2_Pos         				(2U)
N#define	PWM_CHN_ENPWM2_Msk									(0x1L << PWM_CHN_ENPWM2_Pos)
N#define PWM_CHN_ENPWM2          						PWM_CHN_ENPWM2_Msk
N
N#define PWM_CHN_ENPWM3_Pos         				(3U)
N#define	PWM_CHN_ENPWM3_Msk									(0x1L << PWM_CHN_ENPWM3_Pos)
N#define PWM_CHN_ENPWM3          						PWM_CHN_ENPWM3_Msk
N
N#define PWM_CHN_ENPWM4_Pos         				(4U)
N#define	PWM_CHN_ENPWM4_Msk									(0x1L << PWM_CHN_ENPWM4_Pos)
N#define PWM_CHN_ENPWM4          						PWM_CHN_ENPWM4_Msk
N
N#define PWM_CHN_ENPWM5_Pos         				(5U)
N#define	PWM_CHN_ENPWM5_Msk									(0x1L << PWM_CHN_ENPWM5_Pos)
N#define PWM_CHN_ENPWM5          						PWM_CHN_ENPWM5_Msk
N
N#define PWM_CHN_ENPWM6_Pos         				(6U)
N#define	PWM_CHN_ENPWM6_Msk									(0x1L << PWM_CHN_ENPWM6_Pos)
N#define PWM_CHN_ENPWM6          						PWM_CHN_ENPWM6_Msk
N
N#define PWM_CHN_ENPWM7_Pos         				(7U)
N#define	PWM_CHN_ENPWM7_Msk									(0x1L << PWM_CHN_ENPWM7_Pos)
N#define PWM_CHN_ENPWM7          						PWM_CHN_ENPWM7_Msk
N/********************  Bit definition for PWM_STS register  ********************/
N#define PWM_STS_PWMIF_Pos         					(0U)
N#define	PWM_STS_PWMIF_Msk									(0x1L << PWM_STS_PWMIF_Pos)
N#define PWM_STS_PWMIF         							PWM_STS_PWMIF_Msk
N
N#define PWM_STS_FLTSTA_Pos         				(1U)
N#define	PWM_STS_FLTSTA_Msk									(0x1L << PWM_STS_FLTSTA_Pos)
N#define PWM_STS_FLTSTA         						PWM_STS_FLTSTA_Msk
N/********************  Bit definition for PWM_INV register  ********************/
N#define PWM_INV_INV_Pos         					  (0U)
N#define	PWM_INV_INV_Msk										(0xFL << PWM_INV_INV_Pos)
N#define PWM_INV_INV          							PWM_INV_INV_Msk
N
N#define PWM_INV_INV0_Pos         					(0U)
N#define	PWM_INV_INV0_Msk										(0x1L << PWM_INV_INV0_Pos)
N#define PWM_INV_INV0          							PWM_INV_INV0_Msk
N
N#define PWM_INV_INV1_Pos         					(1U)
N#define	PWM_INV_INV1_Msk										(0x1L << PWM_INV_INV1_Pos)
N#define PWM_INV_INV1          							PWM_INV_INV1_Msk
N
N#define PWM_INV_INV2_Pos         					(2U)
N#define	PWM_INV_INV2_Msk										(0x1L << PWM_INV_INV2_Pos)
N#define PWM_INV_INV2          							PWM_INV_INV2_Msk
N
N#define PWM_INV_INV3_Pos         					(3U)
N#define	PWM_INV_INV3_Msk										(0x1L << PWM_INV_INV3_Pos)
N#define PWM_INV_INV3          							PWM_INV_INV3_Msk
N
N#define PWM_INV_INV4_Pos         					(4U)
N#define	PWM_INV_INV4_Msk										(0x1L << PWM_INV_INV4_Pos)
N#define PWM_INV_INV4          							PWM_INV_INV4_Msk
N
N#define PWM_INV_INV5_Pos         					(5U)
N#define	PWM_INV_INV5_Msk										(0x1L << PWM_INV_INV5_Pos)
N#define PWM_INV_INV5          							PWM_INV_INV5_Msk
N
N#define PWM_INV_INV6_Pos         					(6U)
N#define	PWM_INV_INV6_Msk										(0x1L << PWM_INV_INV6_Pos)
N#define PWM_INV_INV6          							PWM_INV_INV6_Msk
N
N#define PWM_INV_INV7_Pos         					(7U)
N#define	PWM_INV_INV7_Msk										(0x1L << PWM_INV_INV7_Pos)
N#define PWM_INV_INV7          							PWM_INV_INV7_Msk
N/********************  Bit definition for PWM_DFR register  ********************/
N#define PWM_DFR_PDR_Pos         						(0U)
N#define	PWM_DFR_PDR_Msk										(0x0FL << PWM_DFR_PDR_Pos)
N#define PWM_DFR_PDR          							PWM_DFR_PDR_Msk
N
N#define PWM_DFR_PDF_Pos         						(8U)
N#define	PWM_DFR_PDF_Msk										(0x0FL << PWM_DFR_PDF_Pos)
N#define PWM_DFR_PDF          							PWM_DFR_PDF_Msk
N/********************  Bit definition for PWM_FLT register  ********************/
N#define PWM_FLT_FLTDT_Pos         					(0U)
N#define	PWM_FLT_FLTDT_Msk									(0x03L << PWM_FLT_FLTDT_Pos)
N#define PWM_FLT_FLTDT          						PWM_FLT_FLTDT_Msk
N
N#define PWM_FLT_FLTTV_Pos         					(4U)
N#define	PWM_FLT_FLTTV_Msk									(0x1L << PWM_FLT_FLTTV_Pos)
N#define PWM_FLT_FLTTV          						PWM_FLT_FLTTV_Msk
N
N#define PWM_FLT_FLTMD_Pos         					(5U)
N#define	PWM_FLT_FLTMD_Msk									(0x1L << PWM_FLT_FLTMD_Pos)
N#define PWM_FLT_FLTMD          						PWM_FLT_FLTMD_Msk
N
N#define PWM_FLT_FLTEN_Pos         					(7U)
N#define	PWM_FLT_FLTEN_Msk									(0x1L << PWM_FLT_FLTEN_Pos)
N#define PWM_FLT_FLTEN         							PWM_FLT_FLTEN_Msk
N/******************************************************************************/
N/*                                                                            */
N/*                      LEDPWM                 																*/
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for PWM_CON register  ********************/
N#define LEDPWM_CON_PWMCLK_Pos								(0U)
N#define LEDPWM_CON_PWMCLK_Msk								(0xFL << LEDPWM_CON_PWMCLK_Pos)
N#define LEDPWM_CON_PWMCLK										LEDPWM_CON_PWMCLK_Msk
N
N#define LEDPWM_CON_PWMMD0_Pos								(6U)
N#define LEDPWM_CON_PWMMD0_Msk								(0x1L << LEDPWM_CON_PWMMD0_Pos)
N#define LEDPWM_CON_PWMMD0										LEDPWM_CON_PWMMD0_Msk
N
N#define LEDPWM_CON_ENPWM_Pos								(7U)
N#define LEDPWM_CON_ENPWM_Msk								(0x1L << LEDPWM_CON_ENPWM_Pos)
N#define LEDPWM_CON_ENPWM										LEDPWM_CON_ENPWM_Msk
N
N#define LEDPWM_CON_INTEN_Pos								(8U)
N#define LEDPWM_CON_INTEN_Msk								(0x1L << LEDPWM_CON_INTEN_Pos)
N#define LEDPWM_CON_INTEN										LEDPWM_CON_INTEN_Msk
N
N/********************  Bit definition for LEDPWM_STS register  ********************/
N#define LEDPWM_STS_PWMIF_Pos								(0U)
N#define LEDPWM_STS_PWMIF_Msk								(0x1L << LEDPWM_STS_PWMIF_Pos)
N#define LEDPWM_STS_PWMIF										LEDPWM_STS_PWMIF_Msk
N
N/******************************************************************************/
N/*                                                                            */
N/*                      SPI0                 																*/
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for SPI_CON register  ********************/
N#define SPI_CON_MSTR_Pos         					(0U)
N#define	SPI_CON_MSTR_Msk										(0x1L << SPI_CON_MSTR_Pos)
N#define SPI_CON_MSTR          							SPI_CON_MSTR_Msk
N
N#define SPI_CON_SPMD_Pos         					(1U)
N#define	SPI_CON_SPMD_Msk										(0x1L << SPI_CON_SPMD_Pos)
N#define SPI_CON_SPMD          							SPI_CON_SPMD_Msk
N
N#define SPI_CON_DORD_Pos         					(2U)
N#define	SPI_CON_DORD_Msk										(0x1L << SPI_CON_DORD_Pos)
N#define SPI_CON_DORD          							SPI_CON_DORD_Msk
N
N#define SPI_CON_CPHA_Pos         					(3U)
N#define	SPI_CON_CPHA_Msk										(0x1L << SPI_CON_CPHA_Pos)
N#define SPI_CON_CPHA          							SPI_CON_CPHA_Msk
N
N#define SPI_CON_CPOL_Pos         					(4U)
N#define	SPI_CON_CPOL_Msk										(0x1L << SPI_CON_CPOL_Pos)
N#define SPI_CON_CPOL          							SPI_CON_CPOL_Msk
N
N#define SPI_CON_SPEN_Pos         					(7U)
N#define	SPI_CON_SPEN_Msk										(0x1L << SPI_CON_SPEN_Pos)
N#define SPI_CON_SPEN          							SPI_CON_SPEN_Msk
N
N#define SPI_CON_SPR_Pos         						(8U)
N#define	SPI_CON_SPR_Msk										(0x0FL << SPI_CON_SPR_Pos)
N#define SPI_CON_SPR          							SPI_CON_SPR_Msk
N
N#define SPI_CON_SPOS_Pos         					(14U)
N#define	SPI_CON_SPOS_Msk										(0x3L << SPI_CON_SPOS_Pos)
N#define SPI_CON_SPOS          							SPI_CON_SPOS_Msk
N/********************  Bit definition for SPI_STS register  ********************/
N#define SPI_STS_SPIF_Pos         					(0U)
N#define	SPI_STS_SPIF_Msk										(0x1L << SPI_STS_SPIF_Pos)
N#define SPI_STS_SPIF          							SPI_STS_SPIF_Msk
N
N#define SPI_STS_RINEIF_Pos         				(1U)
N#define	SPI_STS_RINEIF_Msk									(0x1L << SPI_STS_RINEIF_Pos)
N#define SPI_STS_RINEIF          						SPI_STS_RINEIF_Msk
N
N#define SPI_STS_TXEIF_Pos         					(2U)
N#define	SPI_STS_TXEIF_Msk									(0x1L << SPI_STS_TXEIF_Pos)
N#define SPI_STS_TXEIF          						SPI_STS_TXEIF_Msk
N
N#define SPI_STS_RXFIF_Pos         					(3U)
N#define	SPI_STS_RXFIF_Msk									(0x1L << SPI_STS_RXFIF_Pos)
N#define SPI_STS_RXFIF          						SPI_STS_RXFIF_Msk
N
N#define SPI_STS_RXHIF_Pos         					(4U)
N#define	SPI_STS_RXHIF_Msk									(0x1L << SPI_STS_RXHIF_Pos)
N#define SPI_STS_RXHIF          						SPI_STS_RXHIF_Msk
N
N#define SPI_STS_TXHIF_Pos         					(5U)
N#define	SPI_STS_TXHIF_Msk										(0x1L << SPI_STS_TXHIF_Pos)
N#define SPI_STS_TXHIF          							SPI_STS_TXHIF_Msk
N
N#define SPI_STS_WCOL_Pos         					(7U)
N#define	SPI_STS_WCOL_Msk										(0x1L << SPI_STS_WCOL_Pos)
N#define SPI_STS_WCOL          							SPI_STS_WCOL_Msk
N/********************  Bit definition for SPI_IDE register  ********************/
N#define SPI_IDE_INTEN_Pos         					(0U)
N#define	SPI_IDE_INTEN_Msk									(0x1L << SPI_IDE_INTEN_Pos)
N#define SPI_IDE_INTEN         							SPI_IDE_INTEN_Msk
N
N#define SPI_IDE_RXNEIE_Pos         				(1U)
N#define	SPI_IDE_RXNEIE_Msk									(0x1L << SPI_IDE_RXNEIE_Pos)
N#define SPI_IDE_RXNEIE         						SPI_IDE_RXNEIE_Msk
N
N#define SPI_IDE_TBIE_Pos         					(2U)
N#define	SPI_IDE_TBIE_Msk										(0x1L << SPI_IDE_TBIE_Pos)
N#define SPI_IDE_TBIE        								SPI_IDE_TBIE_Msk
N
N#define SPI_IDE_RXIE_Pos         					(3U)
N#define	SPI_IDE_RXIE_Msk										(0x1L << SPI_IDE_RXIE_Pos)
N#define SPI_IDE_RXIE        								SPI_IDE_RXIE_Msk
N
N#define SPI_IDE_RXHIE_Pos         					(4U)
N#define	SPI_IDE_RXHIE_Msk									(0x1L << SPI_IDE_RXHIE_Pos)
N#define SPI_IDE_RXHIE        							SPI_IDE_RXHIE_Msk
N
N#define SPI_IDE_TXHIE_Pos         					(5U)
N#define	SPI_IDE_TXHIE_Msk									(0x1L << SPI_IDE_TXHIE_Pos)
N#define SPI_IDE_TXHIE        							SPI_IDE_TXHIE_Msk
N
N#define SPI_IDE_RXDMAEN_Pos         				(6U)
N#define	SPI_IDE_RXDMAEN_Msk								(0x1L << SPI_IDE_RXDMAEN_Pos)
N#define SPI_IDE_RXDMAEN        						SPI_IDE_RXDMAEN_Msk
N
N#define SPI_IDE_TXDMAEN_Pos         				(7U)
N#define	SPI_IDE_TXDMAEN_Msk								(0x1L << SPI_IDE_TXDMAEN_Pos)
N#define SPI_IDE_TXDMAEN        						SPI_IDE_TXDMAEN_Msk
N/******************************************************************************/
N/*                                                                            */
N/*                      TIM                																*/
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for TIM_CON register  ********************/
N#define TIM_CON_CPRL_Pos         						(0U)
N#define	TIM_CON_CPRL_Msk										(0x1L << TIM_CON_CPRL_Pos)
N#define TIM_CON_CPRL         								TIM_CON_CPRL_Msk
N
N#define TIM_CON_CTSEL_Pos         					(1U)
N#define	TIM_CON_CTSEL_Msk										(0x1L << TIM_CON_CTSEL_Pos)
N#define TIM_CON_CTSEL         							TIM_CON_CTSEL_Msk
N
N#define TIM_CON_EXENR_Pos         					(2U)
N#define	TIM_CON_EXENR_Msk										(0x1L << TIM_CON_EXENR_Pos)
N#define TIM_CON_EXENR         							TIM_CON_EXENR_Msk
N
N#define TIM_CON_EXENF_Pos         					(3U)
N#define	TIM_CON_EXENF_Msk										(0x1L << TIM_CON_EXENF_Pos)
N#define TIM_CON_EXENF         							TIM_CON_EXENF_Msk
N
N#define TIM_CON_FSEL_Pos         						(4U)
N#define	TIM_CON_FSEL_Msk										(0x1L << TIM_CON_FSEL_Pos)
N#define TIM_CON_FSEL        								TIM_CON_FSEL_Msk
N
N#define TIM_CON_EXENX_Pos         					(5U)
N#define	TIM_CON_EXENX_Msk										(0x1L << TIM_CON_EXENX_Pos)
N#define TIM_CON_EXENX        								TIM_CON_EXENX_Msk
N
N#define TIM_CON_DEC_Pos         						(6U)
N#define	TIM_CON_DEC_Msk											(0x1L << TIM_CON_DEC_Pos)
N#define TIM_CON_DEC        									TIM_CON_DEC_Msk
N
N#define TIM_CON_TR_Pos         							(7U)
N#define	TIM_CON_TR_Msk											(0x1L << TIM_CON_TR_Pos)
N#define TIM_CON_TR        									TIM_CON_TR_Msk
N
N#define TIM_CON_TIMCLK_Pos         					(8U)
N#define	TIM_CON_TIMCLK_Msk									(0x7L << TIM_CON_TIMCLK_Pos)
N#define TIM_CON_TIMCLK         							TIM_CON_TIMCLK_Msk
N
N#define TIM_CON_INVNB_Pos         					(11U)
N#define	TIM_CON_INVNB_Msk										(0x1L << TIM_CON_INVNB_Pos)
N#define TIM_CON_INVNB         							TIM_CON_INVNB_Msk
N
N#define TIM_CON_INVNA_Pos         					(12U)
N#define	TIM_CON_INVNA_Msk										(0x1L << TIM_CON_INVNA_Pos)
N#define TIM_CON_INVNA         							TIM_CON_INVNA_Msk
N
N#define TIM_CON_EPWMNB_Pos         					(13U)
N#define	TIM_CON_EPWMNB_Msk									(0x1L << TIM_CON_EPWMNB_Pos)
N#define TIM_CON_EPWMNB         							TIM_CON_EPWMNB_Msk
N
N#define TIM_CON_EPWMNA_Pos         					(14U)
N#define	TIM_CON_EPWMNA_Msk									(0x1L << TIM_CON_EPWMNA_Pos)
N#define TIM_CON_EPWMNA         							TIM_CON_EPWMNA_Msk
N
N#define TIM_CON_TXOE_Pos         						(15U)
N#define	TIM_CON_TXOE_Msk										(0x1L << TIM_CON_TXOE_Pos)
N#define TIM_CON_TXOE         								TIM_CON_TXOE_Msk
N
N#define TIM_CON_SPOS_Pos         						(19U)
N#define	TIM_CON_SPOS_Msk										(0x1L << TIM_CON_SPOS_Pos)
N#define TIM_CON_SPOS         								TIM_CON_SPOS_Msk
N/********************  Bit definition for TIM_STS register  ********************/
N#define TIM_STS_TIF_Pos         						(0U)
N#define	TIM_STS_TIF_Msk											(0x1L << TIM_STS_TIF_Pos)
N#define TIM_STS_TIF         								TIM_STS_TIF_Msk
N
N#define TIM_STS_EXIR_Pos         						(1U)
N#define	TIM_STS_EXIR_Msk										(0x1L << TIM_STS_EXIR_Pos)
N#define TIM_STS_EXIR         								TIM_STS_EXIR_Msk
N
N#define TIM_STS_EXIF_Pos         						(2U)
N#define	TIM_STS_EXIF_Msk										(0x1L << TIM_STS_EXIF_Pos)
N#define TIM_STS_EXIF        								TIM_STS_EXIF_Msk
N/********************  Bit definition for TIM_IDE register  ********************/
N#define TIM_IDE_INTEN_Pos         					(0U)
N#define	TIM_IDE_INTEN_Msk										(0x1L << TIM_IDE_INTEN_Pos)
N#define TIM_IDE_INTEN         							TIM_IDE_INTEN_Msk
N
N#define TIM_IDE_TIE_Pos         						(1U)
N#define	TIM_IDE_TIE_Msk											(0x1L << TIM_IDE_TIE_Pos)
N#define TIM_IDE_TIE         								TIM_IDE_TIE_Msk
N
N#define TIM_IDE_EXIRE_Pos         					(2U)
N#define	TIM_IDE_EXIRE_Msk										(0x1L << TIM_IDE_EXIRE_Pos)
N#define TIM_IDE_EXIRE         							TIM_IDE_EXIRE_Msk
N
N#define TIM_IDE_EXIFE_Pos         					(3U)
N#define	TIM_IDE_EXIFE_Msk										(0x1L << TIM_IDE_EXIFE_Pos)
N#define TIM_IDE_EXIFE         							TIM_IDE_EXIFE_Msk
N
N#define TIM_IDE_TIDE_Pos         						(4U)
N#define	TIM_IDE_TIDE_Msk										(0x1L << TIM_IDE_TIDE_Pos)
N#define TIM_IDE_TIDE         								TIM_IDE_TIDE_Msk
N
N#define TIM_IDE_CAPRDE_Pos         					(5)
N#define	TIM_IDE_CAPRDE_Msk									(0x1L << TIM_IDE_CAPRDE_Pos)
N#define TIM_IDE_CAPRDE        							TIM_IDE_CAPRDE_Msk
N
N#define TIM_IDE_CAPFDE_Pos         					(6U)
N#define	TIM_IDE_CAPFDE_Msk									(0x1L << TIM_IDE_CAPFDE_Pos)
N#define TIM_IDE_CAPFDE        							TIM_IDE_CAPFDE_Msk
N
N/******************************************************************************/
N/*                                                                            */
N/*                      TWI               																*/
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for TWI_CON register  ********************/
N#define TWI_CON_STRETCH_Pos         					(0U)
N#define	TWI_CON_STRETCH_Msk										(0x1L << TWI_CON_STRETCH_Pos)
N#define TWI_CON_STRETCH         							TWI_CON_STRETCH_Msk
N
N#define TWI_CON_AA_Pos         								(1U)
N#define	TWI_CON_AA_Msk												(0x1L << TWI_CON_AA_Pos)
N#define TWI_CON_AA         										TWI_CON_AA_Msk
N
N#define TWI_CON_STO_Pos         							(4U)
N#define	TWI_CON_STO_Msk												(0x1L << TWI_CON_STO_Pos)
N#define TWI_CON_STO         									TWI_CON_STO_Msk
N
N#define TWI_CON_STA_Pos         							(5U)
N#define	TWI_CON_STA_Msk												(0x1L << TWI_CON_STA_Pos)
N#define TWI_CON_STA         									TWI_CON_STA_Msk
N
N#define TWI_CON_TWEN_Pos         							(7U)
N#define	TWI_CON_TWEN_Msk											(0x1L << TWI_CON_TWEN_Pos)
N#define TWI_CON_TWEN         									TWI_CON_TWEN_Msk
N
N#define TWI_CON_TWCK_Pos         							(8U)
N#define	TWI_CON_TWCK_Msk											(0x0FL << TWI_CON_TWCK_Pos)
N#define TWI_CON_TWCK         									TWI_CON_TWCK_Msk
N
N#define TWI_CON_SPOS_Pos         							(14U)
N#define	TWI_CON_SPOS_Msk											(0x3L << TWI_CON_SPOS_Pos)
N#define TWI_CON_SPOS         									TWI_CON_SPOS_Msk
N/********************  Bit definition for TWI_STS register  ********************/
N#define TWI_STS_TWIF_Pos         							(0U)
N#define	TWI_STS_TWIF_Msk											(0x1L << TWI_STS_TWIF_Pos)
N#define TWI_STS_TWIF         									TWI_STS_TWIF_Msk
N
N#define TWI_STS_TXERXE_Pos         						(1U)
N#define	TWI_STS_TXERXE_Msk										(0x1L << TWI_STS_TXERXE_Pos)
N#define TWI_STS_TXERXE         								TWI_STS_TXERXE_Msk
N
N#define TWI_STS_GCA_Pos         							(2U)
N#define	TWI_STS_GCA_Msk												(0x1L << TWI_STS_GCA_Pos)
N#define TWI_STS_GCA         									TWI_STS_GCA_Msk
N
N#define TWI_STS_MSTR_Pos         							(3U)
N#define	TWI_STS_MSTR_Msk											(0x1L << TWI_STS_MSTR_Pos)
N#define TWI_STS_MSTR         									TWI_STS_MSTR_Msk
N
N#define TWI_STS_STATE_Pos         						(8U)
N#define	TWI_STS_STATE_Msk											(0x7L << TWI_STS_STATE_Pos)
N#define TWI_STS_STATE         								TWI_STS_STATE_Msk
N
N#define TWI_STS_NBYTES_Pos         						(16U)
N#define	TWI_STS_NBYTES_Msk										(0xFFL << TWI_STS_NBYTES_Pos)
N#define TWI_STS_NBYTES         								TWI_STS_NBYTES_Msk
N/********************  Bit definition for TWI_ADD register  ********************/
N#define TWI_ADD_GC_Pos         							  (0U)
N#define	TWI_ADD_GC_Msk											  (0x1L << TWI_ADD_GC_Pos)
N#define TWI_ADD_GC         									  TWI_ADD_GC_Msk
N
N#define TWI_ADD_TWA_Pos         						  (1U)
N#define	TWI_ADD_TWA_Msk										    (0x7FL << TWI_ADD_TWA_Pos)
N#define TWI_ADD_TWA         								  TWI_ADD_TWA_Msk
N/********************  Bit definition for TWI_IDE register  ********************/
N#define TWI_IDE_INTEN_Pos         						(0U)
N#define	TWI_IDE_INTEN_Msk											(0x1L << TWI_IDE_INTEN_Pos)
N#define TWI_IDE_INTEN         								TWI_IDE_INTEN_Msk
N
N#define TWI_IDE_RXDMAEN_Pos         					(6U)
N#define	TWI_IDE_RXDMAEN_Msk										(0x1L << TWI_IDE_RXDMAEN_Pos)
N#define TWI_IDE_RXDMAEN         							TWI_IDE_RXDMAEN_Msk
N
N#define TWI_IDE_TXDMAEN_Pos         					(7U)
N#define	TWI_IDE_TXDMAEN_Msk										(0x1L << TWI_IDE_TXDMAEN_Pos)
N#define TWI_IDE_TXDMAEN        								TWI_IDE_TXDMAEN_Msk
N
N/******************************************************************************/
N/*                                                                            */
N/*                      UART               																*/
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for UART_CON register  ********************/
N#define UART_CON_SM01_Pos         					(0U)
N#define	UART_CON_SM01_Msk										(0x3L << UART_CON_SM01_Pos)
N#define UART_CON_SM01         							UART_CON_SM01_Msk
N
N#define UART_CON_SM2_Pos         						(2U)
N#define	UART_CON_SM2_Msk										(0x1L << UART_CON_SM2_Pos)
N#define UART_CON_SM2         								UART_CON_SM2_Msk
N
N#define UART_CON_BTKR_Pos         					(3U)
N#define	UART_CON_BTKR_Msk										(0x1L << UART_CON_BTKR_Pos)
N#define UART_CON_BTKR         							UART_CON_BTKR_Msk
N
N#define UART_CON_PERSCALER_Pos         			(4U)
N#define	UART_CON_PERSCALER_Msk							(0x1L << UART_CON_PERSCALER_Pos)
N#define UART_CON_PERSCALER         					UART_CON_PERSCALER_Msk
N
N
N#define UART_CON_RXEN_Pos         					(6U)
N#define	UART_CON_RXEN_Msk										(0x1L << UART_CON_RXEN_Pos)
N#define UART_CON_RXEN         							UART_CON_RXEN_Msk
N
N#define UART_CON_TXEN_Pos         					(7U)
N#define	UART_CON_TXEN_Msk										(0x1L << UART_CON_TXEN_Pos)
N#define UART_CON_TXEN         							UART_CON_TXEN_Msk
N
N#define UART_CON_LBDL_Pos         					(11U)
N#define	UART_CON_LBDL_Msk										(0x1L << UART_CON_LBDL_Pos)
N#define UART_CON_LBDL         							UART_CON_LBDL_Msk
N
N#define UART_CON_SPOS_Pos         					(14U)
N#define	UART_CON_SPOS_Msk										(0x3L << UART_CON_SPOS_Pos)
N#define UART_CON_SPOS         							UART_CON_SPOS_Msk
N
N/********************  Bit definition for UART_STS register  ********************/
N#define UART_STS_RXIF_Pos         					(0U)
N#define	UART_STS_RXIF_Msk										(0x1L << UART_STS_RXIF_Pos)
N#define UART_STS_RXIF         							UART_STS_RXIF_Msk
N
N#define UART_STS_TXIF_Pos         					(1U)
N#define	UART_STS_TXIF_Msk										(0x1L << UART_STS_TXIF_Pos)
N#define UART_STS_TXIF         							UART_STS_TXIF_Msk
N
N#define UART_STS_BKIF_Pos         					(3U)
N#define	UART_STS_BKIF_Msk										(0x1L << UART_STS_BKIF_Pos)
N#define UART_STS_BKIF         							UART_STS_BKIF_Msk
N
N#define UART_STS_WKIF_Pos         					(4U)
N#define	UART_STS_WKIF_Msk										(0x1L << UART_STS_WKIF_Pos)
N#define UART_STS_WKIF         							UART_STS_WKIF_Msk
N/********************  Bit definition for UART_IDE register  ********************/
N#define UART_IDE_INTEN_Pos         					(0U)
N#define	UART_IDE_INTEN_Msk									(0x1L << UART_IDE_INTEN_Pos)
N#define UART_IDE_INTEN         							UART_IDE_INTEN_Msk
N
N#define UART_IDE_RXIE_Pos         					(1U)
N#define	UART_IDE_RXIE_Msk										(0x1L << UART_IDE_RXIE_Pos)
N#define UART_IDE_RXIE         							UART_IDE_RXIE_Msk
N
N#define UART_IDE_TXIE_Pos         					(2U)
N#define	UART_IDE_TXIE_Msk										(0x1L << UART_IDE_TXIE_Pos)
N#define UART_IDE_TXIE         							UART_IDE_TXIE_Msk
N
N#define UART_IDE_BKIE_Pos         					(3U)
N#define	UART_IDE_BKIE_Msk										(0x1L << UART_IDE_BKIE_Pos)
N#define UART_IDE_BKIE         							UART_IDE_BKIE_Msk
N
N#define UART_IDE_WKIE_Pos         					(4U)
N#define	UART_IDE_WKIE_Msk										(0x1L << UART_IDE_WKIE_Pos)
N#define UART_IDE_WKIE         							UART_IDE_WKIE_Msk
N
N#define UART_IDE_RXDMAEN_Pos         				(6U)
N#define	UART_IDE_RXDMAEN_Msk								(0x1L << UART_IDE_RXDMAEN_Pos)
N#define UART_IDE_RXDMAEN         						UART_IDE_RXDMAEN_Msk
N
N#define UART_IDE_TXDMAEN_Pos         				(7U)
N#define	UART_IDE_TXDMAEN_Msk								(0x1L << UART_IDE_TXDMAEN_Pos)
N#define UART_IDE_TXDMAEN         						UART_IDE_TXDMAEN_Msk
N
N/******************************************************************************/
N/*                                                                            */
N/*                      WDT               																		*/
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for WDT_CON register  ********************/
N#define WDT_CON_CLRWDT_Pos         					(0U)
N#define	WDT_CON_CLRWDT_Msk									(0x1L << WDT_CON_CLRWDT_Pos)
N#define WDT_CON_CLRWDT         							WDT_CON_CLRWDT_Msk
N
N/********************  Bit definition for WDT_CFG register  ********************/
N#define WDT_CFG_WDTCKS_Pos         					(0U)
N#define	WDT_CFG_WDTCKS_Msk									(0x7L << WDT_CFG_WDTCKS_Pos)
N#define WDT_CFG_WDTCKS         							WDT_CFG_WDTCKS_Msk
N
N#define SC32F10xSx_NIO_Init() {*(uint32_t*)(GPIOA_BIT_BASE+0X00000020)|= 0X00000006;\
N                               *(uint32_t*)(GPIOB_BIT_BASE+0X00000020)|= 0X00009000;}
X#define SC32F10xSx_NIO_Init() {*(uint32_t*)(GPIOA_BIT_BASE+0X00000020)|= 0X00000006;                               *(uint32_t*)(GPIOB_BIT_BASE+0X00000020)|= 0X00009000;}
N
N#define SC32F10xKx_NIO_Init() {*(uint32_t*)(GPIOA_BIT_BASE+0X00000020)|= 0X0000003E;\
N	                             *(uint32_t*)(GPIOB_BIT_BASE+0X00000020)|= 0X000090F4;\
N	                             *(uint32_t*)(GPIOC_BIT_BASE+0X00000020)|= 0X00002032;} 
X#define SC32F10xKx_NIO_Init() {*(uint32_t*)(GPIOA_BIT_BASE+0X00000020)|= 0X0000003E;	                             *(uint32_t*)(GPIOB_BIT_BASE+0X00000020)|= 0X000090F4;	                             *(uint32_t*)(GPIOC_BIT_BASE+0X00000020)|= 0X00002032;} 
N	
N#define SC32F10xGx_NIO_Init() {*(uint32_t*)(GPIOA_BIT_BASE+0X00000020)|= 0X0000003F;\
N	                             *(uint32_t*)(GPIOB_BIT_BASE+0X00000020)|= 0X000091F4;\
N	                             *(uint32_t*)(GPIOC_BIT_BASE+0X00000020)|= 0X00003033;} 
X#define SC32F10xGx_NIO_Init() {*(uint32_t*)(GPIOA_BIT_BASE+0X00000020)|= 0X0000003F;	                             *(uint32_t*)(GPIOB_BIT_BASE+0X00000020)|= 0X000091F4;	                             *(uint32_t*)(GPIOC_BIT_BASE+0X00000020)|= 0X00003033;} 
N
N/** @addtogroup Exported_macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/**
N * @}
N */
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /* sc32f10xx_H */
N
N/**
N  * @}
N  */
N
N/**
N* @}
N*/
N
N/************************ (C) COPYRIGHT SIN ONE CHIP *****END OF FILE****/
L 56 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx.h" 2
N#elif defined(SC32f11xx)
S  #include "SC32f11xx.h"
S#elif defined(SC32f12xx)
S  #include "SC32f12xx.h"
S#elif defined(SC32f15xx)
S  #include "sc32f15Gx.h"
S#else
S #error "Please select first the target SC32F1xxx device used in your application (in SC32F1xxx.h file)"
N#endif
N
N
N
N#ifdef __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /* SC32F1xxx_H */
N
N/**
N  * @}
N  */
N
N/**
N* @}
N*/
N
L 37 "..\FWLib\SC32F1XXX_Lib\inc\sc32f1xxx_gpio.h" 2
N
N/** @addtogroup sc32f1xxx_StdPeriph_Driver
N * @{
N */
N
N/** @addtogroup GPIO
N * @{
N */
N
N/** @defgroup GPIO_Enumerations GPIO Enumerations
N * @{
N */
N
N/** @brief GPIO_Mode GPIO Mode
N * @{
N */
Ntypedef enum
N{
N    GPIO_Mode_IN_HI = 0x00,  /*!< GPIO High-resistance Input Mode   */
N    GPIO_Mode_IN_PU = 0x01,  /*!< GPIO Pull-up Input Mode  */
N    GPIO_Mode_OUT_PP = 0x02  /*!< GPIO Strong push-pull Output Mode   */
N} GPIO_Mode_TypeDef;
N
N#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_Mode_IN_HI) ||\
N														((MODE) == GPIO_Mode_IN_PU) ||\
N                            ((MODE) == GPIO_Mode_OUT_PP))
X#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_Mode_IN_HI) ||														((MODE) == GPIO_Mode_IN_PU) ||                            ((MODE) == GPIO_Mode_OUT_PP))
N/**
N * @}
N */
N
N/** @brief GPIO_DriveLevel GPIO DriveLevel
N * @{
N */
Ntypedef enum
N{
N    GPIO_DriveLevel_0 = 0x00, /*!< I/O output Drive: Level 0(Max) */
N    GPIO_DriveLevel_1 = 0x01, /*!< I/O output Drive: Level 1 */
N    GPIO_DriveLevel_2 = 0x02, /*!< I/O output Drive: Level 2 */
N    GPIO_DriveLevel_3 = 0x03  /*!< I/O output Drive: Level 3 */
N} GPIO_DriveLevel_TypeDef;
N
N#define IS_GPIO_DriveLevel(LEVEL)	(((LEVEL) == GPIO_DriveLevel_0) ||\
N																	((LEVEL) == GPIO_DriveLevel_1) ||\
N																	((LEVEL) == GPIO_DriveLevel_2) ||\
N																	((LEVEL) == GPIO_DriveLevel_3))
X#define IS_GPIO_DriveLevel(LEVEL)	(((LEVEL) == GPIO_DriveLevel_0) ||																	((LEVEL) == GPIO_DriveLevel_1) ||																	((LEVEL) == GPIO_DriveLevel_2) ||																	((LEVEL) == GPIO_DriveLevel_3))
N
N/**
N * @}
N */
N
N/** @brief   BitAction
N * @{
N */
Ntypedef enum
N{
N    Bit_RESET = 0,
N    Bit_SET
N} BitAction;
N
N#define IS_GPIO_BITACTION(STATE) (((STATE) == Bit_RESET) || ((STATE) == Bit_SET))
N
N/**
N * @}
N */
N#if defined(SC32f10xx) || defined(SC32f12xx)|| defined(SC32f15xx)
X#if 1L || 0L|| 0L
N#define IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) || \
N                                    ((PERIPH) == GPIOB) || \
N                                    ((PERIPH) == GPIOC))
X#define IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) ||                                     ((PERIPH) == GPIOB) ||                                     ((PERIPH) == GPIOC))
N#elif defined(SC31f11xx)
S#define IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) || \
S                                    ((PERIPH) == GPIOB) || \
S                                    ((PERIPH) == GPIOC) || \
S                                    ((PERIPH) == GPIOD))
X#define IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) ||                                     ((PERIPH) == GPIOB) ||                                     ((PERIPH) == GPIOC) ||                                     ((PERIPH) == GPIOD))
N#endif
N/** @brief GPIO_Pin GPIO Pins enumeration
N * @{
N */
Ntypedef enum
N{
N    GPIO_Pin_0 = ( ( uint16_t ) 0x0001 ), /*!< Pin 0 selected    */
N    GPIO_Pin_1 = ( ( uint16_t ) 0x0002 ), /*!< Pin 1 selected    */
N    GPIO_Pin_2 = ( ( uint16_t ) 0x0004 ), /*!< Pin 2 selected    */
N    GPIO_Pin_3 = ( ( uint16_t ) 0x0008 ), /*!< Pin 3 selected    */
N    GPIO_Pin_4 = ( ( uint16_t ) 0x0010 ), /*!< Pin 4 selected    */
N    GPIO_Pin_5 = ( ( uint16_t ) 0x0020 ), /*!< Pin 5 selected    */
N    GPIO_Pin_6 = ( ( uint16_t ) 0x0040 ), /*!< Pin 6 selected    */
N    GPIO_Pin_7 = ( ( uint16_t ) 0x0080 ), /*!< Pin 7 selected    */
N    GPIO_Pin_8 = ( ( uint16_t ) 0x0100 ), /*!< Pin 8 selected    */
N    GPIO_Pin_9 = ( ( uint16_t ) 0x0200 ), /*!< Pin 9 selected    */
N    GPIO_Pin_10 = ( ( uint16_t ) 0x0400 ), /*!< Pin 10 selected    */
N    GPIO_Pin_11 = ( ( uint16_t ) 0x0800 ), /*!< Pin 11 selected    */
N    GPIO_Pin_12 = ( ( uint16_t ) 0x1000 ), /*!< Pin 12 selected    */
N    GPIO_Pin_13 = ( ( uint16_t ) 0x2000 ), /*!< Pin 13 selected    */
N    GPIO_Pin_14 = ( ( uint16_t ) 0x4000 ), /*!< Pin 14 selected    */
N    GPIO_Pin_15 = ( ( uint16_t ) 0x8000 ), /*!< Pin 15 selected    */
N    GPIO_PIN_LNIB = ( ( uint16_t ) 0x00FF ), /*!< Pin Low 8 Bits selected			*/
N    GPIO_PIN_HNIB = ( ( uint16_t ) 0xFF00 ), /*!< Pin High 8 Bits selected		*/
N    GPIO_PIN_All = ( ( uint16_t ) 0xFFFF ), /* All pins selected */
N} GPIO_Pin_TypeDef;
N
N
N
N#define GPIO_PIN_MASK 0x0000FFFFU /* PIN mask for assert test */
N
N#define IS_GPIO_PIN(PIN) ((((PIN)&GPIO_PIN_MASK) != 0x00U) && (((PIN) & ~GPIO_PIN_MASK) == 0x00U))
N
N#define IS_GET_GPIO_PIN(PIN) (((PIN) == GPIO_Pin_0) ||  \
N                              ((PIN) == GPIO_Pin_1) ||  \
N                              ((PIN) == GPIO_Pin_2) ||  \
N                              ((PIN) == GPIO_Pin_3) ||  \
N                              ((PIN) == GPIO_Pin_4) ||  \
N                              ((PIN) == GPIO_Pin_5) ||  \
N                              ((PIN) == GPIO_Pin_6) ||  \
N                              ((PIN) == GPIO_Pin_7) ||  \
N                              ((PIN) == GPIO_Pin_8) ||  \
N                              ((PIN) == GPIO_Pin_9) ||  \
N                              ((PIN) == GPIO_Pin_10) || \
N                              ((PIN) == GPIO_Pin_11) || \
N                              ((PIN) == GPIO_Pin_12) || \
N                              ((PIN) == GPIO_Pin_13) || \
N                              ((PIN) == GPIO_Pin_14) || \
N                              ((PIN) == GPIO_Pin_15))
X#define IS_GET_GPIO_PIN(PIN) (((PIN) == GPIO_Pin_0) ||                                ((PIN) == GPIO_Pin_1) ||                                ((PIN) == GPIO_Pin_2) ||                                ((PIN) == GPIO_Pin_3) ||                                ((PIN) == GPIO_Pin_4) ||                                ((PIN) == GPIO_Pin_5) ||                                ((PIN) == GPIO_Pin_6) ||                                ((PIN) == GPIO_Pin_7) ||                                ((PIN) == GPIO_Pin_8) ||                                ((PIN) == GPIO_Pin_9) ||                                ((PIN) == GPIO_Pin_10) ||                               ((PIN) == GPIO_Pin_11) ||                               ((PIN) == GPIO_Pin_12) ||                               ((PIN) == GPIO_Pin_13) ||                               ((PIN) == GPIO_Pin_14) ||                               ((PIN) == GPIO_Pin_15))
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N/* End of Enumerations --------------------------------------------------*/
N
N/** @defgroup GPIO_Struct GPIO Struct
N * @{
N */
N
N/** @brief GPIO_InitTypeDef  GPIO structure definition
N * @{
N */
Ntypedef struct
N{
N    uint16_t GPIO_Pin;          /*!< Specifies the GPIO pins to be configured.
N                                     This parameter can be any value of @ref GPIO_Pin_TypeDef */
N    uint16_t GPIO_Mode; /*!< Specifies the operating mode for the selected pins.
N                                     This parameter can be a value of @ref GPIO_Mode_TypeDef   */
N    uint16_t GPIO_DriveLevel; /*!< Specifies the operating Drive Level for the selected pins.
N                                     This parameter can be a value of @ref GPIO_DriveLevel_TypeDef   */
N} GPIO_InitTypeDef;
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N/* End of Struct --------------------------------------------------*/
N
N/** @addtogroup GPIO_Exported_Functions
N * @{
N */
N
N/* Initialization and de-initialization functions *****************************/
Nvoid GPIO_DeInit ( GPIO_TypeDef* GPIOx );
Nvoid GPIO_Init ( GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct );
Nvoid GPIO_SetDriveLevel ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_DriveLevel_TypeDef GPIO_DriveLevel );
N
N/* IO operation functions *****************************************************/
Nuint16_t GPIO_ReadData ( GPIO_TypeDef* GPIOx );
NBitAction GPIO_ReadDataBit ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin );
Nvoid GPIO_SetBits ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin );
Nvoid GPIO_ResetBits ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin );
Nvoid GPIO_Write ( GPIO_TypeDef* GPIOx, uint16_t PortVal );
Nvoid GPIO_WriteBit ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal );
Nvoid GPIO_TogglePins ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin );
N
N/**
N * @}
N */
N/* End of functions --------------------------------------------------*/
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* _SC32F1XXX_GPIO_H */
N
N
L 27 "..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_gpio.c" 2
N#include "sc32.h"
L 1 "..\FWLib\SC32F1XXX_Lib\inc\sc32.h" 1
N/**
N******************************************************************************
N* @file    SC32.h
N* @author  SOC AE Team
N* @version V1.6
N* @date    04-09-2024
N* @brief
N*
N******************************************************************************
N* @attention
N*
N*1.This software is supplied by SinOne Microelectronics Co.,Ltd. and is only 
N*intended for use with SinOne products. No other uses are authorized. This 
N*software is owned by SinOne Microelectronics Co.,Ltd. and is protected under 
N*all applicable laws, including copyright laws. 
N*2.The software which is for guidance only aims at providing customers with 
N*coding information regarding their products in order for them to save time. 
N*As a result, SinOne shall not be held liable for any direct, indirect or 
N*consequential damages with respect to any claims arising from the content of 
N*such software and/or the use made by customers of the coding information 
N*contained herein in connection with their products.
N*
N*  COPYRIGHT 2024 SinOne Microelectronics
N*/
N/** @addtogroup CMSIS_Device
N* @{
N*/
N
N/** @addtogroup sc32
N  * @{
N  */
N
N#ifndef SC32_H
N#define SC32_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#include <stdint.h>
N
N/* Exported macro ------------------------------------------------------------*/
N#ifdef  USE_FULL_ASSERT
S/**
S  * @brief  The assert_param macro is used for function's parameters check.
S  * @param  expr: If expr is false, it calls assert_failed function
S  *         which reports the name of the source file and the source
S  *         line number of the call that failed.
S  *         If expr is true, it returns no value.
S  * @retval None
S  */
S#define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
S/* Exported functions ------------------------------------------------------- */
Svoid assert_failed(uint8_t* file, uint32_t line);
N#else
N#define assert_param(expr) ((void)0U)
N#endif /* USE_FULL_ASSERT */
N
N
N#ifdef __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /* SC32_H */
N
N/**
N  * @}
N  */
N
N/**
N* @}
N*/
N
N/************************ (C) COPYRIGHT SIN ONE CHIP *****END OF FILE****/
L 28 "..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_gpio.c" 2
N
N/** @defgroup GPIO_Group1 Initialization and Configuration
N *  @brief   Initialization and Configuration
N *
N@verbatim
N ===============================================================================
N                    ##### Initialization and Configuration #####
N ===============================================================================
N
N@endverbatim
N  * @{
N  */
N
N/**
N * @brief  Deinitializes the GPIOx peripheral registers to their default reset
N *         values.
N * @param  GPIOx[in]: where x can be to select the GPIO peripheral.
N *                SC32f10xx Selection range(GPIOA - GPIOC)
N *                SC32f11xx Selection range(GPIOA - GPIOD)
N *                SC32f12xx Selection range(GPIOA - GPIOC)
N *               - GPIOA: select the GPIOA peripheral
N *               - GPIOB: select the GPIOB peripheral
N *               - GPIOC: select the GPIOC peripheral
N *               - GPIOD: select the GPIOD peripheral
N * @retval None
N */
Nvoid GPIO_DeInit ( GPIO_TypeDef* GPIOx )
N{
N    /* Check the parameters */
N    assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
X    ((void)0U);
N
N    /* Deinitializes the GPIOx PXCON register to their default reset values. */
N    GPIOx->PXCON &= ( uint32_t ) ( ~GPIO_PIN_All );
N    /* Deinitializes the GPIOx PXPH register to their default reset values. */
N    GPIOx->PXPH &= ( uint32_t ) ( ~GPIO_PIN_All );
N    /* Deinitializes the GPIOx PIN register to their default reset values. */
N    GPIOx->PIN &= ( uint32_t ) ( ~GPIO_PIN_All );
N    /* Deinitializes the GPIOx PXLEV register to their default reset values. */
N    GPIOx->PXLEV &= ( uint32_t ) 0x00000000;
N}
N
N/**
N * @brief  Initializes the peripheral GPIOx register with the parameters specified in GPIO_InitStruct.
N * @param  GPIOx[in]: where x can be to select the GPIO peripheral.
N *                SC32f10xx Selection range(GPIOA - GPIOC)
N *                SC32f11xx Selection range(GPIOA - GPIOD)
N *                SC32f12xx Selection range(GPIOA - GPIOC)
N *                SC32f15xx Selection range(GPIOA - GPIOC)
N *               - GPIOA: select the GPIOA peripheral
N *               - GPIOB: select the GPIOB peripheral
N *               - GPIOC: select the GPIOC peripheral
N *               - GPIOD: select the GPIOD peripheral
N * @param  GPIO_InitStruct[out]: Pointer to structure GPIO_InitTypeDef, to be initialized.
N * @retval None
N */
Nvoid GPIO_Init ( GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct )
N{
N    uint32_t tmppin, tmppos, tmpreg;
N
N    /* Check the parameters */
N    assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
X    ((void)0U);
N    assert_param ( IS_GPIO_PIN ( GPIO_InitStruct->GPIO_Pin ) );
X    ((void)0U);
N    assert_param ( IS_GPIO_MODE ( GPIO_InitStruct->GPIO_Mode ) );
X    ((void)0U);
N
N    if ( GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT_PP )
N    {
N        /* Configure Pins to High-resistance output mode */
N        GPIOx->PXCON |= ( uint32_t ) GPIO_InitStruct->GPIO_Pin;
N    }
N    else if ( GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IN_PU )
N    {
N        /* Configure Pins to Pull-up input mode */
N        GPIOx->PXCON &= ( uint32_t ) ( ~GPIO_InitStruct->GPIO_Pin );
N        GPIOx->PXPH |= ( uint32_t ) GPIO_InitStruct->GPIO_Pin;
N    }
N    else if ( GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IN_HI )
N    {
N        /* Configure Pin to High-resistance intput mode */
N        GPIOx->PXCON &= ( uint32_t ) ( ~GPIO_InitStruct->GPIO_Pin );
N        GPIOx->PXPH &= ( uint32_t ) ( ~GPIO_InitStruct->GPIO_Pin );
N    }
N
N    /* Get GPIOx PXLEV value */
N    tmpreg = GPIOx->PXLEV;
N    /* Query the Pins that needs to be manipulated */
N    for ( tmppos = 0; tmppos < 16; tmppos++ )
N    {
N        tmppin = ( uint32_t ) ( 0x01 << tmppos );
N        if ( ( tmppin & GPIO_InitStruct->GPIO_Pin ) != RESET )
N        {
N            /* Clear the LEVx bits */
N            tmpreg &= ( uint32_t ) ~ ( GPIO_DriveLevel_3 << ( tmppos * 2 ) );
N            /* Set LEVx bits according to Drive Level value */
N            tmpreg |= ( uint32_t ) ( GPIO_InitStruct->GPIO_DriveLevel << ( tmppos * 2 ) );
N        }
N    }
N    /* Store GPIOx PXLEV the new value */
N    GPIOx->PXLEV = tmpreg;
N}
N
N/**
N * @brief  Sets the I/O driver level
N * @param  GPIOx[in]: where x can be to select the GPIO peripheral.
N *                SC32f10xx Selection range(GPIOA - GPIOC)
N *                SC32f11xx Selection range(GPIOA - GPIOD)
N *                SC32f12xx Selection range(GPIOA - GPIOC)
N *                SC32f15xx Selection range(GPIOA - GPIOC)
N *               - GPIOA: select the GPIOA peripheral
N *               - GPIOB: select the GPIOB peripheral
N *               - GPIOC: select the GPIOC peripheral
N *               - GPIOD: select the GPIOD peripheral
N * @param  GPIO_Pin[in]:specifies the port bit to be read.
N *                   - GPIO_Pin_0:Pin 0 selected
N *                   - GPIO_Pin_1:Pin 1 selected
N *                   - GPIO_Pin_2:Pin 2 selected
N *                   - GPIO_Pin_3:Pin 3 selected
N *                   - GPIO_Pin_4:Pin 4 selected
N *                   - GPIO_Pin_5:Pin 5 selected
N *                   - GPIO_Pin_6:Pin 6 selected
N *                   - GPIO_Pin_7:Pin 7 selected
N *                   - GPIO_Pin_8:Pin 8 selected
N *                   - GPIO_Pin_9:Pin 9 selected
N *                   - GPIO_Pin_10:Pin 10 selected
N *                   - GPIO_Pin_11:Pin 11 selected
N *                   - GPIO_Pin_12:Pin 12 selected
N *                   - GPIO_Pin_13:Pin 13 selected
N *                   - GPIO_Pin_14:Pin 14 selected
N *                   - GPIO_Pin_15:Pin 15 selected
N *                   - GPIO_PIN_LNIB:Pin Low 8 Bits selected
N *                   - GPIO_PIN_HNIB:Pin High 8 Bits selected
N *                   - GPIO_PIN_All:All pins selected
N * @param  GPIO_DriveLevel[in]: specifies the operating Drive Level for the selected pins.
N *                  - GPIO_DriveLevel_0:I/O output Drive: Level 0(Max)
N *                  - GPIO_DriveLevel_1:I/O output Drive: Level 1
N *                  - GPIO_DriveLevel_2:I/O output Drive: Level 2
N *                  - GPIO_DriveLevel_3:I/O output Drive: Level 3
N * @retval None
N */
Nvoid GPIO_SetDriveLevel ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_DriveLevel_TypeDef GPIO_DriveLevel )
N{
N    uint32_t tmppin, tmppos, tmpreg;
N    /* Get GPIOx PXLEV value */
N    tmpreg = GPIOx->PXLEV;
N    /* Query the Pins that needs to be manipulated */
N    for ( tmppos = 0; tmppos < 16; tmppos++ )
N    {
N        tmppin = ( uint32_t ) ( 0x01 << tmppos );
N        if ( ( tmppin & GPIO_Pin ) != RESET )
N        {
N            /* Clear the LEVx bits */
N            tmpreg &= ( uint32_t ) ~ ( GPIO_DriveLevel_3 << ( tmppos * 2 ) );
N            /* Set LEVx bits according to Drive Level value */
N            tmpreg |= ( uint32_t ) ( GPIO_DriveLevel << ( tmppos * 2 ) );
N        }
N    }
N    /* Store GPIOx PXLEV the new value */
N    GPIOx->PXLEV = tmpreg;
N
N}
N
N/**
N * @}
N */
N/* End of PWM_Group1.	*/
N
N/** @defgroup GPIO_Group2 IO operation functions
N  *  @brief   GPIO Read and Write
N  *
N@verbatim
N ===============================================================================
N                       ##### IO operation functions #####
N ===============================================================================
N
N@endverbatim
N  * @{
N  */
N
N/**
N * @brief  Reads the specified input port pin.
N * @param  GPIOx[in]: where x can be to select the GPIO peripheral.
N *                SC32f10xx Selection range(GPIOA - GPIOC)
N *                SC32f11xx Selection range(GPIOA - GPIOD)
N *                SC32f12xx Selection range(GPIOA - GPIOC)
N *                SC32f15xx Selection range(GPIOA - GPIOC)
N *               - GPIOA: select the GPIOA peripheral
N *               - GPIOB: select the GPIOB peripheral
N *               - GPIOC: select the GPIOC peripheral
N *               - GPIOD: select the GPIOD peripheral
N * @retval The input port pin value.
N *                   - GPIO_Pin_0:Pin 0 selected
N *                   - GPIO_Pin_1:Pin 1 selected
N *                   - GPIO_Pin_2:Pin 2 selected
N *                   - GPIO_Pin_3:Pin 3 selected
N *                   - GPIO_Pin_4:Pin 4 selected
N *                   - GPIO_Pin_5:Pin 5 selected
N *                   - GPIO_Pin_6:Pin 6 selected
N *                   - GPIO_Pin_7:Pin 7 selected
N *                   - GPIO_Pin_8:Pin 8 selected
N *                   - GPIO_Pin_9:Pin 9 selected
N *                   - GPIO_Pin_10:Pin 10 selected
N *                   - GPIO_Pin_11:Pin 11 selected
N *                   - GPIO_Pin_12:Pin 12 selected
N *                   - GPIO_Pin_13:Pin 13 selected
N *                   - GPIO_Pin_14:Pin 14 selected
N *                   - GPIO_Pin_15:Pin 15 selected
N *                   - GPIO_PIN_LNIB:Pin Low 8 Bits selected
N *                   - GPIO_PIN_HNIB:Pin High 8 Bits selected
N *                   - GPIO_PIN_All:All pins selected
N */
Nuint16_t GPIO_ReadData ( GPIO_TypeDef* GPIOx )
N{
N    /* Check the parameters */
N    assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
X    ((void)0U);
N
N    return ( uint16_t ) ( GPIOx->PIN );
N}
N
N/**
N * @brief  Reads the selected data port bits.
N * @param  GPIOx[in]: where x can be to select the GPIO peripheral.
N *                SC32f10xx Selection range(GPIOA - GPIOC)
N *                SC32f11xx Selection range(GPIOA - GPIOD)
N *                SC32f12xx Selection range(GPIOA - GPIOC)
N *                SC32f15xx Selection range(GPIOA - GPIOC)
N *               - GPIOA: select the GPIOA peripheral
N *               - GPIOB: select the GPIOB peripheral
N *               - GPIOC: select the GPIOC peripheral
N *               - GPIOD: select the GPIOD peripheral
N * @param  GPIO_Pin[in]: specifies the port bit to be read.
N *                   - GPIO_Pin_0:Pin 0 selected
N *                   - GPIO_Pin_1:Pin 1 selected
N *                   - GPIO_Pin_2:Pin 2 selected
N *                   - GPIO_Pin_3:Pin 3 selected
N *                   - GPIO_Pin_4:Pin 4 selected
N *                   - GPIO_Pin_5:Pin 5 selected
N *                   - GPIO_Pin_6:Pin 6 selected
N *                   - GPIO_Pin_7:Pin 7 selected
N *                   - GPIO_Pin_8:Pin 8 selected
N *                   - GPIO_Pin_9:Pin 9 selected
N *                   - GPIO_Pin_10:Pin 10 selected
N *                   - GPIO_Pin_11:Pin 11 selected
N *                   - GPIO_Pin_12:Pin 12 selected
N *                   - GPIO_Pin_13:Pin 13 selected
N *                   - GPIO_Pin_14:Pin 14 selected
N *                   - GPIO_Pin_15:Pin 15 selected
N *                   - GPIO_PIN_LNIB:Pin Low 8 Bits selected
N *                   - GPIO_PIN_HNIB:Pin High 8 Bits selected
N *                   - GPIO_PIN_All:All pins selected
N * @retval Bit state
N *              - Bit_RESET
N *              - Bit_SET
N */
NBitAction GPIO_ReadDataBit ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin )
N{
N    BitAction bitstatus;
N    /* Check the parameters */
N    assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
X    ((void)0U);
N    assert_param ( IS_GPIO_PIN ( GPIO_Pin ) );
X    ((void)0U);
N
N    if ( GPIOx->PIN & GPIO_Pin )
N    {
N        bitstatus = Bit_SET;
N    }
N    else
N    {
N        bitstatus = Bit_RESET;
N    }
N
N    return bitstatus;
N}
N
N/**
N * @brief  Sets the selected data port bits.
N * @param  GPIOx[in]: where x can be to select the GPIO peripheral.
N *                SC32f10xx Selection range(GPIOA - GPIOC)
N *                SC32f11xx Selection range(GPIOA - GPIOD)
N *                SC32f12xx Selection range(GPIOA - GPIOC)
N *                SC32f15xx Selection range(GPIOA - GPIOC)
N *               - GPIOA: select the GPIOA peripheral
N *               - GPIOB: select the GPIOB peripheral
N *               - GPIOC: select the GPIOC peripheral
N *               - GPIOD: select the GPIOD peripheral
N * @param  GPIO_Pin[in]: specifies the port bit to be written.
N *                   - GPIO_Pin_0:Pin 0 selected
N *                   - GPIO_Pin_1:Pin 1 selected
N *                   - GPIO_Pin_2:Pin 2 selected
N *                   - GPIO_Pin_3:Pin 3 selected
N *                   - GPIO_Pin_4:Pin 4 selected
N *                   - GPIO_Pin_5:Pin 5 selected
N *                   - GPIO_Pin_6:Pin 6 selected
N *                   - GPIO_Pin_7:Pin 7 selected
N *                   - GPIO_Pin_8:Pin 8 selected
N *                   - GPIO_Pin_9:Pin 9 selected
N *                   - GPIO_Pin_10:Pin 10 selected
N *                   - GPIO_Pin_11:Pin 11 selected
N *                   - GPIO_Pin_12:Pin 12 selected
N *                   - GPIO_Pin_13:Pin 13 selected
N *                   - GPIO_Pin_14:Pin 14 selected
N *                   - GPIO_Pin_15:Pin 15 selected
N *                   - GPIO_PIN_LNIB:Pin Low 8 Bits selected
N *                   - GPIO_PIN_HNIB:Pin High 8 Bits selected
N *                   - GPIO_PIN_All:All pins selected
N * @retval None
N */
Nvoid GPIO_SetBits ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin )
N{
N    /* Check the parameters */
N    assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
X    ((void)0U);
N    assert_param ( IS_GPIO_PIN ( GPIO_Pin ) );
X    ((void)0U);
N    __IO uint32_t tmpreg = ( uint32_t ) GPIOx;
X    volatile uint32_t tmpreg = ( uint32_t ) GPIOx;
N    while ( GPIO_Pin != 0 )
N    {
N        if ( GPIO_Pin & 0x0001 )
N        {
N            ( * ( ( uint8_t* ) ( tmpreg ) ) ) = 1;
N        }
N        GPIO_Pin = GPIO_Pin >> 1;
N        tmpreg++;
N    }
N}
N
N/**
N * @brief  Clears the specified data port bit.
N * @param  GPIOx[in]: where x can be to select the GPIO peripheral.
N *                SC32f10xx Selection range(GPIOA - GPIOC)
N *                SC32f11xx Selection range(GPIOA - GPIOD)
N *                SC32f12xx Selection range(GPIOA - GPIOC)
N *                SC32f15xx Selection range(GPIOA - GPIOC)
N *               - GPIOA: select the GPIOA peripheral
N *               - GPIOB: select the GPIOB peripheral
N *               - GPIOC: select the GPIOC peripheral
N *               - GPIOD: select the GPIOD peripheral
N * @param  GPIO_Pin[in]: specifies the port bit to be written.
N *                   - GPIO_Pin_0:Pin 0 selected
N *                   - GPIO_Pin_1:Pin 1 selected
N *                   - GPIO_Pin_2:Pin 2 selected
N *                   - GPIO_Pin_3:Pin 3 selected
N *                   - GPIO_Pin_4:Pin 4 selected
N *                   - GPIO_Pin_5:Pin 5 selected
N *                   - GPIO_Pin_6:Pin 6 selected
N *                   - GPIO_Pin_7:Pin 7 selected
N *                   - GPIO_Pin_8:Pin 8 selected
N *                   - GPIO_Pin_9:Pin 9 selected
N *                   - GPIO_Pin_10:Pin 10 selected
N *                   - GPIO_Pin_11:Pin 11 selected
N *                   - GPIO_Pin_12:Pin 12 selected
N *                   - GPIO_Pin_13:Pin 13 selected
N *                   - GPIO_Pin_14:Pin 14 selected
N *                   - GPIO_Pin_15:Pin 15 selected
N *                   - GPIO_PIN_LNIB:Pin Low 8 Bits selected
N *                   - GPIO_PIN_HNIB:Pin High 8 Bits selected
N *                   - GPIO_PIN_All:All pins selected
N * @retval None
N */
Nvoid GPIO_ResetBits ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin )
N{
N    /* Check the parameters */
N    assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
X    ((void)0U);
N    assert_param ( IS_GPIO_PIN ( GPIO_Pin ) );
X    ((void)0U);
N
N    __IO uint32_t tmpreg = ( uint32_t ) GPIOx;
X    volatile uint32_t tmpreg = ( uint32_t ) GPIOx;
N
N    while ( GPIO_Pin != 0 )
N    {
N        if ( GPIO_Pin & 0x0001 )
N        {
N            ( * ( ( uint8_t* ) ( tmpreg ) ) ) = 0;
N        }
N        GPIO_Pin = GPIO_Pin >> 1;
N        tmpreg++;
N    }
N}
N
N
N/**
N * @brief  Writes data to the specified GPIO data port.
N * @param  GPIOx[in]: where x can be to select the GPIO peripheral.
N *                SC32f10xx Selection range(GPIOA - GPIOC)
N *                SC32f11xx Selection range(GPIOA - GPIOD)
N *                SC32f12xx Selection range(GPIOA - GPIOC)
N *                SC32f15xx Selection range(GPIOA - GPIOC)
N *               - GPIOA: select the GPIOA peripheral
N *               - GPIOB: select the GPIOB peripheral
N *               - GPIOC: select the GPIOC peripheral
N *               - GPIOD: select the GPIOD peripheral
N * @param  PortVal[in]: The value of the port data register to be written.
N * @retval None
N */
Nvoid GPIO_Write ( GPIO_TypeDef* GPIOx, uint16_t PortVal )
N{
N    /* Check the parameters */
N    assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
X    ((void)0U);
N
N    /*  */
N    GPIOx->PIN = PortVal;
N}
N
N/**
N  * @brief  Sets or clears the specified data port bit.
N * @param  GPIOx[in]: where x can be to select the GPIO peripheral.
N *                SC32f10xx Selection range(GPIOA - GPIOC)
N *                SC32f11xx Selection range(GPIOA - GPIOD)
N *                SC32f12xx Selection range(GPIOA - GPIOC)
N *                SC32f15xx Selection range(GPIOA - GPIOC)
N *               - GPIOA: select the GPIOA peripheral
N *               - GPIOB: select the GPIOB peripheral
N *               - GPIOC: select the GPIOC peripheral
N *               - GPIOD: select the GPIOD peripheral
N * @param  GPIO_Pin[in]:specifies the port bit to be read.
N *                   - GPIO_Pin_0:Pin 0 selected
N *                   - GPIO_Pin_1:Pin 1 selected
N *                   - GPIO_Pin_2:Pin 2 selected
N *                   - GPIO_Pin_3:Pin 3 selected
N *                   - GPIO_Pin_4:Pin 4 selected
N *                   - GPIO_Pin_5:Pin 5 selected
N *                   - GPIO_Pin_6:Pin 6 selected
N *                   - GPIO_Pin_7:Pin 7 selected
N *                   - GPIO_Pin_8:Pin 8 selected
N *                   - GPIO_Pin_9:Pin 9 selected
N *                   - GPIO_Pin_10:Pin 10 selected
N *                   - GPIO_Pin_11:Pin 11 selected
N *                   - GPIO_Pin_12:Pin 12 selected
N *                   - GPIO_Pin_13:Pin 13 selected
N *                   - GPIO_Pin_14:Pin 14 selected
N *                   - GPIO_Pin_15:Pin 15 selected
N *                   - GPIO_PIN_LNIB:Pin Low 8 Bits selected
N *                   - GPIO_PIN_HNIB:Pin High 8 Bits selected
N *                   - GPIO_PIN_All:All pins selected
N  * @param  BitVal[in]: specifies the value to be written to the selected bit.
N  *          This parameter can be one of the BitAction enum values:
N *            -  Bit_RESET: to clear the port pin
N *            -  Bit_SET: to set the port pin
N  * @retval None
N  */
Nvoid GPIO_WriteBit ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal )
N{
N    /* Check the parameters */
N    assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
X    ((void)0U);
N    assert_param ( IS_GET_GPIO_PIN ( GPIO_Pin ) );
X    ((void)0U);
N    assert_param ( IS_GPIO_BITACTION ( BitVal ) );
X    ((void)0U);
N
N    if ( BitVal != Bit_RESET )
N    {
N        GPIOx->PIN |= GPIO_Pin;
N    }
N    else
N    {
N        GPIOx->PIN &= ( ~GPIO_Pin ) ;
N    }
N}
N
N/**
N * @brief  Toggles the specified GPIO pins.
N * @param  GPIOx[in]: where x can be to select the GPIO peripheral.
N *                SC32f10xx Selection range(GPIOA - GPIOC)
N *                SC32f11xx Selection range(GPIOA - GPIOD)
N *                SC32f12xx Selection range(GPIOA - GPIOC)
N *                SC32f15xx Selection range(GPIOA - GPIOC)
N *               - GPIOA: select the GPIOA peripheral
N *               - GPIOB: select the GPIOB peripheral
N *               - GPIOC: select the GPIOC peripheral
N *               - GPIOD: select the GPIOD peripheral
N * @param  GPIO_Pin[in]:specifies the port bit to be read.
N *                   - GPIO_Pin_0:Pin 0 selected
N *                   - GPIO_Pin_1:Pin 1 selected
N *                   - GPIO_Pin_2:Pin 2 selected
N *                   - GPIO_Pin_3:Pin 3 selected
N *                   - GPIO_Pin_4:Pin 4 selected
N *                   - GPIO_Pin_5:Pin 5 selected
N *                   - GPIO_Pin_6:Pin 6 selected
N *                   - GPIO_Pin_7:Pin 7 selected
N *                   - GPIO_Pin_8:Pin 8 selected
N *                   - GPIO_Pin_9:Pin 9 selected
N *                   - GPIO_Pin_10:Pin 10 selected
N *                   - GPIO_Pin_11:Pin 11 selected
N *                   - GPIO_Pin_12:Pin 12 selected
N *                   - GPIO_Pin_13:Pin 13 selected
N *                   - GPIO_Pin_14:Pin 14 selected
N *                   - GPIO_Pin_15:Pin 15 selected
N *                   - GPIO_PIN_LNIB:Pin Low 8 Bits selected
N *                   - GPIO_PIN_HNIB:Pin High 8 Bits selected
N *                   - GPIO_PIN_All:All pins selected
N * @retval None
N */
Nvoid GPIO_TogglePins ( GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin )
N{
N    /* Check the parameters */
N    assert_param ( IS_GPIO_ALL_PERIPH ( GPIOx ) );
X    ((void)0U);
N    assert_param ( IS_GPIO_PIN ( GPIO_Pin ) );
X    ((void)0U);
N    __IO uint32_t tmpreg = ( uint32_t ) GPIOx + ( 0x00000010UL );
X    volatile uint32_t tmpreg = ( uint32_t ) GPIOx + ( 0x00000010UL );
N    uint32_t temp = 0;
N    /* Set the GPIOx PIN value  */
N    while ( GPIO_Pin != 0 )
N    {
N
N        if ( GPIO_Pin & 0x0001 )
N        {
N            temp = ~ ( * ( ( uint8_t* ) ( tmpreg ) ) );
N            ( * ( ( uint8_t* ) ( tmpreg ) ) ) = temp;
N        }
N        GPIO_Pin = GPIO_Pin >> 1;
N        tmpreg++;
N    }
N}
N
N/**
N * @}
N */
N/* End of PWM_Group2.	*/
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/**
N * @}
N */
N
N/******************* (C) COPYRIGHT 2022 SinOne Microelectronics *****END OF FILE****/
