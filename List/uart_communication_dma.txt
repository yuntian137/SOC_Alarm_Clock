; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\output\uart_communication_dma.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\output\uart_communication_dma.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\Buzz\Inc -I..\Drivers\TKDriver\C -I..\Mqtt\Inc -ID:\keil\ARM\PACK\Keil\SC32F1xxx_DFP\1.0.6\Device\SC32F10xx\FWLib\SC32_Lib\inc -D__MICROLIB -D__UVISION_VERSION=534 -DSC32F10xx -DSC32f10xx --omf_browse=..\output\uart_communication_dma.crf ..\Apps\UART_Communication_DMA.C]
                          THUMB

                          AREA ||i.TIM3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM3_IRQHandler PROC
;;;51     // 定时器中断处理函数
;;;52     void TIM3_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;53     {
;;;54         if (TIM_GetFlagStatus(TIM3, TIM_Flag_TI) == SET)
000002  2101              MOVS     r1,#1
000004  480b              LDR      r0,|L1.52|
000006  f7fffffe          BL       TIM_GetFlagStatus
00000a  2801              CMP      r0,#1
00000c  d111              BNE      |L1.50|
;;;55         {
;;;56             TIM_ClearFlag(TIM3, TIM_Flag_TI); // 清除定时器中断标志  
00000e  2101              MOVS     r1,#1
000010  4808              LDR      r0,|L1.52|
000012  f7fffffe          BL       TIM_ClearFlag
;;;57             if (UART_RxFlag == RESET) // 如果DMA1没有搬运完成
000016  4808              LDR      r0,|L1.56|
000018  7800              LDRB     r0,[r0,#0]  ; UART_RxFlag
00001a  2800              CMP      r0,#0
00001c  d109              BNE      |L1.50|
;;;58             {
;;;59                 UART_RxFlag = SET; // 设置接收完成标志
00001e  2001              MOVS     r0,#1
000020  4905              LDR      r1,|L1.56|
000022  7008              STRB     r0,[r1,#0]
;;;60                 UART_Communication_DMA_RxCount = 200 - DMA_GetCurrDataCounter(DMA1); // 获取接收到的数据长度
000024  4805              LDR      r0,|L1.60|
000026  f7fffffe          BL       DMA_GetCurrDataCounter
00002a  21c8              MOVS     r1,#0xc8
00002c  1a08              SUBS     r0,r1,r0
00002e  4904              LDR      r1,|L1.64|
000030  8008              STRH     r0,[r1,#0]
                  |L1.50|
;;;61             }
;;;62         }
;;;63     }
000032  bd10              POP      {r4,pc}
;;;64     /*
                          ENDP

                  |L1.52|
                          DCD      0x400201c0
                  |L1.56|
                          DCD      UART_RxFlag
                  |L1.60|
                          DCD      0x40010840
                  |L1.64|
                          DCD      UART_Communication_DMA_RxCount

                          AREA ||i.UART1_IRQHandler_DMA||, CODE, READONLY, ALIGN=2

                  UART1_IRQHandler_DMA PROC
;;;39     // UART接收中断处理函数
;;;40     void UART1_IRQHandler_DMA(void)
000000  b510              PUSH     {r4,lr}
;;;41     {
;;;42         if (UART_GetFlagStatus(UART1, UART_Flag_RX) == SET)
000002  2101              MOVS     r1,#1
000004  4806              LDR      r0,|L2.32|
000006  f7fffffe          BL       UART_GetFlagStatus
00000a  2801              CMP      r0,#1
00000c  d107              BNE      |L2.30|
;;;43         {
;;;44             UART_ClearFlag(UART1, UART_Flag_RX); // 清除UART接收标志
00000e  2101              MOVS     r1,#1
000010  4803              LDR      r0,|L2.32|
000012  f7fffffe          BL       UART_ClearFlag
;;;45             // 重置定时器以检测空闲时间
;;;46             TIM_SetCounter(TIM3, 0);
000016  2100              MOVS     r1,#0
000018  4802              LDR      r0,|L2.36|
00001a  f7fffffe          BL       TIM_SetCounter
                  |L2.30|
;;;47         }
;;;48     }
00001e  bd10              POP      {r4,pc}
;;;49     
                          ENDP

                  |L2.32|
                          DCD      0x40020080
                  |L2.36|
                          DCD      0x400201c0

                          AREA ||i.UART_Communication_DMA||, CODE, READONLY, ALIGN=2

                  UART_Communication_DMA PROC
;;;7      
;;;8      void UART_Communication_DMA(void)
000000  b510              PUSH     {r4,lr}
;;;9      {
;;;10         if (UART_RxFlag == SET) // 空闲中断触发
000002  481a              LDR      r0,|L3.108|
000004  7800              LDRB     r0,[r0,#0]  ; UART_RxFlag
000006  2801              CMP      r0,#1
000008  d12e              BNE      |L3.104|
;;;11         {
;;;12             UART_RxFlag = RESET; // 清标志
00000a  2000              MOVS     r0,#0
00000c  4917              LDR      r1,|L3.108|
00000e  7008              STRB     r0,[r1,#0]
;;;13             // 处理接收到的数据
;;;14             // 将接收到的数据复制到发送缓冲区
;;;15             memcpy(UART_Communication_DMA_Data, UART_Communication_DMA_Buffer, UART_Communication_DMA_RxCount);
000010  4817              LDR      r0,|L3.112|
000012  8802              LDRH     r2,[r0,#0]  ; UART_Communication_DMA_RxCount
000014  4917              LDR      r1,|L3.116|
000016  4818              LDR      r0,|L3.120|
000018  f7fffffe          BL       __aeabi_memcpy
;;;16     
;;;17             // 设置DMA0的当前数据计数器
;;;18             DMA_SetCurrDataCounter(DMA0, UART_Communication_DMA_RxCount);
00001c  4814              LDR      r0,|L3.112|
00001e  8801              LDRH     r1,[r0,#0]  ; UART_Communication_DMA_RxCount
000020  4816              LDR      r0,|L3.124|
000022  f7fffffe          BL       DMA_SetCurrDataCounter
;;;19     
;;;20             // 软件使能DMA0搬运
;;;21             // 检查接收到的数据长度是否为零
;;;22             if (UART_Communication_DMA_RxCount > 0)
000026  4812              LDR      r0,|L3.112|
000028  8800              LDRH     r0,[r0,#0]  ; UART_Communication_DMA_RxCount
00002a  2800              CMP      r0,#0
00002c  dd12              BLE      |L3.84|
;;;23             {
;;;24                 // 设置DMA0的当前数据计数器
;;;25                 DMA_SetCurrDataCounter(DMA0, UART_Communication_DMA_RxCount);
00002e  4810              LDR      r0,|L3.112|
000030  8801              LDRH     r1,[r0,#0]  ; UART_Communication_DMA_RxCount
000032  4812              LDR      r0,|L3.124|
000034  f7fffffe          BL       DMA_SetCurrDataCounter
;;;26     
;;;27                 // 软件使能DMA0搬运
;;;28                 DMA_SoftwareTrigger(DMA0);
000038  4810              LDR      r0,|L3.124|
00003a  f7fffffe          BL       DMA_SoftwareTrigger
;;;29                 while (DMA_GetFlagStatus(DMA0, DMA_FLAG_TCIF) == RESET); // 等待DMA0搬运完成
00003e  bf00              NOP      
                  |L3.64|
000040  2102              MOVS     r1,#2
000042  480e              LDR      r0,|L3.124|
000044  f7fffffe          BL       DMA_GetFlagStatus
000048  2800              CMP      r0,#0
00004a  d0f9              BEQ      |L3.64|
;;;30                 DMA_ClearFlag(DMA0, DMA_FLAG_TCIF); // DMA0标志位清零
00004c  2102              MOVS     r1,#2
00004e  480b              LDR      r0,|L3.124|
000050  f7fffffe          BL       DMA_ClearFlag
                  |L3.84|
;;;31             }
;;;32     
;;;33     
;;;34             // DMA1重新使能
;;;35             DMA_SetCurrDataCounter(DMA1, 200); // 重新写入搬运个数（重新写入搬运个数大小应与修改的数据个数大小一致）
000054  21c8              MOVS     r1,#0xc8
000056  4809              LDR      r0,|L3.124|
000058  3040              ADDS     r0,r0,#0x40
00005a  f7fffffe          BL       DMA_SetCurrDataCounter
;;;36             UART_DMACmd(UART1, UART_DMAReq_RX, ENABLE); // 重新使能UART1 RX触发DMA1
00005e  2201              MOVS     r2,#1
000060  2140              MOVS     r1,#0x40
000062  4807              LDR      r0,|L3.128|
000064  f7fffffe          BL       UART_DMACmd
                  |L3.104|
;;;37         }
;;;38     }
000068  bd10              POP      {r4,pc}
;;;39     // UART接收中断处理函数
                          ENDP

00006a  0000              DCW      0x0000
                  |L3.108|
                          DCD      UART_RxFlag
                  |L3.112|
                          DCD      UART_Communication_DMA_RxCount
                  |L3.116|
                          DCD      UART_Communication_DMA_Buffer
                  |L3.120|
                          DCD      UART_Communication_DMA_Data
                  |L3.124|
                          DCD      0x40010800
                  |L3.128|
                          DCD      0x40020080

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  UART_Communication_DMA_Data
                          %        200
                  UART_Communication_DMA_Buffer
                          %        200

                          AREA ||.data||, DATA, ALIGN=1

                  UART_RxFlag
000000  00                DCB      0x00
                  UART_TxFlag
000001  00                DCB      0x00
                  UART_Communication_DMA_RxCount
000002  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\Apps\\UART_Communication_DMA.C"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___24_UART_Communication_DMA_C_684db807____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___24_UART_Communication_DMA_C_684db807____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___24_UART_Communication_DMA_C_684db807____REVSH|
#line 478
|__asm___24_UART_Communication_DMA_C_684db807____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
